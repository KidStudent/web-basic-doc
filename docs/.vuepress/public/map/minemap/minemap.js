/**
 * minemap-3d-engine
 * version: v4.4.8
 * submission time: 2023-11-16 12:19:02 +0800
 * build time: 2023-11-16 12:22:01
 * branch: master
 * SHA: a5115b70695aa61b1ad66b7d48ef29c4b38dd8b6
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined'
    ? (module.exports = factory())
    : typeof define === 'function' && define.amd
    ? define(factory)
    : ((global = typeof globalThis !== 'undefined' ? globalThis : global || self),
      (global.minemap = factory()));
})(this, function () {
  'use strict';

  /* eslint-disable */
  var shared, worker, minemap;
  function define(_, chunk) {
    if (!shared) {
      shared = chunk;
    } else if (!worker) {
      worker = chunk;
    } else {
      var workerBundleString =
        "self.onerror = function() { console.error('解析webworker附属包出问题'); }; var sharedChunk = {}; (" +
        shared +
        ')(sharedChunk); (' +
        worker +
        ')(sharedChunk); self.onerror = null;';
      var sharedChunk = {};
      shared(sharedChunk);
      minemap = chunk(sharedChunk);
      if (typeof window !== 'undefined' && window && window.URL && window.URL.createObjectURL) {
        minemap.workerUrl = window.URL.createObjectURL(
          new Blob([workerBundleString], { type: 'text/javascript' }),
        );
      }
    }
  }

  define(['exports'], function (e) {
    'use strict';
    function t(e) {
      return null != e;
    }
    const i = (1 / Math.PI) * 180,
      n = (1 / 180) * Math.PI,
      r = 1e-12;
    function o(e, t, i) {
      if (a(e)) {
        i = i || ((n = e).clone ? n.clone() : new Array(...n));
        for (let n = 0; n < i.length && n < e.length; ++n) i[n] = t(e[n], n, i);
        return i;
      }
      var n;
      return t(e);
    }
    function a(e) {
      return (
        (t(e) && e.isMathGLClass) ||
        Array.isArray(e) ||
        (ArrayBuffer.isView(e) && !(e instanceof DataView))
      );
    }
    function s(e) {
      return o(e, (e) => e * n);
    }
    function l(e) {
      return o(e, (e) => e * i);
    }
    function c(e, t, i) {
      return o(e, (e) => Math.max(t, Math.min(i, e)));
    }
    function u(e, t) {
      if (e === t) return !0;
      if (a(e) && a(t)) {
        if (e.length !== t.length) return !1;
        for (let i = 0; i < e.length; ++i) if (!u(e[i], t[i])) return !1;
        return !0;
      }
      return e && e.equals
        ? e.equals(t)
        : t && t.equals
        ? t.equals(e)
        : !(!Number.isFinite(e) || !Number.isFinite(t)) &&
          Math.abs(e - t) <= r * Math.max(1, Math.abs(e), Math.abs(t));
    }
    class h extends Array {
      get isMathGLClass() {
        return !0;
      }
      get ELEMENTS() {
        return this.length;
      }
      get elements() {
        return this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      from(e) {
        return Array.isArray(e) ? this.copy(e) : this.fromObject(e);
      }
      fromArray(e, t = 0) {
        for (let i = 0; i < this.ELEMENTS; ++i) this[i] = e[i + t];
        return this.check();
      }
      to(e) {
        return e === this ? this : a(e) ? this.toArray(e) : this.toObject(e);
      }
      toTarget(e) {
        return e ? this.to(e) : this;
      }
      toArray(e = [], t = 0) {
        for (let i = 0; i < this.ELEMENTS; ++i) e[t + i] = this[i];
        return e;
      }
      toObject(e = {}) {
        for (let t = 0; t < this.ELEMENTS; ++t) e[t] = this[t];
        return e;
      }
      toFloat32Array() {
        return new Float32Array(this.toArray());
      }
      toString() {
        return this.#e();
      }
      #e() {
        let e = '';
        for (let i = 0; i < this.ELEMENTS; ++i)
          e +=
            (i > 0 ? ', ' : '') +
            ((t = (function (e) {
              return Math.round(e / r) * r;
            })((t = this[i]))),
            `${parseFloat(t.toPrecision(4))}`);
        var t;
        return `[${e}]`;
      }
      equals(e) {
        if (!e || this.length !== e.length) return !1;
        for (let t = 0; t < this.ELEMENTS; ++t) if (!u(this[t], e[t])) return !1;
        return !0;
      }
      negate() {
        for (let e = 0; e < this.ELEMENTS; ++e) this[e] = -this[e];
        return this.check();
      }
      add(...e) {
        for (const t of e) for (let e = 0; e < this.ELEMENTS; ++e) this[e] += t[e];
        return this.check();
      }
      subtract(...e) {
        for (const t of e) for (let e = 0; e < this.ELEMENTS; ++e) this[e] -= t[e];
        return this.check();
      }
      sub(e) {
        return this.subtract(e);
      }
      setScalar(e) {
        for (let t = 0; t < this.ELEMENTS; ++t) this[t] = e;
        return this.check();
      }
      addScalar(e) {
        for (let t = 0; t < this.ELEMENTS; ++t) this[t] += e;
        return this.check();
      }
      subScalar(e) {
        return this.addScalar(-e);
      }
      multiplyScalar(e) {
        for (let t = 0; t < this.ELEMENTS; ++t) this[t] *= e;
        return this.check();
      }
      divideScalar(e) {
        return this.multiplyScalar(1 / e);
      }
      clampScalar(e, t) {
        for (let i = 0; i < this.ELEMENTS; ++i) this[i] = Math.min(Math.max(this[i], e), t);
        return this.check();
      }
      multiplyByScalar(e) {
        return this.multiplyScalar(e);
      }
      divideByScalar(e) {
        return this.divideScalar(e);
      }
      check() {
        return this;
      }
      validate() {
        let e = this.length === this.ELEMENTS;
        for (let t = 0; t < this.ELEMENTS; ++t) e = e && Number.isFinite(this[t]);
        return e;
      }
    }
    const d = {};
    function p(e) {
      if (!Number.isFinite(e)) throw new Error(`Invalid number ${e}`);
      return e;
    }
    function f(e, t, i = '') {
      if (
        !(function (e, t) {
          if (e.length !== t) return !1;
          for (let t = 0; t < e.length; ++t) if (!Number.isFinite(e[t])) return !1;
          return !0;
        })(e, t)
      )
        throw new Error(`math.gl: ${i} some fields set to invalid numbers'`);
      return e;
    }
    function m(e, t) {
      d[e] ||
        ((d[e] = !0),
        console.warn(
          `${e} has been removed in version ${t}, see upgrade guide for more information`,
        ));
    }
    var _ = 1e-6,
      g = 'undefined' != typeof Float32Array ? Float32Array : Array;
    function y(e, t, i) {
      var n = t[0],
        r = t[1],
        o = t[2],
        a = t[3],
        s = i[0],
        l = i[1],
        c = i[2],
        u = i[3];
      return (
        (e[0] = n * s + o * l),
        (e[1] = r * s + a * l),
        (e[2] = n * c + o * u),
        (e[3] = r * c + a * u),
        e
      );
    }
    function x(e, t, i) {
      var n = t[1],
        r = t[2],
        o = t[3],
        a = i[0],
        s = i[1];
      return (e[0] = t[0] * a), (e[1] = n * a), (e[2] = r * s), (e[3] = o * s), e;
    }
    function v(e, t, i) {
      var n = t[0],
        r = t[1],
        o = t[2],
        a = t[3],
        s = t[4],
        l = t[5],
        c = t[6],
        u = t[7],
        h = t[8],
        d = i[0],
        p = i[1],
        f = i[2],
        m = i[3],
        _ = i[4],
        g = i[5],
        y = i[6],
        x = i[7],
        v = i[8];
      return (
        (e[0] = d * n + p * a + f * c),
        (e[1] = d * r + p * s + f * u),
        (e[2] = d * o + p * l + f * h),
        (e[3] = m * n + _ * a + g * c),
        (e[4] = m * r + _ * s + g * u),
        (e[5] = m * o + _ * l + g * h),
        (e[6] = y * n + x * a + v * c),
        (e[7] = y * r + x * s + v * u),
        (e[8] = y * o + x * l + v * h),
        e
      );
    }
    function w(e, t, i) {
      var n = i[0],
        r = i[1];
      return (
        (e[0] = n * t[0]),
        (e[1] = n * t[1]),
        (e[2] = n * t[2]),
        (e[3] = r * t[3]),
        (e[4] = r * t[4]),
        (e[5] = r * t[5]),
        (e[6] = t[6]),
        (e[7] = t[7]),
        (e[8] = t[8]),
        e
      );
    }
    function T(e, t, i) {
      var n = t[0],
        r = t[1],
        o = t[2],
        a = t[3],
        s = t[4],
        l = t[5],
        c = t[6],
        u = t[7],
        h = t[8],
        d = t[9],
        p = t[10],
        f = t[11],
        m = t[12],
        _ = t[13],
        g = t[14],
        y = t[15],
        x = i[0],
        v = i[1],
        w = i[2],
        T = i[3];
      return (
        (e[0] = x * n + v * s + w * h + T * m),
        (e[1] = x * r + v * l + w * d + T * _),
        (e[2] = x * o + v * c + w * p + T * g),
        (e[3] = x * a + v * u + w * f + T * y),
        (e[4] = (x = i[4]) * n + (v = i[5]) * s + (w = i[6]) * h + (T = i[7]) * m),
        (e[5] = x * r + v * l + w * d + T * _),
        (e[6] = x * o + v * c + w * p + T * g),
        (e[7] = x * a + v * u + w * f + T * y),
        (e[8] = (x = i[8]) * n + (v = i[9]) * s + (w = i[10]) * h + (T = i[11]) * m),
        (e[9] = x * r + v * l + w * d + T * _),
        (e[10] = x * o + v * c + w * p + T * g),
        (e[11] = x * a + v * u + w * f + T * y),
        (e[12] = (x = i[12]) * n + (v = i[13]) * s + (w = i[14]) * h + (T = i[15]) * m),
        (e[13] = x * r + v * l + w * d + T * _),
        (e[14] = x * o + v * c + w * p + T * g),
        (e[15] = x * a + v * u + w * f + T * y),
        e
      );
    }
    function b() {
      var e = new g(3);
      return g != Float32Array && ((e[0] = 0), (e[1] = 0), (e[2] = 0)), e;
    }
    function S(e) {
      return Math.hypot(e[0], e[1], e[2]);
    }
    function A(e, t, i) {
      var n = new g(3);
      return (n[0] = e), (n[1] = t), (n[2] = i), n;
    }
    function P(e, t) {
      return (e[0] = t[0]), (e[1] = t[1]), (e[2] = t[2]), e;
    }
    function E(e, t, i) {
      return (e[0] = t[0] + i[0]), (e[1] = t[1] + i[1]), (e[2] = t[2] + i[2]), e;
    }
    function C(e, t, i) {
      return (e[0] = t[0] * i), (e[1] = t[1] * i), (e[2] = t[2] * i), e;
    }
    function M(e, t) {
      var i = t[0] - e[0],
        n = t[1] - e[1],
        r = t[2] - e[2];
      return i * i + n * n + r * r;
    }
    function I(e, t) {
      var i = t[0],
        n = t[1],
        r = t[2],
        o = i * i + n * n + r * r;
      return (
        o > 0 && (o = 1 / Math.sqrt(o)), (e[0] = t[0] * o), (e[1] = t[1] * o), (e[2] = t[2] * o), e
      );
    }
    function L(e, t) {
      return e[0] * t[0] + e[1] * t[1] + e[2] * t[2];
    }
    function R(e, t, i) {
      var n = t[0],
        r = t[1],
        o = t[2],
        a = i[0],
        s = i[1],
        l = i[2];
      return (e[0] = r * l - o * s), (e[1] = o * a - n * l), (e[2] = n * s - r * a), e;
    }
    function N(e, t, i) {
      var n = t[0],
        r = t[1],
        o = t[2],
        a = i[3] * n + i[7] * r + i[11] * o + i[15];
      return (
        (e[0] = (i[0] * n + i[4] * r + i[8] * o + i[12]) / (a = a || 1)),
        (e[1] = (i[1] * n + i[5] * r + i[9] * o + i[13]) / a),
        (e[2] = (i[2] * n + i[6] * r + i[10] * o + i[14]) / a),
        e
      );
    }
    function O(e, t, i) {
      var n = t[0],
        r = t[1],
        o = t[2];
      return (
        (e[0] = n * i[0] + r * i[3] + o * i[6]),
        (e[1] = n * i[1] + r * i[4] + o * i[7]),
        (e[2] = n * i[2] + r * i[5] + o * i[8]),
        e
      );
    }
    Math.hypot ||
      (Math.hypot = function () {
        for (var e = 0, t = arguments.length; t--; ) e += arguments[t] * arguments[t];
        return Math.sqrt(e);
      });
    var D = function (e, t, i) {
        return (e[0] = t[0] - i[0]), (e[1] = t[1] - i[1]), (e[2] = t[2] - i[2]), e;
      },
      F = S;
    function z(e, t, i) {
      var n = t[0],
        r = t[1],
        o = t[2],
        a = t[3];
      return (
        (e[0] = i[0] * n + i[4] * r + i[8] * o + i[12] * a),
        (e[1] = i[1] * n + i[5] * r + i[9] * o + i[13] * a),
        (e[2] = i[2] * n + i[6] * r + i[10] * o + i[14] * a),
        (e[3] = i[3] * n + i[7] * r + i[11] * o + i[15] * a),
        e
      );
    }
    function B(e, t, i) {
      var n = t[0],
        r = t[1],
        o = t[2],
        a = i[0],
        s = i[1],
        l = i[2],
        c = i[3],
        u = c * n + s * o - l * r,
        h = c * r + l * n - a * o,
        d = c * o + a * r - s * n,
        p = -a * n - s * r - l * o;
      return (
        (e[0] = u * c + p * -a + h * -l - d * -s),
        (e[1] = h * c + p * -s + d * -a - u * -l),
        (e[2] = d * c + p * -l + u * -s - h * -a),
        (e[3] = t[3]),
        e
      );
    }
    function V() {
      var e = new g(4);
      return g != Float32Array && ((e[0] = 0), (e[1] = 0), (e[2] = 0)), (e[3] = 1), e;
    }
    function U(e, t, i) {
      i *= 0.5;
      var n = Math.sin(i);
      return (e[0] = n * t[0]), (e[1] = n * t[1]), (e[2] = n * t[2]), (e[3] = Math.cos(i)), e;
    }
    function k(e, t, i) {
      var n = t[0],
        r = t[1],
        o = t[2],
        a = t[3],
        s = i[0],
        l = i[1],
        c = i[2],
        u = i[3];
      return (
        (e[0] = n * u + a * s + r * c - o * l),
        (e[1] = r * u + a * l + o * s - n * c),
        (e[2] = o * u + a * c + n * l - r * s),
        (e[3] = a * u - n * s - r * l - o * c),
        e
      );
    }
    b(),
      (function () {
        var e;
        (e = new g(4)), g != Float32Array && ((e[0] = 0), (e[1] = 0), (e[2] = 0), (e[3] = 0));
      })();
    var G,
      H,
      Y,
      q,
      X =
        ((G = b()),
        (H = A(1, 0, 0)),
        (Y = A(0, 1, 0)),
        function (e, t, i) {
          var n = L(t, i);
          return n < -0.999999
            ? (R(G, H, t), F(G) < 1e-6 && R(G, Y, t), I(G, G), U(e, G, Math.PI), e)
            : n > 0.999999
            ? ((e[0] = 0), (e[1] = 0), (e[2] = 0), (e[3] = 1), e)
            : (R(G, t, i),
              (e[0] = G[0]),
              (e[1] = G[1]),
              (e[2] = G[2]),
              (e[3] = 1 + n),
              (function (e, t) {
                var i = t[0],
                  n = t[1],
                  r = t[2],
                  o = t[3],
                  a = i * i + n * n + r * r + o * o;
                return (
                  a > 0 && (a = 1 / Math.sqrt(a)),
                  (e[0] = i * a),
                  (e[1] = n * a),
                  (e[2] = r * a),
                  (e[3] = o * a),
                  e
                );
              })(e, e));
        });
    function j(e, t, i) {
      var n = t[0],
        r = t[1];
      return (e[0] = i[0] * n + i[2] * r), (e[1] = i[1] * n + i[3] * r), e;
    }
    function W(e, t, i) {
      var n = t[0],
        r = t[1];
      return (e[0] = i[0] * n + i[3] * r + i[6]), (e[1] = i[1] * n + i[4] * r + i[7]), e;
    }
    function $(e, t, i) {
      var n = t[0],
        r = t[1];
      return (e[0] = i[0] * n + i[4] * r + i[12]), (e[1] = i[1] * n + i[5] * r + i[13]), e;
    }
    function Z(e, t) {
      return null != e ? e : t;
    }
    V(),
      V(),
      (q = new g(9)),
      g != Float32Array && ((q[1] = 0), (q[2] = 0), (q[3] = 0), (q[5] = 0), (q[6] = 0), (q[7] = 0)),
      (q[0] = 1),
      (q[4] = 1),
      (q[8] = 1),
      (function () {
        var e = new g(2);
        g != Float32Array && ((e[0] = 0), (e[1] = 0));
      })(),
      (Z.EMPTY_OBJECT = Object.freeze({}));
    var K = Q;
    function Q(e, t, i, n) {
      (this.cx = 3 * e),
        (this.bx = 3 * (i - e) - this.cx),
        (this.ax = 1 - this.cx - this.bx),
        (this.cy = 3 * t),
        (this.by = 3 * (n - t) - this.cy),
        (this.ay = 1 - this.cy - this.by),
        (this.p1x = e),
        (this.p1y = n),
        (this.p2x = i),
        (this.p2y = n);
    }
    (Q.prototype.sampleCurveX = function (e) {
      return ((this.ax * e + this.bx) * e + this.cx) * e;
    }),
      (Q.prototype.sampleCurveY = function (e) {
        return ((this.ay * e + this.by) * e + this.cy) * e;
      }),
      (Q.prototype.sampleCurveDerivativeX = function (e) {
        return (3 * this.ax * e + 2 * this.bx) * e + this.cx;
      }),
      (Q.prototype.solveCurveX = function (e, t) {
        var i, n, r, o, a;
        for (void 0 === t && (t = 1e-6), r = e, a = 0; a < 8; a++) {
          if (((o = this.sampleCurveX(r) - e), Math.abs(o) < t)) return r;
          var s = this.sampleCurveDerivativeX(r);
          if (Math.abs(s) < 1e-6) break;
          r -= o / s;
        }
        if ((r = e) < (i = 0)) return i;
        if (r > (n = 1)) return n;
        for (; i < n; ) {
          if (((o = this.sampleCurveX(r)), Math.abs(o - e) < t)) return r;
          e > o ? (i = r) : (n = r), (r = 0.5 * (n - i) + i);
        }
        return r;
      }),
      (Q.prototype.solve = function (e, t) {
        return this.sampleCurveY(this.solveCurveX(e, t));
      });
    var J = 'undefined' != typeof self ? self : {};
    class ee {
      constructor(e, t, i) {
        (this.column = e), (this.row = t), (this.zoom = i);
      }
      clone() {
        return new ee(this.column, this.row, this.zoom);
      }
      zoomTo(e) {
        return this.clone()._zoomTo(e);
      }
      sub(e) {
        return this.clone()._sub(e);
      }
      _zoomTo(e) {
        const t = Math.pow(2, e - this.zoom);
        return (this.column *= t), (this.row *= t), (this.zoom = e), this;
      }
      _sub(e) {
        return (e = e.zoomTo(this.zoom)), (this.column -= e.column), (this.row -= e.row), this;
      }
    }
    var te = ie;
    function ie(e, t, i) {
      (this.x = e), (this.y = t), (this.z = i || 0);
    }
    (ie.prototype = {
      clone: function () {
        return new ie(this.x, this.y, this.z);
      },
      add: function (e) {
        return this.clone()._add(e);
      },
      sub: function (e) {
        return this.clone()._sub(e);
      },
      multByPoint: function (e) {
        return this.clone()._multByPoint(e);
      },
      divByPoint: function (e) {
        return this.clone()._divByPoint(e);
      },
      mult: function (e) {
        return this.clone()._mult(e);
      },
      div: function (e) {
        return this.clone()._div(e);
      },
      rotate: function (e) {
        return this.clone()._rotate(e);
      },
      rotateAround: function (e, t) {
        return this.clone()._rotateAround(e, t);
      },
      matMult: function (e) {
        return this.clone()._matMult(e);
      },
      unit: function () {
        return this.clone()._unit();
      },
      perp: function () {
        return this.clone()._perp();
      },
      round: function () {
        return this.clone()._round();
      },
      mag: function () {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      },
      equals: function (e) {
        return this.x === e.x && this.y === e.y;
      },
      dist: function (e) {
        return Math.sqrt(this.distSqr(e));
      },
      distSqr: function (e) {
        var t = e.x - this.x,
          i = e.y - this.y;
        return t * t + i * i;
      },
      angle: function () {
        return Math.atan2(this.y, this.x);
      },
      angleTo: function (e) {
        return Math.atan2(this.y - e.y, this.x - e.x);
      },
      angleWith: function (e) {
        return this.angleWithSep(e.x, e.y);
      },
      angleWithSep: function (e, t) {
        return Math.atan2(this.x * t - this.y * e, this.x * e + this.y * t);
      },
      _matMult: function (e) {
        var t = e[2] * this.x + e[3] * this.y;
        return (this.x = e[0] * this.x + e[1] * this.y), (this.y = t), this;
      },
      _add: function (e) {
        return (this.x += e.x), (this.y += e.y), this;
      },
      _sub: function (e) {
        return (this.x -= e.x), (this.y -= e.y), this;
      },
      _mult: function (e) {
        return (this.x *= e), (this.y *= e), this;
      },
      _div: function (e) {
        return (this.x /= e), (this.y /= e), this;
      },
      _multByPoint: function (e) {
        return (this.x *= e.x), (this.y *= e.y), this;
      },
      _divByPoint: function (e) {
        return (this.x /= e.x), (this.y /= e.y), this;
      },
      _unit: function () {
        return this._div(this.mag()), this;
      },
      _perp: function () {
        var e = this.y;
        return (this.y = this.x), (this.x = -e), this;
      },
      _rotate: function (e) {
        var t = Math.cos(e),
          i = Math.sin(e),
          n = i * this.x + t * this.y;
        return (this.x = t * this.x - i * this.y), (this.y = n), this;
      },
      _rotateAround: function (e, t) {
        var i = Math.cos(e),
          n = Math.sin(e),
          r = t.y + n * (this.x - t.x) + i * (this.y - t.y);
        return (this.x = t.x + i * (this.x - t.x) - n * (this.y - t.y)), (this.y = r), this;
      },
      _round: function () {
        return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
      },
    }),
      (ie.convert = function (e) {
        return e instanceof ie ? e : Array.isArray(e) ? new ie(e[0], e[1], e[2]) : e;
      });
    const ne = Math.pow(2, 53) - 1;
    function re(e) {
      if (e <= 0) return 0;
      if (e >= 1) return 1;
      const t = e * e,
        i = t * e;
      return 4 * (e < 0.5 ? i : 3 * (e - t) + i - 0.75);
    }
    function oe(e, t, i, n) {
      const r = new K(e, t, i, n);
      return function (e) {
        return r.solve(e);
      };
    }
    const ae = oe(0.25, 0.1, 0.25, 1);
    function se(e, t, i) {
      return Math.min(i, Math.max(t, e));
    }
    function le(e, t, i) {
      const n = i - t,
        r = ((((e - t) % n) + n) % n) + t;
      return r === t ? i : r;
    }
    function ce(e, ...t) {
      for (const i of t) for (const t in i) e[t] = i[t];
      return e;
    }
    oe(0, 0.7, 1, 0.3), oe(0, 0, 1, 1), oe(0.42, 0, 1, 1), oe(0, 0, 0.58, 1), oe(0.42, 0, 0.58, 1);
    let ue = 1;
    function he() {
      return ue++;
    }
    function de() {
      return (function e(t) {
        return t
          ? (t ^ ((16 * Math.random()) >> (t / 4))).toString(16)
          : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, e);
      })();
    }
    function pe(e) {
      return e <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(e) / Math.LN2));
    }
    function fe(e, t) {
      e.forEach((e) => {
        t[e] && (t[e] = t[e].bind(t));
      });
    }
    function me(e, t) {
      return -1 !== e.indexOf(t, e.length - t.length);
    }
    function _e(e, t, i) {
      const n = {};
      for (const r in e) n[r] = t.call(i || this, e[r], r, e);
      return n;
    }
    function ge(e, t, i) {
      const n = {};
      for (const r in e) t.call(i || this, e[r], r, e) && (n[r] = e[r]);
      return n;
    }
    function ye(e) {
      return Array.isArray(e) ? e.map(ye) : 'object' == typeof e && e ? _e(e, ye) : e;
    }
    const xe = {};
    function ve(e) {
      xe[e] || ('undefined' != typeof console && console.warn(e), (xe[e] = !0));
    }
    function we(e, t, i) {
      return (i.y - e.y) * (t.x - e.x) > (t.y - e.y) * (i.x - e.x);
    }
    function Te(e) {
      let t = 0;
      for (let i, n, r = 0, o = e.length, a = o - 1; r < o; a = r++)
        (i = e[r]), (n = e[a]), (t += (n.x - i.x) * (i.y + n.y));
      return t;
    }
    function be() {
      return (
        'undefined' != typeof WorkerGlobalScope &&
        'undefined' != typeof self &&
        self instanceof WorkerGlobalScope
      );
    }
    function Se(e) {
      if (!e) return;
      const t = Array.isArray(e) ? [] : {};
      if ('object' != typeof e) return e;
      for (const i in e) t[i] = 'object' == typeof e[i] ? Se(e[i]) : e[i];
      return t;
    }
    function Ae(e) {
      return 'number' == typeof e;
    }
    function Pe(e) {
      return 'boolean' == typeof e;
    }
    const Ee = 6378137,
      Ce = 3.141592653589793,
      Me = {
        DEFAULT_SPHERE_TRIANGLES: [],
        SCROLL_ZOOM_SPHERE_CONTROL: 4,
        TILE_GRIDSAMPLES_SPLIT: {
          SMALL: 4,
          MIDDLE: 6,
          LARGE: 9,
          LARGE_S: 20,
          SMALL_Z_SAMPLES: 16,
          MIDDLE_Z_SAMPLES: 8,
          LARGE_Z_SAMPLES: 2,
          LARGE_S_Z_SAMPLES: 1,
          THE_MIN_SAMPLES: 1,
        },
        TRANSFORM: {
          PROJECTION_CHANGE_SMALL_ZOOM: 5,
          PROJECTION_CHANGE_MIDDLE_ZOOM: 10,
          PROJECTION_CHANGE_LARGE_ZOOM: 15,
          MAX_LAT: 90,
          MIN_LAT: -90,
          SPHERE_MAX_PITCH: 90,
          PLAIN_MAX_PITCH: 90,
          SPHERE_DRAG_PAN_MAX_PITCH: 45,
          DEG_TO_RAD: Ce / 180,
          RAD_TO_DEG: 180 / Ce,
          R: Ee,
          R1: 6356752.314245179,
          REAL_R: 6378137,
          R_SCALE: 1,
          R_ZOOM: 1,
          CIR: 2 * Ce * Ee,
          COVERING_TILE_ZOOM: 6,
          EPSILON1: 0.1,
          EPSILON2: 0.01,
          EPSILON3: 0.001,
          EPSILON4: 1e-4,
          EPSILON5: 1e-5,
          EPSILON6: 1e-6,
          EPSILON7: 1e-7,
          EPSILON8: 1e-8,
          EPSILON9: 1e-9,
          EPSILON10: 1e-10,
          EPSILON11: 1e-11,
          EPSILON12: 1e-12,
          EPSILON13: 1e-13,
          EPSILON14: 1e-14,
          EPSILON15: 1e-15,
          EPSILON16: 1e-16,
          EPSILON17: 1e-17,
          EPSILON18: 1e-18,
          EPSILON19: 1e-19,
          EPSILON20: 1e-20,
          UNIT_Z: [0, 0, 1],
          UNIT_Z_REVERSE: [0, 0, -1],
          VIEW_MAX_BOUNDING: { west: -180, south: -85.05113, east: 180, north: 85.05113 },
          PI: Ce,
          TWO_PI: 2 * Ce,
          PI_OVER_TWO: Ce / 2,
          FP_ZOOM: 17,
          TERRAIN_FIND_ZOOM_MIN: 5,
          TERRAIN_SIMPLIFY_ZOOM_MAX: 15,
          ERR_TERRAIN_ALT: -Ee,
          OFFSCREEN_WIDTH: 2048,
          OFFSCREEN_HEIGHT: 2048,
          SHADOW_VIEWPORT_SIZE: [8192, 8192],
          RAY_PICK_MIN_ZOOM: 4,
          BOUND_KEYS: [
            'topLeft',
            'topMidL',
            'topMiddle',
            'topMidR',
            'topRight',
            'bottomRight',
            'bottomMiddle',
            'bottomLeft',
          ],
          FOV_IN_RADIANS: 0.6435011087932844,
          FOV_IN_DEGREES: 36.86989764584402,
        },
        CesiumMath: {
          EPSILON1: 0.1,
          EPSILON2: 0.01,
          EPSILON3: 0.001,
          EPSILON4: 1e-4,
          EPSILON5: 1e-5,
          EPSILON6: 1e-6,
          EPSILON7: 1e-7,
          EPSILON8: 1e-8,
          EPSILON9: 1e-9,
          EPSILON10: 1e-10,
          EPSILON11: 1e-11,
          EPSILON12: 1e-12,
          EPSILON13: 1e-13,
          EPSILON14: 1e-14,
          EPSILON15: 1e-15,
          EPSILON16: 1e-16,
          EPSILON17: 1e-17,
          EPSILON18: 1e-18,
          EPSILON19: 1e-19,
          EPSILON20: 1e-20,
          EPSILON21: 1e-21,
          GRAVITATIONALPARAMETER: 3986004418e5,
          SOLAR_RADIUS: 6955e5,
          LUNAR_RADIUS: 1737400,
          SIXTY_FOUR_KILOBYTES: 65536,
          FOUR_GIGABYTES: 4294967296,
          PI: Math.PI,
          ONE_OVER_PI: 1 / Math.PI,
          PI_OVER_TWO: Math.PI / 2,
          PI_OVER_THREE: Math.PI / 3,
          PI_OVER_FOUR: Math.PI / 4,
          PI_OVER_SIX: Math.PI / 6,
          THREE_PI_OVER_TWO: (3 * Math.PI) / 2,
          TWO_PI: 2 * Math.PI,
          ONE_OVER_TWO_PI: 1 / (2 * Math.PI),
          RADIANS_PER_DEGREE: Math.PI / 180,
          DEGREES_PER_RADIAN: 180 / Math.PI,
          RADIANS_PER_ARCSECOND: Math.PI / 180 / 3600,
          log2: Z(Math.log2, (e) => Math.log(e) * Math.LOG2E),
          clamp: (e, t, i) => (e < t ? t : e > i ? i : e),
          equalsEpsilon(e, t, i, n) {
            (i = i || 0), (n = n || i);
            const r = Math.abs(e - t);
            return r <= n || r <= i * Math.max(Math.abs(e), Math.abs(t));
          },
          toRadians: (e) => e * Me.CesiumMath.RADIANS_PER_DEGREE,
          toDegrees: (e) => e * Me.CesiumMath.DEGREES_PER_RADIAN,
          negativePiToPi: (e) =>
            e >= -Me.CesiumMath.PI && e <= Me.CesiumMath.PI
              ? e
              : Me.CesiumMath.zeroToTwoPi(e + Me.CesiumMath.PI) - Me.CesiumMath.PI,
          zeroToTwoPi(e) {
            if (e >= 0 && e <= Me.CesiumMath.TWO_PI) return e;
            const t = Me.CesiumMath.mod(e, Me.CesiumMath.TWO_PI);
            return Math.abs(t) < Me.CesiumMath.EPSILON14 && Math.abs(e) > Me.CesiumMath.EPSILON14
              ? Me.CesiumMath.TWO_PI
              : t;
          },
          mod: (e, t) =>
            Math.sign(e) === Math.sign(t) && Math.abs(e) < Math.abs(t) ? e : ((e % t) + t) % t,
          acosClamped: (e) => Math.acos(se(e, -1, 1)),
          asinClamped: (e) => Math.asin(se(e, -1, 1)),
          chordLength(e, t) {
            if (void 0 === e) throw new Error('angle is required.');
            if (void 0 === t) throw new Error('radius is required.');
            return 2 * t * Math.sin(0.5 * e);
          },
        },
        TEXTUREWRAP: { REPEAT: 10497, CLAMP_TO_EDGE: 33071, MIRRORED_REPEAT: 33648 },
        TEXTUREMAGNIFICATIONFILTER: { NEAREST: 9728, LINEAR: 9729 },
        TEXTUREMINNIFICATIONFILTER: {
          NEAREST: 9728,
          LINEAR: 9729,
          NEAREST_MIPMAP_NEAREST: 9984,
          LINEAR_MIPMAP_NEAREST: 9985,
          NEAREST_MIPMAP_LINEAR: 9986,
          LINEAR_MIPMAP_LINEAR: 9987,
        },
        SOURCE: {
          MAX_BOUNDS: [
            [-180, 90],
            [180, 90],
            [180, -90],
            [-180, -90],
          ],
          ERROR_IMG_INDEX: -999,
          CLOCK_SKEW_RETRY_TIMEOUT: 3e4,
          TRANSPARENT_PNG_URL:
            'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=',
          MAX_PARALLEL_IMAGE_REQUESTS: 16,
          GLOBAL_SOURCE_ID: 'sphere-image-globe',
          SKYBOX_SOURCE_ID: 'sphere-image-skybox',
          PANORAMA_SOURCE_ID: 'panorama-special-source',
          ATMOSPHERE_SOURCE_ID: 'sphere-atmosphere',
          COSMOS_SOURCE_ID: 'sphere-cosmos',
          MAX_GLTF_TILE_COUNT: 300,
          MAX_GLTF_TILE_TO_FIND_PARENT: 64,
          MAX_IMAGE_CONCURRENCY: 32,
          TEXTURE_CUBE_KEYS: ['px', 'nx', 'py', 'ny', 'pz', 'nz'],
          ION_ACCESS_TOKEN:
            'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIzMGY4ODczYy1mNTk4LTRiMDUtYmIxYy0xZWYwOWZmMGY4NjQiLCJpZCI6NDQsInNjb3BlcyI6WyJhc3IiLCJnYyJdLCJhc3NldHMiOlsxLDIsMyw0LDYxOTMsNjI3Myw3MTYyLDczNTMsNzE0Ml0sImlhdCI6MTU0MTYxODM0NX0.lWnGs9ySXO4QK3HagcMsDpZ8L01DpmUDQm38-2QAQuE',
        },
        HIGHLIGHT_TYPE: { PRIMITIVE: 'PRIMITIVE', NODE: 'NODE', SCENE: 'SCENE' },
        MODEL_TYPE: { OSGB: 'osgb', E3DCM: 'e3dcm', TDMODEL: '3dmodel' },
        LAYER: { PANORAMA_LAYER_ID: 'panorama-special-layer', RADIATION_REGIONS: 5 },
        TILE: { EXTENT: 8192, DEPTH_MAX_RANGE: 1, OFFSCREEN_SIZE: 1024 },
        FPMODE: { MAP: 'MAP', DRAG_ROTATE: 'DRAG_ROTATE', NULL: 'NULL' },
        FRAMEBUFFER: { DEPTH_IMAGE_SCALE: 1 },
        EFFECTS: { FOG_START_DISTANCE: 4e3, FOG_CALC_LENGTH: 2e4, SHADOW_OFFSET: 25e-8 },
        CAMERA: {
          SUNLIGHT_CAMERA_ID: 'SUNLIGHT_CAMERA_ID',
          SKYBOX_CAMERA_ID: 'SKYBOX_CAMERA_ID',
          ATMOSPHERE_BLEND_CAMERA_ID: 'ATMOSPHERE_BLEND_CAMERA_ID',
          DRAW_MODE: {
            NORMAL: 'NORMAL',
            OFFSCREEN: 'OFFSCREEN',
            OFFSCREEN_VIEWSHED: 'OFFSCREEN_VIEWSHED',
            ONSCREEN_SHADOW: 'SHADOW',
            ONSCREEN_VIEWSHED: 'VIEWSHED',
            ONSCREEN_ALL: 'ONSCREEN_ALL',
          },
          SUNLIGHT_FIXED_MODE: { FIXED: 'FIXED', DYNAMIC: 'DYNAMIC' },
        },
        GL_CONST: {
          SHADOW_TEXTURE_UNIT1: { VALUE: 33984, INDEX: 0 },
          SHADOW_TEXTURE_UNIT2: { VALUE: 33985, INDEX: 1 },
          SHADOW_BASE_TEXTURE_UNIT: { VALUE: 33986, INDEX: 2 },
          FXAA_TEXTURE_UNIT1: { VALUE: 33987, INDEX: 3 },
          BLUR_TEXTURE_UNIT1: { VALUE: 33988, INDEX: 4 },
          BLUR_TEXTURE_UNIT2: { VALUE: 33989, INDEX: 5 },
          MODEL_TEXTURE_UNIT1: { VALUE: 33990, INDEX: 6 },
          MODEL_TEXTURE_UNIT2: { VALUE: 33991, INDEX: 7 },
          MODEL_TEXTURE_UNIT3: { VALUE: 33992, INDEX: 8 },
          MODEL_TEXTURE_UNIT4: { VALUE: 33993, INDEX: 9 },
          MODEL_TEXTURE_UNIT5: { VALUE: 33994, INDEX: 10 },
          VIDEO_TEXTURE_UNIT1: { VALUE: 33995, INDEX: 11 },
          PATTERN_TEXTURE_UNIT1: { VALUE: 33996, INDEX: 12 },
          BRDF_TEXTURE_UNIT: { VALUE: 33997, INDEX: 13 },
          TEXTURE14: { VALUE: 33998, INDEX: 14 },
          TEXTURE15: { VALUE: 33999, INDEX: 15 },
          TEXTURE16: { VALUE: 34e3, INDEX: 16 },
          TEXTURE17: { VALUE: 34001, INDEX: 17 },
          TEXTURE18: { VALUE: 34002, INDEX: 18 },
        },
        PERFORMANCE: {
          MODE: { FLIGHT: 'FLIGHT', MANUAL: 'MANUAL' },
          SMOOTH_CONSTS: { FRAME_RATE: 30, FRAME_DURATION: 33.33 },
        },
        COMPRESSED_TEXTURE_TYPE: {
          COMPRESSED_RGB_S3TC: {
            COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,
            COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777,
            COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778,
            COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,
          },
          COMPRESSED_RGB_PVRTC: {
            COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,
            COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841,
            COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,
            COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843,
          },
          COMPRESSED_RGB_ETC1_WEBGL: 36196,
        },
        COLORTYPEANDLENGTH: {
          ALPHA: 6406,
          RGB: 6407,
          RGBA: 6408,
          LUMINANCE: 6409,
          LUMINANCE_ALPHA: 6410,
          FRAGMENT_SHADER: 35632,
        },
        PixelDatatype: {
          UNSIGNED_BYTE: 5121,
          UNSIGNED_SHORT: 5123,
          UNSIGNED_INT: 5125,
          FLOAT: 5126,
          HALF_FLOAT_OES: 36193,
          UNSIGNED_INT_24_8: 34042,
          UNSIGNED_SHORT_4_4_4_4: 32819,
          UNSIGNED_SHORT_5_5_5_1: 32820,
          UNSIGNED_SHORT_5_6_5: 33635,
        },
      },
      Ie = {
        SYMTRACKING_DISPLAY_MODE: {
          DEFAULT: 'default',
          SEQUENCE: 'time-sequence',
          TIMESTAMP: 'timestamp',
        },
      };
    class Le {
      heading = 0;
      pitch = 0;
      roll = 0;
      constructor(e = 0, t = 0, i = 0) {
        (this.heading = e), (this.pitch = t), (this.roll = i);
      }
      static fromQuaternion(e, t = new Le()) {
        const i = 2 * (e.w * e.y - e.z * e.x),
          n = 1 - 2 * (e.x * e.x + e.y * e.y),
          r = 2 * (e.w * e.x + e.y * e.z);
        return (
          (t.heading = -Math.atan2(2 * (e.w * e.z + e.x * e.y), 1 - 2 * (e.y * e.y + e.z * e.z))),
          (t.roll = Math.atan2(r, n)),
          (t.pitch = -Me.CesiumMath.asinClamped(i)),
          t
        );
      }
      static fromDegrees(e, t, i, n = new Le()) {
        return (
          (n.heading = e * Me.CesiumMath.RADIANS_PER_DEGREE),
          (n.pitch = t * Me.CesiumMath.RADIANS_PER_DEGREE),
          (n.roll = i * Me.CesiumMath.RADIANS_PER_DEGREE),
          n
        );
      }
      static clone(e, t = new Le()) {
        return (t.heading = e.heading), (t.pitch = e.pitch), (t.roll = e.roll), t;
      }
      static equals(e, i) {
        return (
          e === i ||
          (t(e) && t(i) && e.heading === i.heading && e.pitch === i.pitch && e.roll === i.roll)
        );
      }
      static equalsEpsilon(e, i, n = 0, r = n) {
        return (
          e === i ||
          (t(e) &&
            t(i) &&
            Me.CesiumMath.equalsEpsilon(e.heading, i.heading, n, r) &&
            Me.CesiumMath.equalsEpsilon(e.pitch, i.pitch, n, r) &&
            Me.CesiumMath.equalsEpsilon(e.roll, i.roll, n, r))
        );
      }
      clone(e = new Le()) {
        return Le.clone(this, e);
      }
      equals(e) {
        return Le.equals(this, e);
      }
      equalsEpsilon(e, t = 0, i = t) {
        return Le.equalsEpsilon(this, e, t, i);
      }
      toString() {
        return `(${this.heading}, ${this.pitch}, ${this.roll})`;
      }
    }
    class Re extends h {
      copy(e) {
        for (let t = 0; t < this.ELEMENTS; t++) this[t] = e[t];
        return this;
      }
      len() {
        return Math.sqrt(this.lengthSquared());
      }
      magnitude() {
        return this.len();
      }
      lengthSquared() {
        let e = 0;
        for (let t = 0; t < this.ELEMENTS; ++t) e += this[t] * this[t];
        return e;
      }
      magnitudeSquared() {
        return this.lengthSquared();
      }
      distance(e) {
        return Math.sqrt(this.distanceSquared(e));
      }
      distanceSquared(e) {
        let t = 0;
        for (let i = 0; i < this.ELEMENTS; ++i) {
          const n = this[i] - e[i];
          t += n * n;
        }
        return p(t);
      }
      dot(e) {
        let t = 0;
        for (let i = 0; i < this.ELEMENTS; ++i) t += this[i] * e[i];
        return p(t);
      }
      normalize() {
        const e = this.magnitude();
        if (0 !== e) for (let t = 0; t < this.ELEMENTS; ++t) this[t] /= e;
        return this.check();
      }
      multiply(...e) {
        for (const t of e) for (let e = 0; e < this.ELEMENTS; ++e) this[e] *= t[e];
        return this.check();
      }
      divide(...e) {
        for (const t of e) for (let e = 0; e < this.ELEMENTS; ++e) this[e] /= t[e];
        return this.check();
      }
      lengthSq() {
        return this.lengthSquared();
      }
      distanceTo(e) {
        return this.distance(e);
      }
      distanceToSquared(e) {
        return this.distanceSquared(e);
      }
      getComponent(e) {
        return p(this[e]);
      }
      setComponent(e, t) {
        return (this[e] = t), this.check();
      }
      addVectors(e, t) {
        return this.copy(e).add(t);
      }
      subVectors(e, t) {
        return this.copy(e).subtract(t);
      }
      multiplyVectors(e, t) {
        return this.copy(e).multiply(t);
      }
      addScaledVector(e, t) {
        return this.add(new this.constructor(e).multiplyScalar(t));
      }
      scale(e) {
        if (a(e)) for (let t = 0; t < this.ELEMENTS; ++t) this[t] *= e[t];
        else this.multiplyScalar(e);
        return this;
      }
      lerp(e, t, i) {
        void 0 === i && 'number' == typeof t && ((i = t), (t = e), (e = this));
        for (let n = 0; n < this.ELEMENTS; ++n) {
          const r = e[n];
          this[n] = r + i * (t[n] - r);
        }
        return this.check();
      }
      min(e) {
        for (let t = 0; t < this.ELEMENTS; ++t) this[t] = Math.min(e[t], this[t]);
        return this.check();
      }
      max(e) {
        for (let t = 0; t < this.ELEMENTS; ++t) this[t] = Math.max(e[t], this[t]);
        return this.check();
      }
      clamp(e, t) {
        for (let i = 0; i < this.ELEMENTS; ++i) this[i] = Math.min(Math.max(this[i], e[i]), t[i]);
        return this.check();
      }
    }
    function Ne(e, t, i) {
      const n = t[0],
        r = t[1],
        o = i[3] * n + i[7] * r || 1;
      return (e[0] = (i[0] * n + i[4] * r) / o), (e[1] = (i[1] * n + i[5] * r) / o), e;
    }
    function Oe(e, t, i) {
      const n = t[0],
        r = t[1],
        o = t[2],
        a = i[3] * n + i[7] * r + i[11] * o || 1;
      return (
        (e[0] = (i[0] * n + i[4] * r + i[8] * o) / a),
        (e[1] = (i[1] * n + i[5] * r + i[9] * o) / a),
        (e[2] = (i[2] * n + i[6] * r + i[10] * o) / a),
        e
      );
    }
    function De(e, t, i) {
      const n = t[0],
        r = t[1],
        o = t[2];
      return (
        (e[0] = i[0] * n + i[3] * r + i[6] * o),
        (e[1] = i[1] * n + i[4] * r + i[7] * o),
        (e[2] = i[2] * n + i[5] * r + i[8] * o),
        (e[3] = t[3]),
        e
      );
    }
    class Fe extends h {
      get RANK() {
        return 0;
      }
      toString() {
        let e = '[';
        e += 'row-major:';
        for (let t = 0; t < this.RANK; ++t)
          for (let i = 0; i < this.RANK; ++i) e += ` ${this[i * this.RANK + t]}`;
        return (e += ']'), e;
      }
      getElementIndex(e, t) {
        return t * this.RANK + e;
      }
      getElement(e, t) {
        return this[t * this.RANK + e];
      }
      setElement(e, t, i) {
        return (this[t * this.RANK + e] = p(i)), this;
      }
      getColumn(e, t = new Array(this.RANK).fill(-0)) {
        const i = e * this.RANK;
        for (let e = 0; e < this.RANK; ++e) t[e] = this[i + e];
        return t;
      }
      setColumn(e, t) {
        const i = e * this.RANK;
        for (let e = 0; e < this.RANK; ++e) this[i + e] = t[e];
        return this;
      }
    }
    const ze = {},
      Be = new Float32Array(1),
      Ve = new Uint8Array(Be.buffer),
      Ue = new Uint32Array([287454020]),
      ke = 68 === new Uint8Array(Ue.buffer)[0];
    class Ge extends Re {
      static get ZERO() {
        return (ze.ZERO = ze.ZERO || Object.freeze(new Ge(0, 0, 0, 0)));
      }
      static get ONE() {
        return (ze.ONE = ze.ONE || Object.freeze(new Ge(1, 1, 1, 1)));
      }
      static get UNIT_X() {
        return (ze.UNIT_X = ze.UNIT_X || Object.freeze(new Ge(1, 0, 0, 0)));
      }
      static get UNIT_Y() {
        return (ze.UNIT_Y = ze.UNIT_Y || Object.freeze(new Ge(0, 1, 0, 0)));
      }
      static get UNIT_Z() {
        return (ze.UNIT_Z = ze.UNIT_Z || Object.freeze(new Ge(0, 0, 1, 0)));
      }
      static get UNIT_W() {
        return (ze.UNIT_W = ze.UNIT_W || Object.freeze(new Ge(0, 0, 0, 1)));
      }
      constructor(e = 0, t = 0, i = 0, n = 0) {
        super(-0, -0, -0, -0),
          a(e) && 1 === arguments.length
            ? this.copy(e)
            : ((this[0] = e), (this[1] = t), (this[2] = i), (this[3] = n));
      }
      get ELEMENTS() {
        return 4;
      }
      get x() {
        return this[0];
      }
      set x(e) {
        this[0] = p(e);
      }
      get y() {
        return this[1];
      }
      set y(e) {
        this[1] = p(e);
      }
      get z() {
        return this[2];
      }
      set z(e) {
        this[2] = p(e);
      }
      get w() {
        return this[3];
      }
      set w(e) {
        this[3] = p(e);
      }
      set(e, t, i, n) {
        return (this[0] = e), (this[1] = t), (this[2] = i), (this[3] = n), this.check();
      }
      copy(e) {
        return (this[0] = e[0]), (this[1] = e[1]), (this[2] = e[2]), (this[3] = e[3]), this.check();
      }
      fromObject(e) {
        return (this[0] = e.x), (this[1] = e.y), (this[2] = e.z), (this[3] = e.w), this;
      }
      toObject(e) {
        return (e.x = this[0]), (e.y = this[1]), (e.z = this[2]), (e.w = this[3]), e;
      }
      transform(e, t = this) {
        return z(t, this, e), t.check();
      }
      transformByMatrix3(e, t = this) {
        return De(t, this, e), t.check();
      }
      transformByMatrix2(e, t = this) {
        return (
          (function (e, t, i) {
            const n = t[0],
              r = t[1];
            (e[0] = i[0] * n + i[2] * r),
              (e[1] = i[1] * n + i[3] * r),
              (e[2] = t[2]),
              (e[3] = t[3]);
          })(t, this, e),
          t.check()
        );
      }
      transformByQuaternion(e, t) {
        return B(t, this, e), t.check();
      }
      applyMatrix4(e) {
        return e.transform(this, this), this;
      }
      static fromElements(e, t, i, n, r = new Ge()) {
        return (r.x = e), (r.y = t), (r.z = i), (r.w = n), r;
      }
      static clone(e, t = new Ge()) {
        return (t.x = e.x), (t.y = e.y), (t.z = e.z), (t.w = e.w), t;
      }
      static pack(e, t, i = 0) {
        return (t[i++] = e.x), (t[i++] = e.y), (t[i++] = e.z), (t[i] = e.w), t;
      }
      static unpack(e, t = 0, i = new Ge()) {
        return (i.x = e[t++]), (i.y = e[t++]), (i.z = e[t++]), (i.w = e[t]), i;
      }
      static packArray(e, t = new Array(4 * e.length)) {
        const i = e.length,
          n = 4 * i;
        if (!Array.isArray(t) && t.length !== n)
          throw new Error(
            'If result is a typed array, it must have exactly array.length * 4 elements',
          );
        t.length !== n && (t.length = n);
        for (let n = 0; n < i; ++n) Ge.pack(e[n], t, 4 * n);
        return t;
      }
      static unpackArray(e, t = new Array(e.length / 4)) {
        const i = e.length;
        t.length = i / 4;
        for (let n = 0; n < i; n += 4) {
          const i = n / 4;
          t[i] = Ge.unpack(e, n, t[i]);
        }
        return t;
      }
      static maximumComponent(e) {
        return Math.max(e.x, e.y, e.z, e.w);
      }
      static minimumComponent(e) {
        return Math.min(e.x, e.y, e.z, e.w);
      }
      static minimumByComponent(e, t, i = new Ge()) {
        return (
          (i.x = Math.min(e.x, t.x)),
          (i.y = Math.min(e.y, t.y)),
          (i.z = Math.min(e.z, t.z)),
          (i.w = Math.min(e.w, t.w)),
          i
        );
      }
      static maximumByComponent(e, t, i = new Ge()) {
        return (
          (i.x = Math.max(e.x, t.x)),
          (i.y = Math.max(e.y, t.y)),
          (i.z = Math.max(e.z, t.z)),
          (i.w = Math.max(e.w, t.w)),
          i
        );
      }
      static magnitudeSquared(e) {
        return e.x * e.x + e.y * e.y + e.z * e.z + e.w * e.w;
      }
      static magnitude(e) {
        return Math.sqrt(Ge.magnitudeSquared(e));
      }
      static distance(e, t) {
        const i = new Ge();
        return Ge.subtract(e, t, i), Ge.magnitude(i);
      }
      static distanceSquared(e, t) {
        const i = new Ge();
        return Ge.subtract(e, t, i), Ge.magnitudeSquared(i);
      }
      static normalize(e, t = new Ge()) {
        const i = Ge.magnitude(e);
        return (t.x = e.x / i), (t.y = e.y / i), (t.z = e.z / i), (t.w = e.w / i), t;
      }
      static dot(e, t) {
        return e.x * t.x + e.y * t.y + e.z * t.z + e.w * t.w;
      }
      static multiplyComponents(e, t, i = new Ge()) {
        return (i.x = e.x * t.x), (i.y = e.y * t.y), (i.z = e.z * t.z), (i.w = e.w * t.w), i;
      }
      static divideComponents(e, t, i = new Ge()) {
        return (i.x = e.x / t.x), (i.y = e.y / t.y), (i.z = e.z / t.z), (i.w = e.w / t.w), i;
      }
      static add(e, t, i = new Ge()) {
        return (i.x = e.x + t.x), (i.y = e.y + t.y), (i.z = e.z + t.z), (i.w = e.w + t.w), i;
      }
      static subtract(e, t, i = new Ge()) {
        return (i.x = e.x - t.x), (i.y = e.y - t.y), (i.z = e.z - t.z), (i.w = e.w - t.w), i;
      }
      static multiplyByScalar(e, t, i) {
        return (i.x = e.x * t), (i.y = e.y * t), (i.z = e.z * t), (i.w = e.w * t), i;
      }
      static divideByScalar(e, t, i) {
        return (i.x = e.x / t), (i.y = e.y / t), (i.z = e.z / t), (i.w = e.w / t), i;
      }
      static negate(e, t = new Ge()) {
        return (t.x = -e.x), (t.y = -e.y), (t.z = -e.z), (t.w = -e.w), t;
      }
      static abs(e, t = new Ge()) {
        return (
          (t.x = Math.abs(e.x)),
          (t.y = Math.abs(e.y)),
          (t.z = Math.abs(e.z)),
          (t.w = Math.abs(e.w)),
          t
        );
      }
      static lerp(e, t, i, n = new Ge()) {
        const r = new Ge();
        return (
          Ge.multiplyByScalar(t, i, r), (n = Ge.multiplyByScalar(e, 1 - i, n)), Ge.add(r, n, n)
        );
      }
      static mostOrthogonalAxis(e, t = new Ge()) {
        const i = new Ge(),
          n = Ge.normalize(e, i);
        return (
          Ge.abs(n, n),
          Ge.clone(
            n.x <= n.y
              ? n.x <= n.z
                ? n.x <= n.w
                  ? Ge.UNIT_X
                  : Ge.UNIT_W
                : n.z <= n.w
                ? Ge.UNIT_Z
                : Ge.UNIT_W
              : n.y <= n.z
              ? n.y <= n.w
                ? Ge.UNIT_Y
                : Ge.UNIT_W
              : n.z <= n.w
              ? Ge.UNIT_Z
              : Ge.UNIT_W,
            t,
          )
        );
      }
      static equals(e, i) {
        return (
          e === i || (t(e) && t(i) && e.x === i.x && e.y === i.y && e.z === i.z && e.w === i.w)
        );
      }
      static equalsArray(e, t, i = 0) {
        return e.x === t[i] && e.y === t[i + 1] && e.z === t[i + 2] && e.w === t[i + 3];
      }
      static equalsEpsilon(e, i, n = 0, r = n) {
        return (
          e === i ||
          (t(e) &&
            t(i) &&
            Me.CesiumMath.equalsEpsilon(e.x, i.x, n, r) &&
            Me.CesiumMath.equalsEpsilon(e.y, i.y, n, r) &&
            Me.CesiumMath.equalsEpsilon(e.z, i.z, n, r) &&
            Me.CesiumMath.equalsEpsilon(e.w, i.w, n, r))
        );
      }
      clone(e = new Ge()) {
        return Ge.clone(this, e);
      }
      equals(e) {
        return Ge.equals(this, e);
      }
      equalsEpsilon(e, t = 0, i = t) {
        return Ge.equalsEpsilon(this, e, t, i);
      }
      toString() {
        return `(${this.x}, ${this.y}, ${this.z}, ${this.w})`;
      }
      static packFloat(e, t = new Ge()) {
        return (
          (Be[0] = e),
          ke
            ? ((t.x = Ve[0]), (t.y = Ve[1]), (t.z = Ve[2]), (t.w = Ve[3]))
            : ((t.x = Ve[3]), (t.y = Ve[2]), (t.z = Ve[1]), (t.w = Ve[0])),
          t
        );
      }
      static unpackFloat(e) {
        return (
          ke
            ? ((Ve[0] = e.x), (Ve[1] = e.y), (Ve[2] = e.z), (Ve[3] = e.w))
            : ((Ve[0] = e.w), (Ve[1] = e.z), (Ve[2] = e.y), (Ve[3] = e.x)),
          Be[0]
        );
      }
      static fromColor(e, t, i = new Ge()) {
        return (
          void 0 !== e.r &&
            void 0 !== e.g &&
            void 0 !== e.b &&
            void 0 !== e.a &&
            (t
              ? ((i.x = e.r / 255), (i.y = e.g / 255), (i.z = e.b / 255), (i.w = e.a))
              : ((i.x = e.r), (i.y = e.g), (i.z = e.b), (i.w = e.a))),
          i
        );
      }
      static convert(e) {
        return Array.isArray(e) ? new Ge(e) : e;
      }
    }
    const He = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]),
      Ye = Object.freeze([0, 0, 0, 0, 0, 0, 0, 0, 0]),
      qe = Object.freeze({
        COL0ROW0: 0,
        COL0ROW1: 1,
        COL0ROW2: 2,
        COL1ROW0: 3,
        COL1ROW1: 4,
        COL1ROW2: 5,
        COL2ROW0: 6,
        COL2ROW1: 7,
        COL2ROW2: 8,
      }),
      Xe = {};
    class je extends Fe {
      static get IDENTITY() {
        return (Xe.IDENTITY = Xe.IDENTITY || Object.freeze(new je(He))), Xe.IDENTITY;
      }
      static get ZERO() {
        return (Xe.ZERO = Xe.ZERO || Object.freeze(new je(Ye))), Xe.ZERO;
      }
      constructor(e) {
        super(-0, -0, -0, -0, -0, -0, -0, -0, -0),
          1 === arguments.length && a(e) ? this.copy(e) : this.identity();
      }
      get ELEMENTS() {
        return 9;
      }
      get RANK() {
        return 3;
      }
      copy(e) {
        return (
          (this[0] = e[0]),
          (this[1] = e[1]),
          (this[2] = e[2]),
          (this[3] = e[3]),
          (this[4] = e[4]),
          (this[5] = e[5]),
          (this[6] = e[6]),
          (this[7] = e[7]),
          (this[8] = e[8]),
          this.check()
        );
      }
      set(e, t, i, n, r, o, a, s, l) {
        return (
          (this[0] = e),
          (this[1] = t),
          (this[2] = i),
          (this[3] = n),
          (this[4] = r),
          (this[5] = o),
          (this[6] = a),
          (this[7] = s),
          (this[8] = l),
          this.check()
        );
      }
      setRowMajor(e, t, i, n, r, o, a, s, l) {
        return (
          (this[0] = e),
          (this[1] = n),
          (this[2] = a),
          (this[3] = t),
          (this[4] = r),
          (this[5] = s),
          (this[6] = i),
          (this[7] = o),
          (this[8] = l),
          this.check()
        );
      }
      determinant() {
        return (
          (e = this)[0] * ((a = e[8]) * (i = e[4]) - (n = e[5]) * (o = e[7])) +
          e[1] * (-a * (t = e[3]) + n * (r = e[6])) +
          e[2] * (o * t - i * r)
        );
        var e, t, i, n, r, o, a;
      }
      identity() {
        return this.copy(He);
      }
      fromQuaternion(e, t = this) {
        return (
          (function (e, t) {
            var i = t[0],
              n = t[1],
              r = t[2],
              o = t[3],
              a = i + i,
              s = n + n,
              l = r + r,
              c = i * a,
              u = n * a,
              h = n * s,
              d = r * a,
              p = r * s,
              f = r * l,
              m = o * a,
              _ = o * s,
              g = o * l;
            (e[0] = 1 - h - f),
              (e[3] = u - g),
              (e[6] = d + _),
              (e[1] = u + g),
              (e[4] = 1 - c - f),
              (e[7] = p - m),
              (e[2] = d - _),
              (e[5] = p + m),
              (e[8] = 1 - c - h);
          })(t, e),
          t.check()
        );
      }
      transpose(e = this) {
        return (
          (function (e, t) {
            if (e === t) {
              var i = t[1],
                n = t[2],
                r = t[5];
              (e[1] = t[3]), (e[2] = t[6]), (e[3] = i), (e[5] = t[7]), (e[6] = n), (e[7] = r);
            } else
              (e[0] = t[0]),
                (e[1] = t[3]),
                (e[2] = t[6]),
                (e[3] = t[1]),
                (e[4] = t[4]),
                (e[5] = t[7]),
                (e[6] = t[2]),
                (e[7] = t[5]),
                (e[8] = t[8]);
          })(e, this),
          e.check()
        );
      }
      invert(e = this) {
        return (
          (function (e, t) {
            var i = t[0],
              n = t[1],
              r = t[2],
              o = t[3],
              a = t[4],
              s = t[5],
              l = t[6],
              c = t[7],
              u = t[8],
              h = u * a - s * c,
              d = -u * o + s * l,
              p = c * o - a * l,
              f = i * h + n * d + r * p;
            f &&
              ((e[0] = h * (f = 1 / f)),
              (e[1] = (-u * n + r * c) * f),
              (e[2] = (s * n - r * a) * f),
              (e[3] = d * f),
              (e[4] = (u * i - r * l) * f),
              (e[5] = (-s * i + r * o) * f),
              (e[6] = p * f),
              (e[7] = (-c * i + n * l) * f),
              (e[8] = (a * i - n * o) * f));
          })(e, this),
          e.check()
        );
      }
      multiplyLeft(e, t = this) {
        return v(t, e, this), t.check();
      }
      multiplyRight(e, t = this) {
        return t ? (v(t, this, e), t.check()) : (v(this, this, e), this.check());
      }
      rotate(e, t = this) {
        return (
          (function (e, t, i) {
            var n = t[0],
              r = t[1],
              o = t[2],
              a = t[3],
              s = t[4],
              l = t[5],
              c = t[6],
              u = t[7],
              h = t[8],
              d = Math.sin(i),
              p = Math.cos(i);
            (e[0] = p * n + d * a),
              (e[1] = p * r + d * s),
              (e[2] = p * o + d * l),
              (e[3] = p * a - d * n),
              (e[4] = p * s - d * r),
              (e[5] = p * l - d * o),
              (e[6] = c),
              (e[7] = u),
              (e[8] = h);
          })(t, this, e),
          t.check()
        );
      }
      scale(e, t = this) {
        return a(e) ? w(t, this, e) : w(t, this, [e, e, e]), t.check();
      }
      translate(e, t = this) {
        return (
          (function (e, t, i) {
            var n = t[0],
              r = t[1],
              o = t[2],
              a = t[3],
              s = t[4],
              l = t[5],
              c = t[6],
              u = t[7],
              h = t[8],
              d = i[0],
              p = i[1];
            (e[0] = n),
              (e[1] = r),
              (e[2] = o),
              (e[3] = a),
              (e[4] = s),
              (e[5] = l),
              (e[6] = d * n + p * a + c),
              (e[7] = d * r + p * s + u),
              (e[8] = d * o + p * l + h);
          })(t, this, e),
          t.check()
        );
      }
      getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose();
      }
      transform(e, t) {
        switch (e.length) {
          case 2:
            t = W(t || [-0, -0], e, this);
            break;
          case 3:
            t = O(t || [-0, -0, -0], e, this);
            break;
          case 4:
            t = De(t || [-0, -0, -0, -0], e, this);
            break;
          default:
            throw new Error('Illegal vector');
        }
        return f(t, e.length), t;
      }
      setFromMatrix4(e) {
        const t = e.elements;
        return this.setRowMajor(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
      }
      static multiply(e, t, i = new je()) {
        const n = e[1] * t[0] + e[4] * t[1] + e[7] * t[2],
          r = e[2] * t[0] + e[5] * t[1] + e[8] * t[2],
          o = e[0] * t[3] + e[3] * t[4] + e[6] * t[5],
          a = e[1] * t[3] + e[4] * t[4] + e[7] * t[5],
          s = e[2] * t[3] + e[5] * t[4] + e[8] * t[5],
          l = e[0] * t[6] + e[3] * t[7] + e[6] * t[8],
          c = e[1] * t[6] + e[4] * t[7] + e[7] * t[8],
          u = e[2] * t[6] + e[5] * t[7] + e[8] * t[8];
        return (
          (i[0] = e[0] * t[0] + e[3] * t[1] + e[6] * t[2]),
          (i[1] = n),
          (i[2] = r),
          (i[3] = o),
          (i[4] = a),
          (i[5] = s),
          (i[6] = l),
          (i[7] = c),
          (i[8] = u),
          i
        );
      }
      static multiplyByScale(e, t, i) {
        return (
          (i[0] = e[0] * t.x),
          (i[1] = e[1] * t.x),
          (i[2] = e[2] * t.x),
          (i[3] = e[3] * t.y),
          (i[4] = e[4] * t.y),
          (i[5] = e[5] * t.y),
          (i[6] = e[6] * t.z),
          (i[7] = e[7] * t.z),
          (i[8] = e[8] * t.z),
          i
        );
      }
      static multiplyByVector(e, t, i) {
        const n = t.x,
          r = t.y,
          o = t.z,
          a = e[1] * n + e[4] * r + e[7] * o,
          s = e[2] * n + e[5] * r + e[8] * o;
        return (i.x = e[0] * n + e[3] * r + e[6] * o), (i.y = a), (i.z = s), i;
      }
      static fromScale(e, t = new je()) {
        return (
          (t[0] = e.x),
          (t[1] = 0),
          (t[2] = 0),
          (t[3] = 0),
          (t[4] = e.y),
          (t[5] = 0),
          (t[6] = 0),
          (t[7] = 0),
          (t[8] = e.z),
          t
        );
      }
      static setColumn(e, t, i, n = new je()) {
        const r = 3 * t;
        return ((n = je.clone(e, n))[r] = i.x), (n[r + 1] = i.y), (n[r + 2] = i.z), n;
      }
      static getColumn(e, t, i = new Pt()) {
        const n = 3 * t,
          r = e[n + 1],
          o = e[n + 2];
        return (i.x = e[n]), (i.y = r), (i.z = o), i;
      }
      static clone(e, t = new je()) {
        return (
          (t[0] = e[0]),
          (t[1] = e[1]),
          (t[2] = e[2]),
          (t[3] = e[3]),
          (t[4] = e[4]),
          (t[5] = e[5]),
          (t[6] = e[6]),
          (t[7] = e[7]),
          (t[8] = e[8]),
          t
        );
      }
      static equalsArray(e, t, i = 0) {
        return (
          e[0] === t[0 + i] &&
          e[1] === t[1 + i] &&
          e[2] === t[2 + i] &&
          e[3] === t[3 + i] &&
          e[4] === t[4 + i] &&
          e[5] === t[5 + i] &&
          e[6] === t[6 + i] &&
          e[7] === t[7 + i] &&
          e[8] === t[8 + i]
        );
      }
      static pack(e, t, i = 0) {
        return (
          (t[i++] = e[0]),
          (t[i++] = e[1]),
          (t[i++] = e[2]),
          (t[i++] = e[3]),
          (t[i++] = e[4]),
          (t[i++] = e[5]),
          (t[i++] = e[6]),
          (t[i++] = e[7]),
          (t[i++] = e[8]),
          t
        );
      }
      static equalsEpsilon(e, i, n = 0) {
        return (
          e === i ||
          (t(e) &&
            t(i) &&
            Math.abs(e[0] - i[0]) <= n &&
            Math.abs(e[1] - i[1]) <= n &&
            Math.abs(e[2] - i[2]) <= n &&
            Math.abs(e[3] - i[3]) <= n &&
            Math.abs(e[4] - i[4]) <= n &&
            Math.abs(e[5] - i[5]) <= n &&
            Math.abs(e[6] - i[6]) <= n &&
            Math.abs(e[7] - i[7]) <= n &&
            Math.abs(e[8] - i[8]) <= n)
        );
      }
      static fromQuaternion(e, t = new je()) {
        const i = e.x * e.x,
          n = e.x * e.y,
          r = e.x * e.z,
          o = e.x * e.w,
          a = e.y * e.y,
          s = e.y * e.z,
          l = e.y * e.w,
          c = e.z * e.z,
          u = e.z * e.w,
          h = e.w * e.w,
          d = 2 * (n - u),
          p = 2 * (r + l),
          f = 2 * (n + u),
          m = -i + a - c + h,
          _ = 2 * (s - o),
          g = 2 * (r - l),
          y = 2 * (s + o),
          x = -i - a + c + h;
        return (
          (t[0] = i - a - c + h),
          (t[1] = f),
          (t[2] = g),
          (t[3] = d),
          (t[4] = m),
          (t[5] = y),
          (t[6] = p),
          (t[7] = _),
          (t[8] = x),
          t
        );
      }
      static transpose(e, t = new je()) {
        const i = e[3],
          n = e[6],
          r = e[1],
          o = e[4],
          a = e[7],
          s = e[2],
          l = e[5],
          c = e[8];
        return (
          (t[0] = e[0]),
          (t[1] = i),
          (t[2] = n),
          (t[3] = r),
          (t[4] = o),
          (t[5] = a),
          (t[6] = s),
          (t[7] = l),
          (t[8] = c),
          t
        );
      }
      static getElementIndex = function (e, t) {
        return 3 * e + t;
      };
      static computeFrobeniusNorm(e) {
        let t = 0;
        for (let i = 0; i < 9; ++i) {
          const n = e[i];
          t += n * n;
        }
        return Math.sqrt(t);
      }
      static offDiagonalFrobeniusNorm(e) {
        const t = [2, 2, 1],
          i = [1, 0, 0];
        let n = 0;
        for (let r = 0; r < 3; ++r) {
          const o = e[je.getElementIndex(t[r], i[r])];
          n += 2 * o * o;
        }
        return Math.sqrt(n);
      }
      static shurDecomposition(e, t) {
        const i = [1, 0, 0],
          n = [2, 2, 1];
        let r = 0,
          o = 1;
        for (let t = 0; t < 3; ++t) {
          const a = Math.abs(e[je.getElementIndex(n[t], i[t])]);
          a > r && ((o = t), (r = a));
        }
        let a = 1,
          s = 0;
        const l = i[o],
          c = n[o];
        if (Math.abs(e[je.getElementIndex(c, l)]) > 1e-15) {
          const t =
            (e[je.getElementIndex(c, c)] - e[je.getElementIndex(l, l)]) /
            2 /
            e[je.getElementIndex(c, l)];
          let i;
          (i = t < 0 ? -1 / (-t + Math.sqrt(1 + t * t)) : 1 / (t + Math.sqrt(1 + t * t))),
            (a = 1 / Math.sqrt(1 + i * i)),
            (s = i * a);
        }
        return (
          ((t = je.clone(je.IDENTITY, t))[je.getElementIndex(l, l)] = t[je.getElementIndex(c, c)] =
            a),
          (t[je.getElementIndex(c, l)] = s),
          (t[je.getElementIndex(l, c)] = -s),
          t
        );
      }
      static computeEigenDecomposition(e, t = {}) {
        const i = new je(),
          n = new je();
        let r = 0,
          o = 0;
        const a = (t.unitary = je.clone(je.IDENTITY, t.unitary)),
          s = (t.diagonal = je.clone(e, t.diagonal)),
          l = 1e-20 * je.computeFrobeniusNorm(s);
        for (; o < 10 && je.offDiagonalFrobeniusNorm(s) > l; )
          je.shurDecomposition(s, i),
            je.transpose(i, n),
            je.multiply(s, i, s),
            je.multiply(n, s, s),
            je.multiply(a, i, a),
            ++r > 2 && (++o, (r = 0));
        return t;
      }
      transformVector(e, t) {
        return m('Matrix3.transformVector'), this.transform(e, t);
      }
      transformVector2(e, t) {
        return m('Matrix3.transformVector'), this.transform(e, t);
      }
      transformVector3(e, t) {
        return m('Matrix3.transformVector'), this.transform(e, t);
      }
    }
    const We = {};
    class $e extends Re {
      static get ONE() {
        return (We.ONE = We.ONE || Object.freeze(new $e(1, 1)));
      }
      static get ZERO() {
        return (We.ZERO = We.ZERO || Object.freeze(new $e(0, 0)));
      }
      static get UNIT_X() {
        return (We.UNIT_X = We.UNIT_X || Object.freeze(new $e(1, 0)));
      }
      static get UNIT_Y() {
        return (We.UNIT_Y = We.UNIT_Y || Object.freeze(new $e(0, 1)));
      }
      constructor(e = 0, t = 0) {
        super(2), a(e) && 1 === arguments.length ? this.copy(e) : ((this[0] = e), (this[1] = t));
      }
      get ELEMENTS() {
        return 2;
      }
      get x() {
        return this[0];
      }
      set x(e) {
        this[0] = p(e);
      }
      get y() {
        return this[1];
      }
      set y(e) {
        this[1] = p(e);
      }
      set(e, t) {
        return (this[0] = e), (this[1] = t), this.check();
      }
      copy(e) {
        return (this[0] = e[0]), (this[1] = e[1]), this.check();
      }
      fromObject(e) {
        return (this[0] = e.x), (this[1] = e.y), this.check();
      }
      toObject(e = {}) {
        return (e.x = this[0]), (e.y = this[1]), e;
      }
      horizontalAngle() {
        return Math.atan2(this.y, this.x);
      }
      verticalAngle() {
        return Math.atan2(this.x, this.y);
      }
      rotate(e, t, i) {
        const n = e[0] - t[0],
          r = e[1] - t[1],
          o = Math.sin(i),
          a = Math.cos(i);
        return (this[0] = n * a - r * o + t[0]), (this[1] = n * o + r * a + t[1]), this.check();
      }
      transform(e, t = this) {
        return this.transformAsPoint(e, t);
      }
      transformAsPoint(e, t = this) {
        return $(t, this, e), t.check();
      }
      transformAsVector(e, t = this) {
        return Ne(t, this, e), t.check();
      }
      transformByMatrix3(e, t = this) {
        return W(t, this, e), t.check();
      }
      transformByMatrix2(e, t = this) {
        return j(t, this, e), t.check();
      }
      perp() {
        const e = this.x;
        return (this.x = this.y), (this.y = -e), this.check();
      }
      mostOrthogonalAxis(e, t = new $e()) {
        const i = new $e(),
          n = $e.normalize(e, i);
        return $e.abs(n, n), $e.clone(n.x <= n.y ? $e.UNIT_X : $e.UNIT_Y, t);
      }
      clone(e = new $e()) {
        return $e.clone(this, e);
      }
      equals(e) {
        return $e.equals(this, e);
      }
      equalsEpsilon(e, t = 0, i = t) {
        return $e.equalsEpsilon(this, e, t, i);
      }
      toString() {
        return `(${this.x}, ${this.y})`;
      }
      static fromElements(e, t, i = new $e()) {
        return (i.x = e), (i.y = t), i;
      }
      static clone(e, t = new $e()) {
        return (t.x = e.x), (t.y = e.y), t;
      }
      static pack(e, t, i = 0) {
        return (t[i++] = e.x), (t[i] = e.y), t;
      }
      static unpack(e, t = 0, i = new $e()) {
        return (i.x = e[t++]), (i.y = e[t]), i;
      }
      static packArray(e, i) {
        const n = e.length,
          r = 2 * n;
        if (t(i)) {
          if (!Array.isArray(i) && i.length !== r)
            throw new Error(
              'If result is a typed array, it must have exactly array.length * 2 elements',
            );
          i.length !== r && (i.length = r);
        } else i = new Array(r);
        for (let t = 0; t < n; ++t) $e.pack(e[t], i, 2 * t);
        return i;
      }
      static unpackArray(e, i) {
        const n = e.length;
        t(i) ? (i.length = n / 2) : (i = new Array(n / 2));
        for (let t = 0; t < n; t += 2) {
          const n = t / 2;
          i[n] = $e.unpack(e, t, i[n]);
        }
        return i;
      }
      static maximumComponent(e) {
        return Math.max(e.x, e.y);
      }
      static minimumComponent(e) {
        return Math.min(e.x, e.y);
      }
      static minimumByComponent(e, t, i = new $e()) {
        return (i.x = Math.min(e.x, t.x)), (i.y = Math.min(e.y, t.y)), i;
      }
      static maximumByComponent(e, t, i = new $e()) {
        return (i.x = Math.max(e.x, t.x)), (i.y = Math.max(e.y, t.y)), i;
      }
      static magnitudeSquared(e) {
        return e.x * e.x + e.y * e.y;
      }
      static magnitude(e) {
        return Math.sqrt($e.magnitudeSquared(e));
      }
      static distance(e, t) {
        const i = new $e();
        return $e.subtract(e, t, i), $e.magnitude(i);
      }
      static distanceSquared(e, t) {
        const i = new $e();
        return $e.subtract(e, t, i), $e.magnitudeSquared(i);
      }
      static normalize(e, t = new $e()) {
        const i = $e.magnitude(e);
        return (t.x = e.x / i), (t.y = e.y / i), t;
      }
      static dot(e, t) {
        return e.x * t.x + e.y * t.y;
      }
      static cross(e, t) {
        return e.x * t.y - e.y * t.x;
      }
      static multiplyComponents(e, t, i) {
        return (i.x = e.x * t.x), (i.y = e.y * t.y), i;
      }
      static divideComponents(e, t, i = new $e()) {
        return (i.x = e.x / t.x), (i.y = e.y / t.y), i;
      }
      static add(e, t, i = new $e()) {
        return (i.x = e.x + t.x), (i.y = e.y + t.y), i;
      }
      static subtract(e, t, i = new $e()) {
        return (i.x = e.x - t.x), (i.y = e.y - t.y), i;
      }
      static multiplyByScalar(e, t, i = new $e()) {
        return (i.x = e.x * t), (i.y = e.y * t), i;
      }
      static divideByScalar(e, t, i = new $e()) {
        return (i.x = e.x / t), (i.y = e.y / t), i;
      }
      static negate(e, t) {
        return (t.x = -e.x), (t.y = -e.y), t;
      }
      static abs(e, t) {
        return (t.x = Math.abs(e.x)), (t.y = Math.abs(e.y)), t;
      }
      static lerp(e, t, i, n = new $e()) {
        const r = new $e();
        return (
          $e.multiplyByScalar(t, i, r), (n = $e.multiplyByScalar(e, 1 - i, n)), $e.add(r, n, n)
        );
      }
      static angleBetween(e, t) {
        const i = new $e(),
          n = new $e();
        return $e.normalize(e, i), $e.normalize(t, n), Me.CesiumMath.acosClamped($e.dot(i, n));
      }
      static equals(e, t) {
        return e === t || (e.x === t.x && e.y === t.y);
      }
      static equalsArray(e, t, i = 0) {
        return e.x === t[i] && e.y === t[i + 1];
      }
      static equalsEpsilon(e, t, i = 0, n = i) {
        return (
          e === t ||
          (Me.CesiumMath.equalsEpsilon(e.x, t.x, i, n) &&
            Me.CesiumMath.equalsEpsilon(e.y, t.y, i, n))
        );
      }
      static convert(e) {
        return Array.isArray(e) ? new $e(e) : e;
      }
    }
    const Ze = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      Ke = Object.freeze([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
      Qe = {};
    Object.freeze({
      COL0ROW0: 0,
      COL0ROW1: 1,
      COL0ROW2: 2,
      COL0ROW3: 3,
      COL1ROW0: 4,
      COL1ROW1: 5,
      COL1ROW2: 6,
      COL1ROW3: 7,
      COL2ROW0: 8,
      COL2ROW1: 9,
      COL2ROW2: 10,
      COL2ROW3: 11,
      COL3ROW0: 12,
      COL3ROW1: 13,
      COL3ROW2: 14,
      COL3ROW3: 15,
    });
    class Je extends Fe {
      static get IDENTITY() {
        return (Qe.IDENTITY = Qe.IDENTITY || Object.freeze(new Je(Ze))), Qe.IDENTITY;
      }
      static get ZERO() {
        return (Qe.ZERO = Qe.ZERO || Object.freeze(new Je(Ke))), Qe.ZERO;
      }
      constructor(e) {
        super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0),
          1 === arguments.length && a(e) ? this.copy(e) : this.identity();
      }
      get ELEMENTS() {
        return 16;
      }
      get RANK() {
        return 4;
      }
      copy(e) {
        return (
          (this[0] = e[0]),
          (this[1] = e[1]),
          (this[2] = e[2]),
          (this[3] = e[3]),
          (this[4] = e[4]),
          (this[5] = e[5]),
          (this[6] = e[6]),
          (this[7] = e[7]),
          (this[8] = e[8]),
          (this[9] = e[9]),
          (this[10] = e[10]),
          (this[11] = e[11]),
          (this[12] = e[12]),
          (this[13] = e[13]),
          (this[14] = e[14]),
          (this[15] = e[15]),
          this.check()
        );
      }
      set(e, t, i, n, r, o, a, s, l, c, u, h, d, p, f, m) {
        return (
          (this[0] = e),
          (this[1] = t),
          (this[2] = i),
          (this[3] = n),
          (this[4] = r),
          (this[5] = o),
          (this[6] = a),
          (this[7] = s),
          (this[8] = l),
          (this[9] = c),
          (this[10] = u),
          (this[11] = h),
          (this[12] = d),
          (this[13] = p),
          (this[14] = f),
          (this[15] = m),
          this.check()
        );
      }
      setRowMajor(e, t, i, n, r, o, a, s, l, c, u, h, d, p, f, m) {
        return (
          (this[0] = e),
          (this[1] = r),
          (this[2] = l),
          (this[3] = d),
          (this[4] = t),
          (this[5] = o),
          (this[6] = c),
          (this[7] = p),
          (this[8] = i),
          (this[9] = a),
          (this[10] = u),
          (this[11] = f),
          (this[12] = n),
          (this[13] = s),
          (this[14] = h),
          (this[15] = m),
          this.check()
        );
      }
      toRowMajor(e) {
        return (
          (e[0] = this[0]),
          (e[1] = this[4]),
          (e[2] = this[8]),
          (e[3] = this[12]),
          (e[4] = this[1]),
          (e[5] = this[5]),
          (e[6] = this[9]),
          (e[7] = this[13]),
          (e[8] = this[2]),
          (e[9] = this[6]),
          (e[10] = this[10]),
          (e[11] = this[14]),
          (e[12] = this[3]),
          (e[13] = this[7]),
          (e[14] = this[11]),
          (e[15] = this[15]),
          e
        );
      }
      setFromMatrix3(e) {
        return (
          this.set(e[0], e[1], e[2], 0, e[3], e[4], e[5], 0, e[6], e[7], e[8], 0, 0, 0, 0, 1),
          this.check()
        );
      }
      identity() {
        return this.copy(Ze);
      }
      fromQuaternion(e) {
        return (
          (function (e, t) {
            var i = t[0],
              n = t[1],
              r = t[2],
              o = t[3],
              a = i + i,
              s = n + n,
              l = r + r,
              c = i * a,
              u = n * a,
              h = n * s,
              d = r * a,
              p = r * s,
              f = r * l,
              m = o * a,
              _ = o * s,
              g = o * l;
            (e[0] = 1 - h - f),
              (e[1] = u + g),
              (e[2] = d - _),
              (e[3] = 0),
              (e[4] = u - g),
              (e[5] = 1 - c - f),
              (e[6] = p + m),
              (e[7] = 0),
              (e[8] = d + _),
              (e[9] = p - m),
              (e[10] = 1 - c - h),
              (e[11] = 0),
              (e[12] = 0),
              (e[13] = 0),
              (e[14] = 0),
              (e[15] = 1);
          })(this, e),
          this.check()
        );
      }
      frustum({ left: e, right: t, bottom: i, top: n, near: r, far: o }) {
        return (
          o === 1 / 0
            ? Je.#t(this, e, t, i, n, r)
            : (function (e, t, i, n, r, o, a) {
                var s = 1 / (i - t),
                  l = 1 / (r - n),
                  c = 1 / (o - a);
                (e[0] = 2 * o * s),
                  (e[1] = 0),
                  (e[2] = 0),
                  (e[3] = 0),
                  (e[4] = 0),
                  (e[5] = 2 * o * l),
                  (e[6] = 0),
                  (e[7] = 0),
                  (e[8] = (i + t) * s),
                  (e[9] = (r + n) * l),
                  (e[10] = (a + o) * c),
                  (e[11] = -1),
                  (e[12] = 0),
                  (e[13] = 0),
                  (e[14] = a * o * 2 * c),
                  (e[15] = 0);
              })(this, e, t, i, n, r, o),
          this.check()
        );
      }
      static #t(e, t, i, n, r, o) {
        const a = (2 * o) / (r - n),
          s = (i + t) / (i - t),
          l = (r + n) / (r - n),
          c = -2 * o;
        return (
          (e[0] = (2 * o) / (i - t)),
          (e[1] = 0),
          (e[2] = 0),
          (e[3] = 0),
          (e[4] = 0),
          (e[5] = a),
          (e[6] = 0),
          (e[7] = 0),
          (e[8] = s),
          (e[9] = l),
          (e[10] = -1),
          (e[11] = -1),
          (e[12] = 0),
          (e[13] = 0),
          (e[14] = c),
          (e[15] = 0),
          e
        );
      }
      lookAt(e, t, i) {
        return (
          1 === arguments.length && ({ eye: e, center: t, up: i } = e),
          (function (e, t, i, n) {
            var r,
              o,
              a,
              s,
              l,
              c,
              u,
              h,
              d,
              p,
              f = t[0],
              m = t[1],
              g = t[2],
              y = n[0],
              x = n[1],
              v = n[2],
              w = i[0],
              T = i[1],
              b = i[2];
            Math.abs(f - w) < _ && Math.abs(m - T) < _ && Math.abs(g - b) < _
              ? (function (e) {
                  (e[0] = 1),
                    (e[1] = 0),
                    (e[2] = 0),
                    (e[3] = 0),
                    (e[4] = 0),
                    (e[5] = 1),
                    (e[6] = 0),
                    (e[7] = 0),
                    (e[8] = 0),
                    (e[9] = 0),
                    (e[10] = 1),
                    (e[11] = 0),
                    (e[12] = 0),
                    (e[13] = 0),
                    (e[14] = 0),
                    (e[15] = 1);
                })(e)
              : ((u = f - w),
                (h = m - T),
                (d = g - b),
                (r = x * (d *= p = 1 / Math.hypot(u, h, d)) - v * (h *= p)),
                (o = v * (u *= p) - y * d),
                (a = y * h - x * u),
                (p = Math.hypot(r, o, a))
                  ? ((r *= p = 1 / p), (o *= p), (a *= p))
                  : ((r = 0), (o = 0), (a = 0)),
                (s = h * a - d * o),
                (l = d * r - u * a),
                (c = u * o - h * r),
                (p = Math.hypot(s, l, c))
                  ? ((s *= p = 1 / p), (l *= p), (c *= p))
                  : ((s = 0), (l = 0), (c = 0)),
                (e[0] = r),
                (e[1] = s),
                (e[2] = u),
                (e[3] = 0),
                (e[4] = o),
                (e[5] = l),
                (e[6] = h),
                (e[7] = 0),
                (e[8] = a),
                (e[9] = c),
                (e[10] = d),
                (e[11] = 0),
                (e[12] = -(r * f + o * m + a * g)),
                (e[13] = -(s * f + l * m + c * g)),
                (e[14] = -(u * f + h * m + d * g)),
                (e[15] = 1));
          })(this, e, (t = t || [0, 0, 0]), (i = i || [0, 1, 0])),
          this.check()
        );
      }
      ortho({ left: e, right: t, bottom: i, top: n, near: r = 0.1, far: o = 500 }) {
        return (
          (function (e, t, i, n, r, o, a) {
            var s = 1 / (t - i),
              l = 1 / (n - r),
              c = 1 / (o - a);
            (e[0] = -2 * s),
              (e[1] = 0),
              (e[2] = 0),
              (e[3] = 0),
              (e[4] = 0),
              (e[5] = -2 * l),
              (e[6] = 0),
              (e[7] = 0),
              (e[8] = 0),
              (e[9] = 0),
              (e[10] = 2 * c),
              (e[11] = 0),
              (e[12] = (t + i) * s),
              (e[13] = (r + n) * l),
              (e[14] = (a + o) * c),
              (e[15] = 1);
          })(this, e, t, i, n, r, o),
          this.check()
        );
      }
      perspective({ fov: e = 0.25 * Math.PI, aspect: t = 1, near: i = 0.1, far: n = 500 }) {
        if (e > 2 * Math.PI) throw Error('radians');
        return (
          (function (e, t, i, n, r) {
            var o,
              a = 1 / Math.tan(t / 2);
            (e[0] = a / i),
              (e[1] = 0),
              (e[2] = 0),
              (e[3] = 0),
              (e[4] = 0),
              (e[5] = a),
              (e[6] = 0),
              (e[7] = 0),
              (e[8] = 0),
              (e[9] = 0),
              (e[11] = -1),
              (e[12] = 0),
              (e[13] = 0),
              (e[15] = 0),
              null != r && r !== 1 / 0
                ? ((e[10] = (r + n) * (o = 1 / (n - r))), (e[14] = 2 * r * n * o))
                : ((e[10] = -1), (e[14] = -2 * n));
          })(this, e, t, i, n),
          this.check()
        );
      }
      determinant() {
        return (
          ((t = (e = this)[0]) * (a = e[5]) - (i = e[1]) * (o = e[4])) *
            ((h = e[10]) * (_ = e[15]) - (d = e[11]) * (m = e[14])) -
          (t * (s = e[6]) - (n = e[2]) * o) * ((u = e[9]) * _ - d * (f = e[13])) +
          (t * (l = e[7]) - (r = e[3]) * o) * (u * m - h * f) +
          (i * s - n * a) * ((c = e[8]) * _ - d * (p = e[12])) -
          (i * l - r * a) * (c * m - h * p) +
          (n * l - r * s) * (c * f - u * p)
        );
        var e, t, i, n, r, o, a, s, l, c, u, h, d, p, f, m, _;
      }
      getScale(e = new Pt()) {
        return (
          (e[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2])),
          (e[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6])),
          (e[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10])),
          e
        );
      }
      setTranslation(e) {
        return (this[12] = e[0]), (this[13] = e[1]), (this[14] = e[2]), this.check();
      }
      getTranslation(e = new Pt()) {
        return (e[0] = this[12]), (e[1] = this[13]), (e[2] = this[14]), e;
      }
      getTranslationMatrix4(e = new Je()) {
        return e.identity(), (e[12] = this[12]), (e[13] = this[13]), (e[14] = this[14]), e;
      }
      getRotation(e = new Je()) {
        const t = this.getScale(),
          i = 1 / t[0],
          n = 1 / t[1],
          r = 1 / t[2];
        return (
          (e[0] = this[0] * i),
          (e[1] = this[1] * n),
          (e[2] = this[2] * r),
          (e[3] = 0),
          (e[4] = this[4] * i),
          (e[5] = this[5] * n),
          (e[6] = this[6] * r),
          (e[7] = 0),
          (e[8] = this[8] * i),
          (e[9] = this[9] * n),
          (e[10] = this[10] * r),
          (e[11] = 0),
          (e[12] = 0),
          (e[13] = 0),
          (e[14] = 0),
          (e[15] = 1),
          e
        );
      }
      getRotationMatrix3(e = new je()) {
        const t = this.getScale(),
          i = 1 / t[0],
          n = 1 / t[1],
          r = 1 / t[2];
        return (
          (e[0] = this[0] * i),
          (e[1] = this[1] * n),
          (e[2] = this[2] * r),
          (e[3] = this[4] * i),
          (e[4] = this[5] * n),
          (e[5] = this[6] * r),
          (e[6] = this[8] * i),
          (e[7] = this[9] * n),
          (e[8] = this[10] * r),
          e
        );
      }
      transpose(e = this) {
        return (
          (function (e, t) {
            if (e === t) {
              var i = t[1],
                n = t[2],
                r = t[3],
                o = t[6],
                a = t[7],
                s = t[11];
              (e[1] = t[4]),
                (e[2] = t[8]),
                (e[3] = t[12]),
                (e[4] = i),
                (e[6] = t[9]),
                (e[7] = t[13]),
                (e[8] = n),
                (e[9] = o),
                (e[11] = t[14]),
                (e[12] = r),
                (e[13] = a),
                (e[14] = s);
            } else
              (e[0] = t[0]),
                (e[1] = t[4]),
                (e[2] = t[8]),
                (e[3] = t[12]),
                (e[4] = t[1]),
                (e[5] = t[5]),
                (e[6] = t[9]),
                (e[7] = t[13]),
                (e[8] = t[2]),
                (e[9] = t[6]),
                (e[10] = t[10]),
                (e[11] = t[14]),
                (e[12] = t[3]),
                (e[13] = t[7]),
                (e[14] = t[11]),
                (e[15] = t[15]);
          })(e, this),
          e.check()
        );
      }
      invert(e = this) {
        return (
          (function (e, t) {
            var i = t[0],
              n = t[1],
              r = t[2],
              o = t[3],
              a = t[4],
              s = t[5],
              l = t[6],
              c = t[7],
              u = t[8],
              h = t[9],
              d = t[10],
              p = t[11],
              f = t[12],
              m = t[13],
              _ = t[14],
              g = t[15],
              y = i * s - n * a,
              x = i * l - r * a,
              v = i * c - o * a,
              w = n * l - r * s,
              T = n * c - o * s,
              b = r * c - o * l,
              S = u * m - h * f,
              A = u * _ - d * f,
              P = u * g - p * f,
              E = h * _ - d * m,
              C = h * g - p * m,
              M = d * g - p * _,
              I = y * M - x * C + v * E + w * P - T * A + b * S;
            I &&
              ((e[0] = (s * M - l * C + c * E) * (I = 1 / I)),
              (e[1] = (r * C - n * M - o * E) * I),
              (e[2] = (m * b - _ * T + g * w) * I),
              (e[3] = (d * T - h * b - p * w) * I),
              (e[4] = (l * P - a * M - c * A) * I),
              (e[5] = (i * M - r * P + o * A) * I),
              (e[6] = (_ * v - f * b - g * x) * I),
              (e[7] = (u * b - d * v + p * x) * I),
              (e[8] = (a * C - s * P + c * S) * I),
              (e[9] = (n * P - i * C - o * S) * I),
              (e[10] = (f * T - m * v + g * y) * I),
              (e[11] = (h * v - u * T - p * y) * I),
              (e[12] = (s * A - a * E - l * S) * I),
              (e[13] = (i * E - n * A + r * S) * I),
              (e[14] = (m * x - f * w - _ * y) * I),
              (e[15] = (u * w - h * x + d * y) * I));
          })(e, this),
          e.check()
        );
      }
      inverseTranspose(e = this) {
        return this.transpose(e).invert(e);
      }
      multiplyLeft(e, t = this) {
        return T(t, e, this), t.check();
      }
      multiplyRight(e, t = this) {
        return T(t, this, e), t.check();
      }
      rotateX(e, t = this) {
        return (
          (function (e, t, i) {
            var n = Math.sin(i),
              r = Math.cos(i),
              o = t[4],
              a = t[5],
              s = t[6],
              l = t[7],
              c = t[8],
              u = t[9],
              h = t[10],
              d = t[11];
            t !== e &&
              ((e[0] = t[0]),
              (e[1] = t[1]),
              (e[2] = t[2]),
              (e[3] = t[3]),
              (e[12] = t[12]),
              (e[13] = t[13]),
              (e[14] = t[14]),
              (e[15] = t[15])),
              (e[4] = o * r + c * n),
              (e[5] = a * r + u * n),
              (e[6] = s * r + h * n),
              (e[7] = l * r + d * n),
              (e[8] = c * r - o * n),
              (e[9] = u * r - a * n),
              (e[10] = h * r - s * n),
              (e[11] = d * r - l * n);
          })(t, this, e),
          t.check()
        );
      }
      rotateY(e, t = this) {
        return (
          (function (e, t, i) {
            var n = Math.sin(i),
              r = Math.cos(i),
              o = t[0],
              a = t[1],
              s = t[2],
              l = t[3],
              c = t[8],
              u = t[9],
              h = t[10],
              d = t[11];
            t !== e &&
              ((e[4] = t[4]),
              (e[5] = t[5]),
              (e[6] = t[6]),
              (e[7] = t[7]),
              (e[12] = t[12]),
              (e[13] = t[13]),
              (e[14] = t[14]),
              (e[15] = t[15])),
              (e[0] = o * r - c * n),
              (e[1] = a * r - u * n),
              (e[2] = s * r - h * n),
              (e[3] = l * r - d * n),
              (e[8] = o * n + c * r),
              (e[9] = a * n + u * r),
              (e[10] = s * n + h * r),
              (e[11] = l * n + d * r);
          })(t, this, e),
          t.check()
        );
      }
      rotateZ(e, t = this) {
        return (
          (function (e, t, i) {
            var n = Math.sin(i),
              r = Math.cos(i),
              o = t[0],
              a = t[1],
              s = t[2],
              l = t[3],
              c = t[4],
              u = t[5],
              h = t[6],
              d = t[7];
            t !== e &&
              ((e[8] = t[8]),
              (e[9] = t[9]),
              (e[10] = t[10]),
              (e[11] = t[11]),
              (e[12] = t[12]),
              (e[13] = t[13]),
              (e[14] = t[14]),
              (e[15] = t[15])),
              (e[0] = o * r + c * n),
              (e[1] = a * r + u * n),
              (e[2] = s * r + h * n),
              (e[3] = l * r + d * n),
              (e[4] = c * r - o * n),
              (e[5] = u * r - a * n),
              (e[6] = h * r - s * n),
              (e[7] = d * r - l * n);
          })(t, this, e),
          t.check()
        );
      }
      rotateXYZ([e, t, i]) {
        return this.rotateX(e).rotateY(t).rotateZ(i);
      }
      rotateAxis(e, t, i = this) {
        return (
          (function (e, t, i, n) {
            var r,
              o,
              a,
              s,
              l,
              c,
              u,
              h,
              d,
              p,
              f,
              m,
              g,
              y,
              x,
              v,
              w,
              T,
              b,
              S,
              A,
              P,
              E,
              C,
              M = n[0],
              I = n[1],
              L = n[2],
              R = Math.hypot(M, I, L);
            R < _ ||
              ((M *= R = 1 / R),
              (I *= R),
              (L *= R),
              (r = Math.sin(i)),
              (o = Math.cos(i)),
              (l = t[1]),
              (c = t[2]),
              (u = t[3]),
              (d = t[5]),
              (p = t[6]),
              (f = t[7]),
              (g = t[9]),
              (y = t[10]),
              (x = t[11]),
              (b = M * I * (a = 1 - o) - L * r),
              (S = I * I * a + o),
              (A = L * I * a + M * r),
              (P = M * L * a + I * r),
              (E = I * L * a - M * r),
              (C = L * L * a + o),
              (e[0] =
                (s = t[0]) * (v = M * M * a + o) +
                (h = t[4]) * (w = I * M * a + L * r) +
                (m = t[8]) * (T = L * M * a - I * r)),
              (e[1] = l * v + d * w + g * T),
              (e[2] = c * v + p * w + y * T),
              (e[3] = u * v + f * w + x * T),
              (e[4] = s * b + h * S + m * A),
              (e[5] = l * b + d * S + g * A),
              (e[6] = c * b + p * S + y * A),
              (e[7] = u * b + f * S + x * A),
              (e[8] = s * P + h * E + m * C),
              (e[9] = l * P + d * E + g * C),
              (e[10] = c * P + p * E + y * C),
              (e[11] = u * P + f * E + x * C),
              t !== e && ((e[12] = t[12]), (e[13] = t[13]), (e[14] = t[14]), (e[15] = t[15])));
          })(i, this, e, t),
          i.check()
        );
      }
      scale(e, t = this) {
        return (
          (function (e, t, i) {
            var n = i[0],
              r = i[1],
              o = i[2];
            (e[0] = t[0] * n),
              (e[1] = t[1] * n),
              (e[2] = t[2] * n),
              (e[3] = t[3] * n),
              (e[4] = t[4] * r),
              (e[5] = t[5] * r),
              (e[6] = t[6] * r),
              (e[7] = t[7] * r),
              (e[8] = t[8] * o),
              (e[9] = t[9] * o),
              (e[10] = t[10] * o),
              (e[11] = t[11] * o),
              (e[12] = t[12]),
              (e[13] = t[13]),
              (e[14] = t[14]),
              (e[15] = t[15]);
          })(t, this, 'number' != typeof e ? e : [e, e, e]),
          t.check()
        );
      }
      translate(e, t = this) {
        return (
          (function (e, t, i) {
            var n,
              r,
              o,
              a,
              s,
              l,
              c,
              u,
              h,
              d,
              p,
              f,
              m = i[0],
              _ = i[1],
              g = i[2];
            t === e
              ? ((e[12] = t[0] * m + t[4] * _ + t[8] * g + t[12]),
                (e[13] = t[1] * m + t[5] * _ + t[9] * g + t[13]),
                (e[14] = t[2] * m + t[6] * _ + t[10] * g + t[14]),
                (e[15] = t[3] * m + t[7] * _ + t[11] * g + t[15]))
              : ((r = t[1]),
                (o = t[2]),
                (a = t[3]),
                (s = t[4]),
                (l = t[5]),
                (c = t[6]),
                (u = t[7]),
                (h = t[8]),
                (d = t[9]),
                (p = t[10]),
                (f = t[11]),
                (e[0] = n = t[0]),
                (e[1] = r),
                (e[2] = o),
                (e[3] = a),
                (e[4] = s),
                (e[5] = l),
                (e[6] = c),
                (e[7] = u),
                (e[8] = h),
                (e[9] = d),
                (e[10] = p),
                (e[11] = f),
                (e[12] = n * m + s * _ + h * g + t[12]),
                (e[13] = r * m + l * _ + d * g + t[13]),
                (e[14] = o * m + c * _ + p * g + t[14]),
                (e[15] = a * m + u * _ + f * g + t[15]));
          })(t, this, e),
          t.check()
        );
      }
      transform(e, t) {
        return 4 === e.length
          ? (f((t = z(t || new Ge(), e, this)), 4), t)
          : this.transformAsPoint(e, t);
      }
      transformAsPoint(e, t) {
        const { length: i } = e.toArray();
        switch (i) {
          case 2:
            t = $(t || new $e(), e, this);
            break;
          case 3:
            t = N(t || new Pt(), e, this);
            break;
          default:
            throw new Error('Illegal vector');
        }
        return f(t, e.length), t;
      }
      transformAsVector(e, t) {
        switch (e.length) {
          case 2:
            t = Ne(t || new $e(), e, this);
            break;
          case 3:
            t = Oe(t || new Pt(), e, this);
            break;
          default:
            throw new Error('Illegal vector');
        }
        return f(t, e.length), t;
      }
      makeRotationX(e) {
        return this.identity().rotateX(e);
      }
      makeRotationY(e) {
        return this.identity().rotateY(e);
      }
      makeRotationZ(e) {
        return this.identity().rotateZ(e);
      }
      makeTranslation(e, t, i) {
        return this.identity().translate([e, t, i]);
      }
      makeScale(e, t, i) {
        return this.identity().scale([e, t, i]);
      }
      compose(e, t, i) {
        const n = this.elements,
          r = t[0],
          o = t[1],
          a = t[2],
          s = t[3],
          l = r + r,
          c = o + o,
          u = a + a,
          h = r * l,
          d = r * c,
          p = r * u,
          f = o * c,
          m = o * u,
          _ = a * u,
          g = s * l,
          y = s * c,
          x = s * u,
          v = i[0],
          w = i[1],
          T = i[2];
        return (
          (n[0] = (1 - (f + _)) * v),
          (n[1] = (d + x) * v),
          (n[2] = (p - y) * v),
          (n[3] = 0),
          (n[4] = (d - x) * w),
          (n[5] = (1 - (h + _)) * w),
          (n[6] = (m + g) * w),
          (n[7] = 0),
          (n[8] = (p + y) * T),
          (n[9] = (m - g) * T),
          (n[10] = (1 - (h + f)) * T),
          (n[11] = 0),
          (n[12] = e[0]),
          (n[13] = e[1]),
          (n[14] = e[2]),
          (n[15] = 1),
          this
        );
      }
      decompose(e, t, i) {
        const n = this.elements;
        let r = new Pt(n[0], n[1], n[2]).len();
        const o = new Pt(n[4], n[5], n[6]).len(),
          a = new Pt(n[8], n[9], n[10]).len();
        this.determinant() < 0 && (r = -r), (e[0] = n[12]), (e[1] = n[13]), (e[2] = n[14]);
        const s = this.clone(),
          l = 1 / r,
          c = 1 / o,
          u = 1 / a;
        return (
          (s[0] *= l),
          (s[1] *= l),
          (s[2] *= l),
          (s[4] *= c),
          (s[5] *= c),
          (s[6] *= c),
          (s[8] *= u),
          (s[9] *= u),
          (s[10] *= u),
          t.fromRotationMatrix4(s),
          (i[0] = r),
          (i[1] = o),
          (i[2] = a),
          this
        );
      }
      extractRotation(e = this) {
        const t = this,
          i = e,
          n = 1 / new Pt(t[0], t[1], t[2]).len(),
          r = 1 / new Pt(t[4], t[5], t[6]).len(),
          o = 1 / new Pt(t[8], t[9], t[10]).len();
        return (
          (i[0] = t[0] * n),
          (i[1] = t[1] * n),
          (i[2] = t[2] * n),
          (i[3] = 0),
          (i[4] = t[4] * r),
          (i[5] = t[5] * r),
          (i[6] = t[6] * r),
          (i[7] = 0),
          (i[8] = t[8] * o),
          (i[9] = t[9] * o),
          (i[10] = t[10] * o),
          (i[11] = 0),
          (i[12] = 0),
          (i[13] = 0),
          (i[14] = 0),
          (i[15] = 1),
          i
        );
      }
      static getTranslation(e, t = new Pt()) {
        return (t.x = e[12]), (t.y = e[13]), (t.z = e[14]), t;
      }
      static multiplyByPoint(e, t, i = new Pt()) {
        const n = t.x,
          r = t.y,
          o = t.z,
          a = e[1] * n + e[5] * r + e[9] * o + e[13],
          s = e[2] * n + e[6] * r + e[10] * o + e[14];
        return (i.x = e[0] * n + e[4] * r + e[8] * o + e[12]), (i.y = a), (i.z = s), i;
      }
      static multiply(e, t, i) {
        if (!e || !t || !i) throw new Error('multiply error para');
        return T(e, t, i), e.check();
      }
      static getMaximumScale(e) {
        const t = new Pt();
        return Je.getScale(e, t), Pt.maximumComponent(t);
      }
      static multiplyByVector(e, t, i = new Ge()) {
        const n = t.x,
          r = t.y,
          o = t.z,
          a = t.w,
          s = e[1] * n + e[5] * r + e[9] * o + e[13] * a,
          l = e[2] * n + e[6] * r + e[10] * o + e[14] * a,
          c = e[3] * n + e[7] * r + e[11] * o + e[15] * a;
        return (
          (i.x = e[0] * n + e[4] * r + e[8] * o + e[12] * a), (i.y = s), (i.z = l), (i.w = c), i
        );
      }
      static getScale(e, t = new Pt()) {
        const i = new Pt();
        return (
          (t.x = Pt.magnitude(Pt.fromElements(e[0], e[1], e[2], i))),
          (t.y = Pt.magnitude(Pt.fromElements(e[4], e[5], e[6], i))),
          (t.z = Pt.magnitude(Pt.fromElements(e[8], e[9], e[10], i))),
          t
        );
      }
      static getColumn(e, t, i = new Ge()) {
        const n = 4 * t,
          r = e[n + 1],
          o = e[n + 2],
          a = e[n + 3];
        return (i.x = e[n]), (i.y = r), (i.z = o), (i.w = a), i;
      }
      static inverseTransformation(e, t = new Je()) {
        const i = e[0],
          n = e[1],
          r = e[2],
          o = e[4],
          a = e[5],
          s = e[6],
          l = e[8],
          c = e[9],
          u = e[10],
          h = e[12],
          d = e[13],
          p = e[14],
          f = -i * h - n * d - r * p,
          m = -o * h - a * d - s * p,
          _ = -l * h - c * d - u * p;
        return (
          (t[0] = i),
          (t[1] = o),
          (t[2] = l),
          (t[3] = 0),
          (t[4] = n),
          (t[5] = a),
          (t[6] = c),
          (t[7] = 0),
          (t[8] = r),
          (t[9] = s),
          (t[10] = u),
          (t[11] = 0),
          (t[12] = f),
          (t[13] = m),
          (t[14] = _),
          (t[15] = 1),
          t
        );
      }
      static inverse(e, t = new Je()) {
        const i = new je(),
          n = new je(),
          r = new Ge(),
          o = new Ge(0, 0, 0, 1),
          a = e[0],
          s = e[4],
          l = e[8],
          c = e[12],
          u = e[1],
          h = e[5],
          d = e[9],
          p = e[13],
          f = e[2],
          m = e[6],
          _ = e[10],
          g = e[14],
          y = e[3],
          x = e[7],
          v = e[11],
          w = e[15];
        let T = _ * w,
          b = g * v,
          S = m * w,
          A = g * x,
          P = m * v,
          E = _ * x,
          C = f * w,
          M = g * y,
          I = f * v,
          L = _ * y,
          R = f * x,
          N = m * y;
        const O = T * h + A * d + P * p - (b * h + S * d + E * p),
          D = b * u + C * d + L * p - (T * u + M * d + I * p),
          F = S * u + M * h + R * p - (A * u + C * h + N * p),
          z = E * u + I * h + N * d - (P * u + L * h + R * d),
          B = b * s + S * l + E * c - (T * s + A * l + P * c),
          V = T * a + M * l + I * c - (b * a + C * l + L * c),
          U = A * a + C * s + N * c - (S * a + M * s + R * c),
          k = P * a + L * s + R * l - (E * a + I * s + N * l);
        (T = l * p),
          (b = c * d),
          (S = s * p),
          (A = c * h),
          (P = s * d),
          (E = l * h),
          (C = a * p),
          (M = c * u),
          (I = a * d),
          (L = l * u),
          (R = a * h),
          (N = s * u);
        const G = T * x + A * v + P * w - (b * x + S * v + E * w),
          H = b * y + C * v + L * w - (T * y + M * v + I * w),
          Y = S * y + M * x + R * w - (A * y + C * x + N * w),
          q = E * y + I * x + N * v - (P * y + L * x + R * v),
          X = S * _ + E * g + b * m - (P * g + T * m + A * _),
          j = I * g + T * f + M * _ - (C * _ + L * g + b * f),
          W = C * m + N * g + A * f - (R * g + S * f + M * m),
          $ = R * _ + P * f + L * m - (I * m + N * _ + E * f);
        let Z = a * O + s * D + l * F + c * z;
        if (Math.abs(Z) < Me.CesiumMath.EPSILON21) {
          if (
            je.equalsEpsilon(Je.getMatrix3(e, i), n, Me.CesiumMath.EPSILON7) &&
            Ge.equals(Je.getRow(e, 3, r), o)
          )
            return (
              (t[0] = 0),
              (t[1] = 0),
              (t[2] = 0),
              (t[3] = 0),
              (t[4] = 0),
              (t[5] = 0),
              (t[6] = 0),
              (t[7] = 0),
              (t[8] = 0),
              (t[9] = 0),
              (t[10] = 0),
              (t[11] = 0),
              (t[12] = -e[12]),
              (t[13] = -e[13]),
              (t[14] = -e[14]),
              (t[15] = 1),
              t
            );
          throw new Error('matrix is not invertible because its determinate is zero.');
        }
        return (
          (Z = 1 / Z),
          (t[0] = O * Z),
          (t[1] = D * Z),
          (t[2] = F * Z),
          (t[3] = z * Z),
          (t[4] = B * Z),
          (t[5] = V * Z),
          (t[6] = U * Z),
          (t[7] = k * Z),
          (t[8] = G * Z),
          (t[9] = H * Z),
          (t[10] = Y * Z),
          (t[11] = q * Z),
          (t[12] = X * Z),
          (t[13] = j * Z),
          (t[14] = W * Z),
          (t[15] = $ * Z),
          t
        );
      }
      static transpose(e, t = new Je()) {
        return (
          (t[0] = e[0]),
          (t[1] = e[4]),
          (t[2] = e[8]),
          (t[3] = e[12]),
          (t[4] = e[1]),
          (t[5] = e[5]),
          (t[6] = e[9]),
          (t[7] = e[13]),
          (t[8] = e[2]),
          (t[9] = e[6]),
          (t[10] = e[10]),
          (t[11] = e[14]),
          (t[12] = e[3]),
          (t[13] = e[7]),
          (t[14] = e[11]),
          (t[15] = e[15]),
          t
        );
      }
      static inverseTranspose(e, t = new Je()) {
        const i = new Je();
        return Je.inverse(Je.transpose(e, i), t);
      }
      static getMatrix3(e, t = new je()) {
        return (
          (t[0] = e[0]),
          (t[1] = e[1]),
          (t[2] = e[2]),
          (t[3] = e[4]),
          (t[4] = e[5]),
          (t[5] = e[6]),
          (t[6] = e[8]),
          (t[7] = e[9]),
          (t[8] = e[10]),
          t
        );
      }
      static getRow(e, t, i = new Ge()) {
        const n = e[t + 4],
          r = e[t + 8],
          o = e[t + 12];
        return (i.x = e[t]), (i.y = n), (i.z = r), (i.w = o), i;
      }
      static equals(e, i) {
        return (
          e === i ||
          (t(e) &&
            t(i) &&
            e[12] === i[12] &&
            e[13] === i[13] &&
            e[14] === i[14] &&
            e[0] === i[0] &&
            e[1] === i[1] &&
            e[2] === i[2] &&
            e[4] === i[4] &&
            e[5] === i[5] &&
            e[6] === i[6] &&
            e[8] === i[8] &&
            e[9] === i[9] &&
            e[10] === i[10] &&
            e[3] === i[3] &&
            e[7] === i[7] &&
            e[11] === i[11] &&
            e[15] === i[15])
        );
      }
      static equalsArray(e, t, i = 0) {
        return (
          e[0] === t[0 + i] &&
          e[1] === t[1 + i] &&
          e[2] === t[2 + i] &&
          e[3] === t[3 + i] &&
          e[4] === t[4 + i] &&
          e[5] === t[5 + i] &&
          e[6] === t[6 + i] &&
          e[7] === t[7 + i] &&
          e[8] === t[8 + i] &&
          e[9] === t[9 + i] &&
          e[10] === t[10 + i] &&
          e[11] === t[11 + i] &&
          e[12] === t[12 + i] &&
          e[13] === t[13 + i] &&
          e[14] === t[14 + i] &&
          e[15] === t[15 + i]
        );
      }
      static pack(e, t, i = 0) {
        return (
          (t[i++] = e[0]),
          (t[i++] = e[1]),
          (t[i++] = e[2]),
          (t[i++] = e[3]),
          (t[i++] = e[4]),
          (t[i++] = e[5]),
          (t[i++] = e[6]),
          (t[i++] = e[7]),
          (t[i++] = e[8]),
          (t[i++] = e[9]),
          (t[i++] = e[10]),
          (t[i++] = e[11]),
          (t[i++] = e[12]),
          (t[i++] = e[13]),
          (t[i++] = e[14]),
          (t[i] = e[15]),
          t
        );
      }
      static computeView(e, t, i, n, r = new Je()) {
        return (
          (r[0] = n.x),
          (r[1] = i.x),
          (r[2] = -t.x),
          (r[3] = 0),
          (r[4] = n.y),
          (r[5] = i.y),
          (r[6] = -t.y),
          (r[7] = 0),
          (r[8] = n.z),
          (r[9] = i.z),
          (r[10] = -t.z),
          (r[11] = 0),
          (r[12] = -Pt.dot(n, e)),
          (r[13] = -Pt.dot(i, e)),
          (r[14] = Pt.dot(t, e)),
          (r[15] = 1),
          r
        );
      }
      static fromRotationTranslation(e, t = Pt.ZERO, i = new Je()) {
        return (
          (i[0] = e[0]),
          (i[1] = e[1]),
          (i[2] = e[2]),
          (i[3] = 0),
          (i[4] = e[3]),
          (i[5] = e[4]),
          (i[6] = e[5]),
          (i[7] = 0),
          (i[8] = e[6]),
          (i[9] = e[7]),
          (i[10] = e[8]),
          (i[11] = 0),
          (i[12] = t.x),
          (i[13] = t.y),
          (i[14] = t.z),
          (i[15] = 1),
          i
        );
      }
      static fromTranslationQuaternionRotationScale(
        e = Pt.ZERO,
        t = new Et(),
        i = Pt.ONE,
        n = new Je(),
      ) {
        const r = i.x,
          o = i.y,
          a = i.z,
          s = t.x * t.x,
          l = t.x * t.y,
          c = t.x * t.z,
          u = t.x * t.w,
          h = t.y * t.y,
          d = t.y * t.z,
          p = t.y * t.w,
          f = t.z * t.z,
          m = t.z * t.w,
          _ = t.w * t.w,
          g = 2 * (l - m),
          y = 2 * (c + p),
          x = 2 * (l + m),
          v = -s + h - f + _,
          w = 2 * (d - u),
          T = 2 * (c - p),
          b = 2 * (d + u),
          S = -s - h + f + _;
        return (
          (n[0] = (s - h - f + _) * r),
          (n[1] = x * r),
          (n[2] = T * r),
          (n[3] = 0),
          (n[4] = g * o),
          (n[5] = v * o),
          (n[6] = b * o),
          (n[7] = 0),
          (n[8] = y * a),
          (n[9] = w * a),
          (n[10] = S * a),
          (n[11] = 0),
          (n[12] = e.x),
          (n[13] = e.y),
          (n[14] = e.z),
          (n[15] = 1),
          n
        );
      }
      static fromTranslationHeadingPitchRollRotationScale(
        e = Pt.ZERO,
        t = new Le(),
        i = Pt.ONE,
        n = new Je(),
      ) {
        const r = new Et().fromHeadingPitchRoll(t),
          o = i.x,
          a = i.y,
          s = i.z,
          l = r.x * r.x,
          c = r.x * r.y,
          u = r.x * r.z,
          h = r.x * r.w,
          d = r.y * r.y,
          p = r.y * r.z,
          f = r.y * r.w,
          m = r.z * r.z,
          _ = r.z * r.w,
          g = r.w * r.w,
          y = 2 * (c - _),
          x = 2 * (u + f),
          v = 2 * (c + _),
          w = -l + d - m + g,
          T = 2 * (p - h),
          b = 2 * (u - f),
          S = 2 * (p + h),
          A = -l - d + m + g;
        return (
          (n[0] = (l - d - m + g) * o),
          (n[1] = v * o),
          (n[2] = b * o),
          (n[3] = 0),
          (n[4] = y * a),
          (n[5] = w * a),
          (n[6] = S * a),
          (n[7] = 0),
          (n[8] = x * s),
          (n[9] = T * s),
          (n[10] = A * s),
          (n[11] = 0),
          (n[12] = e.x),
          (n[13] = e.y),
          (n[14] = e.z),
          (n[15] = 1),
          n
        );
      }
      static multiplyTransformation(e, t, i = new Je()) {
        const n = e[0],
          r = e[1],
          o = e[2],
          a = e[4],
          s = e[5],
          l = e[6],
          c = e[8],
          u = e[9],
          h = e[10],
          d = t[0],
          p = t[1],
          f = t[2],
          m = t[4],
          _ = t[5],
          g = t[6],
          y = t[8],
          x = t[9],
          v = t[10],
          w = t[12],
          T = t[13],
          b = t[14],
          S = r * d + s * p + u * f,
          A = o * d + l * p + h * f,
          P = n * m + a * _ + c * g,
          E = r * m + s * _ + u * g,
          C = o * m + l * _ + h * g,
          M = n * y + a * x + c * v,
          I = r * y + s * x + u * v,
          L = o * y + l * x + h * v,
          R = n * w + a * T + c * b + e[12],
          N = r * w + s * T + u * b + e[13],
          O = o * w + l * T + h * b + e[14];
        return (
          (i[0] = n * d + a * p + c * f),
          (i[1] = S),
          (i[2] = A),
          (i[3] = 0),
          (i[4] = P),
          (i[5] = E),
          (i[6] = C),
          (i[7] = 0),
          (i[8] = M),
          (i[9] = I),
          (i[10] = L),
          (i[11] = 0),
          (i[12] = R),
          (i[13] = N),
          (i[14] = O),
          (i[15] = 1),
          i
        );
      }
      static multiplyByPointAsVector(e, t, i = new Pt()) {
        const n = t.x,
          r = t.y,
          o = t.z,
          a = e[1] * n + e[5] * r + e[9] * o,
          s = e[2] * n + e[6] * r + e[10] * o;
        return (i.x = e[0] * n + e[4] * r + e[8] * o), (i.y = a), (i.z = s), i;
      }
      static clone(e, t = new Je()) {
        return (
          (t[0] = e[0]),
          (t[1] = e[1]),
          (t[2] = e[2]),
          (t[3] = e[3]),
          (t[4] = e[4]),
          (t[5] = e[5]),
          (t[6] = e[6]),
          (t[7] = e[7]),
          (t[8] = e[8]),
          (t[9] = e[9]),
          (t[10] = e[10]),
          (t[11] = e[11]),
          (t[12] = e[12]),
          (t[13] = e[13]),
          (t[14] = e[14]),
          (t[15] = e[15]),
          t
        );
      }
      static computeOrthographicOffCenter(e, t, i, n, r, o, a = new Je()) {
        let s = 1 / (t - e),
          l = 1 / (n - i),
          c = 1 / (o - r);
        const u = -(t + e) * s,
          h = -(n + i) * l,
          d = -(o + r) * c;
        return (
          (s *= 2),
          (l *= 2),
          (c *= -2),
          (a[0] = s),
          (a[1] = 0),
          (a[2] = 0),
          (a[3] = 0),
          (a[4] = 0),
          (a[5] = l),
          (a[6] = 0),
          (a[7] = 0),
          (a[8] = 0),
          (a[9] = 0),
          (a[10] = c),
          (a[11] = 0),
          (a[12] = u),
          (a[13] = h),
          (a[14] = d),
          (a[15] = 1),
          a
        );
      }
      static fromTranslation = function (e, t = new Je()) {
        return Je.fromRotationTranslation(je.IDENTITY, e, t);
      };
      static multiplyByTranslation = function (e, t, i = new Je()) {
        const n = t.x,
          r = t.y,
          o = t.z,
          a = n * e[0] + r * e[4] + o * e[8] + e[12],
          s = n * e[1] + r * e[5] + o * e[9] + e[13],
          l = n * e[2] + r * e[6] + o * e[10] + e[14];
        return (
          (i[0] = e[0]),
          (i[1] = e[1]),
          (i[2] = e[2]),
          (i[3] = e[3]),
          (i[4] = e[4]),
          (i[5] = e[5]),
          (i[6] = e[6]),
          (i[7] = e[7]),
          (i[8] = e[8]),
          (i[9] = e[9]),
          (i[10] = e[10]),
          (i[11] = e[11]),
          (i[12] = a),
          (i[13] = s),
          (i[14] = l),
          (i[15] = e[15]),
          i
        );
      };
      static computeViewportTransformation(e = {}, t = 0, i = 1, n = new Je()) {
        const r = Z(e.x, 0),
          o = Z(e.y, 0),
          a = 0.5 * Z(e.width, 0),
          s = 0.5 * Z(e.height, 0),
          l = 0.5 * (i - t),
          c = s,
          u = l,
          h = r + a,
          d = o + s,
          p = t + l;
        return (
          (n[0] = a),
          (n[1] = 0),
          (n[2] = 0),
          (n[3] = 0),
          (n[4] = 0),
          (n[5] = c),
          (n[6] = 0),
          (n[7] = 0),
          (n[8] = 0),
          (n[9] = 0),
          (n[10] = u),
          (n[11] = 0),
          (n[12] = h),
          (n[13] = d),
          (n[14] = p),
          (n[15] = 1),
          n
        );
      }
      transformPoint(e, t) {
        return m('Matrix4.transformPoint', '3.0'), this.transformAsPoint(e, t);
      }
      transformVector(e, t) {
        return m('Matrix4.transformVector', '3.0'), this.transformAsPoint(e, t);
      }
      transformDirection(e, t) {
        return m('Matrix4.transformDirection', '3.0'), this.transformAsVector(e, t);
      }
    }
    const et = 6378137,
      tt = 6378137,
      it = 6356752.314245179,
      nt = (e) => e;
    let rt, ot, at, st, lt;
    function ct(e, t) {
      return (
        rt || (rt = new Pt()),
        (function (e, t, i = nt) {
          return (
            a(e)
              ? ((t[0] = i(e[0])), (t[1] = i(e[1])), (t[2] = e[2]))
              : 'longitude' in e
              ? ((t[0] = i(e.longitude)), (t[1] = i(e.latitude)), (t[2] = e.height))
              : ((t[0] = i(e.x)), (t[1] = i(e.y)), (t[2] = e.z)),
            t
          );
        })(e, t || rt, s)
      );
    }
    function ut(e, t, i = new Pt()) {
      const { oneOverRadii: n, oneOverRadiiSquared: r, centerToleranceSquared: o } = t;
      ot || ((ot = new Pt()), (at = new Pt()), (st = new Pt())), ot.from(e);
      const a = e.x,
        s = e.y,
        l = e.z,
        c = n.x,
        u = n.y,
        h = n.z,
        d = a * a * c * c,
        p = s * s * u * u,
        f = l * l * h * h,
        m = d + p + f,
        _ = Math.sqrt(1 / m);
      if (!Number.isFinite(_)) return;
      const g = at;
      if ((g.copy(e).scale(_), m < o)) return g.to(i);
      const y = r.x,
        x = r.y,
        v = r.z,
        w = st;
      w.set(g.x * y * 2, g.y * x * 2, g.z * v * 2);
      let T,
        b,
        S,
        A,
        P = ((1 - _) * e.len()) / (0.5 * w.len()),
        E = 0;
      do {
        (P -= E), (T = 1 / (1 + P * y)), (b = 1 / (1 + P * x)), (S = 1 / (1 + P * v));
        const e = T * T,
          t = b * b,
          i = S * S;
        (A = d * e + p * t + f * i - 1),
          (E = A / (-2 * (d * (e * T) * y + p * (t * b) * x + f * (i * S) * v)));
      } while (Math.abs(A) > Me.TRANSFORM.EPSILON12);
      return ot.scale([T, b, S]).to(i);
    }
    const ht = {
      north: [-1, 0, 0],
      east: [0, 1, 0],
      up: [0, 0, 1],
      south: [1, 0, 0],
      west: [0, -1, 0],
      down: [0, 0, -1],
    };
    let dt,
      pt,
      ft,
      mt,
      _t,
      gt,
      yt = {};
    function xt(e, t, i, n, r, o) {
      let a, s, l;
      lt ||
        ((lt = new Pt()),
        (yt = {
          east: new Pt(),
          north: new Pt(),
          up: new Pt(),
          west: new Pt(),
          south: new Pt(),
          down: new Pt(),
        }),
        (dt = new Pt()),
        (pt = new Pt()),
        (ft = new Pt()));
      const c = lt.copy(r);
      if (u(c.x, 0) && u(c.y, 0)) {
        const e = Math.sign(c.z);
        (a = dt.fromArray(ht[t])),
          'east' !== t && 'west' !== t && a.scale(e),
          (s = pt.fromArray(ht[i])),
          'east' !== i && 'west' !== i && s.scale(e),
          (l = ft.fromArray(ht[n])),
          'east' !== n && 'west' !== n && l.scale(e);
      } else {
        const { up: r, east: o, north: u } = yt;
        o.set(-c.y, c.x, 0).normalize(), e.geodeticSurfaceNormal(c, r), u.copy(r).cross(o);
        const { down: h, west: d, south: p } = yt;
        h.copy(r).scale(-1),
          d.copy(o).scale(-1),
          p.copy(u).scale(-1),
          (a = yt[t]),
          (s = yt[i]),
          (l = yt[n]);
      }
      return (
        (o[0] = a.x),
        (o[1] = a.y),
        (o[2] = a.z),
        (o[3] = 0),
        (o[4] = s.x),
        (o[5] = s.y),
        (o[6] = s.z),
        (o[7] = 0),
        (o[8] = l.x),
        (o[9] = l.y),
        (o[10] = l.z),
        (o[11] = 0),
        (o[12] = c.x),
        (o[13] = c.y),
        (o[14] = c.z),
        (o[15] = 1),
        o
      );
    }
    function vt(e, t, i, n) {
      (e.radii = new Pt(t, i, n)),
        (e.radiiSquared = new Pt(t * t, i * i, n * n)),
        (e.radiiToTheFourth = new Pt(t * t * t * t, i * i * i * i, n * n * n * n)),
        (e.oneOverRadii = new Pt(0 === t ? 0 : 1 / t, 0 === i ? 0 : 1 / i, 0 === n ? 0 : 1 / n)),
        (e.oneOverRadiiSquared = new Pt(
          0 === t ? 0 : 1 / (t * t),
          0 === i ? 0 : 1 / (i * i),
          0 === n ? 0 : 1 / (n * n),
        )),
        (e.minimumRadius = Math.min(t, i, n)),
        (e.maximumRadius = Math.max(t, i, n)),
        (e.centerToleranceSquared = Me.TRANSFORM.EPSILON1),
        0 !== e.radiiSquared.z && (e.squaredXOverSquaredZ = e.radiiSquared.x / e.radiiSquared.z),
        Object.freeze(this);
    }
    class wt {
      constructor(e = 0, t = 0, i = 0) {
        vt(this, e, t, i);
      }
      equals(e) {
        return this === e || Boolean(e && this.radii.equals(e.radii));
      }
      toString() {
        return this.radii.toString();
      }
      cartographicToCartesian(e, t = [0, 0, 0], i) {
        const n = new Pt(),
          r = new Pt(),
          [, , o] = e;
        this.geodeticSurfaceNormalCartographic(e, n, i), r.copy(this.radiiSquared).scale(n);
        const a = Math.sqrt(n.dot(r));
        return r.scale(1 / a), n.scale(o), r.add(n), r.to(t);
      }
      cartographicToCartesianInRadians(e, t = [0, 0, 0]) {
        const i = new Pt(),
          n = new Pt(),
          [, , r] = e;
        this.geodeticSurfaceNormalCartographic(e, i, !0), n.copy(this.radiiSquared).scale(i);
        const o = Math.sqrt(i.dot(n));
        return n.scale(1 / o), i.scale(r), n.add(i), n.to(t);
      }
      cartesianToCartographic(e, t = [0, 0, 0]) {
        const i = new Pt(),
          n = new Pt(),
          r = new Pt(),
          o = new Pt();
        o.from(e);
        const s = this.scaleToGeodeticSurface(o, n);
        if (!s) return;
        const c = this.geodeticSurfaceNormal(s, i),
          u = r;
        return (
          u.copy(o).subtract(s),
          (function (e, t, i = nt) {
            return (
              a(t)
                ? ((t[0] = i(e[0])), (t[1] = i(e[1])), (t[2] = e[2]))
                : 'longitude' in t
                ? ((t.longitude = i(e[0])), (t.latitude = i(e[1])), (t.height = e[2]))
                : ((t.x = i(e[0])), (t.y = i(e[1])), (t.z = e[2])),
              t
            );
          })([Math.atan2(c.y, c.x), Math.asin(c.z), Math.sign(L(u, o)) * S(u)], t, l)
        );
      }
      eastNorthUpToFixedFrame(e, t = new Je()) {
        return xt(this, 'east', 'north', 'up', e, t);
      }
      localFrameToFixedFrame(e, t, i, n, r = new Je()) {
        return xt(this, e, t, i, n, r);
      }
      geocentricSurfaceNormal(e, t = [0, 0, 0]) {
        return new Pt().from(e).normalize().to(t);
      }
      geodeticSurfaceNormalCartographic(e, t = [0, 0, 0], i) {
        const n = i ? e : ct(e),
          r = n[0],
          o = n[1],
          a = Math.cos(o),
          s = new Pt();
        return s.set(a * Math.cos(r), a * Math.sin(r), Math.sin(o)).normalize(), s.to(t);
      }
      geodeticSurfaceNormal(e, t = [0, 0, 0]) {
        return new Pt().from(e).scale(this.oneOverRadiiSquared).normalize().to(t);
      }
      scaleToGeodeticSurface(e, t) {
        return ut(e, this, t);
      }
      scaleToGeocentricSurface(e, t = [0, 0, 0]) {
        const i = new Pt();
        i.from(e);
        const n = i.x,
          r = i.y,
          o = i.z,
          a = this.oneOverRadiiSquared,
          s = 1 / Math.sqrt(n * n * a.x + r * r * a.y + o * o * a.z);
        return i.multiplyScalar(s).to(t);
      }
      transformPositionToScaledSpace(e, t = [0, 0, 0]) {
        return new Pt().from(e).scale(this.oneOverRadii).to(t);
      }
      transformPositionFromScaledSpace(e, t = [0, 0, 0]) {
        return new Pt().from(e).scale(this.radii).to(t);
      }
      getSurfaceNormalIntersectionWithZAxis(e, t = 0, i = [0, 0, 0]) {
        const n = new Pt();
        n.from(e);
        const r = n.z * (1 - this.squaredXOverSquaredZ);
        if (!(Math.abs(r) >= this.radii.z - t)) return n.set(0, 0, r).to(i);
      }
      static fromCartesian3(e, t) {
        return vt(t, e.x, e.y, e.z);
      }
      static clone(e) {
        return new wt(e.radii.x, e.radii.y, e.radii.z);
      }
      static get WGS84() {
        return (mt = mt || new wt(et, tt, it)), mt;
      }
      static get RegularEllipsoid() {
        return (_t = _t || new wt(et, tt, 6378137)), _t;
      }
      static get UNIT_SPHERE() {
        return (gt = gt || new wt(1, 1, 1)), gt;
      }
    }
    const Tt = [0, 0, 0],
      bt = {},
      St = (e) => e;
    function At(e, t = new Pt(), i = St) {
      return (
        a(e)
          ? ((t[0] = i(e[0])), (t[1] = i(e[1])), (t[2] = e[2]))
          : 'longitude' in e
          ? ((t[0] = i(e.longitude)), (t[1] = i(e.latitude)), (t[2] = e.height))
          : ((t[0] = i(e.x)), (t[1] = i(e.y)), (t[2] = e.z)),
        t
      );
    }
    class Pt extends Re {
      static get ZERO() {
        return (bt.ZERO = bt.ZERO || Object.freeze(new Pt(0, 0, 0)));
      }
      static get ONE() {
        return (bt.ONE = bt.ONE || Object.freeze(new Pt(1, 1, 1)));
      }
      static get UNIT_X() {
        return (bt.UNIT_X = bt.UNIT_X || Object.freeze(new Pt(1, 0, 0)));
      }
      static get UNIT_Y() {
        return (bt.UNIT_Y = bt.UNIT_Y || Object.freeze(new Pt(0, 1, 0)));
      }
      static get UNIT_Z() {
        return (bt.UNIT_Z = bt.UNIT_Z || Object.freeze(new Pt(0, 0, 1)));
      }
      constructor(e = 0, t = 0, i = 0) {
        super(-0, -0, -0),
          1 === arguments.length && a(e)
            ? this.copy(e)
            : ((this[0] = e), (this[1] = t), (this[2] = i));
      }
      get x() {
        return this[0];
      }
      set x(e) {
        this[0] = p(e);
      }
      get y() {
        return this[1];
      }
      set y(e) {
        this[1] = p(e);
      }
      get z() {
        return this[2];
      }
      set z(e) {
        this[2] = p(e);
      }
      get ELEMENTS() {
        return 3;
      }
      set(e, t, i) {
        return (this[0] = e), (this[1] = t), (this[2] = i), this.check();
      }
      copy(e) {
        return (this[0] = e[0]), (this[1] = e[1]), (this[2] = e[2]), this.check();
      }
      fromObject(e) {
        return (this[0] = e.x), (this[1] = e.y), (this[2] = e.z), this.check();
      }
      toObject(e = {}) {
        return (e.x = this[0]), (e.y = this[1]), (e.z = this[2]), e;
      }
      angle(e, t = this) {
        return (
          (r = (i = t)[0]),
          (o = i[1]),
          (a = i[2]),
          (s = (n = e)[0]),
          (l = n[1]),
          (c = n[2]),
          (h =
            (u = Math.sqrt(r * r + o * o + a * a) * Math.sqrt(s * s + l * l + c * c)) &&
            L(i, n) / u),
          Math.acos(Math.min(Math.max(h, -1), 1))
        );
        var i, n, r, o, a, s, l, c, u, h;
      }
      cross(e, t = this) {
        return R(t, this, e), t.check();
      }
      rotateX({ radians: e, origin: t = Tt, result: i = this }) {
        return (
          (function (e, t, i, n) {
            var r = [],
              o = [];
            (r[0] = t[0] - i[0]),
              (r[1] = t[1] - i[1]),
              (r[2] = t[2] - i[2]),
              (o[0] = r[0]),
              (o[1] = r[1] * Math.cos(n) - r[2] * Math.sin(n)),
              (o[2] = r[1] * Math.sin(n) + r[2] * Math.cos(n)),
              (e[0] = o[0] + i[0]),
              (e[1] = o[1] + i[1]),
              (e[2] = o[2] + i[2]);
          })(i, this, t, e),
          i.check()
        );
      }
      rotateY({ radians: e, origin: t = Tt, result: i = this }) {
        return (
          (function (e, t, i, n) {
            var r = [],
              o = [];
            (r[0] = t[0] - i[0]),
              (r[1] = t[1] - i[1]),
              (r[2] = t[2] - i[2]),
              (o[0] = r[2] * Math.sin(n) + r[0] * Math.cos(n)),
              (o[1] = r[1]),
              (o[2] = r[2] * Math.cos(n) - r[0] * Math.sin(n)),
              (e[0] = o[0] + i[0]),
              (e[1] = o[1] + i[1]),
              (e[2] = o[2] + i[2]);
          })(i, this, t, e),
          i.check()
        );
      }
      rotateZ({ radians: e, origin: t = Tt, result: i = this }) {
        return (
          (function (e, t, i, n) {
            var r = [],
              o = [];
            (r[0] = t[0] - i[0]),
              (r[1] = t[1] - i[1]),
              (r[2] = t[2] - i[2]),
              (o[0] = r[0] * Math.cos(n) - r[1] * Math.sin(n)),
              (o[1] = r[0] * Math.sin(n) + r[1] * Math.cos(n)),
              (o[2] = r[2]),
              (e[0] = o[0] + i[0]),
              (e[1] = o[1] + i[1]),
              (e[2] = o[2] + i[2]);
          })(i, this, t, e),
          i.check()
        );
      }
      transform(e) {
        return this.transformAsPoint(e);
      }
      transformAsPoint(e, t = this) {
        return N(t, this, e), t.check();
      }
      transformAsVector(e, t = this) {
        return Oe(t, this, e), t.check();
      }
      transformByMatrix3(e, t = this) {
        return O(t, this, e), t.check();
      }
      transformByMatrix2(e, t = this) {
        return (
          (function (e, t, i) {
            const n = t[0],
              r = t[1];
            (e[0] = i[0] * n + i[2] * r), (e[1] = i[1] * n + i[3] * r), (e[2] = t[2]);
          })(t, this, e),
          t.check()
        );
      }
      transformByQuaternion(e, t = this) {
        return (
          (function (e, t, i) {
            var n = i[0],
              r = i[1],
              o = i[2],
              a = t[0],
              s = t[1],
              l = t[2],
              c = r * l - o * s,
              u = o * a - n * l,
              h = n * s - r * a,
              d = r * h - o * u,
              p = o * c - n * h,
              f = n * u - r * c,
              m = 2 * i[3];
            (u *= m),
              (h *= m),
              (p *= 2),
              (f *= 2),
              (e[0] = a + (c *= m) + (d *= 2)),
              (e[1] = s + u + p),
              (e[2] = l + h + f);
          })(t, this, e),
          t.check()
        );
      }
      applyMatrix3(e) {
        const t = this[0],
          i = this[1],
          n = this[2],
          r = e.elements;
        return (
          (this[0] = r[0] * t + r[3] * i + r[6] * n),
          (this[1] = r[1] * t + r[4] * i + r[7] * n),
          (this[2] = r[2] * t + r[5] * i + r[8] * n),
          this
        );
      }
      applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize();
      }
      applyMatrix4(e) {
        const t = this[0],
          i = this[1],
          n = this[2],
          r = e.elements,
          o = 1 / (r[3] * t + r[7] * i + r[11] * n + r[15]);
        return (
          (this[0] = (r[0] * t + r[4] * i + r[8] * n + r[12]) * o),
          (this[1] = (r[1] * t + r[5] * i + r[9] * n + r[13]) * o),
          (this[2] = (r[2] * t + r[6] * i + r[10] * n + r[14]) * o),
          this
        );
      }
      applyQuaternion(e) {
        const t = this.x,
          i = this.y,
          n = this.z,
          r = e.x,
          o = e.y,
          a = e.z,
          s = e.w,
          l = s * t + o * n - a * i,
          c = s * i + a * t - r * n,
          u = s * n + r * i - o * t,
          h = -r * t - o * i - a * n;
        return (
          (this[0] = l * s + h * -r + c * -a - u * -o),
          (this[1] = c * s + h * -o + u * -r - l * -a),
          (this[2] = u * s + h * -a + l * -o - c * -r),
          this
        );
      }
      project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
      }
      unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
      }
      transformDirection(e) {
        const t = this[0],
          i = this[1],
          n = this[2],
          r = e.elements;
        return (
          (this[0] = r[0] * t + r[4] * i + r[8] * n),
          (this[1] = r[1] * t + r[5] * i + r[9] * n),
          (this[2] = r[2] * t + r[6] * i + r[10] * n),
          this.normalize()
        );
      }
      clampLength(e, t) {
        const i = this.len();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
      }
      floor() {
        return (
          (this[0] = Math.floor(this[0])),
          (this[1] = Math.floor(this[1])),
          (this[2] = Math.floor(this[2])),
          this
        );
      }
      ceil() {
        return (
          (this[0] = Math.ceil(this[0])),
          (this[1] = Math.ceil(this[1])),
          (this[2] = Math.ceil(this[2])),
          this
        );
      }
      round() {
        return (
          (this[0] = Math.round(this[0])),
          (this[1] = Math.round(this[1])),
          (this[2] = Math.round(this[2])),
          this
        );
      }
      roundToZero() {
        return (
          (this[0] = this[0] < 0 ? Math.ceil(this[0]) : Math.floor(this[0])),
          (this[1] = this[1] < 0 ? Math.ceil(this[1]) : Math.floor(this[1])),
          (this[2] = this[2] < 0 ? Math.ceil(this[2]) : Math.floor(this[2])),
          this
        );
      }
      manhattanLength() {
        return Math.abs(this[0]) + Math.abs(this[1]) + Math.abs(this[2]);
      }
      setLength(e) {
        return this.normalize().multiplyScalar(e);
      }
      lerpVectors(e, t, i) {
        return (
          (this[0] = e[0] + (t[0] - e[0]) * i),
          (this[1] = e[1] + (t[1] - e[1]) * i),
          (this[2] = e[2] + (t[2] - e[2]) * i),
          this
        );
      }
      crossVectors(e, t) {
        const i = e[0],
          n = e[1],
          r = e[2],
          o = t[0],
          a = t[1],
          s = t[2];
        return (
          (this[0] = n * s - r * a), (this[1] = r * o - i * s), (this[2] = i * a - n * o), this
        );
      }
      projectOnVector(e) {
        const t = e.lengthSq();
        if (0 === t) return this.set(0, 0, 0);
        const i = e.dot(this) / t;
        return this.copy(e).multiplyScalar(i);
      }
      projectOnPlane(e) {
        const t = new Pt().copy(this).projectOnVector(e);
        return this.sub(t);
      }
      reflect(e) {
        return this.sub(new Pt().copy(e).multiplyScalar(2 * this.dot(e)));
      }
      distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e));
      }
      distanceToSquared(e) {
        const t = this[0] - e[0],
          i = this[1] - e[1],
          n = this[2] - e[2];
        return t * t + i * i + n * n;
      }
      manhattanDistanceTo(e) {
        return Math.abs(this[0] - e[0]) + Math.abs(this[1] - e[1]) + Math.abs(this[2] - e[2]);
      }
      setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
      }
      setFromSphericalCoords(e, t, i) {
        const n = Math.sin(t) * e;
        return (
          (this[0] = n * Math.sin(i)),
          (this[1] = Math.cos(t) * e),
          (this[2] = n * Math.cos(i)),
          this
        );
      }
      setFromMatrixPosition(e) {
        const t = e.elements;
        return (this[0] = t[12]), (this[1] = t[13]), (this[2] = t[14]), this;
      }
      setFromMatrixScale(e) {
        const t = this.setFromMatrixColumn(e, 0).len(),
          i = this.setFromMatrixColumn(e, 1).len(),
          n = this.setFromMatrixColumn(e, 2).len();
        return (this[0] = t), (this[1] = i), (this[2] = n), this;
      }
      setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, 4 * t);
      }
      setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, 3 * t);
      }
      static toCartographicFromRadians(e) {
        return At(e);
      }
      static toCartographicFromDegrees(e) {
        return At(e, new Pt(), s);
      }
      random() {
        return (
          (this[0] = Math.random()), (this[1] = Math.random()), (this[2] = Math.random()), this
        );
      }
      static multiplyByScalar(e, t, i = new Pt()) {
        return (i.x = e.x * t), (i.y = e.y * t), (i.z = e.z * t), i;
      }
      static fromElements(e, t, i, n = new Pt()) {
        return (n.x = e), (n.y = t), (n.z = i), n;
      }
      static fromDegrees(e, t, i = 0, n = wt.WGS84, r = new Pt()) {
        return (
          (e = Me.CesiumMath.toRadians(e)),
          (t = Me.CesiumMath.toRadians(t)),
          Pt.fromRadians(e, t, i, n, r)
        );
      }
      static fromRadians(e, t, i = 0, n = wt.WGS84, r = new Pt()) {
        let o = new Pt(),
          a = new Pt();
        const s = n.radiiSquared,
          l = Math.cos(t);
        (o.x = l * Math.cos(e)),
          (o.y = l * Math.sin(e)),
          (o.z = Math.sin(t)),
          (o = Pt.normalize(o, o)),
          Pt.multiplyComponents(s, o, a);
        const c = Math.sqrt(Pt.dot(o, a));
        return (
          (a = Pt.divideByScalar(a, c, a)), (o = Pt.multiplyByScalar(o, i, o)), Pt.add(a, o, r)
        );
      }
      static fromDegreesArray(e, t = wt.WGS84, i = new Array(e.length / 2)) {
        const n = e.length;
        for (let r = 0; r < n; r += 2) {
          const n = r / 2;
          i[n] = Pt.fromDegrees(e[r], e[r + 1], 0, t, i[n]);
        }
        return i;
      }
      static fromRadiansArray(e, t = wt.WGS84, i = new Array(e.length / 2)) {
        const n = e.length;
        i.length = n / 2;
        for (let r = 0; r < n; r += 2) {
          const n = r / 2;
          i[n] = Pt.fromRadians(e[r], e[r + 1], 0, t, i[n]);
        }
        return i;
      }
      static fromDegreesArrayHeights(e, t = wt.WGS84, i = new Array(e.length / 3)) {
        const n = e.length;
        i.length = n / 3;
        for (let r = 0; r < n; r += 3) {
          const n = r / 3;
          i[n] = Pt.fromDegrees(e[r], e[r + 1], e[r + 2], t, i[n]);
        }
        return i;
      }
      static fromRadiansArrayHeights(e, t = wt.WGS84, i = new Array(e.length / 3)) {
        const n = e.length;
        i.length = n / 3;
        for (let r = 0; r < n; r += 3) {
          const n = r / 3;
          i[n] = Pt.fromRadians(e[r], e[r + 1], e[r + 2], t, i[n]);
        }
        return i;
      }
      clone(e) {
        return Pt.clone(this, e);
      }
      static clone(e, t = new Pt(e.x, e.y, e.z)) {
        return (t.x = e.x), (t.y = e.y), (t.z = e.z), t;
      }
      equals(e) {
        return Pt.equals(this, e);
      }
      static equals(e, i) {
        return e === i || (t(e) && t(i) && e.x === i.x && e.y === i.y && e.z === i.z);
      }
      equalsEpsilon(e, t = 0, i = t) {
        return Pt.equalsEpsilon(this, e, t, i);
      }
      static equalsEpsilon(e, i, n = 0, r = n) {
        return (
          e === i ||
          (t(e) &&
            t(i) &&
            Me.CesiumMath.equalsEpsilon(e.x, i.x, n, r) &&
            Me.CesiumMath.equalsEpsilon(e.y, i.y, n, r) &&
            Me.CesiumMath.equalsEpsilon(e.z, i.z, n, r))
        );
      }
      toString() {
        return `(${this.x}, ${this.y}, ${this.z})`;
      }
      static pack(e, t, i = 0) {
        return (t[i++] = e.x), (t[i++] = e.y), (t[i] = e.z), t;
      }
      static unpack(e, t = 0, i = new Pt()) {
        return (i.x = e[t++]), (i.y = e[t++]), (i.z = e[t]), i;
      }
      static packArray(e, t = new Array(3 * e.length)) {
        const i = e.length,
          n = 3 * i;
        if (!Array.isArray(t) && t.length !== n)
          throw new Error(
            'If result is a typed array, it must have exactly array.length * 3 elements',
          );
        t.length !== n && (t.length = n);
        for (let n = 0; n < i; ++n) Pt.pack(e[n], t, 3 * n);
        return t;
      }
      static unpackArray(e, t = new Array(e.length / 3)) {
        const i = e.length;
        t.length = i / 3;
        for (let n = 0; n < i; n += 3) {
          const i = n / 3;
          t[i] = Pt.unpack(e, n, t[i]);
        }
        return t;
      }
      static maximumComponent(e) {
        return Math.max(e.x, e.y, e.z);
      }
      static minimumComponent(e) {
        return Math.min(e.x, e.y, e.z);
      }
      static minimumByComponent(e, t, i = new Pt()) {
        return (
          (i.x = Math.min(e.x, t.x)), (i.y = Math.min(e.y, t.y)), (i.z = Math.min(e.z, t.z)), i
        );
      }
      static maximumByComponent(e, t, i = new Pt()) {
        return (
          (i.x = Math.max(e.x, t.x)), (i.y = Math.max(e.y, t.y)), (i.z = Math.max(e.z, t.z)), i
        );
      }
      static magnitudeSquared(e) {
        return e.x * e.x + e.y * e.y + e.z * e.z;
      }
      static magnitude(e) {
        return Math.sqrt(Pt.magnitudeSquared(e));
      }
      static distance(e, t) {
        const i = new Pt();
        return Pt.subtract(e, t, i), Pt.magnitude(i);
      }
      static distanceSquared(e, t) {
        const i = new Pt();
        return Pt.subtract(e, t, i), Pt.magnitudeSquared(i);
      }
      static normalize(e, t = new Pt()) {
        const i = Pt.magnitude(e);
        return (t.x = e.x / i), (t.y = e.y / i), (t.z = e.z / i), t;
      }
      static dot(e, t) {
        return e.x * t.x + e.y * t.y + e.z * t.z;
      }
      static multiplyComponents(e, t, i = new Pt()) {
        return (i.x = e.x * t.x), (i.y = e.y * t.y), (i.z = e.z * t.z), i;
      }
      static divideComponents(e, t, i = new Pt()) {
        return (i.x = e.x / t.x), (i.y = e.y / t.y), (i.z = e.z / t.z), i;
      }
      static add(e, t, i = new Pt()) {
        return (i.x = e.x + t.x), (i.y = e.y + t.y), (i.z = e.z + t.z), i;
      }
      static subtract(e, t, i = new Pt()) {
        return (i.x = e.x - t.x), (i.y = e.y - t.y), (i.z = e.z - t.z), i;
      }
      static divideByScalar(e, t, i = new Pt()) {
        return (i.x = e.x / t), (i.y = e.y / t), (i.z = e.z / t), i;
      }
      static negate(e, t) {
        return (t.x = -e.x), (t.y = -e.y), (t.z = -e.z), t;
      }
      static abs(e, [t = new Pt()]) {
        return (t.x = Math.abs(e.x)), (t.y = Math.abs(e.y)), (t.z = Math.abs(e.z)), t;
      }
      static lerp(e, t, i, n = new Pt()) {
        const r = new Pt();
        return (
          Pt.multiplyByScalar(t, i, r), (n = Pt.multiplyByScalar(e, 1 - i, n)), Pt.add(r, n, n)
        );
      }
      static angleBetween(e, t) {
        const i = new Pt(),
          n = new Pt();
        Pt.normalize(e, i), Pt.normalize(t, n);
        const r = Pt.dot(i, n),
          o = Pt.magnitude(Pt.cross(i, n, i));
        return Math.atan2(o, r);
      }
      static mostOrthogonalAxis(e, t = new Pt()) {
        const i = new Pt(),
          n = Pt.normalize(e, i);
        return (
          Pt.abs(n, n),
          Pt.clone(
            n.x <= n.y ? (n.x <= n.z ? Pt.UNIT_X : Pt.UNIT_Z) : n.y <= n.z ? Pt.UNIT_Y : Pt.UNIT_Z,
            t,
          )
        );
      }
      static projectVector(e, t, i = new Pt()) {
        const n = Pt.dot(e, t) / Pt.dot(t, t);
        return Pt.multiplyByScalar(t, n, i);
      }
      static equalsArray(e, t, i = 0) {
        return e.x === t[i] && e.y === t[i + 1] && e.z === t[i + 2];
      }
      static cross(e, t, i = new Pt()) {
        const n = e.x,
          r = e.y,
          o = e.z,
          a = t.x,
          s = t.y,
          l = t.z,
          c = o * a - n * l,
          u = n * s - r * a;
        return (i.x = r * l - o * s), (i.y = c), (i.z = u), i;
      }
      static midpoint(e, t, i = new Pt()) {
        return (i.x = 0.5 * (e.x + t.x)), (i.y = 0.5 * (e.y + t.y)), (i.z = 0.5 * (e.z + t.z)), i;
      }
      static fromCartesian4(...e) {
        return this.clone(...e);
      }
      static fromArray(...e) {
        return this.unpack(...e);
      }
      static packedLength = 3;
    }
    class Et extends h {
      static IDENTITY = Object.freeze(new Et(0, 0, 0, 1));
      constructor(e = 0, t = 0, i = 0, n = 1) {
        super(-0, -0, -0, -0), a(e) && 1 === arguments.length ? this.copy(e) : this.set(e, t, i, n);
      }
      get ELEMENTS() {
        return 4;
      }
      get x() {
        return this[0];
      }
      set x(e) {
        this[0] = p(e);
      }
      get y() {
        return this[1];
      }
      set y(e) {
        this[1] = p(e);
      }
      get z() {
        return this[2];
      }
      set z(e) {
        this[2] = p(e);
      }
      get w() {
        return this[3];
      }
      set w(e) {
        this[3] = p(e);
      }
      copy(e) {
        return (this[0] = e[0]), (this[1] = e[1]), (this[2] = e[2]), (this[3] = e[3]), this.check();
      }
      set(e, t, i, n) {
        return (this[0] = e), (this[1] = t), (this[2] = i), (this[3] = n), this.check();
      }
      fromMatrix3(e) {
        return (
          (function (e, t) {
            var i,
              n = t[0] + t[4] + t[8];
            if (n > 0)
              (i = Math.sqrt(n + 1)),
                (e[3] = 0.5 * i),
                (e[0] = (t[5] - t[7]) * (i = 0.5 / i)),
                (e[1] = (t[6] - t[2]) * i),
                (e[2] = (t[1] - t[3]) * i);
            else {
              var r = 0;
              t[4] > t[0] && (r = 1), t[8] > t[3 * r + r] && (r = 2);
              var o = (r + 1) % 3,
                a = (r + 2) % 3;
              (i = Math.sqrt(t[3 * r + r] - t[3 * o + o] - t[3 * a + a] + 1)),
                (e[r] = 0.5 * i),
                (e[3] = (t[3 * o + a] - t[3 * a + o]) * (i = 0.5 / i)),
                (e[o] = (t[3 * o + r] + t[3 * r + o]) * i),
                (e[a] = (t[3 * a + r] + t[3 * r + a]) * i);
            }
          })(this, e),
          this.check()
        );
      }
      fromRotationMatrix4(e) {
        const t = e.elements,
          i = t[0],
          n = t[4],
          r = t[8],
          o = t[1],
          a = t[5],
          s = t[9],
          l = t[2],
          c = t[6],
          u = t[10],
          h = i + a + u;
        let d;
        return (
          h > 0
            ? ((d = 0.5 / Math.sqrt(h + 1)),
              (this[3] = 0.25 / d),
              (this[0] = (c - s) * d),
              (this[1] = (r - l) * d),
              (this[2] = (o - n) * d))
            : i > a && i > u
            ? ((d = 2 * Math.sqrt(1 + i - a - u)),
              (this[3] = (c - s) / d),
              (this[0] = 0.25 * d),
              (this[1] = (n + o) / d),
              (this[2] = (r + l) / d))
            : a > u
            ? ((d = 2 * Math.sqrt(1 + a - i - u)),
              (this[3] = (r - l) / d),
              (this[0] = (n + o) / d),
              (this[1] = 0.25 * d),
              (this[2] = (s + c) / d))
            : ((d = 2 * Math.sqrt(1 + u - i - a)),
              (this[3] = (o - n) / d),
              (this[0] = (r + l) / d),
              (this[1] = (s + c) / d),
              (this[2] = 0.25 * d)),
          this
        );
      }
      fromHeadingPitchRoll(e) {
        if (!(e instanceof Le)) throw new Error('There is not a HeadingPitchRoll!');
        const t = new Et().setFromAxisAngle([1, 0, 0], e.roll),
          i = new Et().setFromAxisAngle([0, 1, 0], -e.pitch),
          n = new Et().setFromAxisAngle([0, 0, 1], -e.heading);
        return this.multiply(n).multiply(i).multiply(t), this;
      }
      identity() {
        return (
          (function (e) {
            (e[0] = 0), (e[1] = 0), (e[2] = 0), (e[3] = 1);
          })(this),
          this.check()
        );
      }
      fromAxisRotation(e, t) {
        return U(this, e, t), this.check();
      }
      setAxisAngle(e, t) {
        return this.fromAxisRotation(e, t);
      }
      len() {
        return (e = this), Math.hypot(e[0], e[1], e[2], e[3]);
        var e;
      }
      lengthSquared() {
        return (t = (e = this)[0]) * t + (i = e[1]) * i + (n = e[2]) * n + (r = e[3]) * r;
        var e, t, i, n, r;
      }
      dot(e) {
        return (function (e, t) {
          return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3];
        })(this, e);
      }
      getAxisAngle(e = {}) {
        var t, i, n, r;
        return (
          (e.axis = new Pt()),
          (e.angle =
            ((t = e.axis),
            (i = this),
            (n = 2 * Math.acos(i[3])),
            (r = Math.sin(n / 2)) > _
              ? ((t[0] = i[0] / r), (t[1] = i[1] / r), (t[2] = i[2] / r))
              : ((t[0] = 1), (t[1] = 0), (t[2] = 0)),
            n)),
          e
        );
      }
      rotationTo(e, t) {
        return X(this, e, t), this.check();
      }
      add(e) {
        return (
          (function (e, t, i) {
            (e[0] = t[0] + i[0]), (e[1] = t[1] + i[1]), (e[2] = t[2] + i[2]), (e[3] = t[3] + i[3]);
          })(this, this, e),
          this.check()
        );
      }
      calculateW() {
        return (
          (function (e, t) {
            var i = t[0],
              n = t[1],
              r = t[2];
            (e[0] = i),
              (e[1] = n),
              (e[2] = r),
              (e[3] = Math.sqrt(Math.abs(1 - i * i - n * n - r * r)));
          })(this, this),
          this.check()
        );
      }
      conjugate() {
        return (
          (function (e, t) {
            (e[0] = -t[0]), (e[1] = -t[1]), (e[2] = -t[2]), (e[3] = t[3]);
          })(this, this),
          this.check()
        );
      }
      invert() {
        return (
          (function (e, t) {
            var i = t[0],
              n = t[1],
              r = t[2],
              o = t[3],
              a = i * i + n * n + r * r + o * o,
              s = a ? 1 / a : 0;
            (e[0] = -i * s), (e[1] = -n * s), (e[2] = -r * s), (e[3] = o * s);
          })(this, this),
          this.check()
        );
      }
      lerp(e, t, i) {
        return (
          (function (e, t, i, n) {
            var r = t[0],
              o = t[1],
              a = t[2],
              s = t[3];
            (e[0] = r + n * (i[0] - r)),
              (e[1] = o + n * (i[1] - o)),
              (e[2] = a + n * (i[2] - a)),
              (e[3] = s + n * (i[3] - s));
          })(this, e, t, i),
          this.check()
        );
      }
      multiplyRight(e) {
        return k(this, this, e), this.check();
      }
      multiplyLeft(e) {
        return k(this, e, this), this.check();
      }
      normalize() {
        const e = this.len(),
          t = e > 0 ? 1 / e : 0;
        return (
          (this[0] = this[0] * t),
          (this[1] = this[1] * t),
          (this[2] = this[2] * t),
          (this[3] = this[3] * t),
          0 === e && (this[3] = 1),
          this.check()
        );
      }
      rotateX(e) {
        return (
          (function (e, t, i) {
            i *= 0.5;
            var n = t[0],
              r = t[1],
              o = t[2],
              a = t[3],
              s = Math.sin(i),
              l = Math.cos(i);
            (e[0] = n * l + a * s),
              (e[1] = r * l + o * s),
              (e[2] = o * l - r * s),
              (e[3] = a * l - n * s);
          })(this, this, e),
          this.check()
        );
      }
      rotateY(e) {
        return (
          (function (e, t, i) {
            i *= 0.5;
            var n = t[0],
              r = t[1],
              o = t[2],
              a = t[3],
              s = Math.sin(i),
              l = Math.cos(i);
            (e[0] = n * l - o * s),
              (e[1] = r * l + a * s),
              (e[2] = o * l + n * s),
              (e[3] = a * l - r * s);
          })(this, this, e),
          this.check()
        );
      }
      rotateZ(e) {
        return (
          (function (e, t, i) {
            i *= 0.5;
            var n = t[0],
              r = t[1],
              o = t[2],
              a = t[3],
              s = Math.sin(i),
              l = Math.cos(i);
            (e[0] = n * l + r * s),
              (e[1] = r * l - n * s),
              (e[2] = o * l + a * s),
              (e[3] = a * l - o * s);
          })(this, this, e),
          this.check()
        );
      }
      scale(e) {
        return (
          (function (e, t, i) {
            (e[0] = t[0] * i), (e[1] = t[1] * i), (e[2] = t[2] * i), (e[3] = t[3] * i);
          })(this, this, e),
          this.check()
        );
      }
      slerp(e, t, i) {
        return (
          (function (e, t, i, n) {
            var r,
              o,
              a,
              s,
              l,
              c = t[0],
              u = t[1],
              h = t[2],
              d = t[3],
              p = i[0],
              f = i[1],
              m = i[2],
              g = i[3];
            (o = c * p + u * f + h * m + d * g) < 0 &&
              ((o = -o), (p = -p), (f = -f), (m = -m), (g = -g)),
              1 - o > _
                ? ((r = Math.acos(o)),
                  (a = Math.sin(r)),
                  (s = Math.sin((1 - n) * r) / a),
                  (l = Math.sin(n * r) / a))
                : ((s = 1 - n), (l = n)),
              (e[0] = s * c + l * p),
              (e[1] = s * u + l * f),
              (e[2] = s * h + l * m),
              (e[3] = s * d + l * g);
          })(this, e, t, i),
          this.check()
        );
      }
      transformVector4(e, t = new Ge()) {
        return B(t, e, this), f(t, 4);
      }
      lengthSq() {
        return this.lengthSquared();
      }
      setFromAxisAngle(e, t) {
        return this.setAxisAngle(e, t);
      }
      premultiply(e) {
        return this.multiplyLeft(e);
      }
      multiply(e) {
        return this.multiplyRight(e);
      }
      static fromAxisAngle(e, t, i = new Et()) {
        let n = new Pt();
        const r = t / 2,
          o = Math.sin(r);
        n = Pt.normalize(e, n);
        const a = n.x * o,
          s = n.y * o,
          l = n.z * o,
          c = Math.cos(r);
        return (i.x = a), (i.y = s), (i.z = l), (i.w = c), i;
      }
      static multiply(e, t, i = new Et()) {
        const n = e.x,
          r = e.y,
          o = e.z,
          a = e.w,
          s = t.x,
          l = t.y,
          c = t.z,
          u = t.w,
          h = a * l - n * c + r * u + o * s,
          d = a * c + n * l - r * s + o * u,
          p = a * u - n * s - r * l - o * c;
        return (i.x = a * s + n * u + r * c - o * l), (i.y = h), (i.z = d), (i.w = p), i;
      }
    }
    const Ct = 'Unknown Euler angle order',
      Mt = 0.99999;
    class It extends h {
      static ZYX = 0;
      static YXZ = 1;
      static XZY = 2;
      static ZXY = 3;
      static YZX = 4;
      static XYZ = 5;
      static RollPitchYaw = 0;
      static DefaultOrder = It.ZYX;
      constructor(e = 0, t = 0, i = 0, n = It.DefaultOrder) {
        super(-0, -0, -0, -0), a(e) ? this.fromVector3(e, n) : this.set(e, t, i, n);
      }
      get ELEMENTS() {
        return 4;
      }
      get x() {
        return this[0];
      }
      set x(e) {
        this[0] = p(e);
      }
      get y() {
        return this[1];
      }
      set y(e) {
        this[1] = p(e);
      }
      get z() {
        return this[2];
      }
      set z(e) {
        this[2] = p(e);
      }
      get alpha() {
        return this[0];
      }
      set alpha(e) {
        this[0] = p(e);
      }
      get beta() {
        return this[1];
      }
      set beta(e) {
        this[1] = p(e);
      }
      get gamma() {
        return this[2];
      }
      set gamma(e) {
        this[2] = p(e);
      }
      get phi() {
        return this[0];
      }
      set phi(e) {
        this[0] = p(e);
      }
      get theta() {
        return this[1];
      }
      set theta(e) {
        this[1] = p(e);
      }
      get psi() {
        return this[2];
      }
      set psi(e) {
        this[2] = p(e);
      }
      get roll() {
        return this[0];
      }
      set roll(e) {
        this[0] = p(e);
      }
      get pitch() {
        return this[1];
      }
      set pitch(e) {
        this[1] = p(e);
      }
      get yaw() {
        return this[2];
      }
      set yaw(e) {
        this[2] = p(e);
      }
      get order() {
        return this[3];
      }
      set order(e) {
        this[3] = (function (e) {
          if (e < 0 && e >= 6) throw new Error(Ct);
          return e;
        })(e);
      }
      fromQuaternion(e) {
        const [t, i, n, r] = e,
          o = i * i,
          a = -2 * (o + n * n) + 1,
          s = 2 * (t * i + r * n);
        let l = -2 * (t * n - r * i);
        (l = l > 1 ? 1 : l), (l = l < -1 ? -1 : l);
        const c = Math.atan2(2 * (i * n + r * t), -2 * (t * t + o) + 1),
          u = -Math.asin(l),
          h = -Math.atan2(s, a);
        return this.set(c, u, h, It.RollPitchYaw);
      }
      copy(e) {
        return (
          (this[0] = e[0]),
          (this[1] = e[1]),
          (this[2] = e[2]),
          (this[3] = Number.isFinite(e[3]) || this.order),
          this.check()
        );
      }
      set(e, t, i, n = It.ZYX) {
        return (
          (this[0] = e),
          (this[1] = t),
          (this[2] = i),
          (this[3] = Number.isFinite(n) ? n : this[3]),
          this.check()
        );
      }
      validate() {
        return (
          (e = this[3]) >= 0 &&
          e < 6 &&
          Number.isFinite(this[0]) &&
          Number.isFinite(this[1]) &&
          Number.isFinite(this[2])
        );
        var e;
      }
      toArray(e = [], t = 0) {
        return (e[t] = this[0]), (e[t + 1] = this[1]), (e[t + 2] = this[2]), e;
      }
      toArray4(e = [], t = 0) {
        return (
          (e[t] = this[0]), (e[t + 1] = this[1]), (e[t + 2] = this[2]), (e[t + 3] = this[3]), e
        );
      }
      toVector3(e = new Pt()) {
        return (e[0] = this[0]), (e[1] = this[1]), (e[2] = this[2]), e;
      }
      fromVector3(e, t) {
        return this.set(e[0], e[1], e[2], Number.isFinite(t) ? t : this[3]);
      }
      fromArray(e, t = 0) {
        return (
          (this[0] = e[t]),
          (this[1] = e[1 + t]),
          (this[2] = e[2 + t]),
          void 0 !== e[3] && (this[3] = e[3]),
          this.check()
        );
      }
      fromRollPitchYaw(e, t, i) {
        return this.set(e, t, i, It.RollPitchYaw);
      }
      fromHeadingPitchRoll(e) {
        return this.set(e.pitch, -e.roll, -e.heading, It.RollPitchYaw);
      }
      fromRotationMatrix(e, t = It.DefaultOrder) {
        return this.#i(e, t), this.check();
      }
      getRotationMatrix() {
        return this.#n();
      }
      getQuaternion() {
        const e = new Et();
        switch (this[3]) {
          case It.XYZ:
            return e.rotateX(this[0]).rotateY(this[1]).rotateZ(this[2]);
          case It.YXZ:
            return e.rotateY(this[0]).rotateX(this[1]).rotateZ(this[2]);
          case It.ZXY:
            return e.rotateZ(this[0]).rotateX(this[1]).rotateY(this[2]);
          case It.ZYX:
            return e.rotateZ(this[0]).rotateY(this[1]).rotateX(this[2]);
          case It.YZX:
            return e.rotateY(this[0]).rotateZ(this[1]).rotateX(this[2]);
          case It.XZY:
            return e.rotateX(this[0]).rotateZ(this[1]).rotateY(this[2]);
          default:
            throw new Error(Ct);
        }
      }
      #i(e, t = It.DefaultOrder) {
        const i = e.elements,
          n = i[0],
          r = i[4],
          o = i[8],
          a = i[1],
          s = i[5],
          l = i[9],
          u = i[2],
          h = i[6],
          d = i[10];
        switch ((t = t || this[3])) {
          case It.XYZ:
            (this[1] = Math.asin(c(o, -1, 1))),
              Math.abs(o) < Mt
                ? ((this[0] = Math.atan2(-l, d)), (this[2] = Math.atan2(-r, n)))
                : ((this[0] = Math.atan2(h, s)), (this[2] = 0));
            break;
          case It.YXZ:
            (this[0] = Math.asin(-c(l, -1, 1))),
              Math.abs(l) < Mt
                ? ((this[1] = Math.atan2(o, d)), (this[2] = Math.atan2(a, s)))
                : ((this[1] = Math.atan2(-u, n)), (this[2] = 0));
            break;
          case It.ZXY:
            (this[0] = Math.asin(c(h, -1, 1))),
              Math.abs(h) < Mt
                ? ((this[1] = Math.atan2(-u, d)), (this[2] = Math.atan2(-r, s)))
                : ((this[1] = 0), (this[2] = Math.atan2(a, n)));
            break;
          case It.ZYX:
            (this[1] = Math.asin(-c(u, -1, 1))),
              Math.abs(u) < Mt
                ? ((this[0] = Math.atan2(h, d)), (this[2] = Math.atan2(a, n)))
                : ((this[0] = 0), (this[2] = Math.atan2(-r, s)));
            break;
          case It.YZX:
            (this[2] = Math.asin(c(a, -1, 1))),
              Math.abs(a) < Mt
                ? ((this[0] = Math.atan2(-l, s)), (this[1] = Math.atan2(-u, n)))
                : ((this[0] = 0), (this[1] = Math.atan2(o, d)));
            break;
          case It.XZY:
            (this[2] = Math.asin(-c(r, -1, 1))),
              Math.abs(r) < Mt
                ? ((this[0] = Math.atan2(h, s)), (this[1] = Math.atan2(o, n)))
                : ((this[0] = Math.atan2(-l, d)), (this[1] = 0));
            break;
          default:
            throw new Error(Ct);
        }
        return (this[3] = t), this;
      }
      #n(e = new Je()) {
        const t = e,
          i = this.x,
          n = this.y,
          r = this.z,
          o = Math.cos(i),
          a = Math.cos(n),
          s = Math.cos(r),
          l = Math.sin(i),
          c = Math.sin(n),
          u = Math.sin(r);
        switch (this[3]) {
          case It.XYZ: {
            const e = o * s,
              i = o * u,
              n = l * s,
              r = l * u;
            (t[0] = a * s),
              (t[4] = -a * u),
              (t[8] = c),
              (t[1] = i + n * c),
              (t[5] = e - r * c),
              (t[9] = -l * a),
              (t[2] = r - e * c),
              (t[6] = n + i * c),
              (t[10] = o * a);
            break;
          }
          case It.YXZ: {
            const e = a * s,
              i = a * u,
              n = c * s,
              r = c * u;
            (t[0] = e + r * l),
              (t[4] = n * l - i),
              (t[8] = o * c),
              (t[1] = o * u),
              (t[5] = o * s),
              (t[9] = -l),
              (t[2] = i * l - n),
              (t[6] = r + e * l),
              (t[10] = o * a);
            break;
          }
          case It.ZXY: {
            const e = a * s,
              i = a * u,
              n = c * s,
              r = c * u;
            (t[0] = e - r * l),
              (t[4] = -o * u),
              (t[8] = n + i * l),
              (t[1] = i + n * l),
              (t[5] = o * s),
              (t[9] = r - e * l),
              (t[2] = -o * c),
              (t[6] = l),
              (t[10] = o * a);
            break;
          }
          case It.ZYX: {
            const e = o * s,
              i = o * u,
              n = l * s,
              r = l * u;
            (t[0] = a * s),
              (t[4] = n * c - i),
              (t[8] = e * c + r),
              (t[1] = a * u),
              (t[5] = r * c + e),
              (t[9] = i * c - n),
              (t[2] = -c),
              (t[6] = l * a),
              (t[10] = o * a);
            break;
          }
          case It.YZX: {
            const e = o * a,
              i = o * c,
              n = l * a,
              r = l * c;
            (t[0] = a * s),
              (t[4] = r - e * u),
              (t[8] = n * u + i),
              (t[1] = u),
              (t[5] = o * s),
              (t[9] = -l * s),
              (t[2] = -c * s),
              (t[6] = i * u + n),
              (t[10] = e - r * u);
            break;
          }
          case It.XZY: {
            const e = o * a,
              i = o * c,
              n = l * a,
              r = l * c;
            (t[0] = a * s),
              (t[4] = -u),
              (t[8] = c * s),
              (t[1] = e * u + r),
              (t[5] = o * s),
              (t[9] = i * u - n),
              (t[2] = n * u - i),
              (t[6] = l * s),
              (t[10] = r * u + e);
            break;
          }
          default:
            throw new Error(Ct);
        }
        return (
          (t[3] = 0), (t[7] = 0), (t[11] = 0), (t[12] = 0), (t[13] = 0), (t[14] = 0), (t[15] = 1), t
        );
      }
      toQuaternion() {
        const e = Math.cos(0.5 * this.yaw),
          t = Math.sin(0.5 * this.yaw),
          i = Math.cos(0.5 * this.roll),
          n = Math.sin(0.5 * this.roll),
          r = Math.cos(0.5 * this.pitch),
          o = Math.sin(0.5 * this.pitch);
        return new Et(
          e * n * r - t * i * o,
          e * i * o + t * n * r,
          t * i * r - e * n * o,
          e * i * r + t * n * o,
        );
      }
    }
    class Lt {
      constructor(e, t) {
        e &&
          (t
            ? this.setSouthWest(e).setNorthEast(t)
            : 4 === e.length
            ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]])
            : this.setSouthWest(e[0]).setNorthEast(e[1]));
      }
      setNorthEast(e) {
        return (this._ne = e instanceof Nt ? new Nt(e.lng, e.lat) : Nt.convert(e)), this;
      }
      setSouthWest(e) {
        return (this._sw = e instanceof Nt ? new Nt(e.lng, e.lat) : Nt.convert(e)), this;
      }
      extend(e) {
        const t = this._sw,
          i = this._ne;
        let n, r;
        if (e instanceof Nt) (n = e), (r = e);
        else {
          if (!(e instanceof Lt))
            return Array.isArray(e)
              ? e.every(Array.isArray)
                ? this.extend(Lt.convert(e))
                : this.extend(Nt.convert(e))
              : this;
          if (((n = e._sw), (r = e._ne), !n || !r)) return this;
        }
        return (
          t || i
            ? ((t.lng = Math.min(n.lng, t.lng)),
              (t.lat = Math.min(n.lat, t.lat)),
              (i.lng = Math.max(r.lng, i.lng)),
              (i.lat = Math.max(r.lat, i.lat)))
            : ((this._sw = new Nt(n.lng, n.lat)), (this._ne = new Nt(r.lng, r.lat))),
          this
        );
      }
      getCenter() {
        return new Nt((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
      }
      getSouthWest() {
        return this._sw;
      }
      getNorthEast() {
        return this._ne;
      }
      getNorthWest() {
        return new Nt(this.getWest(), this.getNorth());
      }
      getSouthEast() {
        return new Nt(this.getEast(), this.getSouth());
      }
      getWest() {
        return this._sw.lng;
      }
      getSouth() {
        return this._sw.lat;
      }
      getEast() {
        return this._ne.lng;
      }
      getNorth() {
        return this._ne.lat;
      }
      toArray() {
        return [this._sw.toArray(), this._ne.toArray()];
      }
      toString() {
        return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
      }
      isEmpty() {
        return !(this._sw && this._ne);
      }
      contains(e) {
        const { lng: t, lat: i } = Nt.convert(e);
        let n = this._sw.lng <= t && t <= this._ne.lng;
        return (
          this._sw.lng > this._ne.lng && (n = this._sw.lng >= t && t >= this._ne.lng),
          this._sw.lat <= i && i <= this._ne.lat && n
        );
      }
      static convert(e) {
        return !e || e instanceof Lt ? e : new Lt(e);
      }
    }
    const Rt = Me.TRANSFORM.R;
    class Nt {
      constructor(e, t) {
        if (isNaN(e) || isNaN(t)) throw new Error(`Invalid LngLat object: (${e}, ${t})`);
        (this.lng = +e),
          (this.lat = +t),
          (this.lat > 90 || this.lat < -90) &&
            (this.lat = (function (e) {
              return e > 90 ? 90 : e < -90 ? -90 : e;
            })(this.lat));
      }
      wrap() {
        return new Nt(le(this.lng, -180, 180), this.lat);
      }
      toArray() {
        return [this.lng, this.lat];
      }
      toString() {
        return `LngLat(${this.lng}, ${this.lat})`;
      }
      distanceTo(e) {
        const t = Math.PI / 180,
          i = this.lat * t,
          n = e.lat * t,
          r =
            Math.sin(i) * Math.sin(n) +
            Math.cos(i) * Math.cos(n) * Math.cos((e.lng - this.lng) * t);
        return Rt * Math.acos(Math.min(r, 1));
      }
      toBounds(e = 0) {
        const t = (360 * e) / 40075017,
          i = t / Math.cos((Math.PI / 180) * this.lat);
        return new Lt(new Nt(this.lng - i, this.lat - t), new Nt(this.lng + i, this.lat + t));
      }
      static convert(e) {
        if (e instanceof Nt) return e;
        if (Array.isArray(e) && (2 === e.length || 3 === e.length))
          return new Nt(Number(e[0]), Number(e[1]));
        if (!Array.isArray(e) && 'object' == typeof e && null !== e)
          return new Nt(Number('lng' in e ? e.lng : e.lon), Number(e.lat));
        throw new Error(
          '`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]',
        );
      }
      static equals(e, t) {
        return e.lng === t.lng && e.lat === t.lat;
      }
    }
    const Ot = { LATLON: 'LATLON', MERCATOR: 'MERCATOR' },
      Dt = {
        R: Me.TRANSFORM.R,
        CIR: Me.TRANSFORM.CIR,
        projectType: 'LATLON',
        project(e) {
          return new te(this.lngX(e.lng, this.CIR), this.latY(e.lat, this.CIR));
        },
        unproject(e) {
          return new Nt(this.xLng(e.x, this.CIR), this.yLat(e.y, this.CIR));
        },
        projectWithWorldSize(e, t) {
          return new te(this.lngX(e.lng, t), this.latY(e.lat, t));
        },
        unprojectWithWorldSize(e, t) {
          return new Nt(this.xLng(e.x, t), this.yLat(e.y, t));
        },
        lngX: (e, t) => ((180 + e) * t) / 360,
        latY: (e, t) => ((90 - e) / 180) * t * 0.5,
        xLng: (e, t) => (360 * e) / t - 180,
        yLat: (e, t) => 90 - (e / (0.5 * t)) * 180,
        tileNumberToLngLat(e, t, i) {
          return new Nt(this.xLng(e[0] * t, i), this.yLat(e[1] * t, i));
        },
        lngLatToTileNumber(e, t, i) {
          return [this.lngX(e.lng, i) / t, this.latY(e.lat, i) / t];
        },
      },
      Ft = {
        R: Me.TRANSFORM.R,
        CIR: Me.TRANSFORM.CIR,
        projectType: 'MERCATOR',
        project(e) {
          return new te(this.lngX(e.lng, this.CIR), this.latY(e.lat, this.CIR));
        },
        unproject(e) {
          return new Nt(this.xLng(e.x, this.CIR), this.yLat(e.y, this.CIR));
        },
        projectWithWorldSize(e, t) {
          return new te(this.lngX(e.lng, t), this.latY(e.lat, t));
        },
        unprojectWithWorldSize(e, t) {
          return new Nt(this.xLng(e.x, t), this.yLat(e.y, t));
        },
        lngX: (e, t) => ((180 + e) * t) / 360,
        latY: (e, t) =>
          ((180 - (180 / Math.PI) * Math.log(Math.tan(Math.PI / 4 + (e * Math.PI) / 360))) * t) /
          360,
        xLng: (e, t) => (360 * e) / t - 180,
        yLat: (e, t) =>
          (360 / Math.PI) * Math.atan(Math.exp(((180 - (360 * e) / t) * Math.PI) / 180)) - 90,
        tileNumberToLngLat(e, t, i) {
          return new Nt(this.xLng(e[0] * t, i), this.yLat(e[1] * t, i));
        },
        lngLatToTileNumber(e, t, i) {
          return [this.lngX(e.lng, i) / t, this.latY(e.lat, i) / t];
        },
      };
    function zt(e) {
      return e === Ot.LATLON ? Dt : Ft;
    }
    const Bt = {
        lngX: (e, t, i) => zt(i).lngX(e, t),
        lngXRoundZoom: (e, t, i) => zt(i).lngX(e, Math.pow(2, Math.floor(t))),
        latY: (e, t, i) => zt(i).latY(e, t),
        latYRoundZoom: (e, t, i) => zt(i).latY(e, Math.pow(2, Math.floor(t))),
        xLng: (e, t, i) => zt(i).xLng(e, t),
        yLat: (e, t, i) => zt(i).yLat(e, t),
      },
      Vt = {
        Int8: Int8Array,
        Uint8: Uint8Array,
        Int16: Int16Array,
        Uint16: Uint16Array,
        Int32: Int32Array,
        Uint32: Uint32Array,
        Float32: Float32Array,
      };
    class Ut {
      constructor(e, t) {
        (this._structArray = e),
          (this._pos1 = t * this.size),
          (this._pos2 = this._pos1 / 2),
          (this._pos4 = this._pos1 / 4),
          (this._pos8 = this._pos1 / 8);
      }
    }
    class kt {
      constructor() {
        (this.isTransferred = !1), (this.capacity = -1), this.resize(0);
      }
      static serialize(e, t) {
        return (
          e._trim(),
          t && ((e.isTransferred = !0), t.push(e.arrayBuffer)),
          { length: e.length, arrayBuffer: e.arrayBuffer }
        );
      }
      static deserialize(e) {
        const t = Object.create(this.prototype);
        return (
          (t.arrayBuffer = e.arrayBuffer),
          (t.length = e.length),
          (t.capacity = e.arrayBuffer.byteLength / t.bytesPerElement),
          t._refreshViews(),
          t
        );
      }
      _trim() {
        this.length !== this.capacity &&
          ((this.capacity = this.length),
          (this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement)),
          this._refreshViews());
      }
      clear() {
        this.length = 0;
      }
      resize(e) {
        this.reserve(e), (this.length = e);
      }
      reserve(e) {
        if (e > this.capacity) {
          (this.capacity = Math.max(e, Math.floor(5 * this.capacity), 128)),
            (this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement));
          const t = this.uint8;
          this._refreshViews(), t && this.uint8.set(t);
        }
      }
      _refreshViews() {
        throw new Error('_refreshViews() must be implemented by each concrete StructArray layout');
      }
    }
    function Gt(e, t = 1) {
      let i = 0,
        n = 0;
      return {
        members: e.map((e) => {
          const r = Vt[e.type].BYTES_PER_ELEMENT,
            o = (i = Ht(i, Math.max(t, r))),
            a = e.components || 1;
          return (
            (n = Math.max(n, r)),
            (i += r * a),
            { name: e.name, type: e.type, components: a, offset: o }
          );
        }),
        size: Ht(i, Math.max(n, t)),
        alignment: t,
      };
    }
    function Ht(e, t) {
      return Math.ceil(e / t) * t;
    }
    var Yt = Xt,
      qt = 3;
    function Xt(e, t, i) {
      var n = (this.cells = []);
      if (e instanceof ArrayBuffer) {
        this.arrayBuffer = e;
        var r = new Int32Array(this.arrayBuffer);
        (e = r[0]), (this.d = (t = r[1]) + 2 * (i = r[2]));
        for (var o = 0; o < this.d * this.d; o++) {
          var a = r[qt + o],
            s = r[qt + o + 1];
          n.push(a === s ? null : r.subarray(a, s));
        }
        var l = r[qt + n.length + 1];
        (this.keys = r.subarray(r[qt + n.length], l)),
          (this.bboxes = r.subarray(l)),
          (this.insert = this._insertReadonly);
      } else {
        this.d = t + 2 * i;
        for (var c = 0; c < this.d * this.d; c++) n.push([]);
        (this.keys = []), (this.bboxes = []);
      }
      (this.n = t), (this.extent = e), (this.padding = i), (this.scale = t / e), (this.uid = 0);
      var u = (i / t) * e;
      (this.min = -u), (this.max = e + u);
    }
    (Xt.prototype.insert = function (e, t, i, n, r) {
      this._forEachCell(t, i, n, r, this._insertCell, this.uid++),
        this.keys.push(e),
        this.bboxes.push(t),
        this.bboxes.push(i),
        this.bboxes.push(n),
        this.bboxes.push(r);
    }),
      (Xt.prototype._insertReadonly = function () {
        throw 'Cannot insert into a GridIndex created from an ArrayBuffer.';
      }),
      (Xt.prototype._insertCell = function (e, t, i, n, r, o) {
        this.cells[r].push(o);
      }),
      (Xt.prototype.query = function (e, t, i, n, r) {
        var o = this.min,
          a = this.max;
        if (e <= o && t <= o && a <= i && a <= n && !r)
          return Array.prototype.slice.call(this.keys);
        var s = [];
        return this._forEachCell(e, t, i, n, this._queryCell, s, {}, r), s;
      }),
      (Xt.prototype._queryCell = function (e, t, i, n, r, o, a, s) {
        var l = this.cells[r];
        if (null !== l)
          for (var c = this.keys, u = this.bboxes, h = 0; h < l.length; h++) {
            var d = l[h];
            if (void 0 === a[d]) {
              var p = 4 * d;
              (
                s
                  ? s(u[p + 0], u[p + 1], u[p + 2], u[p + 3])
                  : e <= u[p + 2] && t <= u[p + 3] && i >= u[p + 0] && n >= u[p + 1]
              )
                ? ((a[d] = !0), o.push(c[d]))
                : (a[d] = !1);
            }
          }
      }),
      (Xt.prototype._forEachCell = function (e, t, i, n, r, o, a, s) {
        for (
          var l = this._convertToCellCoord(e),
            c = this._convertToCellCoord(t),
            u = this._convertToCellCoord(i),
            h = this._convertToCellCoord(n),
            d = l;
          d <= u;
          d++
        )
          for (var p = c; p <= h; p++) {
            var f = this.d * p + d;
            if (
              (!s ||
                s(
                  this._convertFromCellCoord(d),
                  this._convertFromCellCoord(p),
                  this._convertFromCellCoord(d + 1),
                  this._convertFromCellCoord(p + 1),
                )) &&
              r.call(this, e, t, i, n, f, o, a, s)
            )
              return;
          }
      }),
      (Xt.prototype._convertFromCellCoord = function (e) {
        return (e - this.padding) / this.scale;
      }),
      (Xt.prototype._convertToCellCoord = function (e) {
        return Math.max(0, Math.min(this.d - 1, Math.floor(e * this.scale) + this.padding));
      }),
      (Xt.prototype.toArrayBuffer = function () {
        if (this.arrayBuffer) return this.arrayBuffer;
        for (
          var e = this.cells, t = qt + this.cells.length + 1 + 1, i = 0, n = 0;
          n < this.cells.length;
          n++
        )
          i += this.cells[n].length;
        var r = new Int32Array(t + i + this.keys.length + this.bboxes.length);
        (r[0] = this.extent), (r[1] = this.n), (r[2] = this.padding);
        for (var o = t, a = 0; a < e.length; a++) {
          var s = e[a];
          (r[qt + a] = o), r.set(s, o), (o += s.length);
        }
        return (
          (r[qt + e.length] = o),
          r.set(this.keys, o),
          (r[qt + e.length + 1] = o += this.keys.length),
          r.set(this.bboxes, o),
          (o += this.bboxes.length),
          r.buffer
        );
      });
    const jt = {
      transparent: [0, 0, 0, 0],
      aliceblue: [240, 248, 255, 1],
      antiquewhite: [250, 235, 215, 1],
      aqua: [0, 255, 255, 1],
      aquamarine: [127, 255, 212, 1],
      azure: [240, 255, 255, 1],
      beige: [245, 245, 220, 1],
      bisque: [255, 228, 196, 1],
      black: [0, 0, 0, 1],
      blanchedalmond: [255, 235, 205, 1],
      blue: [0, 0, 255, 1],
      blueviolet: [138, 43, 226, 1],
      brown: [165, 42, 42, 1],
      burlywood: [222, 184, 135, 1],
      cadetblue: [95, 158, 160, 1],
      chartreuse: [127, 255, 0, 1],
      chocolate: [210, 105, 30, 1],
      coral: [255, 127, 80, 1],
      cornflowerblue: [100, 149, 237, 1],
      cornsilk: [255, 248, 220, 1],
      crimson: [220, 20, 60, 1],
      cyan: [0, 255, 255, 1],
      darkblue: [0, 0, 139, 1],
      darkcyan: [0, 139, 139, 1],
      darkgoldenrod: [184, 134, 11, 1],
      darkgray: [169, 169, 169, 1],
      darkgreen: [0, 100, 0, 1],
      darkgrey: [169, 169, 169, 1],
      darkkhaki: [189, 183, 107, 1],
      darkmagenta: [139, 0, 139, 1],
      darkolivegreen: [85, 107, 47, 1],
      darkorange: [255, 140, 0, 1],
      darkorchid: [153, 50, 204, 1],
      darkred: [139, 0, 0, 1],
      darksalmon: [233, 150, 122, 1],
      darkseagreen: [143, 188, 143, 1],
      darkslateblue: [72, 61, 139, 1],
      darkslategray: [47, 79, 79, 1],
      darkslategrey: [47, 79, 79, 1],
      darkturquoise: [0, 206, 209, 1],
      darkviolet: [148, 0, 211, 1],
      deeppink: [255, 20, 147, 1],
      deepskyblue: [0, 191, 255, 1],
      dimgray: [105, 105, 105, 1],
      dimgrey: [105, 105, 105, 1],
      dodgerblue: [30, 144, 255, 1],
      firebrick: [178, 34, 34, 1],
      floralwhite: [255, 250, 240, 1],
      forestgreen: [34, 139, 34, 1],
      fuchsia: [255, 0, 255, 1],
      gainsboro: [220, 220, 220, 1],
      ghostwhite: [248, 248, 255, 1],
      gold: [255, 215, 0, 1],
      goldenrod: [218, 165, 32, 1],
      gray: [128, 128, 128, 1],
      green: [0, 128, 0, 1],
      greenyellow: [173, 255, 47, 1],
      grey: [128, 128, 128, 1],
      honeydew: [240, 255, 240, 1],
      hotpink: [255, 105, 180, 1],
      indianred: [205, 92, 92, 1],
      indigo: [75, 0, 130, 1],
      ivory: [255, 255, 240, 1],
      khaki: [240, 230, 140, 1],
      lavender: [230, 230, 250, 1],
      lavenderblush: [255, 240, 245, 1],
      lawngreen: [124, 252, 0, 1],
      lemonchiffon: [255, 250, 205, 1],
      lightblue: [173, 216, 230, 1],
      lightcoral: [240, 128, 128, 1],
      lightcyan: [224, 255, 255, 1],
      lightgoldenrodyellow: [250, 250, 210, 1],
      lightgray: [211, 211, 211, 1],
      lightgreen: [144, 238, 144, 1],
      lightgrey: [211, 211, 211, 1],
      lightpink: [255, 182, 193, 1],
      lightsalmon: [255, 160, 122, 1],
      lightseagreen: [32, 178, 170, 1],
      lightskyblue: [135, 206, 250, 1],
      lightslategray: [119, 136, 153, 1],
      lightslategrey: [119, 136, 153, 1],
      lightsteelblue: [176, 196, 222, 1],
      lightyellow: [255, 255, 224, 1],
      lime: [0, 255, 0, 1],
      limegreen: [50, 205, 50, 1],
      linen: [250, 240, 230, 1],
      magenta: [255, 0, 255, 1],
      maroon: [128, 0, 0, 1],
      mediumaquamarine: [102, 205, 170, 1],
      mediumblue: [0, 0, 205, 1],
      mediumorchid: [186, 85, 211, 1],
      mediumpurple: [147, 112, 219, 1],
      mediumseagreen: [60, 179, 113, 1],
      mediumslateblue: [123, 104, 238, 1],
      mediumspringgreen: [0, 250, 154, 1],
      mediumturquoise: [72, 209, 204, 1],
      mediumvioletred: [199, 21, 133, 1],
      midnightblue: [25, 25, 112, 1],
      mintcream: [245, 255, 250, 1],
      mistyrose: [255, 228, 225, 1],
      moccasin: [255, 228, 181, 1],
      navajowhite: [255, 222, 173, 1],
      navy: [0, 0, 128, 1],
      oldlace: [253, 245, 230, 1],
      olive: [128, 128, 0, 1],
      olivedrab: [107, 142, 35, 1],
      orange: [255, 165, 0, 1],
      orangered: [255, 69, 0, 1],
      orchid: [218, 112, 214, 1],
      palegoldenrod: [238, 232, 170, 1],
      palegreen: [152, 251, 152, 1],
      paleturquoise: [175, 238, 238, 1],
      palevioletred: [219, 112, 147, 1],
      papayawhip: [255, 239, 213, 1],
      peachpuff: [255, 218, 185, 1],
      peru: [205, 133, 63, 1],
      pink: [255, 192, 203, 1],
      plum: [221, 160, 221, 1],
      powderblue: [176, 224, 230, 1],
      purple: [128, 0, 128, 1],
      rebeccapurple: [102, 51, 153, 1],
      red: [255, 0, 0, 1],
      rosybrown: [188, 143, 143, 1],
      royalblue: [65, 105, 225, 1],
      saddlebrown: [139, 69, 19, 1],
      salmon: [250, 128, 114, 1],
      sandybrown: [244, 164, 96, 1],
      seagreen: [46, 139, 87, 1],
      seashell: [255, 245, 238, 1],
      sienna: [160, 82, 45, 1],
      silver: [192, 192, 192, 1],
      skyblue: [135, 206, 235, 1],
      slateblue: [106, 90, 205, 1],
      slategray: [112, 128, 144, 1],
      slategrey: [112, 128, 144, 1],
      snow: [255, 250, 250, 1],
      springgreen: [0, 255, 127, 1],
      steelblue: [70, 130, 180, 1],
      tan: [210, 180, 140, 1],
      teal: [0, 128, 128, 1],
      thistle: [216, 191, 216, 1],
      tomato: [255, 99, 71, 1],
      turquoise: [64, 224, 208, 1],
      violet: [238, 130, 238, 1],
      wheat: [245, 222, 179, 1],
      white: [255, 255, 255, 1],
      whitesmoke: [245, 245, 245, 1],
      yellow: [255, 255, 0, 1],
      yellowgreen: [154, 205, 50, 1],
    };
    function Wt(e) {
      return (e = Math.round(e)) < 0 ? 0 : e > 255 ? 255 : e;
    }
    function $t(e) {
      return e < 0 ? 0 : e > 1 ? 1 : e;
    }
    function Zt(e) {
      return Wt('%' === e[e.length - 1] ? (Number(e.slice(0, -1)) / 100) * 255 : Number(e));
    }
    function Kt(e) {
      return '%' !== e[e.length - 1] ? null : $t(Number(e.slice(0, -1)) / 100);
    }
    function Qt(e, t, i) {
      return (
        i < 0 ? (i += 1) : i > 1 && (i -= 1),
        6 * i < 1
          ? e + (t - e) * i * 6
          : 2 * i < 1
          ? t
          : 3 * i < 2
          ? e + (t - e) * (2 / 3 - i) * 6
          : e
      );
    }
    function Jt(e) {
      return e < 48 ? NaN : e <= 57 ? e - 48 : e < 97 ? NaN : e <= 102 ? e - 87 : NaN;
    }
    const ei = new Set([' ', '\t', '\n', '\r', ',', '/']);
    function ti(e) {
      const t = e.trim().toLowerCase();
      if (t in jt) return jt[t].slice();
      if ('#' === t[0]) {
        const e = 4 === t.length || 5 === t.length;
        if (!e && 7 !== t.length && 9 !== t.length) return null;
        const i = e ? 1 : 2,
          n = [0, 0, 0, 255],
          r = 5 === t.length || 9 === t.length ? 4 : 3;
        for (let o = 0; o < r; o++) {
          const r = Jt(t.charCodeAt(o * i + 1));
          if (((n[o] = 16 * r + (e ? r : Jt(t.charCodeAt(o * i + 2)))), Number.isNaN(n[o])))
            return null;
        }
        return (n[3] /= 255), n;
      }
      const i = t.indexOf('(');
      let n = t.indexOf(')');
      if ((-1 === n && (n = t.length), -1 !== i && (n + 1 === t.length || n === t.length))) {
        const e = t.substr(0, i),
          r = [];
        let o = '';
        for (let e = i + 1; e < n; e++)
          ei.has(t[e]) ? 0 !== o.length && (r.push(o), (o = '')) : (o += t[e]);
        0 !== o.length && r.push(o);
        const a =
          4 === r.length
            ? (function (e) {
                return Kt(e) ?? $t(Number(e));
              })(r.pop())
            : 1;
        if (3 !== r.length) return null;
        let s, l, c, u, h, d;
        switch (e) {
          case 'rgba':
          case 'rgb':
            return (d = [...r.map(Zt), a]), d.some(Number.isNaN) ? null : d;
          case 'hsla':
          case 'hsl':
            return (
              (s =
                ((((function (e) {
                  return e.endsWith('deg')
                    ? Number(e.slice(0, -3))
                    : e.endsWith('grad')
                    ? (360 * Number(e.slice(0, -4))) / 400
                    : e.endsWith('rad')
                    ? (360 * Number(e.slice(0, -3))) / (2 * Math.PI)
                    : e.endsWith('turn')
                    ? 360 * Number(e.slice(0, -4))
                    : Number(e);
                })(r[0]) %
                  360) +
                  360) %
                  360) /
                360),
              Number.isNaN(s)
                ? null
                : ((l = Kt(r[1])),
                  Number.isNaN(l) || null === l
                    ? null
                    : ((c = Kt(r[2])),
                      Number.isNaN(c) || null === c
                        ? null
                        : ((h = c <= 0.5 ? c * (l + 1) : c + l - c * l),
                          (u = 2 * c - h),
                          [
                            Wt(255 * Qt(u, h, s + 1 / 3)),
                            Wt(255 * Qt(u, h, s)),
                            Wt(255 * Qt(u, h, s - 1 / 3)),
                            a,
                          ])))
            );
          default:
            return null;
        }
      }
      return null;
    }
    class ii {
      constructor(e, t, i, n = 1) {
        (this.r = e), (this.g = t), (this.b = i), (this.a = n);
      }
      set(e) {
        (this.r = e[0]), (this.g = e[1]), (this.b = e[2]), (this.a = e[3]);
      }
      toBytes(e) {
        const i = ii.floatToByte(this.r),
          n = ii.floatToByte(this.g),
          r = ii.floatToByte(this.b),
          o = ii.floatToByte(this.a);
        return t(e) ? ((e[0] = i), (e[1] = n), (e[2] = r), (e[3] = o), e) : [i, n, r, o];
      }
      static equals = function (e, i) {
        return (
          e === i || (t(e) && t(i) && e.r === i.r && e.g === i.g && e.b === i.b && e.a === i.a)
        );
      };
      static parse(e) {
        if (!e) return;
        if (e instanceof ii) return e;
        if (Array.isArray(e)) return new ii(...e);
        if (e instanceof Pt) return new ii(e[0], e[1], e[2]);
        if (e instanceof Ge) return new ii(e[0], e[1], e[2], e[3]);
        if ('string' != typeof e) return;
        const t = ti(e);
        return t ? new ii(t[0] / 255, t[1] / 255, t[2] / 255, t[3]) : void 0;
      }
      toString() {
        const [e, t, i, n] = this.toArray();
        return `rgba(${Math.round(e)},${Math.round(t)},${Math.round(i)},${n})`;
      }
      toArray() {
        const { r: e, g: t, b: i, a: n } = this;
        return 0 === n ? [0, 0, 0, 0] : [(255 * e) / n, (255 * t) / n, (255 * i) / n, n];
      }
      toArrayFloat() {
        const { r: e, g: t, b: i, a: n } = this;
        return 0 === n ? [0, 0, 0, 0] : [e / n, t / n, i / n, n];
      }
      toVector3() {
        const { r: e, g: t, b: i } = this;
        return new Pt(e, t, i);
      }
      toVector4() {
        return new Ge(this.r, this.g, this.b, this.a);
      }
      static floatToByte(e) {
        return 1 === e ? 255 : (256 * e) | 0;
      }
      static byteToFloat(e) {
        return e / 255;
      }
      toRgba() {
        return (
          (oi[0] = ii.floatToByte(this.r)),
          (oi[1] = ii.floatToByte(this.g)),
          (oi[2] = ii.floatToByte(this.b)),
          (oi[3] = ii.floatToByte(this.a)),
          ri[0]
        );
      }
      static toHex(e) {
        return (function (e) {
          const t = e
              .replace(/rgba?\(/, '')
              .replace(/\)/, '')
              .replace(/[\s+]/g, '')
              .split(','),
            i = parseFloat(t[3] || 1),
            n = Math.floor(i * parseInt(t[0]) + 255 * (1 - i)),
            r = Math.floor(i * parseInt(t[1]) + 255 * (1 - i)),
            o = Math.floor(i * parseInt(t[2]) + 255 * (1 - i));
          return `#${`0${n.toString(16)}`.slice(-2)}${`0${r.toString(16)}`.slice(
            -2,
          )}${`0${o.toString(16)}`.slice(-2)}`.toLocaleUpperCase();
        })(this.parse(e).toString());
      }
      static fromRgba(e, t) {
        return (ri[0] = e), ii.fromBytes(oi[0], oi[1], oi[2], oi[3], t);
      }
      static fromBytes(e, i, n, r, o) {
        return (
          (e = ii.byteToFloat(Z(e, 255))),
          (i = ii.byteToFloat(Z(i, 255))),
          (n = ii.byteToFloat(Z(n, 255))),
          (r = ii.byteToFloat(Z(r, 255))),
          t(o) ? ((o.r = e), (o.g = i), (o.b = n), (o.a = r), o) : new ii(e, i, n, r)
        );
      }
      static pack(e, t, i) {
        return (i = Z(i, 0)), (t[i++] = e.r), (t[i++] = e.g), (t[i++] = e.b), (t[i] = e.a), t;
      }
      static unpack(e, i, n) {
        return (
          (i = Z(i, 0)),
          t(n) || (n = new ii()),
          (n.r = e[i++]),
          (n.g = e[i++]),
          (n.b = e[i++]),
          (n.a = e[i]),
          n
        );
      }
      static clone(e, i) {
        if (t(e))
          return t(i)
            ? ((i.r = e.r), (i.g = e.g), (i.b = e.b), (i.a = e.a), i)
            : new ii(e.r, e.g, e.b, e.a);
      }
      copy(e) {
        (this.r = e.r), (this.g = e.g), (this.b = e.b), (this.a = e.a);
      }
    }
    const ni = new ArrayBuffer(4),
      ri = new Uint32Array(ni),
      oi = new Uint8Array(ni);
    (ii.black = new ii(0, 0, 0, 1)),
      (ii.white = new ii(1, 1, 1, 1)),
      (ii.transparent = new ii(0, 0, 0, 0)),
      (ii.packedLength = 4);
    var ai = ii;
    function si(e, ...t) {
      for (const i of t) for (const t in i) e[t] = i[t];
      return e;
    }
    class li extends Error {
      constructor(e, t) {
        super(t), (this.message = t), (this.key = e);
      }
    }
    var ci = li;
    class ui {
      constructor(e, t = []) {
        (this.parent = e), (this.bindings = {});
        for (const [e, i] of t) this.bindings[e] = i;
      }
      concat(e) {
        return new ui(this, e);
      }
      get(e) {
        if (this.bindings[e]) return this.bindings[e];
        if (this.parent) return this.parent.get(e);
        throw new Error(`${e} not found in scope.`);
      }
      has(e) {
        return !!this.bindings[e] || (!!this.parent && this.parent.has(e));
      }
    }
    var hi = ui;
    const di = { kind: 'null' },
      pi = { kind: 'number' },
      fi = { kind: 'string' },
      mi = { kind: 'boolean' },
      _i = { kind: 'color' },
      gi = { kind: 'object' },
      yi = { kind: 'value' },
      xi = { kind: 'collator' },
      vi = { kind: 'formatted' },
      wi = { kind: 'resolvedImage' };
    function Ti(e, t) {
      return { kind: 'array', itemType: e, N: t };
    }
    function bi(e) {
      if ('array' === e.kind) {
        const t = bi(e.itemType);
        return 'number' == typeof e.N
          ? `array<${t}, ${e.N}>`
          : 'value' === e.itemType.kind
          ? 'array'
          : `array<${t}>`;
      }
      return e.kind;
    }
    const Si = [di, pi, fi, mi, _i, vi, gi, Ti(yi), wi];
    function Ai(e, t) {
      if ('error' === t.kind) return null;
      if ('array' === e.kind) {
        if (
          'array' === t.kind &&
          ((0 === t.N && 'value' === t.itemType.kind) || !Ai(e.itemType, t.itemType)) &&
          ('number' != typeof e.N || e.N === t.N)
        )
          return null;
      } else {
        if (e.kind === t.kind) return null;
        if ('value' === e.kind) for (const e of Si) if (!Ai(e, t)) return null;
      }
      return `Expected ${bi(e)} but found ${bi(t)} instead.`;
    }
    function Pi(e, t) {
      return t.some((t) => t.kind === e.kind);
    }
    function Ei(e, t) {
      return t.some((t) =>
        'null' === t
          ? null === e
          : 'array' === t
          ? Array.isArray(e)
          : 'object' === t
          ? e && !Array.isArray(e) && 'object' == typeof e
          : t === typeof e,
      );
    }
    class Ci {
      constructor(e, t, i) {
        (this.sensitivity = e ? (t ? 'variant' : 'case') : t ? 'accent' : 'base'),
          (this.locale = i),
          (this.collator = new Intl.Collator(this.locale ? this.locale : [], {
            sensitivity: this.sensitivity,
            usage: 'search',
          }));
      }
      compare(e, t) {
        return this.collator.compare(e, t);
      }
      resolvedLocale() {
        return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
      }
    }
    class Mi {
      constructor(e, t, i) {
        (this.type = xi),
          (this.locale = i),
          (this.caseSensitive = e),
          (this.diacriticSensitive = t);
      }
      static parse(e, t) {
        if (2 !== e.length) return t.error('Expected one argument.');
        const i = e[1];
        if ('object' != typeof i || Array.isArray(i))
          return t.error('Collator options argument must be an object.');
        const n = t.parse(void 0 !== i['case-sensitive'] && i['case-sensitive'], 1, mi);
        if (!n) return null;
        const r = t.parse(void 0 !== i['diacritic-sensitive'] && i['diacritic-sensitive'], 1, mi);
        if (!r) return null;
        let o = null;
        return i.locale && ((o = t.parse(i.locale, 1, fi)), !o) ? null : new Mi(n, r, o);
      }
      evaluate(e) {
        return new Ci(
          this.caseSensitive.evaluate(e),
          this.diacriticSensitive.evaluate(e),
          this.locale ? this.locale.evaluate(e) : null,
        );
      }
      eachChild(e) {
        e(this.caseSensitive), e(this.diacriticSensitive), this.locale && e(this.locale);
      }
      possibleOutputs() {
        return [void 0];
      }
      serialize() {
        const e = {};
        return (
          (e['case-sensitive'] = this.caseSensitive.serialize()),
          (e['diacritic-sensitive'] = this.diacriticSensitive.serialize()),
          this.locale && (e.locale = this.locale.serialize()),
          ['collator', e]
        );
      }
    }
    var Ii = {
      'Latin-1 Supplement': (e) => e >= 128 && e <= 255,
      Arabic: (e) => e >= 1536 && e <= 1791,
      'Arabic Supplement': (e) => e >= 1872 && e <= 1919,
      'Arabic Extended-A': (e) => e >= 2208 && e <= 2303,
      'Hangul Jamo': (e) => e >= 4352 && e <= 4607,
      'Unified Canadian Aboriginal Syllabics': (e) => e >= 5120 && e <= 5759,
      Khmer: (e) => e >= 6016 && e <= 6143,
      'Unified Canadian Aboriginal Syllabics Extended': (e) => e >= 6320 && e <= 6399,
      'General Punctuation': (e) => e >= 8192 && e <= 8303,
      'Letterlike Symbols': (e) => e >= 8448 && e <= 8527,
      'Number Forms': (e) => e >= 8528 && e <= 8591,
      'Miscellaneous Technical': (e) => e >= 8960 && e <= 9215,
      'Control Pictures': (e) => e >= 9216 && e <= 9279,
      'Optical Character Recognition': (e) => e >= 9280 && e <= 9311,
      'Enclosed Alphanumerics': (e) => e >= 9312 && e <= 9471,
      'Geometric Shapes': (e) => e >= 9632 && e <= 9727,
      'Miscellaneous Symbols': (e) => e >= 9728 && e <= 9983,
      'Miscellaneous Symbols and Arrows': (e) => e >= 11008 && e <= 11263,
      'CJK Radicals Supplement': (e) => e >= 11904 && e <= 12031,
      'Kangxi Radicals': (e) => e >= 12032 && e <= 12255,
      'Ideographic Description Characters': (e) => e >= 12272 && e <= 12287,
      'CJK Symbols and Punctuation': (e) => e >= 12288 && e <= 12351,
      Hiragana: (e) => e >= 12352 && e <= 12447,
      Katakana: (e) => e >= 12448 && e <= 12543,
      Bopomofo: (e) => e >= 12544 && e <= 12591,
      'Hangul Compatibility Jamo': (e) => e >= 12592 && e <= 12687,
      Kanbun: (e) => e >= 12688 && e <= 12703,
      'Bopomofo Extended': (e) => e >= 12704 && e <= 12735,
      'CJK Strokes': (e) => e >= 12736 && e <= 12783,
      'Katakana Phonetic Extensions': (e) => e >= 12784 && e <= 12799,
      'Enclosed CJK Letters and Months': (e) => e >= 12800 && e <= 13055,
      'CJK Compatibility': (e) => e >= 13056 && e <= 13311,
      'CJK Unified Ideographs Extension A': (e) => e >= 13312 && e <= 19903,
      'Yijing Hexagram Symbols': (e) => e >= 19904 && e <= 19967,
      'CJK Unified Ideographs': (e) => e >= 19968 && e <= 40959,
      'Yi Syllables': (e) => e >= 40960 && e <= 42127,
      'Yi Radicals': (e) => e >= 42128 && e <= 42191,
      'Hangul Jamo Extended-A': (e) => e >= 43360 && e <= 43391,
      'Hangul Syllables': (e) => e >= 44032 && e <= 55215,
      'Hangul Jamo Extended-B': (e) => e >= 55216 && e <= 55295,
      'Private Use Area': (e) => e >= 57344 && e <= 63743,
      'CJK Compatibility Ideographs': (e) => e >= 63744 && e <= 64255,
      'Arabic Presentation Forms-A': (e) => e >= 64336 && e <= 65023,
      'Vertical Forms': (e) => e >= 65040 && e <= 65055,
      'CJK Compatibility Forms': (e) => e >= 65072 && e <= 65103,
      'Small Form Variants': (e) => e >= 65104 && e <= 65135,
      'Arabic Presentation Forms-B': (e) => e >= 65136 && e <= 65279,
      'Halfwidth and Fullwidth Forms': (e) => e >= 65280 && e <= 65519,
    };
    function Li(e) {
      for (const t of e) if (Ni(t.charCodeAt(0))) return !0;
      return !1;
    }
    function Ri(e) {
      return !(
        Ii.Arabic(e) ||
        Ii['Arabic Supplement'](e) ||
        Ii['Arabic Extended-A'](e) ||
        Ii['Arabic Presentation Forms-A'](e) ||
        Ii['Arabic Presentation Forms-B'](e)
      );
    }
    function Ni(e) {
      return !(
        746 !== e &&
        747 !== e &&
        (e < 4352 ||
          !(
            Ii['Bopomofo Extended'](e) ||
            Ii.Bopomofo(e) ||
            (Ii['CJK Compatibility Forms'](e) && !(e >= 65097 && e <= 65103)) ||
            Ii['CJK Compatibility Ideographs'](e) ||
            Ii['CJK Compatibility'](e) ||
            Ii['CJK Radicals Supplement'](e) ||
            Ii['CJK Strokes'](e) ||
            !(
              !Ii['CJK Symbols and Punctuation'](e) ||
              (e >= 12296 && e <= 12305) ||
              (e >= 12308 && e <= 12319) ||
              12336 === e
            ) ||
            Ii['CJK Unified Ideographs Extension A'](e) ||
            Ii['CJK Unified Ideographs'](e) ||
            Ii['Enclosed CJK Letters and Months'](e) ||
            Ii['Hangul Compatibility Jamo'](e) ||
            Ii['Hangul Jamo Extended-A'](e) ||
            Ii['Hangul Jamo Extended-B'](e) ||
            Ii['Hangul Jamo'](e) ||
            Ii['Hangul Syllables'](e) ||
            Ii.Hiragana(e) ||
            Ii['Ideographic Description Characters'](e) ||
            Ii.Kanbun(e) ||
            Ii['Kangxi Radicals'](e) ||
            Ii['Katakana Phonetic Extensions'](e) ||
            (Ii.Katakana(e) && 12540 !== e) ||
            !(
              !Ii['Halfwidth and Fullwidth Forms'](e) ||
              65288 === e ||
              65289 === e ||
              65293 === e ||
              (e >= 65306 && e <= 65310) ||
              65339 === e ||
              65341 === e ||
              65343 === e ||
              (e >= 65371 && e <= 65503) ||
              65507 === e ||
              (e >= 65512 && e <= 65519)
            ) ||
            !(
              !Ii['Small Form Variants'](e) ||
              (e >= 65112 && e <= 65118) ||
              (e >= 65123 && e <= 65126)
            ) ||
            Ii['Unified Canadian Aboriginal Syllabics'](e) ||
            Ii['Unified Canadian Aboriginal Syllabics Extended'](e) ||
            Ii['Vertical Forms'](e) ||
            Ii['Yijing Hexagram Symbols'](e) ||
            Ii['Yi Syllables'](e) ||
            Ii['Yi Radicals'](e)
          ))
      );
    }
    function Oi(e) {
      return !(
        Ni(e) ||
        (function (e) {
          return !!(
            (Ii['Latin-1 Supplement'](e) &&
              (167 === e ||
                169 === e ||
                174 === e ||
                177 === e ||
                188 === e ||
                189 === e ||
                190 === e ||
                215 === e ||
                247 === e)) ||
            (Ii['General Punctuation'](e) &&
              (8214 === e ||
                8224 === e ||
                8225 === e ||
                8240 === e ||
                8241 === e ||
                8251 === e ||
                8252 === e ||
                8258 === e ||
                8263 === e ||
                8264 === e ||
                8265 === e ||
                8273 === e)) ||
            Ii['Letterlike Symbols'](e) ||
            Ii['Number Forms'](e) ||
            (Ii['Miscellaneous Technical'](e) &&
              ((e >= 8960 && e <= 8967) ||
                (e >= 8972 && e <= 8991) ||
                (e >= 8996 && e <= 9e3) ||
                9003 === e ||
                (e >= 9085 && e <= 9114) ||
                (e >= 9150 && e <= 9165) ||
                9167 === e ||
                (e >= 9169 && e <= 9179) ||
                (e >= 9186 && e <= 9215))) ||
            (Ii['Control Pictures'](e) && 9251 !== e) ||
            Ii['Optical Character Recognition'](e) ||
            Ii['Enclosed Alphanumerics'](e) ||
            Ii['Geometric Shapes'](e) ||
            (Ii['Miscellaneous Symbols'](e) && !(e >= 9754 && e <= 9759)) ||
            (Ii['Miscellaneous Symbols and Arrows'](e) &&
              ((e >= 11026 && e <= 11055) ||
                (e >= 11088 && e <= 11097) ||
                (e >= 11192 && e <= 11243))) ||
            Ii['CJK Symbols and Punctuation'](e) ||
            Ii.Katakana(e) ||
            Ii['Private Use Area'](e) ||
            Ii['CJK Compatibility Forms'](e) ||
            Ii['Small Form Variants'](e) ||
            Ii['Halfwidth and Fullwidth Forms'](e) ||
            8734 === e ||
            8756 === e ||
            8757 === e ||
            (e >= 9984 && e <= 10087) ||
            (e >= 10102 && e <= 10131) ||
            65532 === e ||
            65533 === e
          );
        })(e)
      );
    }
    function Di(e) {
      return (
        (e >= 1424 && e <= 2303) ||
        Ii['Arabic Presentation Forms-A'](e) ||
        Ii['Arabic Presentation Forms-B'](e)
      );
    }
    function Fi(e, t) {
      return !(
        (!t && Di(e)) ||
        (e >= 2304 && e <= 3583) ||
        (e >= 3840 && e <= 4255) ||
        Ii.Khmer(e)
      );
    }
    function zi(e) {
      for (const t of e) if (Di(t.charCodeAt(0))) return !0;
      return !1;
    }
    class Bi {
      constructor(e, t, i) {
        (this.text = 'string' == typeof e ? e : e.toString()),
          (this.scale = t),
          (this.fontStack = i);
      }
    }
    class Vi {
      constructor(e) {
        this.sections = e;
      }
      static fromString(e) {
        return new Vi([new Bi(e, null, null, null)]);
      }
      static factory(e) {
        return e instanceof Vi ? e : Vi.fromString(e);
      }
      toString() {
        return this.sections.map((e) => e.text).join('');
      }
      containsRTLText() {
        for (const e of this.sections) if (zi(e.text)) return !0;
        return !1;
      }
      serialize() {
        const e = ['format'];
        for (const t of this.sections) {
          e.push(t.text);
          const i = t.fontStack ? ['literal', t.fontStack.split(',')] : null;
          e.push({ 'text-font': i, 'font-scale': t.scale });
        }
        return e;
      }
    }
    class Ui {
      constructor(e) {
        (this.name = e.name), (this.available = e.available);
      }
      toString() {
        return this.name;
      }
      static fromString(e) {
        return e ? new Ui({ name: e, available: !1 }) : null;
      }
      serialize() {
        return ['image', this.name];
      }
    }
    function ki(e, t, i, n) {
      return 'number' == typeof e &&
        e >= 0 &&
        e <= 255 &&
        'number' == typeof t &&
        t >= 0 &&
        t <= 255 &&
        'number' == typeof i &&
        i >= 0 &&
        i <= 255
        ? void 0 === n || ('number' == typeof n && n >= 0 && n <= 1)
          ? null
          : `Invalid rgba value [${[e, t, i, n].join(', ')}]: 'a' must be between 0 and 1.`
        : `Invalid rgba value [${('number' == typeof n ? [e, t, i, n] : [e, t, i]).join(
            ', ',
          )}]: 'r', 'g', and 'b' must be between 0 and 255.`;
    }
    function Gi(e) {
      if (null === e) return !0;
      if ('string' == typeof e) return !0;
      if ('boolean' == typeof e) return !0;
      if ('number' == typeof e) return !0;
      if (e instanceof ai) return !0;
      if (e instanceof Ci) return !0;
      if (e instanceof Vi) return !0;
      if (e instanceof Ui) return !0;
      if (Array.isArray(e)) {
        for (const t of e) if (!Gi(t)) return !1;
        return !0;
      }
      if ('object' == typeof e) {
        for (const t in e) if (!Gi(e[t])) return !1;
        return !0;
      }
      return !1;
    }
    function Hi(e) {
      if (null === e) return di;
      if ('string' == typeof e) return fi;
      if ('boolean' == typeof e) return mi;
      if ('number' == typeof e) return pi;
      if (e instanceof ai) return _i;
      if (e instanceof Ci) return xi;
      if (e instanceof Vi) return vi;
      if (e instanceof Ui) return wi;
      if (Array.isArray(e)) {
        const t = e.length;
        let i;
        for (const t of e) {
          const e = Hi(t);
          if (i) {
            if (i === e) continue;
            i = yi;
            break;
          }
          i = e;
        }
        return Ti(i || yi, t);
      }
      return gi;
    }
    function Yi(e) {
      const t = typeof e;
      return null === e
        ? ''
        : 'string' === t || 'number' === t || 'boolean' === t
        ? String(e)
        : e instanceof ai || e instanceof Vi || e instanceof Ui
        ? e.toString()
        : JSON.stringify(e);
    }
    class qi {
      constructor(e, t) {
        (this.type = e), (this.value = t);
      }
      static parse(e, t) {
        if (2 !== e.length)
          return t.error(
            `'literal' expression requires exactly one argument, but found ${
              e.length - 1
            } instead.`,
          );
        if (!Gi(e[1])) return t.error('invalid value');
        const i = e[1];
        let n = Hi(i);
        const r = t.expectedType;
        return (
          'array' !== n.kind ||
            0 !== n.N ||
            !r ||
            'array' !== r.kind ||
            ('number' == typeof r.N && 0 !== r.N) ||
            (n = r),
          new qi(n, i)
        );
      }
      evaluate() {
        return this.value;
      }
      eachChild() {}
      possibleOutputs() {
        return [this.value];
      }
      serialize() {
        return 'array' === this.type.kind || 'object' === this.type.kind
          ? ['literal', this.value]
          : this.value instanceof ai
          ? ['rgba'].concat(this.value.toArray())
          : this.value instanceof Vi
          ? this.value.serialize()
          : this.value;
      }
    }
    var Xi = qi,
      ji = class {
        constructor(e) {
          (this.name = 'ExpressionEvaluationError'), (this.message = e);
        }
        toJSON() {
          return this.message;
        }
      };
    const Wi = { string: fi, number: pi, boolean: mi, object: gi };
    class $i {
      constructor(e, t) {
        (this.type = e), (this.args = t);
      }
      static parse(e, t) {
        if (e.length < 2) return t.error('Expected at least one argument.');
        const i = Wi[e[0]],
          n = [];
        for (let i = 1; i < e.length; i++) {
          const r = t.parse(e[i], i, yi);
          if (!r) return null;
          n.push(r);
        }
        return new $i(i, n);
      }
      evaluate(e) {
        for (let t = 0; t < this.args.length; t++) {
          const i = this.args[t].evaluate(e);
          if (!Ai(this.type, Hi(i))) return i;
          if (t === this.args.length - 1)
            throw new ji(
              `Expected value to be of type ${bi(this.type)}, but found ${bi(Hi(i))} instead.`,
            );
        }
        return null;
      }
      eachChild(e) {
        this.args.forEach(e);
      }
      possibleOutputs() {
        return [].concat(...this.args.map((e) => e.possibleOutputs()));
      }
      serialize() {
        return [this.type.kind].concat(this.args.map((e) => e.serialize()));
      }
    }
    var Zi = $i;
    const Ki = { string: fi, number: pi, boolean: mi };
    class Qi {
      constructor(e, t) {
        (this.type = e), (this.input = t);
      }
      static parse(e, t) {
        if (e.length < 2 || e.length > 4)
          return t.error(`Expected 1, 2, or 3 arguments, but found ${e.length - 1} instead.`);
        let i, n;
        if (e.length > 2) {
          const n = e[1];
          if ('string' != typeof n || !(n in Ki))
            return t.error(
              'The item type argument of "array" must be one of string, number, boolean',
              1,
            );
          i = Ki[n];
        } else i = yi;
        if (e.length > 3) {
          if ('number' != typeof e[2] || e[2] < 0 || e[2] !== Math.floor(e[2]))
            return t.error('The length argument to "array" must be a positive integer literal', 2);
          n = e[2];
        }
        const r = Ti(i, n),
          o = t.parse(e[e.length - 1], e.length - 1, yi);
        return o ? new Qi(r, o) : null;
      }
      evaluate(e) {
        const t = this.input.evaluate(e);
        if (Ai(this.type, Hi(t)))
          throw new ji(
            `Expected value to be of type ${bi(this.type)}, but found ${bi(Hi(t))} instead.`,
          );
        return t;
      }
      eachChild(e) {
        e(this.input);
      }
      possibleOutputs() {
        return this.input.possibleOutputs();
      }
      serialize() {
        const e = ['array'],
          t = this.type.itemType;
        if ('string' === t.kind || 'number' === t.kind || 'boolean' === t.kind) {
          e.push(t.kind);
          const i = this.type.N;
          'number' == typeof i && e.push(i);
        }
        return e.push(this.input.serialize()), e;
      }
    }
    var Ji = Qi;
    const en = { 'to-number': pi, 'to-color': _i };
    class tn {
      constructor(e, t) {
        (this.type = e), (this.args = t);
      }
      static parse(e, t) {
        if (e.length < 2) return t.error('Expected at least one argument.');
        const i = en[e[0]],
          n = [];
        for (let i = 1; i < e.length; i++) {
          const r = t.parse(e[i], i, yi);
          if (!r) return null;
          n.push(r);
        }
        return new tn(i, n);
      }
      evaluate(e) {
        if ('color' === this.type.kind) {
          let t, i;
          for (const n of this.args)
            if (((t = n.evaluate(e)), (i = null), 'string' == typeof t)) {
              const i = e.parseColor(t);
              if (i) return i;
            } else if (
              Array.isArray(t) &&
              ((i =
                t.length < 3 || t.length > 4
                  ? `Invalid rbga value ${JSON.stringify(
                      t,
                    )}: expected an array containing either three or four numeric values.`
                  : ki(t[0], t[1], t[2], t[3])),
              !i)
            )
              return new ai(t[0] / 255, t[1] / 255, t[2] / 255, t[3]);
          throw new ji(
            i ||
              `Could not parse color from value '${'string' == typeof t ? t : JSON.stringify(t)}'`,
          );
        }
        if ('formatted' === this.type.kind) return Vi.fromString(Yi(this.args[0].evaluate(e)));
        if ('resolvedImage' === this.type.kind) return Ui.fromString(Yi(this.args[0].evaluate(e)));
        {
          let t = null;
          for (const i of this.args) {
            if (((t = i.evaluate(e)), null === t)) continue;
            const n = Number(t);
            if (!isNaN(n)) return n;
          }
          throw new ji(`Could not convert ${JSON.stringify(t)} to number.`);
        }
      }
      eachChild(e) {
        this.args.forEach(e);
      }
      possibleOutputs() {
        return [].concat(...this.args.map((e) => e.possibleOutputs()));
      }
      serialize() {
        const e = [`to-${this.type.kind}`];
        return (
          this.eachChild((t) => {
            e.push(t.serialize());
          }),
          e
        );
      }
    }
    var nn = tn;
    const rn = ['Unknown', 'Point', 'LineString', 'Polygon'];
    var on = class {
      constructor() {
        (this.globals = null),
          (this.feature = null),
          (this.featureState = null),
          (this.formattedSection = null),
          (this._parseColorCache = {}),
          (this.availableImages = null),
          (this.canonical = null);
      }
      id() {
        return this.feature && 'id' in this.feature ? this.feature.id : null;
      }
      geometryType() {
        return this.feature
          ? this.feature._feature
            ? 'number' == typeof this.feature._feature.type
              ? rn[this.feature._feature.type]
              : this.feature._feature.type
            : 'number' == typeof this.feature.type
            ? rn[this.feature.type]
            : this.feature.type
          : null;
      }
      geometry() {
        return this.feature && this.feature.hasOwnProperty('geometry')
          ? this.feature.geometry
          : this.feature &&
            this.feature._feature &&
            this.feature._feature.hasOwnProperty('geometry')
          ? this.feature._feature.geometry
          : null;
      }
      canonicalID() {
        return this.canonical;
      }
      properties() {
        return (this.feature && this.feature.properties) || {};
      }
      parseColor(e) {
        let t = this._parseColorCache[e];
        return t || (t = this._parseColorCache[e] = ai.parse(e)), t;
      }
    };
    class an {
      constructor(e, t, i, n) {
        (this.name = e), (this.type = t), (this._evaluate = i), (this.args = n);
      }
      evaluate(e) {
        return this._evaluate(e, this.args);
      }
      eachChild(e) {
        this.args.forEach(e);
      }
      possibleOutputs() {
        return [void 0];
      }
      serialize() {
        return [this.name].concat(this.args.map((e) => e.serialize()));
      }
      static parse(e, t) {
        const i = e[0],
          n = an.definitions[i];
        if (!n)
          return t.error(
            `Unknown expression "${i}". If you wanted a literal array, use ["literal", [...]].`,
            0,
          );
        const r = Array.isArray(n) ? n[0] : n.type,
          o = Array.isArray(n) ? [[n[1], n[2]]] : n.overloads,
          a = o.filter(([t]) => !Array.isArray(t) || t.length === e.length - 1),
          s = [];
        for (let i = 1; i < e.length; i++) {
          const n = e[i];
          let r;
          if (1 === a.length) {
            const e = a[0][0];
            r = Array.isArray(e) ? e[i - 1] : e.type;
          }
          const o = t.parse(n, 1 + s.length, r);
          if (!o) return null;
          s.push(o);
        }
        let l = null;
        for (const [e, n] of a)
          if (
            ((l = new Rn(t.registry, t.path, null, t.scope)),
            Array.isArray(e) && e.length !== s.length)
          )
            l.error(`Expected ${e.length} arguments, but found ${s.length} instead.`);
          else {
            for (let t = 0; t < s.length; t++) {
              const i = Array.isArray(e) ? e[t] : e.type,
                n = s[t];
              l.concat(t + 1).checkSubtype(i, n.type);
            }
            if (0 === l.errors.length) return new an(i, r, n, s);
          }
        if (1 === a.length) t.errors.push.apply(t.errors, l.errors);
        else {
          const e = (a.length ? a : o)
              .map(([e]) => {
                return (
                  (t = e), Array.isArray(t) ? `(${t.map(bi).join(', ')})` : `(${bi(t.type)}...)`
                );
                var t;
              })
              .join(' | '),
            i = s.map((e) => bi(e.type)).join(', ');
          t.error(`Expected arguments of type ${e}, but found (${i}) instead.`);
        }
        return null;
      }
      static register(e, t) {
        an.definitions = t;
        for (const i in t) e[i] = an;
      }
    }
    var sn = an;
    const ln = 8192;
    function cn(e, t) {
      (e[0] = Math.min(e[0], t[0])),
        (e[1] = Math.min(e[1], t[1])),
        (e[2] = Math.max(e[2], t[0])),
        (e[3] = Math.max(e[3], t[1]));
    }
    function un(e, t) {
      return !(e[0] <= t[0] || e[2] >= t[2] || e[1] <= t[1] || e[3] >= t[3]);
    }
    function hn(e, t) {
      const i = (180 + e[0]) / 360,
        n =
          (180 - (180 / Math.PI) * Math.log(Math.tan(Math.PI / 4 + (e[1] * Math.PI) / 360))) / 360,
        r = Math.pow(2, t.z);
      return [Math.round(i * r * ln), Math.round(n * r * ln)];
    }
    function dn(e, t, i) {
      const n = e[0] - t[0],
        r = e[1] - t[1],
        o = e[0] - i[0],
        a = e[1] - i[1];
      return n * a - o * r == 0 && n * o <= 0 && r * a <= 0;
    }
    function pn(e, t) {
      let i = !1;
      for (let a = 0, s = t.length; a < s; a++) {
        const s = t[a];
        for (let t = 0, a = s.length; t < a - 1; t++) {
          if (dn(e, s[t], s[t + 1])) return !1;
          (r = s[t])[1] > (n = e)[1] != (o = s[t + 1])[1] > n[1] &&
            n[0] < ((o[0] - r[0]) * (n[1] - r[1])) / (o[1] - r[1]) + r[0] &&
            (i = !i);
        }
      }
      var n, r, o;
      return i;
    }
    function fn(e, t) {
      for (let i = 0; i < t.length; i++) if (pn(e, t[i])) return !0;
      return !1;
    }
    function mn(e, t, i, n) {
      const r = n[0] - i[0],
        o = n[1] - i[1],
        a = (e[0] - i[0]) * o - r * (e[1] - i[1]),
        s = (t[0] - i[0]) * o - r * (t[1] - i[1]);
      return (a > 0 && s < 0) || (a < 0 && s > 0);
    }
    function _n(e, t, i) {
      for (const c of i)
        for (let i = 0; i < c.length - 1; ++i)
          if (
            0 !=
              (s = [(a = c[i + 1])[0] - (o = c[i])[0], a[1] - o[1]])[0] *
                (l = [(r = t)[0] - (n = e)[0], r[1] - n[1]])[1] -
                s[1] * l[0] &&
            mn(n, r, o, a) &&
            mn(o, a, n, r)
          )
            return !0;
      var n, r, o, a, s, l;
      return !1;
    }
    function gn(e, t) {
      for (let i = 0; i < e.length; ++i) if (!pn(e[i], t)) return !1;
      for (let i = 0; i < e.length - 1; ++i) if (_n(e[i], e[i + 1], t)) return !1;
      return !0;
    }
    function yn(e, t) {
      for (let i = 0; i < t.length; i++) if (gn(e, t[i])) return !0;
      return !1;
    }
    function xn(e, t, i) {
      const n = [];
      for (let r = 0; r < e.length; r++) {
        const o = [];
        for (let n = 0; n < e[r].length; n++) {
          const a = hn(e[r][n], i);
          cn(t, a), o.push(a);
        }
        n.push(o);
      }
      return n;
    }
    function vn(e, t, i) {
      const n = [];
      for (let r = 0; r < e.length; r++) {
        const o = xn(e[r], t, i);
        n.push(o);
      }
      return n;
    }
    function wn(e, t, i, n) {
      if (e[0] < i[0] || e[0] > i[2]) {
        const t = 0.5 * n;
        let r = e[0] - i[0] > t ? -n : i[0] - e[0] > t ? n : 0;
        0 === r && (r = e[0] - i[2] > t ? -n : i[2] - e[0] > t ? n : 0), (e[0] += r);
      }
      cn(t, e);
    }
    function Tn(e, t, i, n) {
      const r = Math.pow(2, n.z) * ln,
        o = [n.x * ln, n.y * ln],
        a = [];
      for (const n of e)
        if (n.length)
          for (let e = 0; e < n.length; e++) {
            let s;
            (s = n[e].x ? [n[e].x + o[0], n[e].y + o[1]] : [n[e] + o[0], n[e] + o[1]]),
              wn(s, t, i, r),
              a.push(s);
          }
        else
          for (const e of n) {
            const n = [e.x + o[0], e.y + o[1]];
            wn(n, t, i, r), a.push(n);
          }
      return a;
    }
    function bn(e, t, i, n) {
      const r = Math.pow(2, n.z) * ln,
        o = [n.x * ln, n.y * ln],
        a = [];
      for (const i of e) {
        const e = [];
        if (i.length)
          for (let n = 0; n < i.length; n++) {
            const r = [i[n][0] + o[0], i[n][1] + o[1]];
            cn(t, r), e.push(r);
          }
        else
          for (const n of i) {
            const i = [n.x + o[0], n.y + o[1]];
            cn(t, i), e.push(i);
          }
        a.push(e);
      }
      if (t[2] - t[0] <= r / 2) {
        ((s = t)[0] = s[1] = 1 / 0), (s[2] = s[3] = -1 / 0);
        for (const e of a) for (const n of e) wn(n, t, i, r);
      }
      var s;
      return a;
    }
    class Sn {
      constructor(e, t) {
        (this.type = mi), (this.geojson = e), (this.geometries = t);
      }
      static parse(e, t) {
        if (2 !== e.length)
          return t.error(
            `'within' expression requires exactly one argument, but found ${e.length - 1} instead.`,
          );
        if (Gi(e[1])) {
          const t = e[1];
          if ('FeatureCollection' === t.type)
            for (let e = 0; e < t.features.length; ++e) {
              const i = t.features[e].geometry.type;
              if ('Polygon' === i || 'MultiPolygon' === i) return new Sn(t, t.features[e].geometry);
            }
          else if ('Feature' === t.type) {
            const e = t.geometry.type;
            if ('Polygon' === e || 'MultiPolygon' === e) return new Sn(t, t.geometry);
          } else if ('Polygon' === t.type || 'MultiPolygon' === t.type) return new Sn(t, t);
        }
        return t.error(
          "'within' expression requires valid geojson object that contains polygon geometry type.",
        );
      }
      evaluate(e) {
        if (null != e.geometry() && null != e.canonicalID()) {
          if ('Point' === e.geometryType())
            return (function (e, t) {
              const i = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                r = e.canonicalID();
              if ('Polygon' === t.type) {
                const o = xn(t.coordinates, n, r),
                  a = Tn(e.geometry(), i, n, r);
                if (!un(i, n)) return !1;
                for (const e of a) if (!pn(e, o)) return !1;
              }
              if ('MultiPolygon' === t.type) {
                const o = vn(t.coordinates, n, r),
                  a = Tn(e.geometry(), i, n, r);
                if (!un(i, n)) return !1;
                for (const e of a) if (!fn(e, o)) return !1;
              }
              return !0;
            })(e, this.geometries);
          if ('LineString' === e.geometryType())
            return (function (e, t) {
              const i = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                r = e.canonicalID();
              if ('Polygon' === t.type) {
                const o = xn(t.coordinates, n, r),
                  a = bn(e.geometry(), i, n, r);
                if (!un(i, n)) return !1;
                for (const e of a) if (!gn(e, o)) return !1;
              }
              if ('MultiPolygon' === t.type) {
                const o = vn(t.coordinates, n, r),
                  a = bn(e.geometry(), i, n, r);
                if (!un(i, n)) return !1;
                for (const e of a) if (!yn(e, o)) return !1;
              }
              return !0;
            })(e, this.geometries);
        }
        return !1;
      }
      eachChild() {}
      possibleOutputs() {
        return [void 0];
      }
      serialize() {
        return ['within', this.geojson];
      }
    }
    var An = Sn;
    function Pn(e) {
      if (e instanceof sn) {
        if ('get' === e.name && 1 === e.args.length) return !1;
        if ('feature-state' === e.name) return !1;
        if ('has' === e.name && 1 === e.args.length) return !1;
        if ('properties' === e.name || 'geometry-type' === e.name || 'id' === e.name) return !1;
        if (/^filter-/.test(e.name)) return !1;
      }
      if (e instanceof An) return !1;
      let t = !0;
      return (
        e.eachChild((e) => {
          t && !Pn(e) && (t = !1);
        }),
        t
      );
    }
    function En(e) {
      if (e instanceof sn && 'feature-state' === e.name) return !1;
      let t = !0;
      return (
        e.eachChild((e) => {
          t && !En(e) && (t = !1);
        }),
        t
      );
    }
    function Cn(e, t) {
      if (e instanceof sn && t.indexOf(e.name) >= 0) return !1;
      let i = !0;
      return (
        e.eachChild((e) => {
          i && !Cn(e, t) && (i = !1);
        }),
        i
      );
    }
    class Mn {
      constructor(e, t) {
        (this.type = t.type), (this.name = e), (this.boundExpression = t);
      }
      static parse(e, t) {
        if (2 !== e.length || 'string' != typeof e[1])
          return t.error("'var' expression requires exactly one string literal argument.");
        const i = e[1];
        return t.scope.has(i)
          ? new Mn(i, t.scope.get(i))
          : t.error(
              `Unknown variable "${i}". Make sure "${i}" has been bound in an enclosing "let" expression before using it.`,
              1,
            );
      }
      evaluate(e) {
        return this.boundExpression.evaluate(e);
      }
      eachChild() {}
      possibleOutputs() {
        return [void 0];
      }
      serialize() {
        return ['var', this.name];
      }
    }
    var In = Mn;
    class Ln {
      constructor(e, t = [], i, n = new hi(), r = []) {
        (this.registry = e),
          (this.path = t),
          (this.key = t.map((e) => `[${e}]`).join('')),
          (this.scope = n),
          (this.errors = r),
          (this.expectedType = i);
      }
      parse(e, t, i, n, r = {}) {
        return t ? this.concat(t, i, n)._parse(e, r) : this._parse(e, r);
      }
      _parse(e, t) {
        if (
          ((null !== e && 'string' != typeof e && 'boolean' != typeof e && 'number' != typeof e) ||
            (e = ['literal', e]),
          Array.isArray(e))
        ) {
          if (0 === e.length)
            return this.error(
              'Expected an array with at least one element. If you wanted a literal array, use ["literal", []].',
            );
          const i = e[0];
          if ('string' != typeof i)
            return (
              this.error(
                `Expression name must be a string, but found ${typeof i} instead. If you wanted a literal array, use ["literal", [...]].`,
                0,
              ),
              null
            );
          const n = this.registry[i];
          if (n) {
            let i = n.parse(e, this);
            if (!i) return null;
            if (this.expectedType) {
              const e = this.expectedType,
                n = i.type;
              if (
                ('string' !== e.kind &&
                  'number' !== e.kind &&
                  'boolean' !== e.kind &&
                  'object' !== e.kind) ||
                'value' !== n.kind
              )
                if ('array' === e.kind && 'value' === n.kind)
                  t.omitTypeAnnotations || (i = new Ji(e, i));
                else if ('color' !== e.kind || ('value' !== n.kind && 'string' !== n.kind)) {
                  if (this.checkSubtype(this.expectedType, i.type)) return null;
                } else t.omitTypeAnnotations || (i = new nn(e, [i]));
              else t.omitTypeAnnotations || (i = new Zi(e, [i]));
            }
            if (!(i instanceof Xi) && Nn(i)) {
              const e = new on();
              try {
                i = new Xi(i.type, i.evaluate(e));
              } catch (e) {
                return this.error(e.message), null;
              }
            }
            return i;
          }
          return this.error(
            `Unknown expression "${i}". If you wanted a literal array, use ["literal", [...]].`,
            0,
          );
        }
        return this.error(
          void 0 === e
            ? "'undefined' value invalid. Use null instead."
            : 'object' == typeof e
            ? 'Bare objects invalid. Use ["literal", {...}] instead.'
            : `Expected an array, but found ${typeof e} instead.`,
        );
      }
      concat(e, t, i) {
        const n = 'number' == typeof e ? this.path.concat(e) : this.path,
          r = i ? this.scope.concat(i) : this.scope;
        return new Ln(this.registry, n, t || null, r, this.errors);
      }
      error(e, ...t) {
        const i = `${this.key}${t.map((e) => `[${e}]`).join('')}`;
        this.errors.push(new ci(i, e));
      }
      checkSubtype(e, t) {
        const i = Ai(e, t);
        return i && this.error(i), i;
      }
    }
    var Rn = Ln;
    function Nn(e) {
      if (e instanceof In) return Nn(e.boundExpression);
      if (e instanceof sn && 'error' === e.name) return !1;
      if (e instanceof Mi) return !1;
      if (e instanceof An) return !1;
      const t = e instanceof nn || e instanceof Zi || e instanceof Ji;
      let i = !0;
      return (
        e.eachChild((e) => {
          i = t ? i && Nn(e) : i && e instanceof Xi;
        }),
        !!i && Pn(e) && Cn(e, ['zoom', 'heatmap-density', 'line-progress', 'is-supported-script'])
      );
    }
    function On(e, t) {
      let i,
        n,
        r = 0,
        o = e.length - 1,
        a = 0;
      for (; r <= o; ) {
        if (
          ((a = Math.floor((r + o) / 2)), (i = e[a]), (n = e[a + 1]), t === i || (t > i && t < n))
        )
          return a;
        if (i < t) r = a + 1;
        else {
          if (!(i > t)) throw new ji('Input is not a number.');
          o = a - 1;
        }
      }
      return Math.max(a - 1, 0);
    }
    class Dn {
      constructor(e, t, i) {
        (this.type = e), (this.input = t), (this.labels = []), (this.outputs = []);
        for (const [e, t] of i) this.labels.push(e), this.outputs.push(t);
      }
      static parse(e, t) {
        let [, i, ...n] = e;
        if (e.length - 1 < 4)
          return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
        if ((e.length - 1) % 2 != 0) return t.error('Expected an even number of arguments.');
        if (((i = t.parse(i, 1, pi)), !i)) return null;
        const r = [];
        let o = null;
        t.expectedType && 'value' !== t.expectedType.kind && (o = t.expectedType),
          n.unshift(-1 / 0);
        for (let e = 0; e < n.length; e += 2) {
          const i = n[e],
            a = n[e + 1],
            s = e + 1,
            l = e + 2;
          if ('number' != typeof i)
            return t.error(
              'Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.',
              s,
            );
          if (r.length && r[r.length - 1][0] >= i)
            return t.error(
              'Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.',
              s,
            );
          const c = t.parse(a, l, o);
          if (!c) return null;
          (o = o || c.type), r.push([i, c]);
        }
        return new Dn(o, i, r);
      }
      evaluate(e) {
        const t = this.labels,
          i = this.outputs;
        if (1 === t.length) return i[0].evaluate(e);
        const n = this.input.evaluate(e);
        if (n <= t[0]) return i[0].evaluate(e);
        const r = t.length;
        return n >= t[r - 1] ? i[r - 1].evaluate(e) : i[On(t, n)].evaluate(e);
      }
      eachChild(e) {
        e(this.input);
        for (const t of this.outputs) e(t);
      }
      possibleOutputs() {
        return [].concat(...this.outputs.map((e) => e.possibleOutputs()));
      }
      serialize() {
        const e = ['step', this.input.serialize()];
        for (let t = 0; t < this.labels.length; t++)
          t > 0 && e.push(this.labels[t]), e.push(this.outputs[t].serialize());
        return e;
      }
    }
    var Fn = Dn;
    function zn(e, t, i) {
      return e * (1 - i) + t * i;
    }
    var Bn = Object.freeze({
      __proto__: null,
      number: zn,
      color: function (e, t, i) {
        return new ai(zn(e.r, t.r, i), zn(e.g, t.g, i), zn(e.b, t.b, i), zn(e.a, t.a, i));
      },
      array: function (e, t, i) {
        return e.map((e, n) => zn(e, t[n], i));
      },
    });
    class Vn {
      constructor(e, t, i, n) {
        (this.type = e),
          (this.interpolation = t),
          (this.input = i),
          (this.labels = []),
          (this.outputs = []);
        for (const [e, t] of n) this.labels.push(e), this.outputs.push(t);
      }
      static interpolationFactor(e, t, i, n) {
        let r = 0;
        if ('exponential' === e.name) r = Un(t, e.base, i, n);
        else if ('linear' === e.name) r = Un(t, 1, i, n);
        else if ('cubic-bezier' === e.name) {
          const o = e.controlPoints;
          r = new K(o[0], o[1], o[2], o[3]).solve(Un(t, 1, i, n));
        }
        return r;
      }
      static parse(e, t) {
        let [, i, n, ...r] = e;
        if (!Array.isArray(i) || 0 === i.length)
          return t.error('Expected an interpolation type expression.', 1);
        if ('linear' === i[0]) i = { name: 'linear' };
        else if ('exponential' === i[0]) {
          const e = i[1];
          if ('number' != typeof e)
            return t.error('Exponential interpolation requires a numeric base.', 1, 1);
          i = { name: 'exponential', base: e };
        } else {
          if ('cubic-bezier' !== i[0])
            return t.error(`Unknown interpolation type ${String(i[0])}`, 1, 0);
          {
            const e = i.slice(1);
            if (4 !== e.length || e.some((e) => 'number' != typeof e || e < 0 || e > 1))
              return t.error(
                'Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.',
                1,
              );
            i = { name: 'cubic-bezier', controlPoints: e };
          }
        }
        if (e.length - 1 < 4)
          return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
        if ((e.length - 1) % 2 != 0) return t.error('Expected an even number of arguments.');
        if (((n = t.parse(n, 2, pi)), !n)) return null;
        const o = [];
        let a = null;
        t.expectedType && 'value' !== t.expectedType.kind && (a = t.expectedType);
        for (let e = 0; e < r.length; e += 2) {
          const i = r[e],
            n = r[e + 1],
            s = e + 3,
            l = e + 4;
          if ('number' != typeof i)
            return t.error(
              'Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.',
              s,
            );
          if (o.length && o[o.length - 1][0] >= i)
            return t.error(
              'Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.',
              s,
            );
          const c = t.parse(n, l, a);
          if (!c) return null;
          (a = a || c.type), o.push([i, c]);
        }
        return 'number' === a.kind ||
          'color' === a.kind ||
          ('array' === a.kind && 'number' === a.itemType.kind && 'number' == typeof a.N)
          ? new Vn(a, i, n, o)
          : t.error(`Type ${bi(a)} is not interpolatable.`);
      }
      evaluate(e) {
        const t = this.labels,
          i = this.outputs;
        if (1 === t.length) return i[0].evaluate(e);
        const n = this.input.evaluate(e);
        if (n <= t[0]) return i[0].evaluate(e);
        const r = t.length;
        if (n >= t[r - 1]) return i[r - 1].evaluate(e);
        const o = On(t, n),
          a = Vn.interpolationFactor(this.interpolation, n, t[o], t[o + 1]),
          s = i[o].evaluate(e),
          l = i[o + 1].evaluate(e);
        return Bn[this.type.kind.toLowerCase()](s, l, a);
      }
      eachChild(e) {
        e(this.input);
        for (const t of this.outputs) e(t);
      }
      possibleOutputs() {
        return [].concat(...this.outputs.map((e) => e.possibleOutputs()));
      }
      serialize() {
        let e;
        e =
          'linear' === this.interpolation.name
            ? ['linear']
            : 'exponential' === this.interpolation.name
            ? 1 === this.interpolation.base
              ? ['linear']
              : ['exponential', this.interpolation.base]
            : ['cubic-bezier'].concat(this.interpolation.controlPoints);
        const t = ['interpolate', e, this.input.serialize()];
        for (let e = 0; e < this.labels.length; e++)
          t.push(this.labels[e], this.outputs[e].serialize());
        return t;
      }
    }
    function Un(e, t, i, n) {
      const r = n - i,
        o = e - i;
      return 0 === r ? 0 : 1 === t ? o / r : (Math.pow(t, o) - 1) / (Math.pow(t, r) - 1);
    }
    var kn = Vn;
    class Gn {
      constructor(e, t) {
        (this.type = e), (this.args = t);
      }
      static parse(e, t) {
        if (e.length < 2) return t.error('Expectected at least one argument.');
        let i = null;
        const n = t.expectedType;
        n && 'value' !== n.kind && (i = n);
        const r = [];
        for (const n of e.slice(1)) {
          const e = t.parse(n, 1 + r.length, i, void 0, { omitTypeAnnotations: !0 });
          if (!e) return null;
          (i = i || e.type), r.push(e);
        }
        const o = n && r.some((e) => Ai(n, e.type));
        return new Gn(o ? yi : i, r);
      }
      evaluate(e) {
        let t,
          i = null,
          n = 0;
        for (const r of this.args)
          if (
            (n++,
            (i = r.evaluate(e)),
            i &&
              i instanceof Ui &&
              !i.available &&
              (t || (t = i.name), (i = null), n === this.args.length && (i = t)),
            null !== i)
          )
            break;
        return i;
      }
      eachChild(e) {
        this.args.forEach(e);
      }
      possibleOutputs() {
        return [].concat(...this.args.map((e) => e.possibleOutputs()));
      }
      serialize() {
        const e = ['coalesce'];
        return (
          this.eachChild((t) => {
            e.push(t.serialize());
          }),
          e
        );
      }
    }
    var Hn = Gn;
    class Yn {
      constructor(e, t) {
        (this.type = t.type), (this.bindings = [].concat(e)), (this.result = t);
      }
      evaluate(e) {
        return this.result.evaluate(e);
      }
      eachChild(e) {
        for (const t of this.bindings) e(t[1]);
        e(this.result);
      }
      static parse(e, t) {
        if (e.length < 4)
          return t.error(`Expected at least 3 arguments, but found ${e.length - 1} instead.`);
        const i = [];
        for (let n = 1; n < e.length - 1; n += 2) {
          const r = e[n];
          if ('string' != typeof r)
            return t.error(`Expected string, but found ${typeof r} instead.`, n);
          if (/[^a-zA-Z0-9_]/.test(r))
            return t.error("Variable names must contain only alphanumeric characters or '_'.", n);
          const o = t.parse(e[n + 1], n + 1);
          if (!o) return null;
          i.push([r, o]);
        }
        const n = t.parse(e[e.length - 1], e.length - 1, void 0, i);
        return n ? new Yn(i, n) : null;
      }
      possibleOutputs() {
        return this.result.possibleOutputs();
      }
      serialize() {
        const e = ['let'];
        for (const [t, i] of this.bindings) e.push(t, i.serialize());
        return e.push(this.result.serialize()), e;
      }
    }
    var qn = Yn;
    class Xn {
      constructor(e, t, i) {
        (this.type = e), (this.index = t), (this.input = i);
      }
      static parse(e, t) {
        if (3 !== e.length)
          return t.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
        const i = t.parse(e[1], 1, pi),
          n = t.parse(e[2], 2, Ti(t.expectedType || yi));
        return i && n ? new Xn(n.type.itemType, i, n) : null;
      }
      evaluate(e) {
        const t = this.index.evaluate(e),
          i = this.input.evaluate(e);
        if (t < 0) throw new ji(`Array index out of bounds: ${t} < 0.`);
        if (t >= i.length) throw new ji(`Array index out of bounds: ${t} > ${i.length - 1}.`);
        if (t !== Math.floor(t))
          throw new ji(`Array index must be an integer, but found ${t} instead.`);
        return i[t];
      }
      eachChild(e) {
        e(this.index), e(this.input);
      }
      possibleOutputs() {
        return [void 0];
      }
      serialize() {
        return ['at', this.index.serialize(), this.input.serialize()];
      }
    }
    var jn = Xn;
    class Wn {
      constructor(e, t, i, n, r, o) {
        (this.inputType = e),
          (this.type = t),
          (this.input = i),
          (this.cases = n),
          (this.outputs = r),
          (this.otherwise = o);
      }
      static parse(e, t) {
        if (e.length < 5)
          return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
        if (e.length % 2 != 1) return t.error('Expected an even number of arguments.');
        let i, n;
        t.expectedType && 'value' !== t.expectedType.kind && (n = t.expectedType);
        const r = {},
          o = [];
        for (let a = 2; a < e.length - 1; a += 2) {
          let s = e[a];
          const l = e[a + 1];
          Array.isArray(s) || (s = [s]);
          const c = t.concat(a);
          if (0 === s.length) return c.error('Expected at least one branch label.');
          for (const e of s) {
            if ('number' != typeof e && 'string' != typeof e)
              return c.error('Branch labels must be numbers or strings.');
            if ('number' == typeof e && Math.abs(e) > Number.MAX_SAFE_INTEGER)
              return c.error(
                `Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`,
              );
            if ('number' == typeof e && Math.floor(e) !== e)
              return c.error('Numeric branch labels must be integer values.');
            if (i) {
              if (c.checkSubtype(i, Hi(e))) return null;
            } else i = Hi(e);
            if (void 0 !== r[String(e)]) return c.error('Branch labels must be unique.');
            r[String(e)] = o.length;
          }
          const u = t.parse(l, a, n);
          if (!u) return null;
          (n = n || u.type), o.push(u);
        }
        const a = t.parse(e[1], 1, yi);
        if (!a) return null;
        const s = t.parse(e[e.length - 1], e.length - 1, n);
        return s
          ? 'value' !== a.type.kind && t.concat(1).checkSubtype(i, a.type)
            ? null
            : new Wn(i, n, a, r, o, s)
          : null;
      }
      evaluate(e) {
        const t = this.input.evaluate(e);
        return (
          (Hi(t) === this.inputType && this.outputs[this.cases[t]]) ||
          this.otherwise
        ).evaluate(e);
      }
      eachChild(e) {
        e(this.input), this.outputs.forEach(e), e(this.otherwise);
      }
      possibleOutputs() {
        const e = []
          .concat(...this.outputs.map((e) => e.possibleOutputs()))
          .concat(this.otherwise.possibleOutputs());
        return e;
      }
      serialize() {
        const e = ['match', this.input.serialize()],
          t = Object.keys(this.cases).sort(),
          i = [],
          n = {};
        for (const e of t) {
          const t = n[this.cases[e]];
          void 0 === t
            ? ((n[this.cases[e]] = i.length), i.push([this.cases[e], [e]]))
            : i[t][1].push(e);
        }
        const r = (e) => ('number' === this.inputType.kind ? Number(e) : e);
        for (const [t, n] of i) {
          if (1 === n.length) e.push(r(n[0]));
          else {
            const t = n.map(r);
            e.push(t);
          }
          e.push(this.outputs[t].serialize());
        }
        return e.push(this.otherwise.serialize()), e;
      }
    }
    var $n = Wn;
    class Zn {
      constructor(e, t, i) {
        (this.type = e), (this.branches = t), (this.otherwise = i);
      }
      static parse(e, t) {
        if (e.length < 4)
          return t.error(`Expected at least 3 arguments, but found only ${e.length - 1}.`);
        if (e.length % 2 != 0) return t.error('Expected an odd number of arguments.');
        let i;
        t.expectedType && 'value' !== t.expectedType.kind && (i = t.expectedType);
        const n = [];
        for (let r = 1; r < e.length - 1; r += 2) {
          const o = t.parse(e[r], r, mi);
          if (!o) return null;
          const a = t.parse(e[r + 1], r + 1, i);
          if (!a) return null;
          n.push([o, a]), (i = i || a.type);
        }
        const r = t.parse(e[e.length - 1], e.length - 1, i);
        return r ? new Zn(i, n, r) : null;
      }
      evaluate(e) {
        for (const [t, i] of this.branches) if (t.evaluate(e)) return i.evaluate(e);
        return this.otherwise.evaluate(e);
      }
      eachChild(e) {
        for (const [t, i] of this.branches) e(t), e(i);
        e(this.otherwise);
      }
      possibleOutputs() {
        const e = []
          .concat(...this.branches.map(([e, t]) => t.possibleOutputs()))
          .concat(this.otherwise.possibleOutputs());
        return e;
      }
      serialize() {
        const e = ['case'];
        return (
          this.eachChild((t) => {
            e.push(t.serialize());
          }),
          e
        );
      }
    }
    var Kn = Zn;
    class Qn {
      constructor(e) {
        (this.type = wi), (this.input = e);
      }
      static parse(e, t) {
        if (2 !== e.length) return t.error('Expected two arguments.');
        const i = t.parse(e[1], 1, fi);
        return i ? new Qn(i) : t.error('No image name provided.');
      }
      evaluate(e) {
        const t = this.input.evaluate(e),
          i = Ui.fromString(t);
        return i && e.availableImages && (i.available = e.availableImages.indexOf(t) > -1), i;
      }
      eachChild(e) {
        e(this.input);
      }
      possibleOutputs() {
        return [void 0];
      }
      serialize() {
        return ['image', this.input.serialize()];
      }
    }
    class Jn {
      constructor(e, t, i) {
        (this.type = pi), (this.needle = e), (this.haystack = t), (this.fromIndex = i);
      }
      static parse(e, t) {
        if (e.length <= 2 || e.length >= 5)
          return t.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);
        const i = t.parse(e[1], 1, yi),
          n = t.parse(e[2], 2, yi);
        if (!i || !n) return null;
        if (!Pi(i.type, [mi, fi, pi, di, yi]))
          return t.error(
            `Expected first argument to be of type boolean, string, number or null, but found ${bi(
              i.type,
            )} instead`,
          );
        if (4 === e.length) {
          const r = t.parse(e[3], 3, pi);
          return r ? new Jn(i, n, r) : null;
        }
        return new Jn(i, n);
      }
      evaluate(e) {
        const t = this.needle.evaluate(e),
          i = this.haystack.evaluate(e);
        if (!Ei(t, ['boolean', 'string', 'number', 'null']))
          throw new ji(
            `Expected first argument to be of type boolean, string, number or null, but found ${bi(
              Hi(t),
            )} instead.`,
          );
        if (!Ei(i, ['string', 'array']))
          throw new ji(
            `Expected second argument to be of type array or string, but found ${bi(
              Hi(i),
            )} instead.`,
          );
        if (this.fromIndex) {
          const n = this.fromIndex.evaluate(e);
          return i.indexOf(t, n);
        }
        return i.indexOf(t);
      }
      eachChild(e) {
        e(this.needle), e(this.haystack), this.fromIndex && e(this.fromIndex);
      }
      possibleOutputs() {
        return [void 0];
      }
      serialize() {
        if (null != this.fromIndex && void 0 !== this.fromIndex) {
          const e = this.fromIndex.serialize();
          return ['index-of', this.needle.serialize(), this.haystack.serialize(), e];
        }
        return ['index-of', this.needle.serialize(), this.haystack.serialize()];
      }
    }
    var er = Jn;
    function tr(e, t) {
      return '==' === e || '!=' === e
        ? 'boolean' === t.kind ||
            'string' === t.kind ||
            'number' === t.kind ||
            'null' === t.kind ||
            'value' === t.kind
        : 'string' === t.kind || 'number' === t.kind || 'value' === t.kind;
    }
    function ir(e, t, i, n) {
      return 0 === n.compare(t, i);
    }
    function nr(e, t, i) {
      const n = '==' !== e && '!=' !== e;
      return class r {
        constructor(e, t, i) {
          (this.type = mi),
            (this.lhs = e),
            (this.rhs = t),
            (this.collator = i),
            (this.hasUntypedArgument = 'value' === e.type.kind || 'value' === t.type.kind);
        }
        static parse(e, t) {
          if (3 !== e.length && 4 !== e.length) return t.error('Expected two or three arguments.');
          const i = e[0];
          let o = t.parse(e[1], 1, yi);
          if (!o) return null;
          if (!tr(i, o.type))
            return t
              .concat(1)
              .error(`"${i}" comparisons are not supported for type '${bi(o.type)}'.`);
          let a = t.parse(e[2], 2, yi);
          if (!a) return null;
          if (!tr(i, a.type))
            return t
              .concat(2)
              .error(`"${i}" comparisons are not supported for type '${bi(a.type)}'.`);
          if (o.type.kind !== a.type.kind && 'value' !== o.type.kind && 'value' !== a.type.kind)
            return t.error(`Cannot compare types '${bi(o.type)}' and '${bi(a.type)}'.`);
          n &&
            ('value' === o.type.kind && 'value' !== a.type.kind
              ? (o = new Zi(a.type, [o]))
              : 'value' !== o.type.kind && 'value' === a.type.kind && (a = new Zi(o.type, [a])));
          let s = null;
          if (4 === e.length) {
            if (
              'string' !== o.type.kind &&
              'string' !== a.type.kind &&
              'value' !== o.type.kind &&
              'value' !== a.type.kind
            )
              return t.error('Cannot use collator to compare non-string types.');
            if (((s = t.parse(e[3], 3, xi)), !s)) return null;
          }
          return new r(o, a, s);
        }
        evaluate(r) {
          const o = this.lhs.evaluate(r),
            a = this.rhs.evaluate(r);
          if (n && this.hasUntypedArgument) {
            const t = Hi(o),
              i = Hi(a);
            if (t.kind !== i.kind || ('string' !== t.kind && 'number' !== t.kind))
              throw new ji(
                `Expected arguments for "${e}" to be (string, string) or (number, number), but found (${t.kind}, ${i.kind}) instead.`,
              );
          }
          if (this.collator && !n && this.hasUntypedArgument) {
            const e = Hi(o),
              i = Hi(a);
            if ('string' !== e.kind || 'string' !== i.kind) return t(r, o, a);
          }
          return this.collator ? i(r, o, a, this.collator.evaluate(r)) : t(r, o, a);
        }
        eachChild(e) {
          e(this.lhs), e(this.rhs), this.collator && e(this.collator);
        }
        possibleOutputs() {
          return [void 0];
        }
        serialize() {
          const t = [e];
          return (
            this.eachChild((e) => {
              t.push(e.serialize());
            }),
            t
          );
        }
      };
    }
    const rr = nr(
        '==',
        function (e, t, i) {
          return t === i;
        },
        ir,
      ),
      or = nr(
        '!=',
        function (e, t, i) {
          return t !== i;
        },
        function (e, t, i, n) {
          return !ir(0, t, i, n);
        },
      ),
      ar = nr(
        '<',
        function (e, t, i) {
          return t < i;
        },
        function (e, t, i, n) {
          return n.compare(t, i) < 0;
        },
      ),
      sr = nr(
        '>',
        function (e, t, i) {
          return t > i;
        },
        function (e, t, i, n) {
          return n.compare(t, i) > 0;
        },
      ),
      lr = nr(
        '<=',
        function (e, t, i) {
          return t <= i;
        },
        function (e, t, i, n) {
          return n.compare(t, i) <= 0;
        },
      ),
      cr = nr(
        '>=',
        function (e, t, i) {
          return t >= i;
        },
        function (e, t, i, n) {
          return n.compare(t, i) >= 0;
        },
      );
    class ur {
      constructor(e) {
        (this.type = pi), (this.input = e);
      }
      static parse(e, t) {
        if (2 !== e.length)
          return t.error(`Expected 1 argument, but found ${e.length - 1} instead.`);
        const i = t.parse(e[1], 1);
        return i
          ? 'array' !== i.type.kind && 'string' !== i.type.kind && 'value' !== i.type.kind
            ? t.error(`Expected argument of type string or array, but found ${bi(i.type)} instead.`)
            : new ur(i)
          : null;
      }
      evaluate(e) {
        const t = this.input.evaluate(e);
        if ('string' == typeof t) return t.length;
        if (Array.isArray(t)) return t.length;
        throw new ji(
          `Expected value to be of type string or array, but found ${bi(Hi(t))} instead.`,
        );
      }
      eachChild(e) {
        e(this.input);
      }
      possibleOutputs() {
        return [void 0];
      }
      serialize() {
        const e = ['length'];
        return (
          this.eachChild((t) => {
            e.push(t.serialize());
          }),
          e
        );
      }
    }
    var hr = ur;
    class dr {
      constructor(e, t, i, n) {
        (this.type = e), (this.input = t), (this.beginIndex = i), (this.endIndex = n);
      }
      static parse(e, t) {
        if (e.length <= 2 || e.length >= 5)
          return t.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);
        const i = t.parse(e[1], 1, yi),
          n = t.parse(e[2], 2, pi);
        if (!i || !n) return null;
        if (!Pi(i.type, [Ti(yi), fi, yi]))
          return t.error(
            `Expected first argument to be of type array or string, but found ${bi(
              i.type,
            )} instead`,
          );
        if (4 === e.length) {
          const r = t.parse(e[3], 3, pi);
          return r ? new dr(i.type, i, n, r) : null;
        }
        return new dr(i.type, i, n);
      }
      evaluate(e) {
        const t = this.input.evaluate(e),
          i = this.beginIndex.evaluate(e);
        if (!Ei(t, ['string', 'array']))
          throw new ji(
            `Expected first argument to be of type array or string, but found ${bi(
              Hi(t),
            )} instead.`,
          );
        if (this.endIndex) {
          const n = this.endIndex.evaluate(e);
          return t.slice(i, n);
        }
        return t.slice(i);
      }
      eachChild(e) {
        e(this.input), e(this.beginIndex), this.endIndex && e(this.endIndex);
      }
      possibleOutputs() {
        return [void 0];
      }
      serialize() {
        if (null != this.endIndex && void 0 !== this.endIndex) {
          const e = this.endIndex.serialize();
          return ['slice', this.input.serialize(), this.beginIndex.serialize(), e];
        }
        return ['slice', this.input.serialize(), this.beginIndex.serialize()];
      }
    }
    var pr = dr;
    class fr {
      constructor(e, t, i, n, r) {
        (this.type = fi),
          (this.number = e),
          (this.locale = t),
          (this.currency = i),
          (this.minFractionDigits = n),
          (this.maxFractionDigits = r);
      }
      static parse(e, t) {
        if (3 !== e.length) return t.error('Expected two arguments.');
        const i = t.parse(e[1], 1, pi);
        if (!i) return null;
        const n = e[2];
        if ('object' != typeof n || Array.isArray(n))
          return t.error('NumberFormat options argument must be an object.');
        let r = null;
        if (n.locale && ((r = t.parse(n.locale, 1, fi)), !r)) return null;
        let o = null;
        if (n.currency && ((o = t.parse(n.currency, 1, fi)), !o)) return null;
        let a = null;
        if (n['min-fraction-digits'] && ((a = t.parse(n['min-fraction-digits'], 1, pi)), !a))
          return null;
        let s = null;
        return n['max-fraction-digits'] && ((s = t.parse(n['max-fraction-digits'], 1, pi)), !s)
          ? null
          : new fr(i, r, o, a, s);
      }
      evaluate(e) {
        return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e) : [], {
          style: this.currency ? 'currency' : 'decimal',
          currency: this.currency ? this.currency.evaluate(e) : void 0,
          minimumFractionDigits: this.minFractionDigits
            ? this.minFractionDigits.evaluate(e)
            : void 0,
          maximumFractionDigits: this.maxFractionDigits
            ? this.maxFractionDigits.evaluate(e)
            : void 0,
        }).format(this.number.evaluate(e));
      }
      eachChild(e) {
        e(this.number),
          this.locale && e(this.locale),
          this.currency && e(this.currency),
          this.minFractionDigits && e(this.minFractionDigits),
          this.maxFractionDigits && e(this.maxFractionDigits);
      }
      possibleOutputs() {
        return [void 0];
      }
      serialize() {
        const e = {};
        return (
          this.locale && (e.locale = this.locale.serialize()),
          this.currency && (e.currency = this.currency.serialize()),
          this.minFractionDigits && (e['min-fraction-digits'] = this.minFractionDigits.serialize()),
          this.maxFractionDigits && (e['max-fraction-digits'] = this.maxFractionDigits.serialize()),
          ['number-format', this.number.serialize(), e]
        );
      }
    }
    class mr {
      constructor(e, t) {
        (this.type = mi), (this.needle = e), (this.haystack = t);
      }
      static parse(e, t) {
        if (3 !== e.length)
          return t.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
        const i = t.parse(e[1], 1, yi),
          n = t.parse(e[2], 2, yi);
        return i && n
          ? Pi(i.type, [mi, fi, pi, di, yi])
            ? new mr(i, n)
            : t.error(
                `Expected first argument to be of type boolean, string, number or null, but found ${bi(
                  i.type,
                )} instead`,
              )
          : null;
      }
      evaluate(e) {
        const t = this.needle.evaluate(e),
          i = this.haystack.evaluate(e);
        if (!i) return !1;
        if (!Ei(t, ['boolean', 'string', 'number', 'null']))
          throw new ji(
            `Expected first argument to be of type boolean, string, number or null, but found ${bi(
              Hi(t),
            )} instead.`,
          );
        if (!Ei(i, ['string', 'array']))
          throw new ji(
            `Expected second argument to be of type array or string, but found ${bi(
              Hi(i),
            )} instead.`,
          );
        return i.indexOf(t) >= 0;
      }
      eachChild(e) {
        e(this.needle), e(this.haystack);
      }
      possibleOutputs() {
        return [void 0];
      }
      serialize() {
        return ['in', this.needle.serialize(), this.haystack.serialize()];
      }
    }
    var _r = mr;
    class gr {
      constructor(e) {
        (this.type = vi), (this.sections = e);
      }
      static parse(e, t) {
        if (e.length < 2) return t.error('Expected at least one argument.');
        const i = e[1];
        if (!Array.isArray(i) && 'object' == typeof i)
          return t.error('First argument must be an image or text section.');
        const n = [];
        let r = !1;
        for (let i = 1; i <= e.length - 1; ++i) {
          const o = e[i];
          if (r && 'object' == typeof o && !Array.isArray(o)) {
            r = !1;
            let e = null;
            if (o['font-scale'] && ((e = t.parse(o['font-scale'], 1, pi)), !e)) return null;
            let i = null;
            if (o['text-font'] && ((i = t.parse(o['text-font'], 1, Ti(fi))), !i)) return null;
            let a = null;
            if (o['text-color'] && ((a = t.parse(o['text-color'], 1, _i)), !a)) return null;
            const s = n[n.length - 1];
            (s.scale = e), (s.font = i), (s.textColor = a);
          } else {
            const o = t.parse(e[i], 1, yi);
            if (!o) return null;
            const a = o.type.kind;
            if ('string' !== a && 'value' !== a && 'null' !== a && 'resolvedImage' !== a)
              return t.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
            (r = !0), n.push({ content: o, scale: null, font: null, textColor: null });
          }
        }
        return new gr(n);
      }
      evaluate(e) {
        return new Vi(
          this.sections.map((t) => {
            const i = t.content.evaluate(e);
            return Hi(i) === wi
              ? new Bi('', i, null, null, null)
              : new Bi(
                  Yi(i),
                  null,
                  t.scale ? t.scale.evaluate(e) : null,
                  t.font ? t.font.evaluate(e).join(',') : null,
                  t.textColor ? t.textColor.evaluate(e) : null,
                );
          }),
        );
      }
      eachChild(e) {
        for (const t of this.sections)
          e(t.content), t.scale && e(t.scale), t.font && e(t.font), t.textColor && e(t.textColor);
      }
      possibleOutputs() {
        return [void 0];
      }
      serialize() {
        const e = ['format'];
        for (const t of this.sections) {
          e.push(t.content.serialize());
          const i = {};
          t.scale && (i['font-scale'] = t.scale.serialize()),
            t.font && (i['text-font'] = t.font.serialize()),
            t.textColor && (i['text-color'] = t.textColor.serialize()),
            e.push(i);
        }
        return e;
      }
    }
    const yr = {
      '==': rr,
      '!=': or,
      '>': sr,
      '<': ar,
      '>=': cr,
      '<=': lr,
      array: Ji,
      at: jn,
      boolean: Zi,
      case: Kn,
      coalesce: Hn,
      collator: Mi,
      format: gr,
      image: Qn,
      in: _r,
      'index-of': er,
      interpolate: kn,
      'interpolate-hcl': kn,
      'interpolate-lab': kn,
      length: hr,
      let: qn,
      literal: Xi,
      match: $n,
      number: Zi,
      'number-format': fr,
      object: Zi,
      slice: pr,
      step: Fn,
      string: Zi,
      'to-boolean': nn,
      'to-color': nn,
      'to-number': nn,
      'to-string': nn,
      var: In,
      within: An,
    };
    function xr(e, [t, i, n, r]) {
      (t = t.evaluate(e)), (i = i.evaluate(e)), (n = n.evaluate(e));
      const o = r ? r.evaluate(e) : 1,
        a = ki(t, i, n, o);
      if (a) throw new ji(a);
      return new ai((t / 255) * o, (i / 255) * o, (n / 255) * o, o);
    }
    function vr(e, t) {
      return e in t;
    }
    function wr(e, t) {
      const i = t[e];
      return void 0 === i ? null : i;
    }
    function Tr(e) {
      return { type: e };
    }
    sn.register(yr, {
      error: [
        { kind: 'error' },
        [fi],
        (e, [t]) => {
          throw new ji(t.evaluate(e));
        },
      ],
      typeof: [fi, [yi], (e, [t]) => bi(Hi(t.evaluate(e)))],
      'to-rgba': [Ti(pi, 4), [_i], (e, [t]) => t.evaluate(e).toArray()],
      rgb: [_i, [pi, pi, pi], xr],
      rgba: [_i, [pi, pi, pi, pi], xr],
      has: {
        type: mi,
        overloads: [
          [[fi], (e, [t]) => vr(t.evaluate(e), e.properties())],
          [[fi, gi], (e, [t, i]) => vr(t.evaluate(e), i.evaluate(e))],
        ],
      },
      get: {
        type: yi,
        overloads: [
          [[fi], (e, [t]) => wr(t.evaluate(e), e.properties())],
          [[fi, gi], (e, [t, i]) => wr(t.evaluate(e), i.evaluate(e))],
        ],
      },
      'feature-state': [yi, [fi], (e, [t]) => wr(t.evaluate(e), e.featureState || {})],
      properties: [gi, [], (e) => e.properties()],
      'geometry-type': [fi, [], (e) => e.geometryType()],
      id: [yi, [], (e) => e.id()],
      zoom: [pi, [], (e) => e.globals.zoom],
      'heatmap-density': [pi, [], (e) => e.globals.heatmapDensity || 0],
      'line-progress': [pi, [], (e) => e.globals.lineProgress || 0],
      accumulated: [
        yi,
        [],
        (e) => (void 0 === e.globals.accumulated ? null : e.globals.accumulated),
      ],
      '+': [
        pi,
        Tr(pi),
        (e, t) => {
          let i = 0;
          for (const n of t) i += n.evaluate(e);
          return i;
        },
      ],
      '*': [
        pi,
        Tr(pi),
        (e, t) => {
          let i = 1;
          for (const n of t) i *= n.evaluate(e);
          return i;
        },
      ],
      '-': {
        type: pi,
        overloads: [
          [[pi, pi], (e, [t, i]) => t.evaluate(e) - i.evaluate(e)],
          [[pi], (e, [t]) => -t.evaluate(e)],
        ],
      },
      '/': [pi, [pi, pi], (e, [t, i]) => t.evaluate(e) / i.evaluate(e)],
      '%': [pi, [pi, pi], (e, [t, i]) => t.evaluate(e) % i.evaluate(e)],
      ln2: [pi, [], () => Math.LN2],
      pi: [pi, [], () => Math.PI],
      e: [pi, [], () => Math.E],
      '^': [pi, [pi, pi], (e, [t, i]) => Math.pow(t.evaluate(e), i.evaluate(e))],
      sqrt: [pi, [pi], (e, [t]) => Math.sqrt(t.evaluate(e))],
      log10: [pi, [pi], (e, [t]) => Math.log(t.evaluate(e)) / Math.LN10],
      ln: [pi, [pi], (e, [t]) => Math.log(t.evaluate(e))],
      log2: [pi, [pi], (e, [t]) => Math.log(t.evaluate(e)) / Math.LN2],
      sin: [pi, [pi], (e, [t]) => Math.sin(t.evaluate(e))],
      cos: [pi, [pi], (e, [t]) => Math.cos(t.evaluate(e))],
      tan: [pi, [pi], (e, [t]) => Math.tan(t.evaluate(e))],
      asin: [pi, [pi], (e, [t]) => Math.asin(t.evaluate(e))],
      acos: [pi, [pi], (e, [t]) => Math.acos(t.evaluate(e))],
      atan: [pi, [pi], (e, [t]) => Math.atan(t.evaluate(e))],
      min: [pi, Tr(pi), (e, t) => Math.min(...t.map((t) => t.evaluate(e)))],
      max: [pi, Tr(pi), (e, t) => Math.max(...t.map((t) => t.evaluate(e)))],
      abs: [pi, [pi], (e, [t]) => Math.abs(t.evaluate(e))],
      round: [
        pi,
        [pi],
        (e, [t]) => {
          const i = t.evaluate(e);
          return i < 0 ? -Math.round(-i) : Math.round(i);
        },
      ],
      floor: [pi, [pi], (e, [t]) => Math.floor(t.evaluate(e))],
      ceil: [pi, [pi], (e, [t]) => Math.ceil(t.evaluate(e))],
      'filter-==': [mi, [fi, yi], (e, [t, i]) => e.properties()[t.value] === i.value],
      'filter-id-==': [mi, [yi], (e, [t]) => e.id() === t.value],
      'filter-type-==': [mi, [fi], (e, [t]) => e.geometryType() === t.value],
      'filter-<': [
        mi,
        [fi, yi],
        (e, [t, i]) => {
          const n = e.properties()[t.value],
            r = i.value;
          return typeof n == typeof r && n < r;
        },
      ],
      'filter-id-<': [
        mi,
        [yi],
        (e, [t]) => {
          const i = e.id(),
            n = t.value;
          return typeof i == typeof n && i < n;
        },
      ],
      'filter->': [
        mi,
        [fi, yi],
        (e, [t, i]) => {
          const n = e.properties()[t.value],
            r = i.value;
          return typeof n == typeof r && n > r;
        },
      ],
      'filter-id->': [
        mi,
        [yi],
        (e, [t]) => {
          const i = e.id(),
            n = t.value;
          return typeof i == typeof n && i > n;
        },
      ],
      'filter-<=': [
        mi,
        [fi, yi],
        (e, [t, i]) => {
          const n = e.properties()[t.value],
            r = i.value;
          return typeof n == typeof r && n <= r;
        },
      ],
      'filter-id-<=': [
        mi,
        [yi],
        (e, [t]) => {
          const i = e.id(),
            n = t.value;
          return typeof i == typeof n && i <= n;
        },
      ],
      'filter->=': [
        mi,
        [fi, yi],
        (e, [t, i]) => {
          const n = e.properties()[t.value],
            r = i.value;
          return typeof n == typeof r && n >= r;
        },
      ],
      'filter-id->=': [
        mi,
        [yi],
        (e, [t]) => {
          const i = e.id(),
            n = t.value;
          return typeof i == typeof n && i >= n;
        },
      ],
      'filter-like': [mi, [fi, yi], (e, [t, i]) => e.properties()[t.value].indexOf(i.value) >= 0],
      'filter-id-like': [mi, [yi], (e, [t]) => e.id().indexOf(t.value) >= 0],
      'filter-type-like': [mi, [fi], (e, [t]) => e.geometryType().indexOf(t.value) >= 0],
      'filter-start': [mi, [fi, yi], (e, [t, i]) => 0 === e.properties()[t.value].indexOf(i.value)],
      'filter-id-start': [mi, [yi], (e, [t]) => 0 === e.id().indexOf(t.value)],
      'filter-type-start': [mi, [fi], (e, [t]) => 0 === e.geometryType().indexOf(t.value)],
      'filter-end': [
        mi,
        [fi, yi],
        (e, [t, i]) => {
          const n = e.properties()[t.value],
            r = i.value;
          return n.slice(-r.length) === r;
        },
      ],
      'filter-id-end': [
        mi,
        [yi],
        (e, [t]) => {
          const i = e.id(),
            n = t.value;
          return i.slice(-n.length) === n;
        },
      ],
      'filter-type-end': [
        mi,
        [fi],
        (e, [t]) => {
          const i = e.geometryType(),
            n = t.value;
          return i.slice(-n.length) === n;
        },
      ],
      'filter-has': [mi, [yi], (e, [t]) => t.value in e.properties()],
      'filter-has-id': [mi, [], (e) => null !== e.id() && void 0 !== e.id()],
      'filter-type-in': [mi, [Ti(fi)], (e, [t]) => t.value.indexOf(e.geometryType()) >= 0],
      'filter-type-arrin': [mi, [Ti(fi)], (e, [t]) => t.value.indexOf(e.geometryType()) >= 0],
      'filter-arrin': [
        mi,
        [fi, Ti(yi)],
        (e, [t, i]) =>
          (function (e, t, i, n) {
            for (; i <= n; ) {
              if (!e) return !1;
              if (e.indexOf(t[i]) > -1) return !0;
              i += 1;
            }
            return !1;
          })(e.properties()[t.value], i.value, 0, i.value.length - 1),
      ],
      'filter-id-in': [mi, [Ti(yi)], (e, [t]) => t.value.indexOf(e.id()) >= 0],
      'filter-in-small': [
        mi,
        [fi, Ti(yi)],
        (e, [t, i]) => i.value.indexOf(e.properties()[t.value]) >= 0,
      ],
      'filter-in-large': [
        mi,
        [fi, Ti(yi)],
        (e, [t, i]) =>
          (function (e, t, i, n) {
            for (; i <= n; ) {
              const r = (i + n) >> 1;
              if (t[r] === e) return !0;
              t[r] > e ? (n = r - 1) : (i = r + 1);
            }
            return !1;
          })(e.properties()[t.value], i.value, 0, i.value.length - 1),
      ],
      all: {
        type: mi,
        overloads: [
          [[mi, mi], (e, [t, i]) => t.evaluate(e) && i.evaluate(e)],
          [
            Tr(mi),
            (e, t) => {
              for (const i of t) if (!i.evaluate(e)) return !1;
              return !0;
            },
          ],
        ],
      },
      any: {
        type: mi,
        overloads: [
          [[mi, mi], (e, [t, i]) => t.evaluate(e) || i.evaluate(e)],
          [
            Tr(mi),
            (e, t) => {
              for (const i of t) if (i.evaluate(e)) return !0;
              return !1;
            },
          ],
        ],
      },
      '!': [mi, [mi], (e, [t]) => !t.evaluate(e)],
      'is-supported-script': [
        mi,
        [fi],
        (e, [t]) => {
          const i = e.globals && e.globals.isSupportedScript;
          return !i || i(t.evaluate(e));
        },
      ],
      upcase: [fi, [fi], (e, [t]) => t.evaluate(e).toUpperCase()],
      downcase: [fi, [fi], (e, [t]) => t.evaluate(e).toLowerCase()],
      concat: [fi, Tr(yi), (e, t) => t.map((t) => Yi(t.evaluate(e))).join('')],
      'resolved-locale': [fi, [xi], (e, [t]) => t.evaluate(e).resolvedLocale()],
    });
    var br = yr;
    function Sr(e) {
      return { result: 'success', value: e };
    }
    function Ar(e) {
      return { result: 'error', value: e };
    }
    function Pr(e) {
      return (
        'data-driven' === e['property-type'] || 'cross-faded-data-driven' === e['property-type']
      );
    }
    function Er(e) {
      return !!e.expression && e.expression.parameters.indexOf('zoom') > -1;
    }
    function Cr(e) {
      return !!e.expression && e.expression.interpolated;
    }
    const Mr = 0.95047,
      Ir = 1.08883,
      Lr = 4 / 29,
      Rr = 6 / 29,
      Nr = 3 * Rr * Rr,
      Or = Rr * Rr * Rr,
      Dr = Math.PI / 180,
      Fr = 180 / Math.PI;
    function zr(e) {
      return e > Or ? Math.pow(e, 1 / 3) : e / Nr + Lr;
    }
    function Br(e) {
      return e > Rr ? e * e * e : Nr * (e - Lr);
    }
    function Vr(e) {
      return 255 * (e <= 0.0031308 ? 12.92 * e : 1.055 * Math.pow(e, 1 / 2.4) - 0.055);
    }
    function Ur(e) {
      return (e /= 255) <= 0.04045 ? e / 12.92 : Math.pow((e + 0.055) / 1.055, 2.4);
    }
    function kr(e) {
      const t = Ur(e.r),
        i = Ur(e.g),
        n = Ur(e.b),
        r = zr((0.4124564 * t + 0.3575761 * i + 0.1804375 * n) / Mr),
        o = zr((0.2126729 * t + 0.7151522 * i + 0.072175 * n) / 1);
      return {
        l: 116 * o - 16,
        a: 500 * (r - o),
        b: 200 * (o - zr((0.0193339 * t + 0.119192 * i + 0.9503041 * n) / Ir)),
        alpha: e.a,
      };
    }
    function Gr(e) {
      let t = (e.l + 16) / 116,
        i = isNaN(e.a) ? t : t + e.a / 500,
        n = isNaN(e.b) ? t : t - e.b / 200;
      return (
        (t = 1 * Br(t)),
        (i = Mr * Br(i)),
        (n = Ir * Br(n)),
        new ai(
          Vr(3.2404542 * i - 1.5371385 * t - 0.4985314 * n),
          Vr(-0.969266 * i + 1.8760108 * t + 0.041556 * n),
          Vr(0.0556434 * i - 0.2040259 * t + 1.0572252 * n),
          e.alpha,
        )
      );
    }
    function Hr(e, t, i) {
      const n = t - e;
      return e + i * (n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n);
    }
    var Yr = Object.freeze({
      __proto__: null,
      lab: {
        forward: kr,
        reverse: Gr,
        interpolate: function (e, t, i) {
          return {
            l: zn(e.l, t.l, i),
            a: zn(e.a, t.a, i),
            b: zn(e.b, t.b, i),
            alpha: zn(e.alpha, t.alpha, i),
          };
        },
      },
      hcl: {
        forward: function (e) {
          const { l: t, a: i, b: n } = kr(e),
            r = Math.atan2(n, i) * Fr;
          return { h: r < 0 ? r + 360 : r, c: Math.sqrt(i * i + n * n), l: t, alpha: e.a };
        },
        reverse: function (e) {
          const t = e.h * Dr,
            i = e.c;
          return Gr({ l: e.l, a: Math.cos(t) * i, b: Math.sin(t) * i, alpha: e.alpha });
        },
        interpolate: function (e, t, i) {
          return {
            h: Hr(e.h, t.h, i),
            c: zn(e.c, t.c, i),
            l: zn(e.l, t.l, i),
            alpha: zn(e.alpha, t.alpha, i),
          };
        },
      },
    });
    function qr(e) {
      return e instanceof Number
        ? 'number'
        : e instanceof String
        ? 'string'
        : e instanceof Boolean
        ? 'boolean'
        : Array.isArray(e)
        ? 'array'
        : null === e
        ? 'null'
        : typeof e;
    }
    function Xr(e) {
      return 'object' == typeof e && null !== e && !Array.isArray(e);
    }
    function jr(e) {
      return e;
    }
    function Wr(e, t) {
      const i = 'color' === t.type,
        n = e.stops && 'object' == typeof e.stops[0][0],
        r = n || !(n || void 0 !== e.property),
        o = e.type || (Cr(t) ? 'exponential' : 'interval');
      if (
        (i &&
          ((e = si({}, e)).stops && (e.stops = e.stops.map((e) => [e[0], ai.parse(e[1])])),
          (e.default = ai.parse(e.default ? e.default : t.default))),
        e.colorSpace && 'rgb' !== e.colorSpace && !Yr[e.colorSpace])
      )
        throw new Error(`Unknown color space: ${e.colorSpace}`);
      let a, s, l;
      if ('exponential' === o) a = Qr;
      else if ('interval' === o) a = Kr;
      else if ('categorical' === o) {
        (a = Zr), (s = Object.create(null));
        for (const t of e.stops) s[t[0]] = t[1];
        l = typeof e.stops[0][0];
      } else {
        if ('identity' !== o) throw new Error(`Unknown function type "${o}"`);
        a = Jr;
      }
      if (n) {
        const i = {},
          n = [];
        for (let t = 0; t < e.stops.length; t++) {
          const r = e.stops[t],
            o = r[0].zoom;
          void 0 === i[o] &&
            ((i[o] = {
              zoom: o,
              type: e.type,
              property: e.property,
              default: e.default,
              stops: [],
            }),
            n.push(o)),
            i[o].stops.push([r[0].value, r[1]]);
        }
        const r = [];
        for (const e of n) r.push([i[e].zoom, Wr(i[e], t)]);
        return {
          kind: 'composite',
          interpolationFactor: kn.interpolationFactor.bind(void 0, { name: 'linear' }),
          zoomStops: r.map((e) => e[0]),
          evaluate: ({ zoom: i }, n) => Qr({ stops: r, base: e.base }, t, i).evaluate(i, n),
        };
      }
      return r
        ? {
            kind: 'camera',
            interpolationFactor:
              'exponential' === o
                ? kn.interpolationFactor.bind(void 0, {
                    name: 'exponential',
                    base: void 0 !== e.base ? e.base : 1,
                  })
                : () => 0,
            zoomStops: e.stops.map((e) => e[0]),
            evaluate: ({ zoom: i }) => a(e, t, i, s, l),
          }
        : {
            kind: 'source',
            evaluate(i, n) {
              const r = n && n.properties ? n.properties[e.property] : void 0;
              return void 0 === r ? $r(e.default, t.default) : a(e, t, r, s, l);
            },
          };
    }
    function $r(e, t, i) {
      return void 0 !== e ? e : void 0 !== t ? t : void 0 !== i ? i : void 0;
    }
    function Zr(e, t, i, n, r) {
      return $r(typeof i === r ? n[i] : void 0, e.default, t.default);
    }
    function Kr(e, t, i) {
      if ('number' !== qr(i)) return $r(e.default, t.default);
      const n = e.stops.length;
      if (1 === n) return e.stops[0][1];
      if (i <= e.stops[0][0]) return e.stops[0][1];
      if (i >= e.stops[n - 1][0]) return e.stops[n - 1][1];
      const r = eo(e.stops, i);
      return e.stops[r][1];
    }
    function Qr(e, t, i) {
      const n = void 0 !== e.base ? e.base : 1;
      if ('number' !== qr(i)) return $r(e.default, t.default);
      const r = e.stops.length;
      if (1 === r) return e.stops[0][1];
      if (i <= e.stops[0][0]) return e.stops[0][1];
      if (i >= e.stops[r - 1][0]) return e.stops[r - 1][1];
      const o = eo(e.stops, i),
        a = (function (e, t, i, n) {
          const r = n - i,
            o = e - i;
          return 0 === r ? 0 : 1 === t ? o / r : (Math.pow(t, o) - 1) / (Math.pow(t, r) - 1);
        })(i, n, e.stops[o][0], e.stops[o + 1][0]),
        s = e.stops[o][1],
        l = e.stops[o + 1][1];
      let c = Bn[t.type] || jr;
      if (e.colorSpace && 'rgb' !== e.colorSpace) {
        const t = Yr[e.colorSpace];
        c = (e, i) => t.reverse(t.interpolate(t.forward(e), t.forward(i), a));
      }
      return 'function' == typeof s.evaluate
        ? {
            evaluate(...e) {
              const t = s.evaluate.apply(void 0, e),
                i = l.evaluate.apply(void 0, e);
              if (void 0 !== t && void 0 !== i) return c(t, i, a);
            },
          }
        : c(s, l, a);
    }
    function Jr(e, t, i) {
      return (
        'color' === t.type
          ? 'x-color' !== t.units && (i = ai.parse(i))
          : 'formatted' === t.type
          ? (i = Vi.fromString(i.toString()))
          : 'resolvedImage' === t.type
          ? (i = Ui.fromString(i.toString()))
          : qr(i) === t.type || ('enum' === t.type && t.values[i]) || (i = void 0),
        $r(i, e.default, t.default)
      );
    }
    function eo(e, t) {
      let i,
        n,
        r = 0,
        o = e.length - 1,
        a = 0;
      for (; r <= o; ) {
        if (
          ((a = Math.floor((r + o) / 2)),
          (i = e[a][0]),
          (n = e[a + 1][0]),
          t === i || (t > i && t < n))
        )
          return a;
        i < t ? (r = a + 1) : i > t && (o = a - 1);
      }
      return Math.max(a - 1, 0);
    }
    class to {
      constructor(e, t) {
        (this.expression = e),
          (this._warningHistory = {}),
          (this._defaultValue = (function (e) {
            return 'color' === e.type && (Xr(e.default) || Array.isArray(e.default))
              ? new ai(0, 0, 0, 0)
              : 'color' === e.type
              ? ai.parse(e.default) || null
              : void 0 === e.default
              ? null
              : e.default;
          })(t)),
          'enum' === t.type && (this._enumValues = t.values);
      }
      evaluateWithoutErrorHandling(e, t, i) {
        return (
          this._evaluator || (this._evaluator = new on()),
          (this._evaluator.globals = e),
          (this._evaluator.feature = t),
          (this._evaluator.featureState = i),
          this.expression.evaluate(this._evaluator)
        );
      }
      evaluate(e, t, i, n, r, o) {
        this._evaluator || (this._evaluator = new on()),
          (this._evaluator.globals = e),
          (this._evaluator.feature = t),
          (this._evaluator.featureState = i),
          (this._evaluator.canonical = n),
          (this._evaluator.availableImages = r),
          (this._evaluator.formattedSection = o);
        try {
          const e = this.expression.evaluate(this._evaluator);
          if (null == e) return this._defaultValue;
          if (this._enumValues && !(e in this._enumValues))
            throw new ji(
              `Expected value to be one of ${Object.keys(this._enumValues)
                .map((e) => JSON.stringify(e))
                .join(', ')}, but found ${JSON.stringify(e)} instead.`,
            );
          return e;
        } catch (e) {
          return (
            this._warningHistory[e.message] ||
              ((this._warningHistory[e.message] = !0),
              'undefined' != typeof console && console.warn(e.message)),
            this._defaultValue
          );
        }
      }
    }
    function io(e) {
      return Array.isArray(e) && e.length > 0 && 'string' == typeof e[0] && e[0] in br;
    }
    function no(e, t) {
      const i = new Rn(
          br,
          [],
          t
            ? (function (e) {
                const t = { color: _i, string: fi, number: pi, enum: fi, boolean: mi };
                return 'array' === e.type ? Ti(t[e.value] || yi, e.length) : t[e.type] || null;
              })(t)
            : void 0,
        ),
        n = i.parse(
          e,
          void 0,
          void 0,
          void 0,
          t && 'string' === t.type ? { typeAnnotation: 'coerce' } : void 0,
        );
      return n ? Sr(new to(n, t)) : Ar(i.errors);
    }
    class ro {
      constructor(e, t) {
        (this.kind = e),
          (this._styleExpression = t),
          (this.isStateDependent = 'constant' !== e && !En(t.expression));
      }
      evaluateWithoutErrorHandling(e, t, i, n, r, o) {
        return this._styleExpression.evaluateWithoutErrorHandling(e, t, i, n, r, o);
      }
      evaluate(e, t, i, n, r, o) {
        return this._styleExpression.evaluate(e, t, i, n, r, o);
      }
    }
    class oo {
      constructor(e, t, i) {
        (this.kind = e),
          (this.zoomStops = i.labels),
          (this._styleExpression = t),
          (this.isStateDependent = 'camera' !== e && !En(t.expression)),
          i instanceof kn && (this._interpolationType = i.interpolation);
      }
      evaluateWithoutErrorHandling(e, t, i, n, r, o) {
        return this._styleExpression.evaluateWithoutErrorHandling(e, t, i, n, r, o);
      }
      evaluate(e, t, i, n, r, o) {
        return this._styleExpression.evaluate(e, t, i, n, r, o);
      }
      interpolationFactor(e, t, i) {
        return this._interpolationType
          ? kn.interpolationFactor(this._interpolationType, e, t, i)
          : 0;
      }
    }
    function ao(e, t) {
      if ('error' === (e = no(e, t)).result) return e;
      const i = e.value.expression,
        n = Pn(i);
      if (!n && !Pr(t)) return Ar([new ci('', 'data expressions not supported')]);
      const r = Cn(i, ['zoom']);
      if (!r && !Er(t)) return Ar([new ci('', 'zoom expressions not supported')]);
      const o = co(i);
      return o || r
        ? o instanceof ci
          ? Ar([o])
          : o instanceof kn && !Cr(t)
          ? Ar([new ci('', '"interpolate" expressions cannot be used with this property')])
          : Sr(
              o
                ? new oo(n ? 'camera' : 'composite', e.value, o)
                : new ro(n ? 'constant' : 'source', e.value),
            )
        : Ar([
            new ci(
              '',
              '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.',
            ),
          ]);
    }
    class so {
      constructor(e, t) {
        (this._parameters = e),
          (this._specification = t),
          si(this, Wr(this._parameters, this._specification));
      }
      static deserialize(e) {
        return new so(e._parameters, e._specification);
      }
      static serialize(e) {
        return { _parameters: e._parameters, _specification: e._specification };
      }
    }
    function lo(e, t) {
      if (Xr(e)) return new so(e, t);
      if (io(e)) {
        const i = ao(e, t);
        if ('error' === i.result)
          throw new Error(i.value.map((e) => `${e.key}: ${e.message}`).join(', '));
        return i.value;
      }
      {
        let i = e;
        return (
          'string' == typeof e && 'color' === t.type && (i = ai.parse(e)),
          { kind: 'constant', evaluate: () => i }
        );
      }
    }
    function co(e) {
      let t = null;
      if (e instanceof qn) t = co(e.result);
      else if (e instanceof Hn) {
        for (const i of e.args) if (((t = co(i)), t)) break;
      } else
        (e instanceof Fn || e instanceof kn) &&
          e.input instanceof sn &&
          'zoom' === e.input.name &&
          (t = e);
      return (
        t instanceof ci ||
          e.eachChild((e) => {
            const i = co(e);
            i instanceof ci
              ? (t = i)
              : !t && i
              ? (t = new ci(
                  '',
                  '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.',
                ))
              : t &&
                i &&
                t !== i &&
                (t = new ci(
                  '',
                  'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.',
                ));
          }),
        t
      );
    }
    const { ImageData: uo, ImageBitmap: ho } = J,
      po = {};
    function fo(e, t, i = {}) {
      Object.defineProperty(t, '_classRegistryKey', { value: e, writeable: !1 }),
        (po[e] = { klass: t, omit: i.omit || [], shallow: i.shallow || [] });
    }
    fo('Object', Object),
      (Yt.serialize = function (e, t) {
        const i = e.toArrayBuffer();
        return t && t.push(i), i;
      }),
      (Yt.deserialize = function (e) {
        return new Yt(e);
      }),
      fo('Grid', Yt),
      fo('Color', ai),
      fo('Error', Error),
      fo('StylePropertyFunction', so),
      fo('StyleExpression', to, { omit: ['_evaluator'] }),
      fo('ZoomDependentExpression', oo),
      fo('ZoomConstantExpression', ro),
      fo('CompoundExpression', sn, { omit: ['_evaluate'] });
    for (const e in br) br[e]._classRegistryKey || fo(`Expression_${e}`, br[e]);
    function mo(e) {
      return (
        e &&
        'undefined' != typeof ArrayBuffer &&
        (e instanceof ArrayBuffer || (e.constructor && 'ArrayBuffer' === e.constructor.name))
      );
    }
    function _o(e) {
      return ho && e instanceof ho;
    }
    function go(e, t) {
      if (
        null == e ||
        'boolean' == typeof e ||
        'number' == typeof e ||
        'string' == typeof e ||
        e instanceof Boolean ||
        e instanceof Number ||
        e instanceof String ||
        e instanceof Date ||
        e instanceof RegExp ||
        e instanceof J.Blob
      )
        return e;
      if (mo(e) || _o(e)) return t && t.push(e), e;
      if (ArrayBuffer.isView(e)) {
        const i = e;
        return t && t.push(i.buffer), i;
      }
      if (e instanceof uo) return t && t.push(e.data.buffer), e;
      if (Array.isArray(e)) {
        const i = [];
        for (const n of e) i.push(go(n, t));
        return i;
      }
      if ('object' == typeof e) {
        const i = e.constructor,
          n = i._classRegistryKey;
        if (!n) throw new Error("can't serialize object of unregistered class");
        const r = {};
        if (i.serialize) r._serialized = i.serialize(e, t);
        else {
          for (const i in e) {
            if (!e.hasOwnProperty(i)) continue;
            if (po[n].omit.indexOf(i) >= 0) continue;
            const o = e[i];
            r[i] = po[n].shallow.indexOf(i) >= 0 ? o : go(o, t);
          }
          e instanceof Error && (r.message = e.message);
        }
        return { name: n, properties: r };
      }
      throw new Error("can't serialize object of type " + typeof e);
    }
    function yo(e) {
      if (
        null == e ||
        'boolean' == typeof e ||
        'number' == typeof e ||
        'string' == typeof e ||
        e instanceof Boolean ||
        e instanceof Number ||
        e instanceof String ||
        e instanceof Date ||
        e instanceof RegExp ||
        mo(e) ||
        _o(e) ||
        ArrayBuffer.isView(e) ||
        e instanceof uo ||
        e instanceof J.Blob
      )
        return e;
      if (Array.isArray(e)) return e.map((e) => yo(e));
      if ('object' == typeof e) {
        const { name: t, properties: i } = e;
        if (!t) throw new Error("can't deserialize object of anonymous class");
        const { klass: n } = po[t];
        if (!n) throw new Error(`can't deserialize unregistered class ${t}`);
        if (n.deserialize) return n.deserialize(i._serialized);
        const r = Object.create(n.prototype);
        for (const e of Object.keys(i)) r[e] = po[t].shallow.indexOf(e) >= 0 ? i[e] : yo(i[e]);
        return r;
      }
      throw new Error("can't deserialize object of type " + typeof e);
    }
    class xo extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.int16 = new Int16Array(this.arrayBuffer));
      }
      emplaceBack(e, t) {
        const i = this.length;
        this.resize(i + 1);
        const n = 2 * i;
        return (this.int16[n + 0] = e), (this.int16[n + 1] = t), i;
      }
      emplace(e, t, i) {
        const n = 2 * e;
        return (this.int16[n + 0] = t), (this.int16[n + 1] = i), e;
      }
    }
    (xo.prototype.bytesPerElement = 4), fo('StructArrayLayout2i4', xo);
    class vo extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.int16 = new Int16Array(this.arrayBuffer));
      }
      emplaceBack(e, t, i, n) {
        const r = this.length;
        this.resize(r + 1);
        const o = 4 * r;
        return (
          (this.int16[o + 0] = e),
          (this.int16[o + 1] = t),
          (this.int16[o + 2] = i),
          (this.int16[o + 3] = n),
          r
        );
      }
      emplace(e, t, i, n, r) {
        const o = 4 * e;
        return (
          (this.int16[o + 0] = t),
          (this.int16[o + 1] = i),
          (this.int16[o + 2] = n),
          (this.int16[o + 3] = r),
          e
        );
      }
    }
    (vo.prototype.bytesPerElement = 8), fo('StructArrayLayout4i8', vo);
    class wo extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer));
      }
      emplaceBack(e, t, i, n, r) {
        const o = this.length;
        this.resize(o + 1);
        const a = 5 * o;
        return (
          (this.float32[a + 0] = e),
          (this.float32[a + 1] = t),
          (this.float32[a + 2] = i),
          (this.float32[a + 3] = n),
          (this.float32[a + 4] = r),
          o
        );
      }
      emplace(e, t, i, n, r, o) {
        const a = 5 * e;
        return (
          (this.float32[a + 0] = t),
          (this.float32[a + 1] = i),
          (this.float32[a + 2] = n),
          (this.float32[a + 3] = r),
          (this.float32[a + 4] = o),
          e
        );
      }
    }
    (wo.prototype.bytesPerElement = 20), fo('StructArrayLayout5f20', wo);
    class To extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer));
      }
      emplaceBack(e, t, i, n, r, o, a, s) {
        const l = this.length;
        this.resize(l + 1);
        const c = 8 * l;
        return (
          (this.float32[c + 0] = e),
          (this.float32[c + 1] = t),
          (this.float32[c + 2] = i),
          (this.float32[c + 3] = n),
          (this.float32[c + 4] = r),
          (this.float32[c + 5] = o),
          (this.float32[c + 6] = a),
          (this.float32[c + 7] = s),
          l
        );
      }
      emplace(e, t, i, n, r, o, a, s, l) {
        const c = 8 * e;
        return (
          (this.float32[c + 0] = t),
          (this.float32[c + 1] = i),
          (this.float32[c + 2] = n),
          (this.float32[c + 3] = r),
          (this.float32[c + 4] = o),
          (this.float32[c + 5] = a),
          (this.float32[c + 6] = s),
          (this.float32[c + 7] = l),
          e
        );
      }
    }
    (To.prototype.bytesPerElement = 32), fo('StructArrayLayout8f32', To);
    class bo extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer));
      }
      emplaceBack(e, t, i, n, r, o, a, s) {
        const l = this.length;
        this.resize(l + 1);
        const c = 8 * l;
        return (
          (this.float32[c + 0] = e),
          (this.float32[c + 1] = t),
          (this.float32[c + 2] = i),
          (this.float32[c + 3] = n),
          (this.float32[c + 4] = r),
          (this.float32[c + 5] = o),
          (this.float32[c + 6] = a),
          (this.float32[c + 7] = s),
          l
        );
      }
      emplace(e, t, i, n, r, o, a, s, l) {
        const c = 8 * e;
        return (
          (this.float32[c + 0] = t),
          (this.float32[c + 1] = i),
          (this.float32[c + 2] = n),
          (this.float32[c + 3] = r),
          (this.float32[c + 4] = o),
          (this.float32[c + 5] = a),
          (this.float32[c + 6] = s),
          (this.float32[c + 7] = l),
          e
        );
      }
    }
    (bo.prototype.bytesPerElement = 32), fo('StructArrayLayout3f2f3f32', bo);
    class So extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer));
      }
      emplaceBack(e, t, i, n, r, o, a, s, l, c, u, h, d, p, f, m, _, g, y, x, v) {
        const w = this.length;
        this.resize(w + 1);
        const T = 21 * w;
        return (
          (this.float32[T + 0] = e),
          (this.float32[T + 1] = t),
          (this.float32[T + 2] = i),
          (this.float32[T + 3] = n),
          (this.float32[T + 4] = r),
          (this.float32[T + 5] = o),
          (this.float32[T + 6] = a),
          (this.float32[T + 7] = s),
          (this.float32[T + 8] = l),
          (this.float32[T + 9] = c),
          (this.float32[T + 10] = u),
          (this.float32[T + 11] = h),
          (this.float32[T + 12] = d),
          (this.float32[T + 13] = p),
          (this.float32[T + 14] = f),
          (this.float32[T + 15] = m),
          (this.float32[T + 16] = _),
          (this.float32[T + 17] = g),
          (this.float32[T + 18] = y),
          (this.float32[T + 19] = x),
          (this.float32[T + 20] = v),
          w
        );
      }
      emplace(e, t, i, n, r, o, a, s, l, c, u, h, d, p, f, m, _, g, y, x, v, w) {
        const T = 21 * e;
        return (
          (this.float32[T + 0] = t),
          (this.float32[T + 1] = i),
          (this.float32[T + 2] = n),
          (this.float32[T + 3] = r),
          (this.float32[T + 4] = o),
          (this.float32[T + 5] = a),
          (this.float32[T + 6] = s),
          (this.float32[T + 7] = l),
          (this.float32[T + 8] = c),
          (this.float32[T + 9] = u),
          (this.float32[T + 10] = h),
          (this.float32[T + 11] = d),
          (this.float32[T + 12] = p),
          (this.float32[T + 13] = f),
          (this.float32[T + 14] = m),
          (this.float32[T + 15] = _),
          (this.float32[T + 16] = g),
          (this.float32[T + 17] = y),
          (this.float32[T + 18] = x),
          (this.float32[T + 19] = v),
          (this.float32[T + 20] = w),
          e
        );
      }
    }
    (So.prototype.bytesPerElement = 84), fo('StructArrayLayout21f84', So);
    class Ao extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer));
      }
      emplaceBack(e, t, i, n, r, o, a, s, l, c, u, h, d, p, f, m, _, g, y, x, v, w) {
        const T = this.length;
        this.resize(T + 1);
        const b = 22 * T;
        return (
          (this.float32[b + 0] = e),
          (this.float32[b + 1] = t),
          (this.float32[b + 2] = i),
          (this.float32[b + 3] = n),
          (this.float32[b + 4] = r),
          (this.float32[b + 5] = o),
          (this.float32[b + 6] = a),
          (this.float32[b + 7] = s),
          (this.float32[b + 8] = l),
          (this.float32[b + 9] = c),
          (this.float32[b + 10] = u),
          (this.float32[b + 11] = h),
          (this.float32[b + 12] = d),
          (this.float32[b + 13] = p),
          (this.float32[b + 14] = f),
          (this.float32[b + 15] = m),
          (this.float32[b + 16] = _),
          (this.float32[b + 17] = g),
          (this.float32[b + 18] = y),
          (this.float32[b + 19] = x),
          (this.float32[b + 20] = v),
          (this.float32[b + 21] = w),
          T
        );
      }
      emplace(e, t, i, n, r, o, a, s, l, c, u, h, d, p, f, m, _, g, y, x, v, w, T) {
        const b = 22 * e;
        return (
          (this.float32[b + 0] = t),
          (this.float32[b + 1] = i),
          (this.float32[b + 2] = n),
          (this.float32[b + 3] = r),
          (this.float32[b + 4] = o),
          (this.float32[b + 5] = a),
          (this.float32[b + 6] = s),
          (this.float32[b + 7] = l),
          (this.float32[b + 8] = c),
          (this.float32[b + 9] = u),
          (this.float32[b + 10] = h),
          (this.float32[b + 11] = d),
          (this.float32[b + 12] = p),
          (this.float32[b + 13] = f),
          (this.float32[b + 14] = m),
          (this.float32[b + 15] = _),
          (this.float32[b + 16] = g),
          (this.float32[b + 17] = y),
          (this.float32[b + 18] = x),
          (this.float32[b + 19] = v),
          (this.float32[b + 20] = w),
          (this.float32[b + 21] = T),
          e
        );
      }
    }
    (Ao.prototype.bytesPerElement = 88), fo('StructArrayLayout22f88', Ao);
    class Po extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer));
      }
      emplaceBack(e, t, i, n, r, o, a, s, l, c, u, h, d, p, f, m, _, g, y, x, v, w, T, b, S, A, P) {
        const E = this.length;
        this.resize(E + 1);
        const C = 27 * E;
        return (
          (this.float32[C + 0] = e),
          (this.float32[C + 1] = t),
          (this.float32[C + 2] = i),
          (this.float32[C + 3] = n),
          (this.float32[C + 4] = r),
          (this.float32[C + 5] = o),
          (this.float32[C + 6] = a),
          (this.float32[C + 7] = s),
          (this.float32[C + 8] = l),
          (this.float32[C + 9] = c),
          (this.float32[C + 10] = u),
          (this.float32[C + 11] = h),
          (this.float32[C + 12] = d),
          (this.float32[C + 13] = p),
          (this.float32[C + 14] = f),
          (this.float32[C + 15] = m),
          (this.float32[C + 16] = _),
          (this.float32[C + 17] = g),
          (this.float32[C + 18] = y),
          (this.float32[C + 19] = x),
          (this.float32[C + 20] = v),
          (this.float32[C + 21] = w),
          (this.float32[C + 22] = T),
          (this.float32[C + 23] = b),
          (this.float32[C + 24] = S),
          (this.float32[C + 25] = A),
          (this.float32[C + 26] = P),
          E
        );
      }
      emplace(e, t, i, n, r, o, a, s, l, c, u, h, d, p, f, m, _, g, y, x, v, w, T, b, S, A, P, E) {
        const C = 27 * e;
        return (
          (this.float32[C + 0] = t),
          (this.float32[C + 1] = i),
          (this.float32[C + 2] = n),
          (this.float32[C + 3] = r),
          (this.float32[C + 4] = o),
          (this.float32[C + 5] = a),
          (this.float32[C + 6] = s),
          (this.float32[C + 7] = l),
          (this.float32[C + 8] = c),
          (this.float32[C + 9] = u),
          (this.float32[C + 10] = h),
          (this.float32[C + 11] = d),
          (this.float32[C + 12] = p),
          (this.float32[C + 13] = f),
          (this.float32[C + 14] = m),
          (this.float32[C + 15] = _),
          (this.float32[C + 16] = g),
          (this.float32[C + 17] = y),
          (this.float32[C + 18] = x),
          (this.float32[C + 19] = v),
          (this.float32[C + 20] = w),
          (this.float32[C + 21] = T),
          (this.float32[C + 22] = b),
          (this.float32[C + 23] = S),
          (this.float32[C + 24] = A),
          (this.float32[C + 25] = P),
          (this.float32[C + 26] = E),
          e
        );
      }
    }
    (Po.prototype.bytesPerElement = 108), fo('StructArrayLayout27f108', Po);
    class Eo extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer));
      }
      emplaceBack(e, t, i, n, r, o, a, s, l, c, u, h, d, p, f, m, _, g, y, x, v, w, T, b, S) {
        const A = this.length;
        this.resize(A + 1);
        const P = 25 * A;
        return (
          (this.float32[P + 0] = e),
          (this.float32[P + 1] = t),
          (this.float32[P + 2] = i),
          (this.float32[P + 3] = n),
          (this.float32[P + 4] = r),
          (this.float32[P + 5] = o),
          (this.float32[P + 6] = a),
          (this.float32[P + 7] = s),
          (this.float32[P + 8] = l),
          (this.float32[P + 9] = c),
          (this.float32[P + 10] = u),
          (this.float32[P + 11] = h),
          (this.float32[P + 12] = d),
          (this.float32[P + 13] = p),
          (this.float32[P + 14] = f),
          (this.float32[P + 15] = m),
          (this.float32[P + 16] = _),
          (this.float32[P + 17] = g),
          (this.float32[P + 18] = y),
          (this.float32[P + 19] = x),
          (this.float32[P + 20] = v),
          (this.float32[P + 21] = w),
          (this.float32[P + 22] = T),
          (this.float32[P + 23] = b),
          (this.float32[P + 24] = S),
          A
        );
      }
      emplace(e, t, i, n, r, o, a, s, l, c, u, h, d, p, f, m, _, g, y, x, v, w, T, b, S, A) {
        const P = 25 * e;
        return (
          (this.float32[P + 0] = t),
          (this.float32[P + 1] = i),
          (this.float32[P + 2] = n),
          (this.float32[P + 3] = r),
          (this.float32[P + 4] = o),
          (this.float32[P + 5] = a),
          (this.float32[P + 6] = s),
          (this.float32[P + 7] = l),
          (this.float32[P + 8] = c),
          (this.float32[P + 9] = u),
          (this.float32[P + 10] = h),
          (this.float32[P + 11] = d),
          (this.float32[P + 12] = p),
          (this.float32[P + 13] = f),
          (this.float32[P + 14] = m),
          (this.float32[P + 15] = _),
          (this.float32[P + 16] = g),
          (this.float32[P + 17] = y),
          (this.float32[P + 18] = x),
          (this.float32[P + 19] = v),
          (this.float32[P + 20] = w),
          (this.float32[P + 21] = T),
          (this.float32[P + 22] = b),
          (this.float32[P + 23] = S),
          (this.float32[P + 24] = A),
          e
        );
      }
    }
    (Eo.prototype.bytesPerElement = 100), fo('StructArrayLayout25f100', Eo);
    class Co extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer));
      }
      emplaceBack(e, t, i, n, r, o, a, s, l, c, u) {
        const h = this.length;
        this.resize(h + 1);
        const d = 11 * h;
        return (
          (this.float32[d + 0] = e),
          (this.float32[d + 1] = t),
          (this.float32[d + 2] = i),
          (this.float32[d + 3] = n),
          (this.float32[d + 4] = r),
          (this.float32[d + 5] = o),
          (this.float32[d + 6] = a),
          (this.float32[d + 7] = s),
          (this.float32[d + 8] = l),
          (this.float32[d + 9] = c),
          (this.float32[d + 10] = u),
          h
        );
      }
      emplace(e, t, i, n, r, o, a, s, l, c, u, h) {
        const d = 11 * e;
        return (
          (this.float32[d + 0] = t),
          (this.float32[d + 1] = i),
          (this.float32[d + 2] = n),
          (this.float32[d + 3] = r),
          (this.float32[d + 4] = o),
          (this.float32[d + 5] = a),
          (this.float32[d + 6] = s),
          (this.float32[d + 7] = l),
          (this.float32[d + 8] = c),
          (this.float32[d + 9] = u),
          (this.float32[d + 10] = h),
          e
        );
      }
    }
    (Co.prototype.bytesPerElement = 44), fo('StructArrayLayout11f44', Co);
    class Mo extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer));
      }
      emplaceBack(e, t, i, n, r, o) {
        const a = this.length;
        this.resize(a + 1);
        const s = 6 * a;
        return (
          (this.float32[s + 0] = e),
          (this.float32[s + 1] = t),
          (this.float32[s + 2] = i),
          (this.float32[s + 3] = n),
          (this.float32[s + 4] = r),
          (this.float32[s + 5] = o),
          a
        );
      }
      emplace(e, t, i, n, r, o, a) {
        const s = 6 * e;
        return (
          (this.float32[s + 0] = t),
          (this.float32[s + 1] = i),
          (this.float32[s + 2] = n),
          (this.float32[s + 3] = r),
          (this.float32[s + 4] = o),
          (this.float32[s + 5] = a),
          e
        );
      }
    }
    (Mo.prototype.bytesPerElement = 24), fo('StructArrayLayout3f3f24', Mo);
    class Io extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer)),
          (this.int8 = new Int8Array(this.arrayBuffer));
      }
      emplaceBack(e, t, i, n, r) {
        const o = this.length;
        this.resize(o + 1);
        const a = 4 * o,
          s = 16 * o;
        return (
          (this.float32[a + 0] = e),
          (this.float32[a + 1] = t),
          (this.float32[a + 2] = i),
          (this.int8[s + 12] = n),
          (this.int8[s + 13] = r),
          o
        );
      }
      emplace(e, t, i, n, r, o) {
        const a = 4 * e,
          s = 16 * e;
        return (
          (this.float32[a + 0] = t),
          (this.float32[a + 1] = i),
          (this.float32[a + 2] = n),
          (this.int8[s + 12] = r),
          (this.int8[s + 13] = o),
          e
        );
      }
    }
    (Io.prototype.bytesPerElement = 16), fo('StructArrayLayout3f2b16', Io);
    class Lo extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer));
      }
      emplaceBack(e, t, i, n, r, o, a, s, l) {
        const c = this.length;
        this.resize(c + 1);
        const u = 9 * c;
        return (
          (this.float32[u + 0] = e),
          (this.float32[u + 1] = t),
          (this.float32[u + 2] = i),
          (this.float32[u + 3] = n),
          (this.float32[u + 4] = r),
          (this.float32[u + 5] = o),
          (this.float32[u + 6] = a),
          (this.float32[u + 7] = s),
          (this.float32[u + 8] = l),
          c
        );
      }
      emplace(e, t, i, n, r, o, a, s, l, c) {
        const u = 9 * e;
        return (
          (this.float32[u + 0] = t),
          (this.float32[u + 1] = i),
          (this.float32[u + 2] = n),
          (this.float32[u + 3] = r),
          (this.float32[u + 4] = o),
          (this.float32[u + 5] = a),
          (this.float32[u + 6] = s),
          (this.float32[u + 7] = l),
          (this.float32[u + 8] = c),
          e
        );
      }
    }
    (Lo.prototype.bytesPerElement = 36), fo('StructArrayLayout3f3f3f36', Lo);
    class Ro extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer));
      }
      emplaceBack(e, t, i, n, r, o, a, s) {
        const l = this.length;
        this.resize(l + 1);
        const c = 8 * l;
        return (
          (this.float32[c + 0] = e),
          (this.float32[c + 1] = t),
          (this.float32[c + 2] = i),
          (this.float32[c + 3] = n),
          (this.float32[c + 4] = r),
          (this.float32[c + 5] = o),
          (this.float32[c + 6] = a),
          (this.float32[c + 7] = s),
          l
        );
      }
      emplace(e, t, i, n, r, o, a, s, l) {
        const c = 8 * e;
        return (
          (this.float32[c + 0] = t),
          (this.float32[c + 1] = i),
          (this.float32[c + 2] = n),
          (this.float32[c + 3] = r),
          (this.float32[c + 4] = o),
          (this.float32[c + 5] = a),
          (this.float32[c + 6] = s),
          (this.float32[c + 7] = l),
          e
        );
      }
    }
    (Ro.prototype.bytesPerElement = 32), fo('StructArrayLayout1f1f3f3f32', Ro);
    class No extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer));
      }
      emplaceBack(e, t, i, n, r, o, a, s, l, c) {
        const u = this.length;
        this.resize(u + 1);
        const h = 4 * u,
          d = 16 * u;
        return (
          (this.float32[h + 0] = e),
          (this.float32[h + 1] = t),
          (this.uint8[d + 8] = i),
          (this.uint8[d + 9] = n),
          (this.uint8[d + 10] = r),
          (this.uint8[d + 11] = o),
          (this.uint8[d + 12] = a),
          (this.uint8[d + 13] = s),
          (this.uint8[d + 14] = l),
          (this.uint8[d + 15] = c),
          u
        );
      }
      emplace(e, t, i, n, r, o, a, s, l, c, u) {
        const h = 4 * e,
          d = 16 * e;
        return (
          (this.float32[h + 0] = t),
          (this.float32[h + 1] = i),
          (this.uint8[d + 8] = n),
          (this.uint8[d + 9] = r),
          (this.uint8[d + 10] = o),
          (this.uint8[d + 11] = a),
          (this.uint8[d + 12] = s),
          (this.uint8[d + 13] = l),
          (this.uint8[d + 14] = c),
          (this.uint8[d + 15] = u),
          e
        );
      }
    }
    (No.prototype.bytesPerElement = 16), fo('StructArrayLayout2f8ub16', No);
    class Oo extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer)),
          (this.int8 = new Int8Array(this.arrayBuffer));
      }
      emplaceBack(e, t, i, n, r, o, a, s, l, c, u, h) {
        const d = this.length;
        this.resize(d + 1);
        const p = 6 * d,
          f = 24 * d;
        return (
          (this.float32[p + 0] = e),
          (this.float32[p + 1] = t),
          (this.float32[p + 2] = i),
          (this.int8[f + 12] = n),
          (this.int8[f + 13] = r),
          (this.uint8[f + 16] = o),
          (this.uint8[f + 17] = a),
          (this.uint8[f + 18] = s),
          (this.uint8[f + 19] = l),
          (this.uint8[f + 20] = c),
          (this.uint8[f + 21] = u),
          (this.uint8[f + 22] = h),
          d
        );
      }
      emplace(e, t, i, n, r, o, a, s, l, c, u, h, d) {
        const p = 6 * e,
          f = 24 * e;
        return (
          (this.float32[p + 0] = t),
          (this.float32[p + 1] = i),
          (this.float32[p + 2] = n),
          (this.int8[f + 12] = r),
          (this.int8[f + 13] = o),
          (this.uint8[f + 16] = a),
          (this.uint8[f + 17] = s),
          (this.uint8[f + 18] = l),
          (this.uint8[f + 19] = c),
          (this.uint8[f + 20] = u),
          (this.uint8[f + 21] = h),
          (this.uint8[f + 22] = d),
          e
        );
      }
    }
    (Oo.prototype.bytesPerElement = 24), fo('StructArrayLayout3f2b4ub3ub24', Oo);
    class Do extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer));
      }
      emplaceBack(e, t, i, n, r, o, a, s, l, c) {
        const u = this.length;
        this.resize(u + 1);
        const h = 6 * u,
          d = 24 * u;
        return (
          (this.float32[h + 0] = e),
          (this.float32[h + 1] = t),
          (this.float32[h + 2] = i),
          (this.uint8[d + 12] = n),
          (this.uint8[d + 16] = r),
          (this.uint8[d + 17] = o),
          (this.uint8[d + 18] = a),
          (this.uint8[d + 19] = s),
          (this.uint8[d + 20] = l),
          (this.uint8[d + 21] = c),
          u
        );
      }
      emplace(e, t, i, n, r, o, a, s, l, c, u) {
        const h = 6 * e,
          d = 24 * e;
        return (
          (this.float32[h + 0] = t),
          (this.float32[h + 1] = i),
          (this.float32[h + 2] = n),
          (this.uint8[d + 12] = r),
          (this.uint8[d + 16] = o),
          (this.uint8[d + 17] = a),
          (this.uint8[d + 18] = s),
          (this.uint8[d + 19] = l),
          (this.uint8[d + 20] = c),
          (this.uint8[d + 21] = u),
          e
        );
      }
    }
    (Do.prototype.bytesPerElement = 24), fo('StructArrayLayout3f1ub4ub2ub24', Do);
    class Fo extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.uint16 = new Uint16Array(this.arrayBuffer));
      }
      emplaceBack(e, t, i, n, r, o, a, s, l, c) {
        const u = this.length;
        this.resize(u + 1);
        const h = 10 * u;
        return (
          (this.uint16[h + 0] = e),
          (this.uint16[h + 1] = t),
          (this.uint16[h + 2] = i),
          (this.uint16[h + 3] = n),
          (this.uint16[h + 4] = r),
          (this.uint16[h + 5] = o),
          (this.uint16[h + 6] = a),
          (this.uint16[h + 7] = s),
          (this.uint16[h + 8] = l),
          (this.uint16[h + 9] = c),
          u
        );
      }
      emplace(e, t, i, n, r, o, a, s, l, c, u) {
        const h = 10 * e;
        return (
          (this.uint16[h + 0] = t),
          (this.uint16[h + 1] = i),
          (this.uint16[h + 2] = n),
          (this.uint16[h + 3] = r),
          (this.uint16[h + 4] = o),
          (this.uint16[h + 5] = a),
          (this.uint16[h + 6] = s),
          (this.uint16[h + 7] = l),
          (this.uint16[h + 8] = c),
          (this.uint16[h + 9] = u),
          e
        );
      }
    }
    (Fo.prototype.bytesPerElement = 20), fo('StructArrayLayout10ui20', Fo);
    class zo extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer)),
          (this.uint16 = new Uint16Array(this.arrayBuffer));
      }
      emplaceBack(e, t, i, n, r, o, a, s, l, c, u) {
        const h = this.length;
        this.resize(h + 1);
        const d = 7 * h,
          p = 28 * h,
          f = 14 * h;
        return (
          (this.float32[d + 0] = e),
          (this.float32[d + 1] = t),
          (this.float32[d + 2] = i),
          (this.uint8[p + 12] = n),
          (this.uint8[p + 16] = r),
          (this.uint8[p + 17] = o),
          (this.uint8[p + 18] = a),
          (this.uint8[p + 19] = s),
          (this.uint16[f + 10] = l),
          (this.uint16[f + 12] = c),
          (this.uint16[f + 13] = u),
          h
        );
      }
      emplace(e, t, i, n, r, o, a, s, l, c, u, h) {
        const d = 7 * e,
          p = 28 * e,
          f = 14 * e;
        return (
          (this.float32[d + 0] = t),
          (this.float32[d + 1] = i),
          (this.float32[d + 2] = n),
          (this.uint8[p + 12] = r),
          (this.uint8[p + 16] = o),
          (this.uint8[p + 17] = a),
          (this.uint8[p + 18] = s),
          (this.uint8[p + 19] = l),
          (this.uint16[f + 10] = c),
          (this.uint16[f + 12] = u),
          (this.uint16[f + 13] = h),
          e
        );
      }
    }
    (zo.prototype.bytesPerElement = 28), fo('StructArrayLayout3f1ub4ub1ui2ui28', zo);
    class Bo extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer));
      }
      emplaceBack(e, t, i, n, r) {
        const o = this.length;
        this.resize(o + 1);
        const a = 5 * o;
        return (
          (this.float32[a + 0] = e),
          (this.float32[a + 1] = t),
          (this.float32[a + 2] = i),
          (this.float32[a + 3] = n),
          (this.float32[a + 4] = r),
          o
        );
      }
      emplace(e, t, i, n, r, o) {
        const a = 5 * e;
        return (
          (this.float32[a + 0] = t),
          (this.float32[a + 1] = i),
          (this.float32[a + 2] = n),
          (this.float32[a + 3] = r),
          (this.float32[a + 4] = o),
          e
        );
      }
    }
    (Bo.prototype.bytesPerElement = 20), fo('StructArrayLayout3f2f20', Bo);
    class Vo extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer)),
          (this.int8 = new Int8Array(this.arrayBuffer)),
          (this.uint16 = new Uint16Array(this.arrayBuffer));
      }
      emplaceBack(e, t, i, n, r, o, a, s, l, c) {
        const u = this.length;
        this.resize(u + 1);
        const h = 6 * u,
          d = 24 * u,
          p = 12 * u;
        return (
          (this.float32[h + 0] = e),
          (this.float32[h + 1] = t),
          (this.float32[h + 2] = i),
          (this.int8[d + 12] = n),
          (this.int8[d + 13] = r),
          (this.uint8[d + 16] = o),
          (this.uint8[d + 17] = a),
          (this.uint8[d + 18] = s),
          (this.uint8[d + 19] = l),
          (this.uint16[p + 10] = c),
          u
        );
      }
      emplace(e, t, i, n, r, o, a, s, l, c, u) {
        const h = 6 * e,
          d = 24 * e,
          p = 12 * e;
        return (
          (this.float32[h + 0] = t),
          (this.float32[h + 1] = i),
          (this.float32[h + 2] = n),
          (this.int8[d + 12] = r),
          (this.int8[d + 13] = o),
          (this.uint8[d + 16] = a),
          (this.uint8[d + 17] = s),
          (this.uint8[d + 18] = l),
          (this.uint8[d + 19] = c),
          (this.uint16[p + 10] = u),
          e
        );
      }
    }
    (Vo.prototype.bytesPerElement = 24), fo('StructArrayLayout3f2b4ub1ui24', Vo);
    class Uo extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer));
      }
      emplaceBack(e, t, i) {
        const n = this.length;
        this.resize(n + 1);
        const r = 3 * n;
        return (this.float32[r + 0] = e), (this.float32[r + 1] = t), (this.float32[r + 2] = i), n;
      }
      emplace(e, t, i, n) {
        const r = 3 * e;
        return (this.float32[r + 0] = t), (this.float32[r + 1] = i), (this.float32[r + 2] = n), e;
      }
    }
    (Uo.prototype.bytesPerElement = 12), fo('StructArrayLayout1f1f1f12', Uo);
    class ko extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer)),
          (this.int16 = new Int16Array(this.arrayBuffer));
      }
      emplaceBack(e, t, i, n, r) {
        const o = this.length;
        this.resize(o + 1);
        const a = 4 * o,
          s = 8 * o;
        return (
          (this.float32[a + 0] = e),
          (this.float32[a + 1] = t),
          (this.float32[a + 2] = i),
          (this.int16[s + 6] = n),
          (this.int16[s + 7] = r),
          o
        );
      }
      emplace(e, t, i, n, r, o) {
        const a = 4 * e,
          s = 8 * e;
        return (
          (this.float32[a + 0] = t),
          (this.float32[a + 1] = i),
          (this.float32[a + 2] = n),
          (this.int16[s + 6] = r),
          (this.int16[s + 7] = o),
          e
        );
      }
    }
    (ko.prototype.bytesPerElement = 16), fo('StructArrayLayout3f2i16', ko);
    class Go extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer));
      }
      emplaceBack(e, t, i) {
        const n = this.length;
        this.resize(n + 1);
        const r = 3 * n;
        return (this.float32[r + 0] = e), (this.float32[r + 1] = t), (this.float32[r + 2] = i), n;
      }
      emplace(e, t, i, n) {
        const r = 3 * e;
        return (this.float32[r + 0] = t), (this.float32[r + 1] = i), (this.float32[r + 2] = n), e;
      }
    }
    (Go.prototype.bytesPerElement = 12), fo('StructArrayLayout3f12', Go);
    class Ho extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer));
      }
      emplaceBack(e, t) {
        const i = this.length;
        this.resize(i + 1);
        const n = 2 * i;
        return (this.float32[n + 0] = e), (this.float32[n + 1] = t), i;
      }
      emplace(e, t, i) {
        const n = 2 * e;
        return (this.float32[n + 0] = t), (this.float32[n + 1] = i), e;
      }
    }
    (Ho.prototype.bytesPerElement = 8), fo('StructArrayLayout2f8', Ho);
    class Yo extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.uint32 = new Uint32Array(this.arrayBuffer));
      }
      emplaceBack(e) {
        const t = this.length;
        return this.resize(t + 1), (this.uint32[1 * t + 0] = e), t;
      }
      emplace(e, t) {
        return (this.uint32[1 * e + 0] = t), e;
      }
    }
    (Yo.prototype.bytesPerElement = 4), fo('StructArrayLayout1ul4', Yo);
    class qo extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.int16 = new Int16Array(this.arrayBuffer)),
          (this.uint32 = new Uint32Array(this.arrayBuffer)),
          (this.uint16 = new Uint16Array(this.arrayBuffer));
      }
      emplaceBack(e, t, i, n, r, o, a, s, l, c, u) {
        const h = this.length;
        this.resize(h + 1);
        const d = 12 * h,
          p = 6 * h;
        return (
          (this.int16[d + 0] = e),
          (this.int16[d + 1] = t),
          (this.int16[d + 2] = i),
          (this.int16[d + 3] = n),
          (this.int16[d + 4] = r),
          (this.int16[d + 5] = o),
          (this.uint32[p + 3] = a),
          (this.uint16[d + 8] = s),
          (this.uint16[d + 9] = l),
          (this.int16[d + 10] = c),
          (this.int16[d + 11] = u),
          h
        );
      }
      emplace(e, t, i, n, r, o, a, s, l, c, u, h) {
        const d = 12 * e,
          p = 6 * e;
        return (
          (this.int16[d + 0] = t),
          (this.int16[d + 1] = i),
          (this.int16[d + 2] = n),
          (this.int16[d + 3] = r),
          (this.int16[d + 4] = o),
          (this.int16[d + 5] = a),
          (this.uint32[p + 3] = s),
          (this.uint16[d + 8] = l),
          (this.uint16[d + 9] = c),
          (this.int16[d + 10] = u),
          (this.int16[d + 11] = h),
          e
        );
      }
    }
    (qo.prototype.bytesPerElement = 24), fo('StructArrayLayout6i1ul2ui2i24', qo);
    class Xo extends kt {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer);
      }
      emplaceBack(e, t) {
        const i = this.length;
        this.resize(i + 1);
        const n = 4 * i;
        return (this.uint8[n + 0] = e), (this.uint8[n + 1] = t), i;
      }
      emplace(e, t, i) {
        const n = 4 * e;
        return (this.uint8[n + 0] = t), (this.uint8[n + 1] = i), e;
      }
    }
    (Xo.prototype.bytesPerElement = 4), fo('StructArrayLayout2ub4', Xo);
    class jo extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.int16 = new Int16Array(this.arrayBuffer)),
          (this.uint16 = new Uint16Array(this.arrayBuffer)),
          (this.uint32 = new Uint32Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer));
      }
      emplaceBack(e, t, i, n, r, o, a, s, l, c, u, h, d, p) {
        const f = this.length;
        this.resize(f + 1);
        const m = 20 * f,
          _ = 10 * f,
          g = 40 * f;
        return (
          (this.int16[m + 0] = e),
          (this.int16[m + 1] = t),
          (this.uint16[m + 2] = i),
          (this.uint16[m + 3] = n),
          (this.uint32[_ + 2] = r),
          (this.uint32[_ + 3] = o),
          (this.uint32[_ + 4] = a),
          (this.uint16[m + 10] = s),
          (this.uint16[m + 11] = l),
          (this.uint16[m + 12] = c),
          (this.float32[_ + 7] = u),
          (this.float32[_ + 8] = h),
          (this.uint8[g + 36] = d),
          (this.uint8[g + 37] = p),
          f
        );
      }
      emplace(e, t, i, n, r, o, a, s, l, c, u, h, d, p, f) {
        const m = 20 * e,
          _ = 10 * e,
          g = 40 * e;
        return (
          (this.int16[m + 0] = t),
          (this.int16[m + 1] = i),
          (this.uint16[m + 2] = n),
          (this.uint16[m + 3] = r),
          (this.uint32[_ + 2] = o),
          (this.uint32[_ + 3] = a),
          (this.uint32[_ + 4] = s),
          (this.uint16[m + 10] = l),
          (this.uint16[m + 11] = c),
          (this.uint16[m + 12] = u),
          (this.float32[_ + 7] = h),
          (this.float32[_ + 8] = d),
          (this.uint8[g + 36] = p),
          (this.uint8[g + 37] = f),
          e
        );
      }
    }
    (jo.prototype.bytesPerElement = 40), fo('StructArrayLayout2i2ui3ul3ui2f2ub40', jo);
    class Wo extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer));
      }
      emplaceBack(e) {
        const t = this.length;
        return this.resize(t + 1), (this.float32[1 * t + 0] = e), t;
      }
      emplace(e, t) {
        return (this.float32[1 * e + 0] = t), e;
      }
    }
    (Wo.prototype.bytesPerElement = 4), fo('StructArrayLayout1f4', Wo);
    class $o extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.int16 = new Int16Array(this.arrayBuffer));
      }
      emplaceBack(e, t, i) {
        const n = this.length;
        this.resize(n + 1);
        const r = 3 * n;
        return (this.int16[r + 0] = e), (this.int16[r + 1] = t), (this.int16[r + 2] = i), n;
      }
      emplace(e, t, i, n) {
        const r = 3 * e;
        return (this.int16[r + 0] = t), (this.int16[r + 1] = i), (this.int16[r + 2] = n), e;
      }
    }
    ($o.prototype.bytesPerElement = 6), fo('StructArrayLayout3i6', $o);
    class Zo extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer)),
          (this.int16 = new Int16Array(this.arrayBuffer)),
          (this.uint16 = new Uint16Array(this.arrayBuffer));
      }
      emplaceBack(e, t, i, n, r, o, a, s, l) {
        const c = this.length;
        this.resize(c + 1);
        const u = 6 * c,
          h = 12 * c;
        return (
          (this.float32[u + 0] = e),
          (this.float32[u + 1] = t),
          (this.float32[u + 2] = i),
          (this.int16[h + 6] = n),
          (this.int16[h + 7] = r),
          (this.uint16[h + 8] = o),
          (this.uint16[h + 9] = a),
          (this.uint16[h + 10] = s),
          (this.uint16[h + 11] = l),
          c
        );
      }
      emplace(e, t, i, n, r, o, a, s, l, c) {
        const u = 6 * e,
          h = 12 * e;
        return (
          (this.float32[u + 0] = t),
          (this.float32[u + 1] = i),
          (this.float32[u + 2] = n),
          (this.int16[h + 6] = r),
          (this.int16[h + 7] = o),
          (this.uint16[h + 8] = a),
          (this.uint16[h + 9] = s),
          (this.uint16[h + 10] = l),
          (this.uint16[h + 11] = c),
          e
        );
      }
    }
    (Zo.prototype.bytesPerElement = 24), fo('StructArrayLayout3f2i4ui24', Zo);
    class Ko extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer)),
          (this.int16 = new Int16Array(this.arrayBuffer));
      }
      emplaceBack(e, t, i, n, r, o, a) {
        const s = this.length;
        this.resize(s + 1);
        const l = 5 * s,
          c = 10 * s;
        return (
          (this.float32[l + 0] = e),
          (this.float32[l + 1] = t),
          (this.float32[l + 2] = i),
          (this.int16[c + 6] = n),
          (this.int16[c + 7] = r),
          (this.int16[c + 8] = o),
          (this.int16[c + 9] = a),
          s
        );
      }
      emplace(e, t, i, n, r, o, a, s) {
        const l = 5 * e,
          c = 10 * e;
        return (
          (this.float32[l + 0] = t),
          (this.float32[l + 1] = i),
          (this.float32[l + 2] = n),
          (this.int16[c + 6] = r),
          (this.int16[c + 7] = o),
          (this.int16[c + 8] = a),
          (this.int16[c + 9] = s),
          e
        );
      }
    }
    (Ko.prototype.bytesPerElement = 20), fo('StructArrayLayout3f2i2i20', Ko);
    class Qo extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer)),
          (this.int16 = new Int16Array(this.arrayBuffer)),
          (this.uint16 = new Uint16Array(this.arrayBuffer));
      }
      emplaceBack(e, t, i, n, r, o, a, s, l, c, u, h) {
        const d = this.length;
        this.resize(d + 1);
        const p = 8 * d,
          f = 16 * d;
        return (
          (this.float32[p + 0] = e),
          (this.float32[p + 1] = t),
          (this.float32[p + 2] = i),
          (this.int16[f + 6] = n),
          (this.int16[f + 7] = r),
          (this.uint16[f + 8] = o),
          (this.uint16[f + 9] = a),
          (this.uint16[f + 10] = s),
          (this.uint16[f + 11] = l),
          (this.uint16[f + 12] = c),
          (this.uint16[f + 13] = u),
          (this.uint16[f + 14] = h),
          d
        );
      }
      emplace(e, t, i, n, r, o, a, s, l, c, u, h, d) {
        const p = 8 * e,
          f = 16 * e;
        return (
          (this.float32[p + 0] = t),
          (this.float32[p + 1] = i),
          (this.float32[p + 2] = n),
          (this.int16[f + 6] = r),
          (this.int16[f + 7] = o),
          (this.uint16[f + 8] = a),
          (this.uint16[f + 9] = s),
          (this.uint16[f + 10] = l),
          (this.uint16[f + 11] = c),
          (this.uint16[f + 12] = u),
          (this.uint16[f + 13] = h),
          (this.uint16[f + 14] = d),
          e
        );
      }
    }
    (Qo.prototype.bytesPerElement = 32), fo('StructArrayLayout3f2i7ui32', Qo);
    class Jo extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.uint32 = new Uint32Array(this.arrayBuffer)),
          (this.uint16 = new Uint16Array(this.arrayBuffer));
      }
      emplaceBack(e, t, i) {
        const n = this.length;
        this.resize(n + 1);
        const r = 4 * n;
        return (this.uint32[2 * n + 0] = e), (this.uint16[r + 2] = t), (this.uint16[r + 3] = i), n;
      }
      emplace(e, t, i, n) {
        const r = 4 * e;
        return (this.uint32[2 * e + 0] = t), (this.uint16[r + 2] = i), (this.uint16[r + 3] = n), e;
      }
    }
    (Jo.prototype.bytesPerElement = 8), fo('StructArrayLayout1ul2ui8', Jo);
    class ea extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.uint16 = new Uint16Array(this.arrayBuffer));
      }
      emplaceBack(e, t, i) {
        const n = this.length;
        this.resize(n + 1);
        const r = 3 * n;
        return (this.uint16[r + 0] = e), (this.uint16[r + 1] = t), (this.uint16[r + 2] = i), n;
      }
      emplace(e, t, i, n) {
        const r = 3 * e;
        return (this.uint16[r + 0] = t), (this.uint16[r + 1] = i), (this.uint16[r + 2] = n), e;
      }
    }
    (ea.prototype.bytesPerElement = 6), fo('StructArrayLayout3ui6', ea);
    class ta extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.uint32 = new Uint32Array(this.arrayBuffer));
      }
      emplaceBack(e, t, i) {
        const n = this.length;
        this.resize(n + 1);
        const r = 3 * n;
        return (this.uint32[r + 0] = e), (this.uint32[r + 1] = t), (this.uint32[r + 2] = i), n;
      }
      emplace(e, t, i, n) {
        const r = 3 * e;
        return (this.uint32[r + 0] = t), (this.uint32[r + 1] = i), (this.uint32[r + 2] = n), e;
      }
    }
    (ta.prototype.bytesPerElement = 12), fo('StructArrayLayout3ul12', ta);
    class ia extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.uint16 = new Uint16Array(this.arrayBuffer));
      }
      emplaceBack(e, t) {
        const i = this.length;
        this.resize(i + 1);
        const n = 2 * i;
        return (this.uint16[n + 0] = e), (this.uint16[n + 1] = t), i;
      }
      emplace(e, t, i) {
        const n = 2 * e;
        return (this.uint16[n + 0] = t), (this.uint16[n + 1] = i), e;
      }
    }
    (ia.prototype.bytesPerElement = 4), fo('StructArrayLayout2ui4', ia);
    class na extends kt {
      _refreshViews() {
        (this.uint8 = new Uint8Array(this.arrayBuffer)),
          (this.float32 = new Float32Array(this.arrayBuffer));
      }
      emplaceBack(e, t, i, n) {
        const r = this.length;
        this.resize(r + 1);
        const o = 4 * r;
        return (
          (this.float32[o + 0] = e),
          (this.float32[o + 1] = t),
          (this.float32[o + 2] = i),
          (this.float32[o + 3] = n),
          r
        );
      }
      emplace(e, t, i, n, r) {
        const o = 4 * e;
        return (
          (this.float32[o + 0] = t),
          (this.float32[o + 1] = i),
          (this.float32[o + 2] = n),
          (this.float32[o + 3] = r),
          e
        );
      }
    }
    (na.prototype.bytesPerElement = 16), fo('StructArrayLayout4f16', na);
    class ra extends Ut {
      get anchorPointX() {
        return this._structArray.int16[this._pos2 + 0];
      }
      set anchorPointX(e) {
        this._structArray.int16[this._pos2 + 0] = e;
      }
      get anchorPointY() {
        return this._structArray.int16[this._pos2 + 1];
      }
      set anchorPointY(e) {
        this._structArray.int16[this._pos2 + 1] = e;
      }
      get x1() {
        return this._structArray.int16[this._pos2 + 2];
      }
      set x1(e) {
        this._structArray.int16[this._pos2 + 2] = e;
      }
      get y1() {
        return this._structArray.int16[this._pos2 + 3];
      }
      set y1(e) {
        this._structArray.int16[this._pos2 + 3] = e;
      }
      get x2() {
        return this._structArray.int16[this._pos2 + 4];
      }
      set x2(e) {
        this._structArray.int16[this._pos2 + 4] = e;
      }
      get y2() {
        return this._structArray.int16[this._pos2 + 5];
      }
      set y2(e) {
        this._structArray.int16[this._pos2 + 5] = e;
      }
      get featureIndex() {
        return this._structArray.uint32[this._pos4 + 3];
      }
      set featureIndex(e) {
        this._structArray.uint32[this._pos4 + 3] = e;
      }
      get sourceLayerIndex() {
        return this._structArray.uint16[this._pos2 + 8];
      }
      set sourceLayerIndex(e) {
        this._structArray.uint16[this._pos2 + 8] = e;
      }
      get bucketIndex() {
        return this._structArray.uint16[this._pos2 + 9];
      }
      set bucketIndex(e) {
        this._structArray.uint16[this._pos2 + 9] = e;
      }
      get radius() {
        return this._structArray.int16[this._pos2 + 10];
      }
      set radius(e) {
        this._structArray.int16[this._pos2 + 10] = e;
      }
      get signedDistanceFromAnchor() {
        return this._structArray.int16[this._pos2 + 11];
      }
      set signedDistanceFromAnchor(e) {
        this._structArray.int16[this._pos2 + 11] = e;
      }
      get anchorPoint() {
        return new te(this.anchorPointX, this.anchorPointY);
      }
    }
    ra.prototype.size = 24;
    class oa extends qo {
      get(e) {
        return new ra(this, e);
      }
    }
    fo('CollisionBoxArray', oa);
    class aa extends Ut {
      get anchorX() {
        return this._structArray.int16[this._pos2 + 0];
      }
      set anchorX(e) {
        this._structArray.int16[this._pos2 + 0] = e;
      }
      get anchorY() {
        return this._structArray.int16[this._pos2 + 1];
      }
      set anchorY(e) {
        this._structArray.int16[this._pos2 + 1] = e;
      }
      get glyphStartIndex() {
        return this._structArray.uint16[this._pos2 + 2];
      }
      set glyphStartIndex(e) {
        this._structArray.uint16[this._pos2 + 2] = e;
      }
      get numGlyphs() {
        return this._structArray.uint16[this._pos2 + 3];
      }
      set numGlyphs(e) {
        this._structArray.uint16[this._pos2 + 3] = e;
      }
      get vertexStartIndex() {
        return this._structArray.uint32[this._pos4 + 2];
      }
      set vertexStartIndex(e) {
        this._structArray.uint32[this._pos4 + 2] = e;
      }
      get lineStartIndex() {
        return this._structArray.uint32[this._pos4 + 3];
      }
      set lineStartIndex(e) {
        this._structArray.uint32[this._pos4 + 3] = e;
      }
      get lineLength() {
        return this._structArray.uint32[this._pos4 + 4];
      }
      set lineLength(e) {
        this._structArray.uint32[this._pos4 + 4] = e;
      }
      get segment() {
        return this._structArray.uint16[this._pos2 + 10];
      }
      set segment(e) {
        this._structArray.uint16[this._pos2 + 10] = e;
      }
      get lowerSize() {
        return this._structArray.uint16[this._pos2 + 11];
      }
      set lowerSize(e) {
        this._structArray.uint16[this._pos2 + 11] = e;
      }
      get upperSize() {
        return this._structArray.uint16[this._pos2 + 12];
      }
      set upperSize(e) {
        this._structArray.uint16[this._pos2 + 12] = e;
      }
      get lineOffsetX() {
        return this._structArray.float32[this._pos4 + 7];
      }
      set lineOffsetX(e) {
        this._structArray.float32[this._pos4 + 7] = e;
      }
      get lineOffsetY() {
        return this._structArray.float32[this._pos4 + 8];
      }
      set lineOffsetY(e) {
        this._structArray.float32[this._pos4 + 8] = e;
      }
      get writingMode() {
        return this._structArray.uint8[this._pos1 + 36];
      }
      set writingMode(e) {
        this._structArray.uint8[this._pos1 + 36] = e;
      }
      get hidden() {
        return this._structArray.uint8[this._pos1 + 37];
      }
      set hidden(e) {
        this._structArray.uint8[this._pos1 + 37] = e;
      }
    }
    aa.prototype.size = 40;
    class sa extends jo {
      get(e) {
        return new aa(this, e);
      }
    }
    fo('PlacedSymbolArray', sa);
    class la extends Ut {
      get offsetX() {
        return this._structArray.float32[this._pos4 + 0];
      }
      set offsetX(e) {
        this._structArray.float32[this._pos4 + 0] = e;
      }
    }
    la.prototype.size = 4;
    class ca extends Wo {
      getoffsetX(e) {
        return this.float32[1 * e + 0];
      }
      get(e) {
        return new la(this, e);
      }
    }
    fo('GlyphOffsetArray', ca);
    class ua extends Ut {
      get x() {
        return this._structArray.int16[this._pos2 + 0];
      }
      set x(e) {
        this._structArray.int16[this._pos2 + 0] = e;
      }
      get y() {
        return this._structArray.int16[this._pos2 + 1];
      }
      set y(e) {
        this._structArray.int16[this._pos2 + 1] = e;
      }
      get tileUnitDistanceFromAnchor() {
        return this._structArray.int16[this._pos2 + 2];
      }
      set tileUnitDistanceFromAnchor(e) {
        this._structArray.int16[this._pos2 + 2] = e;
      }
    }
    ua.prototype.size = 6;
    class ha extends $o {
      getx(e) {
        return this.int16[3 * e + 0];
      }
      gety(e) {
        return this.int16[3 * e + 1];
      }
      gettileUnitDistanceFromAnchor(e) {
        return this.int16[3 * e + 2];
      }
      get(e) {
        return new ua(this, e);
      }
    }
    fo('SymbolLineVertexArray', ha);
    class da extends Ut {
      get featureIndex() {
        return this._structArray.uint32[this._pos4 + 0];
      }
      set featureIndex(e) {
        this._structArray.uint32[this._pos4 + 0] = e;
      }
      get sourceLayerIndex() {
        return this._structArray.uint16[this._pos2 + 2];
      }
      set sourceLayerIndex(e) {
        this._structArray.uint16[this._pos2 + 2] = e;
      }
      get bucketIndex() {
        return this._structArray.uint16[this._pos2 + 3];
      }
      set bucketIndex(e) {
        this._structArray.uint16[this._pos2 + 3] = e;
      }
    }
    da.prototype.size = 8;
    class pa extends Jo {
      get(e) {
        return new da(this, e);
      }
    }
    function fa(e, t, i) {
      (i[e] && -1 !== i[e].indexOf(t)) || ((i[e] = i[e] || []), i[e].push(t));
    }
    function ma(e, t, i) {
      if (i && i[e]) {
        const n = i[e].indexOf(t);
        -1 !== n && i[e].splice(n, 1);
      }
    }
    fo('FeatureIndexArray', pa);
    class _a {
      constructor(e, t = {}) {
        ce(this, t), (this.type = e);
      }
    }
    class ga extends _a {
      constructor(e, t = {}) {
        super('error', ce({ error: e }, t));
      }
    }
    class ya {
      on(e, t) {
        return (this._listeners = this._listeners || {}), fa(e, t, this._listeners), this;
      }
      off(e, t) {
        return ma(e, t, this._listeners), ma(e, t, this._oneTimeListeners), this;
      }
      once(e, t) {
        return t
          ? ((this._oneTimeListeners = this._oneTimeListeners || {}),
            fa(e, t, this._oneTimeListeners),
            this)
          : new Promise((t) => this.once(e, t));
      }
      fire(e, t) {
        'string' == typeof e && (e = new _a(e, t || {}));
        const i = e.type;
        if (this.listens(i)) {
          e.target = this;
          const t = this._listeners && this._listeners[i] ? this._listeners[i].slice() : [];
          for (const i of t) i && i.call(this, e);
          const n =
            this._oneTimeListeners && this._oneTimeListeners[i]
              ? this._oneTimeListeners[i].slice()
              : [];
          for (const t of n) ma(i, t, this._oneTimeListeners), t && t.call(this, e);
          const r = this._eventedParent;
          r &&
            (ce(
              e,
              'function' == typeof this._eventedParentData
                ? this._eventedParentData()
                : this._eventedParentData,
            ),
            r.fire(e));
        } else e instanceof ga && console.error(e.error);
        return this;
      }
      listens(e) {
        return !!(
          (this._listeners && this._listeners[e] && this._listeners[e].length > 0) ||
          (this._oneTimeListeners &&
            this._oneTimeListeners[e] &&
            this._oneTimeListeners[e].length > 0) ||
          (this._eventedParent && this._eventedParent.listens(e))
        );
      }
      setEventedParent(e, t) {
        return (this._eventedParent = e), (this._eventedParentData = t), this;
      }
    }
    const xa = Object.freeze(new Pt(1, 0, 0)),
      va = Object.freeze(new Pt(0, 1, 0)),
      wa = Object.freeze(new Pt(0, 0, 1));
    class Ta extends ya {
      constructor() {
        super(),
          (this.isObject3D = !0),
          (this.type = 'Object3D'),
          (this._rotation = new Pt(0, 0, 0)),
          (this._quaternion = new Et()),
          (this._scale = new Pt(1, 1, 1)),
          (this._position = new Pt(0, 0, 0)),
          (this._matrix = new Je()),
          (this._matrixWorld = new Je()),
          (this.matrixAutoUpdate = ba),
          (this.matrixWorldNeedsUpdate = !1),
          (this.unmodified = !1),
          (this.parent = null),
          (this.visible = !0),
          (this.children = []),
          (this.castShadow = !1),
          (this.receiveShadow = !1),
          (this.frustumCulled = !1);
      }
      get target() {
        return this._target;
      }
      set target(e) {
        (this.unmodified = !1), (this._target = e);
      }
      set up(e) {
        (this.unmodified = !1), (this._up = e);
      }
      get up() {
        return (
          this._up || Pt.normalize(new Pt(this.matrix[4], this.matrix[5], this.matrix[6]), new Pt())
        );
      }
      get right() {
        return Pt.normalize(new Pt(this.matrix[0], this.matrix[1], this.matrix[2]), new Pt());
      }
      get direction() {
        return Pt.normalize(new Pt(this.matrix[8], this.matrix[9], this.matrix[10]), new Pt());
      }
      get quaternion() {
        return this._quaternion;
      }
      set quaternion(e) {
        (this.unmodified = !1), (this._quaternion = e);
      }
      get position() {
        return this._position;
      }
      set position(e) {
        if (((this.unmodified = !1), 3 !== e.length))
          throw new Error('position must be a array of length 3!');
        (this._position = e), this.updateMatrixWorld(!0);
      }
      get cartographicPosition() {
        return Il.cartesian3ToCartographic(this._position);
      }
      set cartographicPosition(e) {
        if (((this.unmodified = !1), 3 !== e.length))
          throw new Error('position must be a array of length 3!');
        const t = Il.cartographicToCartesian3(new Pt(...e));
        (this._position = t), this.updateMatrixWorld(!0);
      }
      get rotation() {
        return this._rotation;
      }
      set rotation(e) {
        (this.unmodified = !1), (this._rotation = e);
      }
      get scale() {
        return this._scale;
      }
      set scale(e) {
        (this.unmodified = !1), (this._scale = e), this.updateMatrixWorld(!0);
      }
      get matrix() {
        return this._matrix;
      }
      set matrix(e) {
        (this.unmodified = !1), (this._matrix = e);
      }
      get matrixWorld() {
        return this._matrixWorld;
      }
      set matrixWorld(e) {
        (this.unmodified = !1), (this._matrixWorld = e);
      }
      get modelViewMatrix() {
        return new Je();
      }
      get normalMatrix() {
        return new je();
      }
      setMatrix(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
          (this.matrix = e),
          this.matrix.decompose(this.position, this.quaternion, this.scale);
      }
      applyMatrix(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
          this.matrix.multiplyLeft(e),
          this.matrix.decompose(this.position, this.quaternion, this.scale);
      }
      applyQuaternion(e) {
        return this.quaternion.premultiply(e), this;
      }
      setRotationFromAxisAngle(e, t) {
        this.quaternion.fromAxisRotation(e, t);
      }
      setRotationFromEuler(e) {
        this.quaternion = e.getQuaternion();
      }
      setRotationFromMatrix(e) {
        this.quaternion.fromRotationMatrix4(e);
      }
      setRotationFromQuaternion(e) {
        this.quaternion.copy(e);
      }
      rotateOnAxis(e, t) {
        const i = new Et().fromAxisRotation(e, t);
        return this.quaternion.multiplyRight(i), this;
      }
      rotateOnWorldAxis(e, t) {
        const i = new Et().fromAxisRotation(e, t);
        return this.quaternion.multiplyLeft(i), this;
      }
      rotateX(e) {
        return this.rotateOnAxis(xa, e);
      }
      rotateY(e) {
        return this.rotateOnAxis(va, e);
      }
      rotateZ(e) {
        return this.rotateOnAxis(wa, e);
      }
      translateOnAxis(e, t) {
        const i = new Pt();
        return (
          i.copy(e).applyQuaternion(this.quaternion), this.position.add(i.multiplyScalar(t)), this
        );
      }
      translateX(e) {
        return this.translateOnAxis(xa, e);
      }
      translateY(e) {
        return this.translateOnAxis(va, e);
      }
      translateZ(e) {
        return this.translateOnAxis(wa, e);
      }
      localToWorld(e) {
        return e.applyMatrix4(this.matrixWorld);
      }
      worldToLocal(e) {
        return e.transform(this.matrixWorld.clone().invert());
      }
      lookAt(e) {
        const t = new Pt(e),
          i = this.parent;
        this.updateWorldMatrix(!0, !1);
        const n = new Pt();
        n.setFromMatrixPosition(this.matrixWorld);
        let r = new Je();
        if (
          (this.isCamera || this.isLight ? r.lookAt(n, t, this.up) : r.lookAt(t, n, this.up),
          this.quaternion.fromRotationMatrix4(r),
          i)
        ) {
          r = i.matrixWorld.clone().extractRotation();
          const e = new Et().fromRotationMatrix4(r);
          this.quaternion.multiplyLeft(e.invert());
        }
      }
      addObject3DsWithoutParent(e) {
        if (arguments.length > 1) {
          for (let e = 0; e < arguments.length; e++) this.addObject3DsWithoutParent(arguments[e]);
          return this;
        }
        return e === this
          ? (console.error('不能将自己添加为自己的child', e), this)
          : (e && e.isObject3D
              ? e.parent || ((e.parent = this), this.children.push(e))
              : console.error('添加的object必须是Object3D的类型', e),
            this);
      }
      add(e) {
        if (arguments.length > 1) {
          for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
          return this;
        }
        return e === this
          ? (console.error('不能将自己添加为自己的child', e), this)
          : (e && e.isObject3D
              ? (null !== e.parent && e.parent.remove(e), (e.parent = this), this.children.push(e))
              : console.error('添加的object必须是Object3D的类型', e),
            this);
      }
      remove(e) {
        if (arguments.length > 1) {
          for (let e = 0; e < arguments.length; e++) this.remove(arguments[e]);
          return this;
        }
        const t = this.children.indexOf(e);
        return -1 !== t && ((e.parent = null), this.children.splice(t, 1)), this;
      }
      attach(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.clone().invert();
        return (
          null !== e.parent &&
            (e.parent.updateWorldMatrix(!0, !1), t.multiplyRight(e.parent.matrixWorld)),
          e.applyMatrix(t),
          e.updateWorldMatrix(!1, !1),
          this.add(e),
          this
        );
      }
      getObjectById(e) {
        return this.getObjectByProperty('id', e);
      }
      getObjectByName(e) {
        return this.getObjectByProperty('name', e);
      }
      getObjectByProperty(e, t) {
        if (this[e] === t) return this;
        for (let i = 0, n = this.children.length; i < n; i++) {
          const n = this.children[i].getObjectByProperty(e, t);
          if (void 0 !== n) return n;
        }
      }
      getWorldPosition(e) {
        return (
          void 0 === e && (e = new Pt()),
          this.updateMatrixWorld(!0),
          e.setFromMatrixPosition(this.matrixWorld)
        );
      }
      getWorldQuaternion(e) {
        return (
          void 0 === e && (e = new Et()),
          this.updateMatrixWorld(!0),
          this.matrixWorld.decompose(new Pt(), e, new Pt()),
          e
        );
      }
      getWorldScale(e) {
        return (
          void 0 === e && (e = new Pt()),
          this.updateMatrixWorld(!0),
          this.matrixWorld.decompose(new Pt(), new Pt(), e),
          e
        );
      }
      getWorldDirection(e) {
        void 0 === e && (e = new Pt()), this.updateMatrixWorld(!0);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize();
      }
      raycast() {}
      traverse(e) {
        e(this);
        const t = this.children;
        for (let i = 0, n = t.length; i < n; i++) t[i].traverse(e);
      }
      traverseVisible(e) {
        if (!1 === this.visible) return;
        e(this);
        const t = this.children;
        for (let i = 0, n = t.length; i < n; i++) t[i].traverseVisible(e);
      }
      traverseAncestors(e) {
        const t = this.parent;
        null !== t && (e(t), t.traverseAncestors(e));
      }
      updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
          (this.matrixWorldNeedsUpdate = !0);
      }
      updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
          (this.matrixWorldNeedsUpdate || e) &&
            (null === this.parent
              ? this.matrixWorld.copy(this.matrix)
              : (this.matrixWorld = this.parent.matrixWorld.clone().multiplyRight(this.matrix)),
            (this.matrixWorldNeedsUpdate = !1),
            (e = !0));
        const t = this.children;
        for (let i = 0, n = t.length; i < n; i++) t[i].updateMatrixWorld(e);
        this.unmodified = !0;
      }
      updateWorldMatrix(e, t) {
        const i = this.parent;
        if (
          (!0 === e && null !== i && i.updateWorldMatrix(!0, !1),
          this.matrixAutoUpdate && this.updateMatrix(),
          null === this.parent
            ? this.matrixWorld.copy(this.matrix)
            : (this.matrixWorld = this.parent.matrixWorld.clone().multiplyRight(this.matrix)),
          !0 === t)
        ) {
          const e = this.children;
          for (let t = 0, i = e.length; t < i; t++) e[t].updateWorldMatrix(!1, !0);
        }
        this.unmodified = !0;
      }
      clone(e) {
        return new this.constructor().copy(this, e);
      }
      copy(e, t) {
        if (
          (void 0 === t && (t = !0),
          (this.name = e.name),
          this.up.copy(e.up),
          this.position.copy(e.position),
          this.quaternion.copy(e.quaternion),
          this.scale.copy(e.scale),
          this.matrix.copy(e.matrix),
          this.matrixWorld.copy(e.matrixWorld),
          (this.matrixAutoUpdate = e.matrixAutoUpdate),
          (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
          (this.visible = e.visible),
          (this.frustumCulled = e.frustumCulled),
          (this.userData = JSON.parse(JSON.stringify(e.userData))),
          !0 === t)
        )
          for (let t = 0; t < e.children.length; t++) this.add(e.children[t].clone());
        return this;
      }
    }
    const ba = !0,
      Sa = new Pt(0, 1, 0),
      Aa = Object.freeze({ OUTSIDE: -1, INTERSECTING: 0, INSIDE: 1 }),
      Pa = new Pt(),
      Ea = new Pt();
    class Ca {
      constructor(e = [0, 0, 1], t = 0) {
        (this.normal = new Pt()), (this.distance = -0), this.fromNormalDistance(e, t);
      }
      fromNormalDistance(e, t) {
        return this.normal.from(e).normalize(), (this.distance = t), this;
      }
      fromPointNormal(e, t) {
        (e = Pa.from(e)), this.normal.from(t).normalize();
        const i = -this.normal.dot(e);
        return (this.distance = i), this;
      }
      fromCoefficients(e, t, i, n) {
        return this.normal.set(e, t, i), (this.distance = n), this;
      }
      clone() {
        return new Ca(this.normal, this.distance);
      }
      equals(e) {
        return u(this.distance, e.distance) && u(this.normal, e.normal);
      }
      getPointDistance(e) {
        return this.normal.dot(e) + this.distance;
      }
      transform(e) {
        const t = Ea.copy(this.normal).transformAsVector(e).normalize(),
          i = this.normal.scale(-this.distance).transform(e);
        return this.fromPointNormal(i, t);
      }
      projectPointOntoPlane(e, t = [0, 0, 0]) {
        e = Pa.from(e);
        const i = this.getPointDistance(e),
          n = Ea.copy(this.normal).scale(i);
        return e.subtract(n).to(t);
      }
      static fromPointNormal(e, i, n) {
        const r = -Pt.dot(i, e);
        return t(n) ? (Pt.clone(i, n.normal), (n.distance = r), n) : new Ca(i, r);
      }
      static fromCartesian4(e, i) {
        const n = new Pt(),
          r = Pt.fromCartesian4(e, n),
          o = e.w;
        return t(i) ? (Pt.clone(r, i.normal), (i.distance = o), i) : new Ca(r, o);
      }
      static getPointDistance(e, t) {
        return Pt.dot(e.normal, t) + e.distance;
      }
      static projectPointOntoPlane = function (e, i, n) {
        const r = new Pt();
        t(n) || (n = new Pt());
        const o = Ca.getPointDistance(e, i),
          a = Pt.multiplyByScalar(e.normal, o, r);
        return Pt.subtract(i, a, n);
      };
      static transform(e, t, i) {
        const n = new Je(),
          r = new Ge(),
          o = new Pt(),
          a = e.normal,
          s = e.distance,
          l = Je.inverseTranspose(t, n);
        let c = Ge.fromElements(a.x, a.y, a.z, s, r);
        c = Je.multiplyByVector(l, c, c);
        const u = Pt.fromCartesian4(c, o);
        return (c = Ge.divideByScalar(c, Pt.magnitude(u), c)), Ca.fromCartesian4(c, i);
      }
      static clone(e, i) {
        return t(i)
          ? (Pt.clone(e.normal, i.normal), (i.distance = e.distance), i)
          : new Ca(e.normal, e.distance);
      }
      static equals(e, t) {
        return e.distance === t.distance && Pt.equals(e.normal, t.normal);
      }
    }
    const Ma = [new Pt([1, 0, 0]), new Pt([0, 1, 0]), new Pt([0, 0, 1])],
      Ia = new Pt(),
      La = new Pt();
    new Ca(new Pt(1, 0, 0), 0);
    class Ra {
      static get MASK_OUTSIDE() {
        return 4294967295;
      }
      static get MASK_INSIDE() {
        return 0;
      }
      static get MASK_INDETERMINATE() {
        return 2147483647;
      }
      constructor(e = []) {
        this.planes = e;
      }
      fromBoundingSphere(e) {
        this.planes.length = 2 * Ma.length;
        const t = e.center,
          i = e.radius;
        let n = 0;
        for (const e of Ma) {
          let r = this.planes[n],
            o = this.planes[n + 1];
          r || (r = this.planes[n] = new Ca()), o || (o = this.planes[n + 1] = new Ca());
          const a = Ia.copy(e).scale(-i).add(t);
          e.dot(a), r.fromPointNormal(a, e);
          const s = Ia.copy(e).scale(i).add(t),
            l = La.copy(e).negate();
          l.dot(s), o.fromPointNormal(s, l), (n += 2);
        }
        return this;
      }
      computeVisibility(e) {
        let t = Aa.INSIDE;
        for (let i = 0; i < 6; i++)
          switch (e.intersectPlane(this.planes[i])) {
            case Aa.OUTSIDE:
              return Aa.OUTSIDE;
            case Aa.INTERSECTING:
              t = Aa.INTERSECTING;
          }
        return t;
      }
      computeVisibilityWithPlaneMask(e, t) {
        if (t === Ra.MASK_OUTSIDE || t === Ra.MASK_INSIDE) return t;
        let i = Ra.MASK_INSIDE;
        const n = this.planes;
        for (let r = 0; r < this.planes.length; ++r) {
          const o = r < 31 ? 1 << r : 0;
          if (r < 31 && 0 == (t & o)) continue;
          const a = e.intersectPlane(n[r]);
          if (a === Aa.OUTSIDE) return Ra.MASK_OUTSIDE;
          a === Aa.INTERSECTING && (i |= o);
        }
        return i;
      }
    }
    const Na = new Pt(),
      Oa = new Pt(),
      Da = new Pt(),
      Fa = new Pt(),
      za = new Pt();
    class Ba {
      constructor(e = {}) {
        (e = { near: 1, far: 5e8, ...e }),
          (this.left = e.left),
          (this._left = void 0),
          (this.right = e.right),
          (this._right = void 0),
          (this.top = e.top),
          (this._top = void 0),
          (this.bottom = e.bottom),
          (this._bottom = void 0),
          (this.near = e.near),
          (this._near = this.near),
          (this.far = e.far),
          (this._far = this.far),
          (this._cullingVolume = new Ra([
            new Ca(),
            new Ca(),
            new Ca(),
            new Ca(),
            new Ca(),
            new Ca(),
          ])),
          (this._perspectiveMatrix = new Je()),
          (this._infinitePerspective = new Je());
      }
      clone() {
        return new Ba({
          right: this.right,
          left: this.left,
          top: this.top,
          bottom: this.bottom,
          near: this.near,
          far: this.far,
        });
      }
      equals(e) {
        return (
          e &&
          e instanceof Ba &&
          this.right === e.right &&
          this.left === e.left &&
          this.top === e.top &&
          this.bottom === e.bottom &&
          this.near === e.near &&
          this.far === e.far
        );
      }
      get projectionMatrix() {
        return Va(this), this._perspectiveMatrix;
      }
      get infiniteProjectionMatrix() {
        return Va(this), this._infinitePerspective;
      }
      computeCullingVolume(e, t, i) {
        const n = this._cullingVolume.planes;
        i = Na.copy(i).normalize();
        const r = Oa.copy(t).cross(i).normalize(),
          o = Da.copy(t).multiplyByScalar(this.near).add(e),
          a = Fa.copy(t).multiplyByScalar(this.far).add(e);
        let s = za;
        return (
          s.copy(r).multiplyByScalar(this.left).add(o).subtract(e).cross(i),
          n[0].fromPointNormal(e, s),
          s.copy(r).multiplyByScalar(this.right).add(o).subtract(e).cross(i).negate(),
          n[1].fromPointNormal(e, s),
          s.copy(i).multiplyByScalar(this.bottom).add(o).subtract(e).cross(r).negate(),
          n[2].fromPointNormal(e, s),
          s.copy(i).multiplyByScalar(this.top).add(o).subtract(e).cross(r),
          n[3].fromPointNormal(e, s),
          (s = new Pt().copy(t)),
          n[4].fromPointNormal(o, s),
          s.negate(),
          n[5].fromPointNormal(a, s),
          this._cullingVolume
        );
      }
      setFromMatrix(e) {
        const t = this._cullingVolume.planes,
          i = e[0],
          n = e[1],
          r = e[2],
          o = e[3],
          a = e[4],
          s = e[5],
          l = e[6],
          c = e[7],
          u = e[8],
          h = e[9],
          d = e[10],
          p = e[11],
          f = e[12],
          m = e[13],
          _ = e[14],
          g = e[15];
        t[0].fromNormalDistance([o - i, c - a, p - u], g - f),
          t[1].fromNormalDistance([o + i, c + a, p + u], g + f),
          t[2].fromNormalDistance([o + n, c + s, p + h], g + m),
          t[3].fromNormalDistance([o - n, c - s, p - h], g - m),
          t[4].fromNormalDistance([o - r, c - l, p - d], g - _),
          t[5].fromNormalDistance([o + r, c + l, p + d], g + _);
      }
      getPixelDimensions(e, t, i, n) {
        Va(this);
        const r = 1 / this.near;
        let o = this.top * r;
        const a = (2 * i * o) / t;
        return (o = this.right * r), (n.x = (2 * i * o) / e), (n.y = a), n;
      }
    }
    function Va(e) {
      const { top: t, bottom: i, right: n, left: r, near: o, far: a } = e;
      (t === e._top &&
        i === e._bottom &&
        r === e._left &&
        n === e._right &&
        o === e._near &&
        a === e._far) ||
        ((e._left = r),
        (e._right = n),
        (e._top = t),
        (e._bottom = i),
        (e._near = o),
        (e._far = a),
        (e._perspectiveMatrix = new Je().frustum({
          left: r,
          right: n,
          bottom: i,
          top: t,
          near: o,
          far: a,
        })),
        (e._infinitePerspective = new Je().frustum({
          left: r,
          right: n,
          bottom: i,
          top: t,
          near: o,
          far: 1 / 0,
        })));
    }
    const Ua = new Pt(),
      ka = new Pt(),
      Ga = new Pt(),
      Ha = new Pt();
    class Ya {
      constructor(e) {
        (e = Z(e, Z.EMPTY_OBJECT)),
          (this.left = e.left),
          (this._left = void 0),
          (this.right = e.right),
          (this._right = void 0),
          (this.top = e.top),
          (this._top = void 0),
          (this.bottom = e.bottom),
          (this._bottom = void 0),
          (this.near = Z(e.near, 1)),
          (this._near = this.near),
          (this.far = Z(e.far, 5e8)),
          (this._far = this.far),
          (this._cullingVolume = new Ra([
            new Ca(),
            new Ca(),
            new Ca(),
            new Ca(),
            new Ca(),
            new Ca(),
          ])),
          (this._orthographicMatrix = new Je());
      }
      get projectionMatrix() {
        return qa(this), this._orthographicMatrix;
      }
      computeCullingVolume(e, i, n) {
        const r = this._cullingVolume.planes,
          o = this.top,
          a = this.bottom,
          s = this.right,
          l = this.left,
          c = this.near,
          u = this.far,
          h = Ua.copy(i).cross(n);
        h.normalize();
        const d = ka;
        d.copy(i).multiplyByScalar(c), d.add(e);
        const p = Ga;
        p.copy(h).multiplyByScalar(l), p.add(d);
        let f = r[0];
        t(f) || (f = r[0] = new Ca());
        let m = -h.dot(p);
        return (
          f.fromCoefficients(h[0], h[1], h[2], m),
          p.copy(h).multiplyByScalar(s),
          p.add(d),
          (f = r[1]),
          t(f) || (f = r[1] = new Ca()),
          (m = -Ha.copy(h).negate().dot(p)),
          f.fromCoefficients(-h[0], -h[1], -h[2], m),
          p.copy(n).multiplyByScalar(a),
          p.add(d),
          (f = r[2]),
          t(f) || (f = r[2] = new Ca()),
          (m = -n.dot(p)),
          Pt.normalize(n, n),
          f.fromCoefficients(n[0], n[1], n[2], m),
          p.copy(n).multiplyByScalar(o),
          p.add(d),
          (f = r[3]),
          t(f) || (f = r[3] = new Ca()),
          (m = -Ha.copy(n).negate().dot(p)),
          f.fromCoefficients(-n[0], -n[1], -n[2], m),
          (f = r[4]),
          t(f) || (f = r[4] = new Ca()),
          (m = -i.dot(d)),
          Pt.normalize(i, i),
          f.fromCoefficients(i[0], i[1], i[2], m),
          p.copy(i).multiplyByScalar(u),
          p.add(e),
          (f = r[5]),
          t(f) || (f = r[5] = new Ca()),
          (m = -Ha.copy(i).negate().dot(p)),
          f.fromCoefficients(-i[0], -i[1], -i[2], m),
          this._cullingVolume
        );
      }
      getPixelDimensions(e, t, i, n, r) {
        qa(this);
        const o = (n * (this.top - this.bottom)) / t;
        return (r.x = (n * (this.right - this.left)) / e), (r.y = o), r;
      }
      clone(e) {
        return (
          t(e) || (e = new Ya()),
          (e.left = this.left),
          (e.right = this.right),
          (e.top = this.top),
          (e.bottom = this.bottom),
          (e.near = this.near),
          (e.far = this.far),
          (e._left = void 0),
          (e._right = void 0),
          (e._top = void 0),
          (e._bottom = void 0),
          (e._near = void 0),
          (e._far = void 0),
          e
        );
      }
      equals(e) {
        return (
          t(e) &&
          e instanceof Ya &&
          this.right === e.right &&
          this.left === e.left &&
          this.top === e.top &&
          this.bottom === e.bottom &&
          this.near === e.near &&
          this.far === e.far
        );
      }
      equalsEpsilon(e, i, n) {
        return (
          e === this ||
          (t(e) &&
            e instanceof Ya &&
            Me.CesiumMath.equalsEpsilon(this.right, e.right, i, n) &&
            Me.CesiumMath.equalsEpsilon(this.left, e.left, i, n) &&
            Me.CesiumMath.equalsEpsilon(this.top, e.top, i, n) &&
            Me.CesiumMath.equalsEpsilon(this.bottom, e.bottom, i, n) &&
            Me.CesiumMath.equalsEpsilon(this.near, e.near, i, n) &&
            Me.CesiumMath.equalsEpsilon(this.far, e.far, i, n))
        );
      }
    }
    function qa(e) {
      (e.top === e._top &&
        e.bottom === e._bottom &&
        e.left === e._left &&
        e.right === e._right &&
        e.near === e._near &&
        e.far === e._far) ||
        ((e._left = e.left),
        (e._right = e.right),
        (e._top = e.top),
        (e._bottom = e.bottom),
        (e._near = e.near),
        (e._far = e.far),
        (e._orthographicMatrix = new Je().ortho({
          left: e.left,
          right: e.right,
          bottom: e.bottom,
          top: e.top,
          near: e.near,
          far: e.far,
        })));
    }
    class Xa {
      constructor(e) {
        (e = Z(e, Z.EMPTY_OBJECT)),
          (this._offCenterFrustum = new Ya()),
          (this.width = e.width),
          (this._width = void 0),
          (this.aspectRatio = e.aspectRatio),
          (this._aspectRatio = void 0),
          (this.near = Z(e.near, 1)),
          (this._near = this.near),
          (this.far = Z(e.far, 5e8)),
          (this._far = this.far);
      }
      static pack(e, t, i) {
        return (
          (i = Z(i, 0)),
          (t[i++] = e.width),
          (t[i++] = e.aspectRatio),
          (t[i++] = e.near),
          (t[i] = e.far),
          t
        );
      }
      static packedLength = 4;
      static unpack(e, i, n) {
        return (
          (i = Z(i, 0)),
          t(n) || (n = new Xa()),
          (n.width = e[i++]),
          (n.aspectRatio = e[i++]),
          (n.near = e[i++]),
          (n.far = e[i]),
          n
        );
      }
      get projectionMatrix() {
        return ja(this), this._offCenterFrustum.projectionMatrix;
      }
      computeCullingVolume(e, t, i) {
        return ja(this), this._offCenterFrustum.computeCullingVolume(e, t, i);
      }
      getPixelDimensions(e, t, i, n, r) {
        return ja(this), this._offCenterFrustum.getPixelDimensions(e, t, i, n, r);
      }
      clone(e) {
        return (
          t(e) || (e = new Xa()),
          (e.aspectRatio = this.aspectRatio),
          (e.width = this.width),
          (e.near = this.near),
          (e.far = this.far),
          (e._aspectRatio = void 0),
          (e._width = void 0),
          (e._near = void 0),
          (e._far = void 0),
          this._offCenterFrustum.clone(e._offCenterFrustum),
          e
        );
      }
      equals(e) {
        return (
          !!(t(e) && e instanceof Xa) &&
          (ja(this),
          ja(e),
          this.width === e.width &&
            this.aspectRatio === e.aspectRatio &&
            this._offCenterFrustum.equals(e._offCenterFrustum))
        );
      }
      equalsEpsilon(e, i, n) {
        return (
          !!(t(e) && e instanceof Xa) &&
          (ja(this),
          ja(e),
          Me.CesiumMath.equalsEpsilon(this.width, e.width, i, n) &&
            Me.CesiumMath.equalsEpsilon(this.aspectRatio, e.aspectRatio, i, n) &&
            this._offCenterFrustum.equalsEpsilon(e._offCenterFrustum, i, n))
        );
      }
    }
    function ja(e) {
      const t = e._offCenterFrustum;
      if (
        e.width !== e._width ||
        e.aspectRatio !== e._aspectRatio ||
        e.near !== e._near ||
        e.far !== e._far
      ) {
        (e._aspectRatio = e.aspectRatio),
          (e._width = e.width),
          (e._near = e.near),
          (e._far = e.far);
        const i = 1 / e.aspectRatio;
        (t.right = 0.5 * e.width),
          (t.left = -t.right),
          (t.top = i * t.right),
          (t.bottom = -t.top),
          (t.near = e.near),
          (t.far = e.far);
      }
    }
    Xa.packedLength = 4;
    class Wa {
      constructor(e) {
        let t;
        (this.name = 'DeveloperError'), (this.message = e);
        try {
          throw new Error();
        } catch (e) {
          t = e.stack;
        }
        this.stack = t;
      }
      toString() {
        let e = `${this.name}: ${this.message}`;
        return t(this.stack) && (e += `\n${this.stack.toString()}`), e;
      }
      static throwInstantiationError() {
        throw new Wa('This function defines an interface and should not be called directly.');
      }
    }
    const $a = new Pt(),
      Za = new Pt(),
      Ka = new Pt(),
      Qa = new Pt();
    class Ja {
      constructor(e, t) {
        (this.origin = new Pt(void 0 !== e ? e : [0, 0, 0])),
          (this.direction = new Pt(void 0 !== t ? t : [0, 0, 0]));
      }
      set(e, t) {
        return P(this.origin, e), P(this.direction, t), this;
      }
      clone() {
        return new Ja(this.origin, this.direction);
      }
      copy(e) {
        P(this.origin, e.origin), P(this.direction, e.direction);
      }
      at(e, t) {
        return (
          void 0 === t &&
            (console.warn('THREE.Ray: .at() target is now required'), (t = [0, 0, 0])),
          P(t, this.direction),
          C(t, t, e),
          E(t, t, this.origin),
          t
        );
      }
      lookAt(e) {
        return (
          P(this.direction, e),
          D(this.direction, this.direction, this.origin),
          I(this.direction, this.direction),
          this
        );
      }
      closestPointToPoint(e, t) {
        void 0 === t &&
          (console.warn('THREE.Ray: .closestPointToPoint() target is now required'),
          (t = [0, 0, 0])),
          D(t, e, this.origin);
        const i = L(t, this.direction);
        return i < 0
          ? P(t, this.origin)
          : (P(t, this.direction), C(t, t, i), E(t, t, this.origin), t);
      }
      distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e));
      }
      distanceSqToPoint() {
        const e = [0, 0, 0],
          t = L(D(e, point, this.origin), this.direction);
        return t < 0
          ? M(this.origin, point)
          : (P(e, this.direction), C(e, e, t), E(e, e, this.origin), M(e, point));
      }
      distanceSqToSegment(e, t, i, n) {
        const r = [0, 0, 0],
          o = [0, 0, 0],
          a = [0, 0, 0];
        r.copy(e).add(t).multiplyScalar(0.5),
          o.copy(t).sub(e).normalize(),
          a.copy(this.origin).sub(r);
        const s = 0.5 * e.distanceTo(t),
          l = -this.direction.dot(o),
          c = a.dot(this.direction),
          u = -a.dot(o),
          h = a.lengthSq(),
          d = Math.abs(1 - l * l);
        let p, f, m, _;
        if (d > 0)
          if (((p = l * u - c), (f = l * c - u), (_ = s * d), p >= 0))
            if (f >= -_)
              if (f <= _) {
                const e = 1 / d;
                (p *= e), (f *= e), (m = p * (p + l * f + 2 * c) + f * (l * p + f + 2 * u) + h);
              } else (f = s), (p = Math.max(0, -(l * f + c))), (m = -p * p + f * (f + 2 * u) + h);
            else (f = -s), (p = Math.max(0, -(l * f + c))), (m = -p * p + f * (f + 2 * u) + h);
          else
            f <= -_
              ? ((p = Math.max(0, -(-l * s + c))),
                (f = p > 0 ? -s : Math.min(Math.max(-s, -u), s)),
                (m = -p * p + f * (f + 2 * u) + h))
              : f <= _
              ? ((p = 0), (f = Math.min(Math.max(-s, -u), s)), (m = f * (f + 2 * u) + h))
              : ((p = Math.max(0, -(l * s + c))),
                (f = p > 0 ? s : Math.min(Math.max(-s, -u), s)),
                (m = -p * p + f * (f + 2 * u) + h));
        else
          (f = l > 0 ? -s : s), (p = Math.max(0, -(l * f + c))), (m = -p * p + f * (f + 2 * u) + h);
        return (
          i && i.copy(this.direction).multiplyScalar(p).add(this.origin),
          n && n.copy(o).multiplyScalar(f).add(r),
          m
        );
      }
      intersectSphere(e, t) {
        const i = [0, 0, 0];
        D(i, e.center, this.origin);
        const n = L(i, this.direction),
          r = L(i, i) - n * n,
          o = e.radius * e.radius;
        if (r > o) return null;
        const a = Math.sqrt(o - r),
          s = n - a,
          l = n + a;
        return s < 0 && l < 0 ? null : this.at(s < 0 ? l : s, t);
      }
      intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
      }
      distanceToPlane(e) {
        const t = e.normal.dot(this.direction);
        if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
        const i = -(this.origin.dot(e.normal) + e.constant) / t;
        return i >= 0 ? i : null;
      }
      intersectPlane(e, t) {
        const i = this.distanceToPlane(e);
        return null === i ? null : this.at(i, t);
      }
      intersectsPlane(e) {
        const t = e.distanceToPoint(this.origin);
        return 0 === t || e.normal.dot(this.direction) * t < 0;
      }
      intersectBox(e, t) {
        let i, n, r, o, a, s;
        const l = 1 / this.direction[0],
          c = 1 / this.direction[1],
          u = 1 / this.direction[2],
          h = this.origin;
        return (
          l >= 0
            ? ((i = (e[0][0] - h[0]) * l), (n = (e[1][0] - h[0]) * l))
            : ((i = (e[1][0] - h[0]) * l), (n = (e[0][0] - h[0]) * l)),
          c >= 0
            ? ((r = (e[0][1] - h[1]) * c), (o = (e[1][1] - h[1]) * c))
            : ((r = (e[1][1] - h[1]) * c), (o = (e[0][1] - h[1]) * c)),
          i > o || r > n
            ? null
            : ((r > i || i != i) && (i = r),
              (o < n || n != n) && (n = o),
              u >= 0
                ? ((a = (e[0][2] - h[2]) * u), (s = (e[1][2] - h[2]) * u))
                : ((a = (e[1][2] - h[2]) * u), (s = (e[0][2] - h[2]) * u)),
              i > s || a > n
                ? null
                : ((a > i || i != i) && (i = a),
                  (s < n || n != n) && (n = s),
                  n < 0 ? null : this.at(i >= 0 ? i : n, t)))
        );
      }
      intersectTriangle(e, t, i, n, r) {
        Za.subVectors(t, e), Ka.subVectors(i, e), Qa.crossVectors(Za, Ka);
        let o,
          a = this.direction.dot(Qa);
        if (a > 0) {
          if (n) return null;
          o = 1;
        } else {
          if (!(a < 0)) return null;
          (o = -1), (a = -a);
        }
        $a.subVectors(this.origin, e);
        const s = o * this.direction.dot(Ka.crossVectors($a, Ka));
        if (s < 0) return null;
        const l = o * this.direction.dot(Za.cross($a));
        if (l < 0) return null;
        if (s + l > a) return null;
        const c = -o * $a.dot(Qa);
        return c < 0 ? null : this.at(c / a, r);
      }
      applyMatrix4(e) {
        return z(this.origin, this.origin, e), z(this.direction, this.direction, e), this;
      }
      equals(e) {
        return e.origin === this.origin && e.direction === this.direction;
      }
    }
    const es = new Pt(),
      ts = new Pt(),
      is = new Pt(),
      ns = new Pt(),
      rs = new Pt(),
      os = new Pt();
    class as extends Pt {
      constructor(e = 0, t = 0, i = 0) {
        super(e, t, i);
      }
      get longitude() {
        return this[0];
      }
      set longitude(e) {
        this[0] = e;
      }
      get latitude() {
        return this[1];
      }
      set latitude(e) {
        this[1] = e;
      }
      get height() {
        return this[2];
      }
      set height(e) {
        this[2] = e;
      }
      clone(e = new as()) {
        return as.clone(this, e);
      }
      equals(e) {
        return as.equals(this, e);
      }
      equalsEpsilon(e, t = 0) {
        return as.equalsEpsilon(this, e, t);
      }
      toString() {
        return `(${this.longitude}, ${this.latitude}, ${this.height})`;
      }
      static fromRadians(e, t, i = 0, n = new as()) {
        return (n.longitude = e), (n.latitude = t), (n.height = i), n;
      }
      static fromDegrees(e, t, i = 0, n = new as()) {
        return (
          (e = Me.CesiumMath.toRadians(e)),
          (t = Me.CesiumMath.toRadians(t)),
          as.fromRadians(e, t, i, n)
        );
      }
      static fromVector3(e, i = wt.WGS84, n = new as()) {
        const r = ut(e, i, rs);
        if (!t(r)) return;
        let o = Pt.multiplyComponents(r, i.oneOverRadiiSquared, ns);
        o = Pt.normalize(o, o);
        const a = Pt.subtract(e, r, os),
          s = Math.atan2(o.y, o.x),
          l = Math.asin(o.z),
          c = Math.sign(Pt.dot(a, e)) * Pt.magnitude(a);
        return (n.longitude = s), (n.latitude = l), (n.height = c), n;
      }
      static toVector3(e, t = wt.WGS84, i = new Pt()) {
        return Pt.fromRadians(e.longitude, e.latitude, e.height, t, i);
      }
      static clone(e, t = new as()) {
        return (t.longitude = e.longitude), (t.latitude = e.latitude), (t.height = e.height), t;
      }
      static equals(e, i) {
        return (
          e === i ||
          (t(e) &&
            t(i) &&
            e.longitude === i.longitude &&
            e.latitude === i.latitude &&
            e.height === i.height)
        );
      }
      static equalsEpsilon(e, i, n = 0) {
        return (
          e === i ||
          (t(e) &&
            t(i) &&
            Math.abs(e.longitude - i.longitude) <= n &&
            Math.abs(e.latitude - i.latitude) <= n &&
            Math.abs(e.height - i.height) <= n)
        );
      }
    }
    const ss = {};
    function ls(e, t, i) {
      const n = e + t;
      return Math.sign(e) !== Math.sign(t) && Math.abs(n / Math.max(Math.abs(e), Math.abs(t))) < i
        ? 0
        : n;
    }
    (ss.computeDiscriminant = function (e, t, i) {
      return t * t - 4 * e * i;
    }),
      (ss.computeRealRoots = function (e, t, i) {
        let n;
        if (0 === e) return 0 === t ? [] : [-i / t];
        if (0 === t) {
          if (0 === i) return [0, 0];
          const t = Math.abs(i),
            r = Math.abs(e);
          if (t < r && t / r < Me.CesiumMath.EPSILON14) return [0, 0];
          if (t > r && r / t < Me.CesiumMath.EPSILON14) return [];
          if (((n = -i / e), n < 0)) return [];
          const o = Math.sqrt(n);
          return [-o, o];
        }
        if (0 === i) return (n = -t / e), n < 0 ? [n, 0] : [0, n];
        const r = ls(t * t, -4 * e * i, Me.CesiumMath.EPSILON14);
        if (r < 0) return [];
        const o = -0.5 * ls(t, Math.sign(t) * Math.sqrt(r), Me.CesiumMath.EPSILON14);
        return t > 0 ? [o / e, i / o] : [i / o, o / e];
      });
    const cs = {};
    function us(e, t, i, n) {
      const r = e,
        o = t / 3,
        a = i / 3,
        s = n,
        l = r * a,
        c = o * s,
        u = o * o,
        h = a * a,
        d = r * a - u,
        p = r * s - o * a,
        f = o * s - h,
        m = 4 * d * f - p * p;
      let _, g;
      if (m < 0) {
        let e, t, i;
        u * c >= l * h
          ? ((e = r), (t = d), (i = -2 * o * d + r * p))
          : ((e = s), (t = f), (i = -s * p + 2 * a * f));
        const n = -(i < 0 ? -1 : 1) * Math.abs(e) * Math.sqrt(-m);
        g = -i + n;
        const y = g / 2,
          x = y < 0 ? -Math.pow(-y, 1 / 3) : Math.pow(y, 1 / 3),
          v = g === n ? -x : -t / x;
        return (
          (_ = t <= 0 ? x + v : -i / (x * x + v * v + t)),
          u * c >= l * h ? [(_ - o) / r] : [-s / (_ + a)]
        );
      }
      const y = d,
        x = -2 * o * d + r * p,
        v = f,
        w = -s * p + 2 * a * f,
        T = Math.sqrt(m),
        b = Math.sqrt(3) / 2;
      let S = Math.abs(Math.atan2(r * T, -x) / 3);
      _ = 2 * Math.sqrt(-y);
      let A = Math.cos(S);
      g = _ * A;
      let P = _ * (-A / 2 - b * Math.sin(S));
      const E = g + P > 2 * o ? g - o : P - o,
        C = r,
        M = E / C;
      (S = Math.abs(Math.atan2(s * T, -w) / 3)),
        (_ = 2 * Math.sqrt(-v)),
        (A = Math.cos(S)),
        (g = _ * A),
        (P = _ * (-A / 2 - b * Math.sin(S)));
      const I = -s,
        L = g + P < 2 * a ? g + a : P + a,
        R = I / L,
        N = -E * L - C * I,
        O = (a * N - o * (E * I)) / (-o * N + a * (C * L));
      return M <= O
        ? M <= R
          ? O <= R
            ? [M, O, R]
            : [M, R, O]
          : [R, M, O]
        : M <= R
        ? [O, M, R]
        : O <= R
        ? [O, R, M]
        : [R, O, M];
    }
    (cs.computeDiscriminant = function (e, t, i, n) {
      const r = t * t,
        o = i * i;
      return 18 * e * t * i * n + r * o - e * e * 27 * (n * n) - 4 * (e * o * i + r * t * n);
    }),
      (cs.computeRealRoots = function (e, t, i, n) {
        let r, o;
        if (0 === e) return ss.computeRealRoots(t, i, n);
        if (0 === t) {
          if (0 === i) {
            if (0 === n) return [0, 0, 0];
            o = -n / e;
            const t = o < 0 ? -Math.pow(-o, 1 / 3) : Math.pow(o, 1 / 3);
            return [t, t, t];
          }
          return 0 === n
            ? ((r = ss.computeRealRoots(e, 0, i)), 0 === r.Length ? [0] : [r[0], 0, r[1]])
            : us(e, 0, i, n);
        }
        return 0 === i
          ? 0 === n
            ? ((o = -t / e), o < 0 ? [o, 0, 0] : [0, 0, o])
            : us(e, t, 0, n)
          : 0 === n
          ? ((r = ss.computeRealRoots(e, t, i)),
            0 === r.length
              ? [0]
              : r[1] <= 0
              ? [r[0], r[1], 0]
              : r[0] >= 0
              ? [0, r[0], r[1]]
              : [r[0], 0, r[1]])
          : us(e, t, i, n);
      });
    const hs = {
        computeDiscriminant: function (e, t, i, n, r) {
          const o = e * e,
            a = t * t,
            s = a * t,
            l = i * i,
            c = l * i,
            u = n * n,
            h = u * n,
            d = r * r;
          return (
            a * l * u -
            4 * s * h -
            4 * e * c * u +
            18 * e * t * i * h -
            27 * o * u * u +
            o * e * 256 * (d * r) +
            r *
              (18 * s * i * n -
                4 * a * c +
                16 * e * l * l -
                80 * e * t * l * n -
                6 * e * a * u +
                144 * o * i * u) +
            d * (144 * e * a * i - 27 * a * a - 128 * o * l - 192 * o * t * n)
          );
        },
        computeRealRoots: function (e, t, i, n, r) {
          if (Math.abs(e) < Me.CesiumMath.EPSILON15) return cs.computeRealRoots(t, i, n, r);
          const o = t / e,
            a = i / e,
            s = n / e,
            l = r / e;
          let c = o < 0 ? 1 : 0;
          switch (
            ((c += a < 0 ? c + 1 : c), (c += s < 0 ? c + 1 : c), (c += l < 0 ? c + 1 : c), c)
          ) {
            case 0:
            case 3:
            case 4:
            case 6:
            case 7:
            case 9:
            case 10:
            case 12:
            case 13:
            case 14:
            case 15:
              return (function (e, t, i, n) {
                const r = e * e,
                  o = t - (3 * r) / 8,
                  a = i - (t * e) / 2 + (r * e) / 8,
                  s = n - (i * e) / 4 + (t * r) / 16 - (3 * r * r) / 256,
                  l = cs.computeRealRoots(1, 2 * o, o * o - 4 * s, -a * a);
                if (l.length > 0) {
                  const t = -e / 4,
                    i = l[l.length - 1];
                  if (Math.abs(i) < Me.CesiumMath.EPSILON14) {
                    const e = ss.computeRealRoots(1, o, s);
                    if (2 === e.length) {
                      const i = e[0],
                        n = e[1];
                      let r;
                      if (i >= 0 && n >= 0) {
                        const e = Math.sqrt(i),
                          r = Math.sqrt(n);
                        return [t - r, t - e, t + e, t + r];
                      }
                      if (i >= 0 && n < 0) return (r = Math.sqrt(i)), [t - r, t + r];
                      if (i < 0 && n >= 0) return (r = Math.sqrt(n)), [t - r, t + r];
                    }
                    return [];
                  }
                  if (i > 0) {
                    const e = Math.sqrt(i),
                      n = (o + i + a / e) / 2,
                      r = ss.computeRealRoots(1, e, (o + i - a / e) / 2),
                      s = ss.computeRealRoots(1, -e, n);
                    return 0 !== r.length
                      ? ((r[0] += t),
                        (r[1] += t),
                        0 !== s.length
                          ? ((s[0] += t),
                            (s[1] += t),
                            r[1] <= s[0]
                              ? [r[0], r[1], s[0], s[1]]
                              : s[1] <= r[0]
                              ? [s[0], s[1], r[0], r[1]]
                              : r[0] >= s[0] && r[1] <= s[1]
                              ? [s[0], r[0], r[1], s[1]]
                              : s[0] >= r[0] && s[1] <= r[1]
                              ? [r[0], s[0], s[1], r[1]]
                              : r[0] > s[0] && r[0] < s[1]
                              ? [s[0], r[0], s[1], r[1]]
                              : [r[0], s[0], r[1], s[1]])
                          : r)
                      : 0 !== s.length
                      ? ((s[0] += t), (s[1] += t), s)
                      : [];
                  }
                }
                return [];
              })(o, a, s, l);
            case 1:
            case 2:
            case 5:
            case 8:
            case 11:
              return (function (e, t, i, n) {
                const r = e * e,
                  o = cs.computeRealRoots(
                    1,
                    -2 * t,
                    i * e + t * t - 4 * n,
                    r * n - i * t * e + i * i,
                  );
                if (o.length > 0) {
                  const a = o[0],
                    s = t - a,
                    l = s * s,
                    c = e / 2,
                    u = s / 2,
                    h = l - 4 * n,
                    d = l + 4 * Math.abs(n),
                    p = r - 4 * a,
                    f = r + 4 * Math.abs(a);
                  let m, _, g, y, x, v;
                  if (a < 0 || h * f < p * d) {
                    const t = Math.sqrt(p);
                    (m = t / 2), (_ = 0 === t ? 0 : (e * u - i) / t);
                  } else {
                    const t = Math.sqrt(h);
                    (m = 0 === t ? 0 : (e * u - i) / t), (_ = t / 2);
                  }
                  0 === c && 0 === m
                    ? ((g = 0), (y = 0))
                    : Math.sign(c) === Math.sign(m)
                    ? ((g = c + m), (y = a / g))
                    : ((y = c - m), (g = a / y)),
                    0 === u && 0 === _
                      ? ((x = 0), (v = 0))
                      : Math.sign(u) === Math.sign(_)
                      ? ((x = u + _), (v = n / x))
                      : ((v = u - _), (x = n / v));
                  const w = ss.computeRealRoots(1, g, x),
                    T = ss.computeRealRoots(1, y, v);
                  if (0 !== w.length)
                    return 0 !== T.length
                      ? w[1] <= T[0]
                        ? [w[0], w[1], T[0], T[1]]
                        : T[1] <= w[0]
                        ? [T[0], T[1], w[0], w[1]]
                        : w[0] >= T[0] && w[1] <= T[1]
                        ? [T[0], w[0], w[1], T[1]]
                        : T[0] >= w[0] && T[1] <= w[1]
                        ? [w[0], T[0], T[1], w[1]]
                        : w[0] > T[0] && w[0] < T[1]
                        ? [T[0], w[0], T[1], w[1]]
                        : [w[0], T[0], w[1], T[1]]
                      : w;
                  if (0 !== T.length) return T;
                }
                return [];
              })(o, a, s, l);
            default:
              return;
          }
        },
      },
      ds = {
        rayPlane: function (e, i, n) {
          t(n) || (n = new Pt());
          const r = e.origin,
            o = e.direction,
            a = i.normal,
            s = Pt.dot(a, o);
          if (Math.abs(s) < Me.CesiumMath.EPSILON15) return;
          const l = (-i.distance - Pt.dot(a, r)) / s;
          return l < 0 ? void 0 : ((n = Pt.multiplyByScalar(o, l, n)), Pt.add(r, n, n));
        },
      },
      ps = new Pt(),
      fs = new Pt(),
      ms = new Pt(),
      _s = new Pt(),
      gs = new Pt();
    (ds.rayTriangleParametric = function (e, t, i, n, r) {
      r = Z(r, !1);
      const o = e.origin,
        a = e.direction,
        s = Pt.subtract(i, t, ps),
        l = Pt.subtract(n, t, fs),
        c = Pt.cross(a, l, ms),
        u = Pt.dot(s, c);
      let h, d, p, f, m;
      if (r) {
        if (u < Me.CesiumMath.EPSILON6) return;
        if (((h = Pt.subtract(o, t, _s)), (p = Pt.dot(h, c)), p < 0 || p > u)) return;
        if (((d = Pt.cross(h, s, gs)), (f = Pt.dot(a, d)), f < 0 || p + f > u)) return;
        m = Pt.dot(l, d) / u;
      } else {
        if (Math.abs(u) < Me.CesiumMath.EPSILON6) return;
        const e = 1 / u;
        if (((h = Pt.subtract(o, t, _s)), (p = Pt.dot(h, c) * e), p < 0 || p > 1)) return;
        if (((d = Pt.cross(h, s, gs)), (f = Pt.dot(a, d) * e), f < 0 || p + f > 1)) return;
        m = Pt.dot(l, d) * e;
      }
      return m;
    }),
      (ds.rayTriangle = function (e, i, n, r, o, a) {
        const s = ds.rayTriangleParametric(e, i, n, r, o);
        if (t(s) && !(s < 0))
          return (
            t(a) || (a = new Pt()), Pt.multiplyByScalar(e.direction, s, a), Pt.add(e.origin, a, a)
          );
      });
    const ys = new Ja();
    ds.lineSegmentTriangle = function (e, i, n, r, o, a, s) {
      const l = ys;
      Pt.clone(e, l.origin), Pt.subtract(i, e, l.direction), Pt.normalize(l.direction, l.direction);
      const c = ds.rayTriangleParametric(l, n, r, o, a);
      if (!(!t(c) || c < 0 || c > Pt.distance(e, i)))
        return (
          t(s) || (s = new Pt()), Pt.multiplyByScalar(l.direction, c, s), Pt.add(l.origin, s, s)
        );
    };
    const xs = { root0: 0, root1: 0 };
    function vs(e, i, n) {
      t(n) || (n = { start: 0, stop: 0 });
      const r = e.direction,
        o = i.radius * i.radius,
        a = Pt.subtract(e.origin, i.center, ms),
        s = (function (e, t, i, n) {
          const r = t * t - 4 * e * i;
          if (r < 0) return;
          if (r > 0) {
            const i = 1 / (2 * e),
              o = Math.sqrt(r),
              a = (-t + o) * i,
              s = (-t - o) * i;
            return a < s ? ((n.root0 = a), (n.root1 = s)) : ((n.root0 = s), (n.root1 = a)), n;
          }
          const o = -t / (2 * e);
          return 0 !== o ? ((n.root0 = n.root1 = o), n) : void 0;
        })(Pt.dot(r, r), 2 * Pt.dot(r, a), Pt.magnitudeSquared(a) - o, xs);
      if (t(s)) return (n.start = s.root0), (n.stop = s.root1), n;
    }
    ds.raySphere = function (e, i, n) {
      if (t((n = vs(e, i, n))) && !(n.stop < 0)) return (n.start = Math.max(n.start, 0)), n;
    };
    const ws = new Ja();
    ds.lineSegmentSphere = function (e, i, n, r) {
      const o = ws;
      Pt.clone(e, o.origin);
      const a = Pt.subtract(i, e, o.direction),
        s = Pt.magnitude(a);
      if ((Pt.normalize(a, a), !(!t((r = vs(o, n, r))) || r.stop < 0 || r.start > s)))
        return (r.start = Math.max(r.start, 0)), (r.stop = Math.min(r.stop, s)), r;
    };
    const Ts = new Pt(),
      bs = new Pt();
    function Ss(e, t, i) {
      const n = e + t;
      return Math.sign(e) !== Math.sign(t) && Math.abs(n / Math.max(Math.abs(e), Math.abs(t))) < i
        ? 0
        : n;
    }
    ds.rayEllipsoid = function (e, t) {
      const i = t.oneOverRadii,
        n = Pt.multiplyComponents(i, e.origin, Ts),
        r = Pt.multiplyComponents(i, e.direction, bs),
        o = Pt.magnitudeSquared(n),
        a = Pt.dot(n, r);
      let s, l, c, u, h;
      if (o > 1) {
        if (a >= 0) return;
        const e = a * a;
        if (((s = o - 1), (l = Pt.magnitudeSquared(r)), (c = l * s), e < c)) return;
        if (e > c) {
          (u = a * a - c), (h = -a + Math.sqrt(u));
          const e = h / l,
            t = s / h;
          return e < t ? { start: e, stop: t } : { start: t, stop: e };
        }
        const t = Math.sqrt(s / l);
        return { start: t, stop: t };
      }
      return o < 1
        ? ((s = o - 1),
          (l = Pt.magnitudeSquared(r)),
          (c = l * s),
          (u = a * a - c),
          (h = -a + Math.sqrt(u)),
          { start: 0, stop: h / l })
        : a < 0
        ? ((l = Pt.magnitudeSquared(r)), { start: 0, stop: -a / l })
        : void 0;
    };
    const As = new Pt(),
      Ps = new Pt(),
      Es = new Pt(),
      Cs = new Pt(),
      Ms = new Pt(),
      Is = new je(),
      Ls = new je(),
      Rs = new je(),
      Ns = new je(),
      Os = new je(),
      Ds = new je(),
      Fs = new je(),
      zs = new Pt(),
      Bs = new Pt();
    ds.grazingAltitudeLocation = function (e, i) {
      const n = e.origin,
        r = e.direction;
      if (!Pt.equals(n, Pt.ZERO)) {
        const e = i.geodeticSurfaceNormal(n, As);
        if (Pt.dot(r, e) >= 0) return n;
      }
      const o = t(this.rayEllipsoid(e, i)),
        a = i.transformPositionToScaledSpace(r, As),
        s = Pt.normalize(a, a),
        l = Pt.mostOrthogonalAxis(a, Cs),
        c = Pt.normalize(Pt.cross(l, s, Ps), Ps),
        u = Pt.normalize(Pt.cross(s, c, Es), Es),
        h = Is;
      (h[0] = s.x),
        (h[1] = s.y),
        (h[2] = s.z),
        (h[3] = c.x),
        (h[4] = c.y),
        (h[5] = c.z),
        (h[6] = u.x),
        (h[7] = u.y),
        (h[8] = u.z);
      const d = h.transpose(Ls),
        p = je.fromScale(i.radii, Rs),
        f = je.fromScale(i.oneOverRadii, Ns),
        m = Os;
      (m[0] = 0),
        (m[1] = -r.z),
        (m[2] = r.y),
        (m[3] = r.z),
        (m[4] = 0),
        (m[5] = -r.x),
        (m[6] = -r.y),
        (m[7] = r.x),
        (m[8] = 0);
      const _ = je.multiply(je.multiply(d, f, Ds), m, Ds),
        g = je.multiply(je.multiply(_, p, Fs), h, Fs),
        y = je.multiplyByVector(_, n, Ms),
        x = (function (e, t, i, n, r) {
          const o = 1 * (e[qe.COL1ROW1] - e[qe.COL2ROW2]),
            a = 1 * (0 * Ss(e[qe.COL1ROW0], e[qe.COL0ROW1], Me.CesiumMath.EPSILON15) + t.y),
            s = 0 * e[qe.COL0ROW0] + 1 * e[qe.COL2ROW2] + 0 * t.x + 0,
            l = 1 * Ss(e[qe.COL2ROW1], e[qe.COL1ROW2], Me.CesiumMath.EPSILON15),
            c = 1 * (0 * Ss(e[qe.COL2ROW0], e[qe.COL0ROW2]) + t.z);
          let u;
          const h = [];
          if (0 === c && 0 === l) {
            if (((u = ss.computeRealRoots(o, a, s)), 0 === u.length)) return h;
            const e = u[0],
              t = Math.sqrt(Math.max(1 - e * e, 0));
            if (
              (h.push(new Pt(0, 1 * e, 1 * -t)), h.push(new Pt(0, 1 * e, 1 * t)), 2 === u.length)
            ) {
              const e = u[1],
                t = Math.sqrt(Math.max(1 - e * e, 0));
              h.push(new Pt(0, 1 * e, 1 * -t)), h.push(new Pt(0, 1 * e, 1 * t));
            }
            return h;
          }
          const d = c * c,
            p = l * l,
            f = c * l,
            m = o * o + p,
            _ = 2 * (a * o + f),
            g = 2 * s * o + a * a - p + d,
            y = 2 * (s * a - f);
          if (0 === m && 0 === _ && 0 === g && 0 === y) return h;
          u = hs.computeRealRoots(m, _, g, y, s * s - d);
          const x = u.length;
          if (0 === x) return h;
          for (let e = 0; e < x; ++e) {
            const t = u[e],
              i = t * t,
              n = Math.max(1 - i, 0),
              r = Math.sqrt(n);
            let d;
            d =
              Math.sign(o) === Math.sign(s)
                ? Ss(o * i + s, a * t, Me.CesiumMath.EPSILON12)
                : Math.sign(s) === Math.sign(a * t)
                ? Ss(o * i, a * t + s, Me.CesiumMath.EPSILON12)
                : Ss(o * i + a * t, s, Me.CesiumMath.EPSILON12);
            const p = d * Ss(l * t, c, Me.CesiumMath.EPSILON15);
            p < 0
              ? h.push(new Pt(0, 1 * t, 1 * r))
              : p > 0
              ? h.push(new Pt(0, 1 * t, 1 * -r))
              : 0 !== r
              ? (h.push(new Pt(0, 1 * t, 1 * -r)), h.push(new Pt(0, 1 * t, 1 * r)), ++e)
              : h.push(new Pt(0, 1 * t, 1 * r));
          }
          return h;
        })(g, Pt.negate(y, As));
      let v, w;
      const T = x.length;
      if (T > 0) {
        let e = Pt.clone(Pt.ZERO, Bs),
          t = Number.NEGATIVE_INFINITY;
        for (let i = 0; i < T; ++i) {
          v = je.multiplyByVector(p, je.multiplyByVector(h, x[i], zs), zs);
          const o = Pt.normalize(Pt.subtract(v, n, Cs), Cs),
            a = Pt.dot(o, r);
          a > t && ((t = a), (e = Pt.clone(v, e)));
        }
        const a = new as(),
          s = i.cartesianToCartographic(e, a);
        return (
          (t = se(t, 0, 1)),
          (w = Pt.magnitude(Pt.subtract(e, n, Cs)) * Math.sqrt(1 - t * t)),
          (w = o ? -w : w),
          (s.height = w),
          i.cartographicToCartesianInRadians(s, new Pt())
        );
      }
    };
    const Vs = new Pt();
    function Us(e) {
      const t = ds.rayEllipsoid(e, Il.DefaultEllipsoid);
      if (t) {
        const i = e.origin.clone().add(e.direction.clone().multiplyScalar(t.start));
        return { cartographic: Il.cartesian3ToCartographic(i), cartesian: i };
      }
      return { cartographic: null, cartesian: null };
    }
    function ks(e, t, i, n) {
      const r = n.getCameraPos(),
        o = new Ge((2 * e) / n.width - 1, 1 - (2 * t) / n.height, i, 1);
      return (
        (function (e, t) {
          e.transform(t.activeCamera.projectionMatrixInverse),
            e.scale(1 / e[3]),
            e.transform(t.activeCamera.matrixWorld);
        })(o, n),
        new Pt(o).sub(r).normalize()
      );
    }
    function Gs(e, t, i) {
      if (t < 2) return 18040095.69614729 * (2 - t) + 18040095.69614729;
      if (t <= 24) {
        const n = 1 / Math.tan(e / 2),
          r = 1;
        return (
          i *
          Math.sqrt(Math.pow(n, 2) + Math.pow(r, 2)) *
          Math.sin(Math.PI / Math.pow(2, t) + e / 2)
        );
      }
      return 6378140.582985588 - t + 24;
    }
    function Hs(e, t, i) {
      if (t > 18040095.69614729) return 3 - t / 18040095.69614729;
      if (t < 6378140.582985588) return 6378164.582985588 - t;
      {
        const n = 1 / Math.tan(e / 2),
          r = 1,
          o = t / i / Math.sqrt(Math.pow(n, 2) + Math.pow(r, 2)),
          a = Math.asin(o);
        return Math.log2(Math.PI / (a - e / 2));
      }
    }
    function Ys(e, t, i, n, r, o, a) {
      const s = Math.pow(2, o),
        l = n + e / 8192,
        c = r + t / 8192,
        u = zt(a),
        h = u.xLng(l, s),
        d = u.yLat(c, s);
      return Il.cartographicToCartesian3(new Pt(h, d, i));
    }
    function qs(e, t, i, n) {
      const r = i,
        o = e,
        a = t,
        s = zt(n);
      return [s.xLng(o, r), s.yLat(a, r)];
    }
    function Xs(e, t, i, n, r) {
      const o = qs(e, t, Math.pow(2, i), n);
      return Il.cartographicToCartesian3(new Pt(o[0], o[1], r || 0));
    }
    function js(e, t) {
      const i = t,
        n = new Je();
      return n.translate(i), n;
    }
    function Ws(e, t, i) {
      return (1 - i) * e + i * t;
    }
    function $s(e, t) {
      const i = Gs(t, e[2], Me.TRANSFORM.R) - Me.TRANSFORM.R,
        n = (function (e) {
          const t = new Pt([e.cartographic[0], e.cartographic[1], 0]),
            i = Il.cartographicToCartesian3(t),
            n = Il.localFrameToFixedFrame(i),
            r = new Je()
              .rotateZ(-e.bearing * Me.TRANSFORM.DEG_TO_RAD)
              .rotateY(-e.roll * Me.TRANSFORM.DEG_TO_RAD)
              .rotateX(e.pitch * Me.TRANSFORM.DEG_TO_RAD),
            o = new Pt([0, 0, e.cartographic[2]]).transform(r);
          return (r[12] = o.x), (r[13] = o.y), (r[14] = o.z), n.multiplyRight(r), n;
        })({
          cartographic: [e[0], e[1], i],
          bearing: e[3],
          pitch: e[4],
          roll: e.length > 5 ? e[5] : 0,
        }),
        r = Il.fixedFrameToHeadingPitchRoll(n),
        o = Il.cartesian3ToCartographic(new Pt(n[12], n[13], n[14])),
        a = Hs(t, o[2] + Me.TRANSFORM.R, Me.TRANSFORM.R),
        s = ((l = r.roll), (c = Math.PI / 2), l < 0 ? 0 : l > c ? c : l);
      var l, c;
      const u = le(r.heading, -Math.PI, Math.PI),
        h = le(r.pitch, -Math.PI, Math.PI);
      return [
        o[0],
        o[1],
        a,
        u * Me.TRANSFORM.RAD_TO_DEG,
        s * Me.TRANSFORM.RAD_TO_DEG,
        h * Me.TRANSFORM.RAD_TO_DEG,
        new Pt(o),
      ];
    }
    (ds.lineSegmentPlane = function (e, i, n, r) {
      t(r) || (r = new Pt());
      const o = Pt.subtract(i, e, Vs),
        a = n.normal,
        s = Pt.dot(a, o);
      if (Math.abs(s) < Me.CesiumMath.EPSILON6) return;
      const l = Pt.dot(a, e),
        c = -(n.distance + l) / s;
      return c < 0 || c > 1 ? void 0 : (Pt.multiplyByScalar(o, c, r), Pt.add(e, r, r), r);
    }),
      (ds.trianglePlaneIntersection = function (e, t, i, n) {
        const r = n.normal,
          o = n.distance,
          a = Pt.dot(r, e) + o < 0,
          s = Pt.dot(r, t) + o < 0,
          l = Pt.dot(r, i) + o < 0;
        let c,
          u,
          h = 0;
        if (
          ((h += a ? 1 : 0),
          (h += s ? 1 : 0),
          (h += l ? 1 : 0),
          (1 !== h && 2 !== h) || ((c = new Pt()), (u = new Pt())),
          1 === h)
        ) {
          if (a)
            return (
              ds.lineSegmentPlane(e, t, n, c),
              ds.lineSegmentPlane(e, i, n, u),
              { positions: [e, t, i, c, u], indices: [0, 3, 4, 1, 2, 4, 1, 4, 3] }
            );
          if (s)
            return (
              ds.lineSegmentPlane(t, i, n, c),
              ds.lineSegmentPlane(t, e, n, u),
              { positions: [e, t, i, c, u], indices: [1, 3, 4, 2, 0, 4, 2, 4, 3] }
            );
          if (l)
            return (
              ds.lineSegmentPlane(i, e, n, c),
              ds.lineSegmentPlane(i, t, n, u),
              { positions: [e, t, i, c, u], indices: [2, 3, 4, 0, 1, 4, 0, 4, 3] }
            );
        } else if (2 === h) {
          if (!a)
            return (
              ds.lineSegmentPlane(t, e, n, c),
              ds.lineSegmentPlane(i, e, n, u),
              { positions: [e, t, i, c, u], indices: [1, 2, 4, 1, 4, 3, 0, 3, 4] }
            );
          if (!s)
            return (
              ds.lineSegmentPlane(i, t, n, c),
              ds.lineSegmentPlane(e, t, n, u),
              { positions: [e, t, i, c, u], indices: [2, 0, 4, 2, 4, 3, 1, 3, 4] }
            );
          if (!l)
            return (
              ds.lineSegmentPlane(e, i, n, c),
              ds.lineSegmentPlane(t, i, n, u),
              { positions: [e, t, i, c, u], indices: [0, 1, 4, 0, 4, 3, 2, 3, 4] }
            );
        }
      });
    const Zs = {};
    function Ks(e, t, i) {
      return `Expected ${i} to be typeof ${t}, actual typeof was ${e}`;
    }
    function Qs(e, t, i) {
      Zs.defined('array', e), Zs.defined('itemToFind', t), Zs.defined('comparator', i);
      let n,
        r,
        o = 0,
        a = e.length - 1;
      for (; o <= a; )
        if (((n = ~~((o + a) / 2)), (r = i(e[n], t)), r < 0)) o = n + 1;
        else {
          if (!(r > 0)) return n;
          a = n - 1;
        }
      return ~(a + 1);
    }
    function Js(e, t, i, n, r, o, a, s) {
      (this.year = e),
        (this.month = t),
        (this.day = i),
        (this.hour = n),
        (this.minute = r),
        (this.second = o),
        (this.millisecond = a),
        (this.isLeapSecond = s);
    }
    function el(e) {
      if (null === e || isNaN(e)) throw new Wa('year is required and must be a number.');
      return (e % 4 == 0 && e % 100 != 0) || e % 400 == 0;
    }
    function tl(e, t) {
      (this.julianDate = e), (this.offset = t);
    }
    (Zs.typeOf = {}),
      (Zs.defined = function (e, i) {
        if (!t(i))
          throw new Wa(
            (function (e) {
              return `${e} is required, actual value was undefined`;
            })(e),
          );
      }),
      (Zs.typeOf.func = function (e, t) {
        if ('function' != typeof t) throw new Wa(Ks(typeof t, 'function', e));
      }),
      (Zs.typeOf.string = function (e, t) {
        if ('string' != typeof t) throw new Wa(Ks(typeof t, 'string', e));
      }),
      (Zs.typeOf.number = function (e, t) {
        if ('number' != typeof t) throw new Wa(Ks(typeof t, 'number', e));
      }),
      (Zs.typeOf.number.lessThan = function (e, t, i) {
        if ((Zs.typeOf.number(e, t), t >= i))
          throw new Wa(`Expected ${e} to be less than ${i}, actual value was ${t}`);
      }),
      (Zs.typeOf.number.lessThanOrEquals = function (e, t, i) {
        if ((Zs.typeOf.number(e, t), t > i))
          throw new Wa(`Expected ${e} to be less than or equal to ${i}, actual value was ${t}`);
      }),
      (Zs.typeOf.number.greaterThan = function (e, t, i) {
        if ((Zs.typeOf.number(e, t), t <= i))
          throw new Wa(`Expected ${e} to be greater than ${i}, actual value was ${t}`);
      }),
      (Zs.typeOf.number.greaterThanOrEquals = function (e, t, i) {
        if ((Zs.typeOf.number(e, t), t < i))
          throw new Wa(`Expected ${e} to be greater than or equal to ${i}, actual value was ${t}`);
      }),
      (Zs.typeOf.object = function (e, t) {
        if ('object' != typeof t) throw new Wa(Ks(typeof t, 'object', e));
      }),
      (Zs.typeOf.bool = function (e, t) {
        if ('boolean' != typeof t) throw new Wa(Ks(typeof t, 'boolean', e));
      }),
      (Zs.typeOf.bigint = function (e, t) {
        if ('bigint' != typeof t) throw new Wa(Ks(typeof t, 'bigint', e));
      }),
      (Zs.typeOf.number.equals = function (e, t, i, n) {
        if ((Zs.typeOf.number(e, i), Zs.typeOf.number(t, n), i !== n))
          throw new Wa(`${e} must be equal to ${t}, the actual values are ${i} and ${n}`);
      });
    var il = Object.freeze({
        SECONDS_PER_MILLISECOND: 0.001,
        SECONDS_PER_MINUTE: 60,
        MINUTES_PER_HOUR: 60,
        HOURS_PER_DAY: 24,
        SECONDS_PER_HOUR: 3600,
        MINUTES_PER_DAY: 1440,
        SECONDS_PER_DAY: 86400,
        DAYS_PER_JULIAN_CENTURY: 36525,
        PICOSECOND: 1e-9,
        MODIFIED_JULIAN_DATE_DIFFERENCE: 2400000.5,
      }),
      nl = Object.freeze({ UTC: 0, TAI: 1 });
    const rl = new Js(),
      ol = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function al(e, t) {
      return Tl.compare(e.julianDate, t.julianDate);
    }
    const sl = new tl();
    function ll(e) {
      sl.julianDate = e;
      const t = Tl.leapSeconds;
      let i = Qs(t, sl, al);
      i < 0 && (i = ~i), i >= t.length && (i = t.length - 1);
      let n = t[i].offset;
      i > 0 && Tl.secondsDifference(t[i].julianDate, e) > n && (i--, (n = t[i].offset)),
        Tl.addSeconds(e, n, e);
    }
    function cl(e, t) {
      sl.julianDate = e;
      const i = Tl.leapSeconds;
      let n = Qs(i, sl, al);
      if ((n < 0 && (n = ~n), 0 === n)) return Tl.addSeconds(e, -i[0].offset, t);
      if (n >= i.length) return Tl.addSeconds(e, -i[n - 1].offset, t);
      const r = Tl.secondsDifference(i[n].julianDate, e);
      return 0 === r
        ? Tl.addSeconds(e, -i[n].offset, t)
        : r <= 1
        ? void 0
        : Tl.addSeconds(e, -i[--n].offset, t);
    }
    function ul(e, t, i) {
      const n = (t / il.SECONDS_PER_DAY) | 0;
      return (
        (e += n),
        (t -= il.SECONDS_PER_DAY * n) < 0 && (e--, (t += il.SECONDS_PER_DAY)),
        (i.dayNumber = e),
        (i.secondsOfDay = t),
        i
      );
    }
    function hl(e, t, i, n, r, o, a) {
      const s = ((t - 14) / 12) | 0,
        l = e + 4800 + s;
      let c =
        (((1461 * l) / 4) | 0) +
        (((367 * (t - 2 - 12 * s)) / 12) | 0) -
        (((3 * (((l + 100) / 100) | 0)) / 4) | 0) +
        i -
        32075;
      (n -= 12) < 0 && (n += 24);
      const u =
        o + (n * il.SECONDS_PER_HOUR + r * il.SECONDS_PER_MINUTE + a * il.SECONDS_PER_MILLISECOND);
      return u >= 43200 && (c -= 1), [c, u];
    }
    const dl = /^(\d{4})$/,
      pl = /^(\d{4})-(\d{2})$/,
      fl = /^(\d{4})-?(\d{3})$/,
      ml = /^(\d{4})-?W(\d{2})-?(\d{1})?$/,
      _l = /^(\d{4})-?(\d{2})-?(\d{2})$/,
      gl = /([Z+\-])?(\d{2})?:?(\d{2})?$/,
      yl = /^(\d{2})(\.\d+)?/.source + gl.source,
      xl = /^(\d{2}):?(\d{2})(\.\d+)?/.source + gl.source,
      vl = /^(\d{2}):?(\d{2}):?(\d{2})(\.\d+)?/.source + gl.source,
      wl = 'Invalid ISO 8601 date.';
    function Tl(e, t, i) {
      (this.dayNumber = void 0),
        (this.secondsOfDay = void 0),
        (e = Z(e, 0)),
        (t = Z(t, 0)),
        (i = Z(i, nl.UTC));
      const n = 0 | e;
      ul(n, (t += (e - n) * il.SECONDS_PER_DAY), this), i === nl.UTC && ll(this);
    }
    (Tl.fromGregorianDate = function (e, i) {
      if (!(e instanceof Js)) throw new Wa('date must be a valid GregorianDate.');
      const n = hl(e.year, e.month, e.day, e.hour, e.minute, e.second, e.millisecond);
      return t(i) ? (ul(n[0], n[1], i), ll(i), i) : new Tl(n[0], n[1], nl.UTC);
    }),
      (Tl.fromDate = function (e, i) {
        if (!(e instanceof Date) || isNaN(e.getTime()))
          throw new Wa('date must be a valid JavaScript Date.');
        const n = hl(
          e.getUTCFullYear(),
          e.getUTCMonth() + 1,
          e.getUTCDate(),
          e.getUTCHours(),
          e.getUTCMinutes(),
          e.getUTCSeconds(),
          e.getUTCMilliseconds(),
        );
        return t(i) ? (ul(n[0], n[1], i), ll(i), i) : new Tl(n[0], n[1], nl.UTC);
      }),
      (Tl.fromIso8601 = function (e, i) {
        if ('string' != typeof e) throw new Wa(wl);
        let n,
          r = (e = e.replace(',', '.')).split('T'),
          o = 1,
          a = 1,
          s = 0,
          l = 0,
          c = 0,
          u = 0;
        const h = r[0],
          d = r[1];
        let p, f, m, _;
        if (!t(h)) throw new Wa(wl);
        if (((r = h.match(_l)), null !== r)) {
          if (((m = h.split('-').length - 1), m > 0 && 2 !== m)) throw new Wa(wl);
          (n = +r[1]), (o = +r[2]), (a = +r[3]);
        } else if (((r = h.match(pl)), null !== r)) (n = +r[1]), (o = +r[2]);
        else if (((r = h.match(dl)), null !== r)) n = +r[1];
        else {
          let e;
          if (((r = h.match(fl)), null !== r)) {
            if (((n = +r[1]), (e = +r[2]), (f = el(n)), e < 1 || (f && e > 366) || (!f && e > 365)))
              throw new Wa(wl);
          } else {
            if (((r = h.match(ml)), null === r)) throw new Wa(wl);
            {
              n = +r[1];
              const i = +r[2],
                o = +r[3] || 0;
              if (
                ((m = h.split('-').length - 1),
                m > 0 && ((!t(r[3]) && 1 !== m) || (t(r[3]) && 2 !== m)))
              )
                throw new Wa(wl);
              e = 7 * i + o - new Date(Date.UTC(n, 0, 4)).getUTCDay() - 3;
            }
          }
          (p = new Date(Date.UTC(n, 0, 1))),
            p.setUTCDate(e),
            (o = p.getUTCMonth() + 1),
            (a = p.getUTCDate());
        }
        if (
          ((f = el(n)),
          o < 1 ||
            o > 12 ||
            a < 1 ||
            ((2 !== o || !f) && a > ol[o - 1]) ||
            (f && 2 === o && a > 29))
        )
          throw new Wa(wl);
        if (t(d)) {
          if (((r = d.match(vl)), null !== r)) {
            if (((m = d.split(':').length - 1), m > 0 && 2 !== m && 3 !== m)) throw new Wa(wl);
            (s = +r[1]), (l = +r[2]), (c = +r[3]), (u = 1e3 * +(r[4] || 0)), (_ = 5);
          } else if (((r = d.match(xl)), null !== r)) {
            if (((m = d.split(':').length - 1), m > 2)) throw new Wa(wl);
            (s = +r[1]), (l = +r[2]), (c = 60 * +(r[3] || 0)), (_ = 4);
          } else {
            if (((r = d.match(yl)), null === r)) throw new Wa(wl);
            (s = +r[1]), (l = 60 * +(r[2] || 0)), (_ = 3);
          }
          if (l >= 60 || c >= 61 || s > 24 || (24 === s && (l > 0 || c > 0 || u > 0)))
            throw new Wa(wl);
          const e = +r[_ + 1],
            t = +(r[_ + 2] || 0);
          switch (r[_]) {
            case '+':
              (s -= e), (l -= t);
              break;
            case '-':
              (s += e), (l += t);
              break;
            case 'Z':
              break;
            default:
              l += new Date(Date.UTC(n, o - 1, a, s, l)).getTimezoneOffset();
          }
        }
        const g = 60 === c;
        for (g && c--; l >= 60; ) (l -= 60), s++;
        for (; s >= 24; ) (s -= 24), a++;
        for (p = f && 2 === o ? 29 : ol[o - 1]; a > p; )
          (a -= p), o++, o > 12 && ((o -= 12), n++), (p = f && 2 === o ? 29 : ol[o - 1]);
        for (; l < 0; ) (l += 60), s--;
        for (; s < 0; ) (s += 24), a--;
        for (; a < 1; )
          o--, o < 1 && ((o += 12), n--), (p = f && 2 === o ? 29 : ol[o - 1]), (a += p);
        const y = hl(n, o, a, s, l, c, u);
        return (
          t(i) ? (ul(y[0], y[1], i), ll(i)) : (i = new Tl(y[0], y[1], nl.UTC)),
          g && Tl.addSeconds(i, 1, i),
          i
        );
      }),
      (Tl.now = function (e) {
        return Tl.fromDate(new Date(), e);
      });
    const bl = new Tl(0, 0, nl.TAI);
    (Tl.toGregorianDate = function (e, i) {
      if (!t(e)) throw new Wa('julianDate is required.');
      let n = !1,
        r = cl(e, bl);
      t(r) || (Tl.addSeconds(e, -1, bl), (r = cl(bl, bl)), (n = !0));
      let o = r.dayNumber;
      const a = r.secondsOfDay;
      a >= 43200 && (o += 1);
      let s = (o + 68569) | 0;
      const l = ((4 * s) / 146097) | 0;
      s = (s - (((146097 * l + 3) / 4) | 0)) | 0;
      const c = ((4e3 * (s + 1)) / 1461001) | 0;
      s = (s - (((1461 * c) / 4) | 0) + 31) | 0;
      const u = ((80 * s) / 2447) | 0,
        h = (s - (((2447 * u) / 80) | 0)) | 0;
      s = (u / 11) | 0;
      const d = (u + 2 - 12 * s) | 0,
        p = (100 * (l - 49) + c + s) | 0;
      let f = (a / il.SECONDS_PER_HOUR) | 0,
        m = a - f * il.SECONDS_PER_HOUR;
      const _ = (m / il.SECONDS_PER_MINUTE) | 0;
      m -= _ * il.SECONDS_PER_MINUTE;
      let g = 0 | m;
      const y = (m - g) / il.SECONDS_PER_MILLISECOND;
      return (
        (f += 12),
        f > 23 && (f -= 24),
        n && (g += 1),
        t(i)
          ? ((i.year = p),
            (i.month = d),
            (i.day = h),
            (i.hour = f),
            (i.minute = _),
            (i.second = g),
            (i.millisecond = y),
            (i.isLeapSecond = n),
            i)
          : new Js(p, d, h, f, _, g, y, n)
      );
    }),
      (Tl.toDate = function (e) {
        if (!t(e)) throw new Wa('julianDate is required.');
        const i = Tl.toGregorianDate(e, rl);
        let n = i.second;
        return (
          i.isLeapSecond && (n -= 1),
          new Date(Date.UTC(i.year, i.month - 1, i.day, i.hour, i.minute, n, i.millisecond))
        );
      }),
      (Tl.toIso8601 = function (e, i) {
        if (!t(e)) throw new Wa('julianDate is required.');
        const n = Tl.toGregorianDate(e, rl);
        let r = n.year,
          o = n.month,
          a = n.day,
          s = n.hour;
        const l = n.minute,
          c = n.second,
          u = n.millisecond;
        let h;
        return (
          1e4 === r &&
            1 === o &&
            1 === a &&
            0 === s &&
            0 === l &&
            0 === c &&
            0 === u &&
            ((r = 9999), (o = 12), (a = 31), (s = 24)),
          t(i) || 0 === u
            ? t(i) && 0 !== i
              ? ((h = (0.01 * u).toFixed(i).replace('.', '').slice(0, i)),
                `${r.toString().padStart(4, '0')}-${o.toString().padStart(2, '0')}-${a
                  .toString()
                  .padStart(2, '0')}T${s.toString().padStart(2, '0')}:${l
                  .toString()
                  .padStart(2, '0')}:${c.toString().padStart(2, '0')}.${h}Z`)
              : `${r.toString().padStart(4, '0')}-${o.toString().padStart(2, '0')}-${a
                  .toString()
                  .padStart(2, '0')}T${s.toString().padStart(2, '0')}:${l
                  .toString()
                  .padStart(2, '0')}:${c.toString().padStart(2, '0')}Z`
            : ((h = (0.01 * u).toString().replace('.', '')),
              `${r.toString().padStart(4, '0')}-${o.toString().padStart(2, '0')}-${a
                .toString()
                .padStart(2, '0')}T${s.toString().padStart(2, '0')}:${l
                .toString()
                .padStart(2, '0')}:${c.toString().padStart(2, '0')}.${h}Z`)
        );
      }),
      (Tl.clone = function (e, i) {
        if (t(e))
          return t(i)
            ? ((i.dayNumber = e.dayNumber), (i.secondsOfDay = e.secondsOfDay), i)
            : new Tl(e.dayNumber, e.secondsOfDay, nl.TAI);
      }),
      (Tl.compare = function (e, i) {
        if (!t(e)) throw new Wa('left is required.');
        if (!t(i)) throw new Wa('right is required.');
        const n = e.dayNumber - i.dayNumber;
        return 0 !== n ? n : e.secondsOfDay - i.secondsOfDay;
      }),
      (Tl.equals = function (e, i) {
        return (
          e === i ||
          (t(e) && t(i) && e.dayNumber === i.dayNumber && e.secondsOfDay === i.secondsOfDay)
        );
      }),
      (Tl.equalsEpsilon = function (e, i, n) {
        return (
          (n = Z(n, 0)), e === i || (t(e) && t(i) && Math.abs(Tl.secondsDifference(e, i)) <= n)
        );
      }),
      (Tl.totalDays = function (e) {
        if (!t(e)) throw new Wa('julianDate is required.');
        return e.dayNumber + e.secondsOfDay / il.SECONDS_PER_DAY;
      }),
      (Tl.secondsDifference = function (e, i) {
        if (!t(e)) throw new Wa('left is required.');
        if (!t(i)) throw new Wa('right is required.');
        return (e.dayNumber - i.dayNumber) * il.SECONDS_PER_DAY + (e.secondsOfDay - i.secondsOfDay);
      }),
      (Tl.daysDifference = function (e, i) {
        if (!t(e)) throw new Wa('left is required.');
        if (!t(i)) throw new Wa('right is required.');
        return e.dayNumber - i.dayNumber + (e.secondsOfDay - i.secondsOfDay) / il.SECONDS_PER_DAY;
      }),
      (Tl.computeTaiMinusUtc = function (e) {
        sl.julianDate = e;
        const t = Tl.leapSeconds;
        let i = Qs(t, sl, al);
        return i < 0 && ((i = ~i), --i, i < 0 && (i = 0)), t[i].offset;
      }),
      (Tl.addSeconds = function (e, i, n) {
        if (!t(e)) throw new Wa('julianDate is required.');
        if (!t(i)) throw new Wa('seconds is required.');
        if (!t(n)) throw new Wa('result is required.');
        return ul(e.dayNumber, e.secondsOfDay + i, n);
      }),
      (Tl.addMinutes = function (e, i, n) {
        if (!t(e)) throw new Wa('julianDate is required.');
        if (!t(i)) throw new Wa('minutes is required.');
        if (!t(n)) throw new Wa('result is required.');
        return ul(e.dayNumber, e.secondsOfDay + i * il.SECONDS_PER_MINUTE, n);
      }),
      (Tl.addHours = function (e, i, n) {
        if (!t(e)) throw new Wa('julianDate is required.');
        if (!t(i)) throw new Wa('hours is required.');
        if (!t(n)) throw new Wa('result is required.');
        return ul(e.dayNumber, e.secondsOfDay + i * il.SECONDS_PER_HOUR, n);
      }),
      (Tl.addDays = function (e, i, n) {
        if (!t(e)) throw new Wa('julianDate is required.');
        if (!t(i)) throw new Wa('days is required.');
        if (!t(n)) throw new Wa('result is required.');
        return ul(e.dayNumber + i, e.secondsOfDay, n);
      }),
      (Tl.lessThan = function (e, t) {
        return Tl.compare(e, t) < 0;
      }),
      (Tl.lessThanOrEquals = function (e, t) {
        return Tl.compare(e, t) <= 0;
      }),
      (Tl.greaterThan = function (e, t) {
        return Tl.compare(e, t) > 0;
      }),
      (Tl.greaterThanOrEquals = function (e, t) {
        return Tl.compare(e, t) >= 0;
      }),
      (Tl.prototype.clone = function (e) {
        return Tl.clone(this, e);
      }),
      (Tl.prototype.equals = function (e) {
        return Tl.equals(this, e);
      }),
      (Tl.prototype.equalsEpsilon = function (e, t) {
        return Tl.equalsEpsilon(this, e, t);
      }),
      (Tl.prototype.toString = function () {
        return Tl.toIso8601(this);
      }),
      (Tl.leapSeconds = [
        new tl(new Tl(2441317, 43210, nl.TAI), 10),
        new tl(new Tl(2441499, 43211, nl.TAI), 11),
        new tl(new Tl(2441683, 43212, nl.TAI), 12),
        new tl(new Tl(2442048, 43213, nl.TAI), 13),
        new tl(new Tl(2442413, 43214, nl.TAI), 14),
        new tl(new Tl(2442778, 43215, nl.TAI), 15),
        new tl(new Tl(2443144, 43216, nl.TAI), 16),
        new tl(new Tl(2443509, 43217, nl.TAI), 17),
        new tl(new Tl(2443874, 43218, nl.TAI), 18),
        new tl(new Tl(2444239, 43219, nl.TAI), 19),
        new tl(new Tl(2444786, 43220, nl.TAI), 20),
        new tl(new Tl(2445151, 43221, nl.TAI), 21),
        new tl(new Tl(2445516, 43222, nl.TAI), 22),
        new tl(new Tl(2446247, 43223, nl.TAI), 23),
        new tl(new Tl(2447161, 43224, nl.TAI), 24),
        new tl(new Tl(2447892, 43225, nl.TAI), 25),
        new tl(new Tl(2448257, 43226, nl.TAI), 26),
        new tl(new Tl(2448804, 43227, nl.TAI), 27),
        new tl(new Tl(2449169, 43228, nl.TAI), 28),
        new tl(new Tl(2449534, 43229, nl.TAI), 29),
        new tl(new Tl(2450083, 43230, nl.TAI), 30),
        new tl(new Tl(2450630, 43231, nl.TAI), 31),
        new tl(new Tl(2451179, 43232, nl.TAI), 32),
        new tl(new Tl(2453736, 43233, nl.TAI), 33),
        new tl(new Tl(2454832, 43234, nl.TAI), 34),
        new tl(new Tl(2456109, 43235, nl.TAI), 35),
        new tl(new Tl(2457204, 43236, nl.TAI), 36),
        new tl(new Tl(2457754, 43237, nl.TAI), 37),
      ]);
    const Sl = wt.RegularEllipsoid,
      Al = wt.WGS84,
      Pl = wt.WGS84,
      El = (2 * Math.PI) / 86400;
    let Cl = new Tl();
    const Ml = {
      WGS84Ellipsoid: Al,
      RegularEllipsoid: Sl,
      DefaultEllipsoid: Pl,
      cartesian3ToCartographic: (e, t = Pl) => t.cartesianToCartographic(e),
      cartographicToCartesian3: (e, t = Pl) => t.cartographicToCartesian(e),
      cartographicToFixedFrame(e, t = Pl) {
        const i = t.cartographicToCartesian(e);
        return t.eastNorthUpToFixedFrame(i);
      },
      cartesianToFixedFrame: (e, t = Pl) => t.eastNorthUpToFixedFrame(e),
      localFrameToFixedFrame: (e, t = Pl) => t.eastNorthUpToFixedFrame(e),
      headingPitchRollToFixedFrame(e, t, i = Pl) {
        const n = new It();
        return (
          n.fromHeadingPitchRoll(t),
          Ml.localFrameToFixedFrame(e, i).multiplyRight(n.getRotationMatrix())
        );
      },
      fixedFrameToHeadingPitchRoll(e, t = Pl) {
        const i = e.getTranslation(),
          n = Ml.localFrameToFixedFrame(i, t).invert(),
          r = e.clone().setTranslation([0, 0, 0]);
        n.multiplyRight(r);
        const o = new Et().fromRotationMatrix4(n.extractRotation());
        return o.normalize(), Le.fromQuaternion(o);
      },
      computeTemeToPseudoFixedMatrix(e, i) {
        (e = Tl.fromDate(e)), (Cl = Tl.addSeconds(e, -Tl.computeTaiMinusUtc(e), Cl));
        const n = Cl.dayNumber,
          r = Cl.secondsOfDay;
        let o;
        const a = n - 2451545;
        o =
          r >= 43200
            ? (a + 0.5) / il.DAYS_PER_JULIAN_CENTURY
            : (a - 0.5) / il.DAYS_PER_JULIAN_CENTURY;
        const s =
            (((24110.54841 + o * (8640184.812866 + o * (0.093104 + -62e-7 * o))) * El) %
              (2 * Math.PI)) +
            ((r + 0.5 * il.SECONDS_PER_DAY) % il.SECONDS_PER_DAY) *
              (72921158553e-15 + 11772758384668e-32 * (n - 2451545.5)),
          l = Math.cos(s),
          c = Math.sin(s);
        return t(i)
          ? ((i[0] = l),
            (i[1] = -c),
            (i[2] = 0),
            (i[3] = 0),
            (i[4] = c),
            (i[5] = l),
            (i[6] = 0),
            (i[7] = 0),
            (i[8] = 0),
            (i[9] = 0),
            (i[10] = 1),
            (i[11] = 0),
            (i[12] = 0),
            (i[13] = 0),
            (i[14] = 0),
            (i[15] = 1),
            i)
          : new Je([l, c, 0, 0, -c, l, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      },
      pointToWindowCoordinates(e, t, i) {
        const n = i.clone().transformAsPoint(e);
        return n.transformAsPoint(t), new $e(n);
      },
      pointToGLWindowCoordinates(e, t) {
        const i = t.clone().transformAsPoint(e);
        return new Pt(i);
      },
      eastNorthUpToFixedFrame: (e, t = Pl) => t.eastNorthUpToFixedFrame(e),
      rotationMatrixFromPositionVelocity(e, i, n = Pl, r) {
        const o = new Pt(),
          a = new Pt(),
          s = new Pt(),
          l = Z(n, Pl).geodeticSurfaceNormal(e, o);
        let c = Pt.cross(i, l, a);
        Pt.equalsEpsilon(c, Pt.ZERO, Me.TRANSFORM.EPSILON6) && (c = Pt.clone(Pt.UNIT_X, c));
        const u = Pt.cross(c, i, s);
        return (
          Pt.normalize(u, u),
          Pt.cross(i, u, c),
          Pt.negate(c, c),
          Pt.normalize(c, c),
          t(r) || (r = new je()),
          (r[0] = i.x),
          (r[1] = i.y),
          (r[2] = i.z),
          (r[3] = c.x),
          (r[4] = c.y),
          (r[5] = c.z),
          (r[6] = u.x),
          (r[7] = u.y),
          (r[8] = u.z),
          r
        );
      },
      convertV34Pos2V4: (e) => $s(e, Me.TRANSFORM.FOV_IN_RADIANS),
      convertMapCenterOptions2CameraPositionOptions: (e) => Ml.convertV34Pos2V4(e),
      convertV4Pos2V34: (e) =>
        (function (e, t) {
          const i = Gs(t, e[2], Me.TRANSFORM.R) - Me.TRANSFORM.R,
            n = Pt.fromDegrees(e[0], e[1], i),
            r = Il.headingPitchRollToFixedFrame(
              n,
              new Le(
                e[3] * Me.TRANSFORM.DEG_TO_RAD,
                e[4] * Me.TRANSFORM.DEG_TO_RAD,
                e[5] * Me.TRANSFORM.DEG_TO_RAD,
              ),
            ),
            o = Us(
              new Ja(
                [r[12], r[13], r[14]],
                new Pt(r[8], r[9], r[10]).normalize().multiplyScalar(-1),
              ),
            ),
            a = o.cartographic,
            s = o.cartesian;
          if (!a) return;
          const l = Il.localFrameToFixedFrame(o.cartesian).invert().multiplyRight(r),
            c = new je();
          (c[0] = l[0]),
            (c[1] = l[1]),
            (c[2] = l[2]),
            (c[3] = l[4]),
            (c[4] = l[5]),
            (c[5] = l[6]),
            (c[6] = l[8]),
            (c[7] = l[9]),
            (c[8] = l[10]);
          const u = new Et();
          u.fromMatrix3(c);
          const h = Le.fromQuaternion(u);
          let d = h.heading * Me.TRANSFORM.RAD_TO_DEG;
          Math.abs(e[3] - d) < 0.01 && (d = e[3]);
          const p = h.roll * Me.TRANSFORM.RAD_TO_DEG,
            f = h.pitch * Me.TRANSFORM.RAD_TO_DEG,
            m = Hs(
              t,
              new Pt(r[12] - s[0], r[13] - s[1], r[14] - s[2]).len() + Me.TRANSFORM.R,
              Me.TRANSFORM.R,
            );
          return [a[0], a[1], m, d, p, f];
        })(e, Me.TRANSFORM.FOV_IN_RADIANS),
      convertCameraPositionOptions2MapCenterOptions: (e) => Ml.convertV4Pos2V34(e),
      convertMapCenterFromCameraPosition: (e) =>
        (function (e) {
          const t = Il.cartographicToFixedFrame(e);
          return Us(
            new Ja([t[12], t[13], t[14]], new Pt(t[8], t[9], t[10]).normalize().multiplyScalar(-1)),
          );
        })(e),
      convertMapCenterFromCameraCartesian3Position: (e) =>
        (function (e) {
          const t = Il.localFrameToFixedFrame(e);
          return Us(
            new Ja([t[12], t[13], t[14]], new Pt(t[8], t[9], t[10]).normalize().multiplyScalar(-1)),
          );
        })(e),
    };
    var Il = Ml,
      Ll = Object.freeze({
        DEPTH_BUFFER_BIT: 256,
        STENCIL_BUFFER_BIT: 1024,
        COLOR_BUFFER_BIT: 16384,
        POINTS: 0,
        LINES: 1,
        LINE_LOOP: 2,
        LINE_STRIP: 3,
        TRIANGLES: 4,
        TRIANGLE_STRIP: 5,
        TRIANGLE_FAN: 6,
        ZERO: 0,
        ONE: 1,
        SRC_COLOR: 768,
        ONE_MINUS_SRC_COLOR: 769,
        SRC_ALPHA: 770,
        ONE_MINUS_SRC_ALPHA: 771,
        DST_ALPHA: 772,
        ONE_MINUS_DST_ALPHA: 773,
        DST_COLOR: 774,
        ONE_MINUS_DST_COLOR: 775,
        SRC_ALPHA_SATURATE: 776,
        FUNC_ADD: 32774,
        BLEND_EQUATION: 32777,
        BLEND_EQUATION_RGB: 32777,
        BLEND_EQUATION_ALPHA: 34877,
        FUNC_SUBTRACT: 32778,
        FUNC_REVERSE_SUBTRACT: 32779,
        BLEND_DST_RGB: 32968,
        BLEND_SRC_RGB: 32969,
        BLEND_DST_ALPHA: 32970,
        BLEND_SRC_ALPHA: 32971,
        CONSTANT_COLOR: 32769,
        ONE_MINUS_CONSTANT_COLOR: 32770,
        CONSTANT_ALPHA: 32771,
        ONE_MINUS_CONSTANT_ALPHA: 32772,
        BLEND_COLOR: 32773,
        ARRAY_BUFFER: 34962,
        ELEMENT_ARRAY_BUFFER: 34963,
        ARRAY_BUFFER_BINDING: 34964,
        ELEMENT_ARRAY_BUFFER_BINDING: 34965,
        STREAM_DRAW: 35040,
        STATIC_DRAW: 35044,
        DYNAMIC_DRAW: 35048,
        BUFFER_SIZE: 34660,
        BUFFER_USAGE: 34661,
        CURRENT_VERTEX_ATTRIB: 34342,
        FRONT: 1028,
        BACK: 1029,
        FRONT_AND_BACK: 1032,
        CULL_FACE: 2884,
        BLEND: 3042,
        DITHER: 3024,
        STENCIL_TEST: 2960,
        DEPTH_TEST: 2929,
        SCISSOR_TEST: 3089,
        POLYGON_OFFSET_FILL: 32823,
        SAMPLE_ALPHA_TO_COVERAGE: 32926,
        SAMPLE_COVERAGE: 32928,
        NO_ERROR: 0,
        INVALID_ENUM: 1280,
        INVALID_VALUE: 1281,
        INVALID_OPERATION: 1282,
        OUT_OF_MEMORY: 1285,
        CW: 2304,
        CCW: 2305,
        LINE_WIDTH: 2849,
        ALIASED_POINT_SIZE_RANGE: 33901,
        ALIASED_LINE_WIDTH_RANGE: 33902,
        CULL_FACE_MODE: 2885,
        FRONT_FACE: 2886,
        DEPTH_RANGE: 2928,
        DEPTH_WRITEMASK: 2930,
        DEPTH_CLEAR_VALUE: 2931,
        DEPTH_FUNC: 2932,
        STENCIL_CLEAR_VALUE: 2961,
        STENCIL_FUNC: 2962,
        STENCIL_FAIL: 2964,
        STENCIL_PASS_DEPTH_FAIL: 2965,
        STENCIL_PASS_DEPTH_PASS: 2966,
        STENCIL_REF: 2967,
        STENCIL_VALUE_MASK: 2963,
        STENCIL_WRITEMASK: 2968,
        STENCIL_BACK_FUNC: 34816,
        STENCIL_BACK_FAIL: 34817,
        STENCIL_BACK_PASS_DEPTH_FAIL: 34818,
        STENCIL_BACK_PASS_DEPTH_PASS: 34819,
        STENCIL_BACK_REF: 36003,
        STENCIL_BACK_VALUE_MASK: 36004,
        STENCIL_BACK_WRITEMASK: 36005,
        VIEWPORT: 2978,
        SCISSOR_BOX: 3088,
        COLOR_CLEAR_VALUE: 3106,
        COLOR_WRITEMASK: 3107,
        UNPACK_ALIGNMENT: 3317,
        PACK_ALIGNMENT: 3333,
        MAX_TEXTURE_SIZE: 3379,
        MAX_VIEWPORT_DIMS: 3386,
        SUBPIXEL_BITS: 3408,
        RED_BITS: 3410,
        GREEN_BITS: 3411,
        BLUE_BITS: 3412,
        ALPHA_BITS: 3413,
        DEPTH_BITS: 3414,
        STENCIL_BITS: 3415,
        POLYGON_OFFSET_UNITS: 10752,
        POLYGON_OFFSET_FACTOR: 32824,
        TEXTURE_BINDING_2D: 32873,
        SAMPLE_BUFFERS: 32936,
        SAMPLES: 32937,
        SAMPLE_COVERAGE_VALUE: 32938,
        SAMPLE_COVERAGE_INVERT: 32939,
        COMPRESSED_TEXTURE_FORMATS: 34467,
        DONT_CARE: 4352,
        FASTEST: 4353,
        NICEST: 4354,
        GENERATE_MIPMAP_HINT: 33170,
        BYTE: 5120,
        UNSIGNED_BYTE: 5121,
        SHORT: 5122,
        UNSIGNED_SHORT: 5123,
        INT: 5124,
        UNSIGNED_INT: 5125,
        FLOAT: 5126,
        DEPTH_COMPONENT: 6402,
        ALPHA: 6406,
        RGB: 6407,
        RGBA: 6408,
        LUMINANCE: 6409,
        LUMINANCE_ALPHA: 6410,
        UNSIGNED_SHORT_4_4_4_4: 32819,
        UNSIGNED_SHORT_5_5_5_1: 32820,
        UNSIGNED_SHORT_5_6_5: 33635,
        FRAGMENT_SHADER: 35632,
        VERTEX_SHADER: 35633,
        MAX_VERTEX_ATTRIBS: 34921,
        MAX_VERTEX_UNIFORM_VECTORS: 36347,
        MAX_VARYING_VECTORS: 36348,
        MAX_COMBINED_TEXTURE_IMAGE_UNITS: 35661,
        MAX_VERTEX_TEXTURE_IMAGE_UNITS: 35660,
        MAX_TEXTURE_IMAGE_UNITS: 34930,
        MAX_FRAGMENT_UNIFORM_VECTORS: 36349,
        SHADER_TYPE: 35663,
        DELETE_STATUS: 35712,
        LINK_STATUS: 35714,
        VALIDATE_STATUS: 35715,
        ATTACHED_SHADERS: 35717,
        ACTIVE_UNIFORMS: 35718,
        ACTIVE_ATTRIBUTES: 35721,
        SHADING_LANGUAGE_VERSION: 35724,
        CURRENT_PROGRAM: 35725,
        NEVER: 512,
        LESS: 513,
        EQUAL: 514,
        LEQUAL: 515,
        GREATER: 516,
        NOTEQUAL: 517,
        GEQUAL: 518,
        ALWAYS: 519,
        KEEP: 7680,
        REPLACE: 7681,
        INCR: 7682,
        DECR: 7683,
        INVERT: 5386,
        INCR_WRAP: 34055,
        DECR_WRAP: 34056,
        VENDOR: 7936,
        RENDERER: 7937,
        VERSION: 7938,
        NEAREST: 9728,
        LINEAR: 9729,
        NEAREST_MIPMAP_NEAREST: 9984,
        LINEAR_MIPMAP_NEAREST: 9985,
        NEAREST_MIPMAP_LINEAR: 9986,
        LINEAR_MIPMAP_LINEAR: 9987,
        TEXTURE_MAG_FILTER: 10240,
        TEXTURE_MIN_FILTER: 10241,
        TEXTURE_WRAP_S: 10242,
        TEXTURE_WRAP_T: 10243,
        TEXTURE_2D: 3553,
        TEXTURE: 5890,
        TEXTURE_CUBE_MAP: 34067,
        TEXTURE_BINDING_CUBE_MAP: 34068,
        TEXTURE_CUBE_MAP_POSITIVE_X: 34069,
        TEXTURE_CUBE_MAP_NEGATIVE_X: 34070,
        TEXTURE_CUBE_MAP_POSITIVE_Y: 34071,
        TEXTURE_CUBE_MAP_NEGATIVE_Y: 34072,
        TEXTURE_CUBE_MAP_POSITIVE_Z: 34073,
        TEXTURE_CUBE_MAP_NEGATIVE_Z: 34074,
        MAX_CUBE_MAP_TEXTURE_SIZE: 34076,
        TEXTURE0: 33984,
        TEXTURE1: 33985,
        TEXTURE2: 33986,
        TEXTURE3: 33987,
        TEXTURE4: 33988,
        TEXTURE5: 33989,
        TEXTURE6: 33990,
        TEXTURE7: 33991,
        TEXTURE8: 33992,
        TEXTURE9: 33993,
        TEXTURE10: 33994,
        TEXTURE11: 33995,
        TEXTURE12: 33996,
        TEXTURE13: 33997,
        TEXTURE14: 33998,
        TEXTURE15: 33999,
        TEXTURE16: 34e3,
        TEXTURE17: 34001,
        TEXTURE18: 34002,
        TEXTURE19: 34003,
        TEXTURE20: 34004,
        TEXTURE21: 34005,
        TEXTURE22: 34006,
        TEXTURE23: 34007,
        TEXTURE24: 34008,
        TEXTURE25: 34009,
        TEXTURE26: 34010,
        TEXTURE27: 34011,
        TEXTURE28: 34012,
        TEXTURE29: 34013,
        TEXTURE30: 34014,
        TEXTURE31: 34015,
        ACTIVE_TEXTURE: 34016,
        REPEAT: 10497,
        CLAMP_TO_EDGE: 33071,
        MIRRORED_REPEAT: 33648,
        FLOAT_VEC2: 35664,
        FLOAT_VEC3: 35665,
        FLOAT_VEC4: 35666,
        INT_VEC2: 35667,
        INT_VEC3: 35668,
        INT_VEC4: 35669,
        BOOL: 35670,
        BOOL_VEC2: 35671,
        BOOL_VEC3: 35672,
        BOOL_VEC4: 35673,
        FLOAT_MAT2: 35674,
        FLOAT_MAT3: 35675,
        FLOAT_MAT4: 35676,
        SAMPLER_2D: 35678,
        SAMPLER_CUBE: 35680,
        VERTEX_ATTRIB_ARRAY_ENABLED: 34338,
        VERTEX_ATTRIB_ARRAY_SIZE: 34339,
        VERTEX_ATTRIB_ARRAY_STRIDE: 34340,
        VERTEX_ATTRIB_ARRAY_TYPE: 34341,
        VERTEX_ATTRIB_ARRAY_NORMALIZED: 34922,
        VERTEX_ATTRIB_ARRAY_POINTER: 34373,
        VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 34975,
        IMPLEMENTATION_COLOR_READ_TYPE: 35738,
        IMPLEMENTATION_COLOR_READ_FORMAT: 35739,
        COMPILE_STATUS: 35713,
        LOW_FLOAT: 36336,
        MEDIUM_FLOAT: 36337,
        HIGH_FLOAT: 36338,
        LOW_INT: 36339,
        MEDIUM_INT: 36340,
        HIGH_INT: 36341,
        FRAMEBUFFER: 36160,
        RENDERBUFFER: 36161,
        RGBA4: 32854,
        RGB5_A1: 32855,
        RGB565: 36194,
        DEPTH_COMPONENT16: 33189,
        STENCIL_INDEX: 6401,
        STENCIL_INDEX8: 36168,
        DEPTH_STENCIL: 34041,
        RENDERBUFFER_WIDTH: 36162,
        RENDERBUFFER_HEIGHT: 36163,
        RENDERBUFFER_INTERNAL_FORMAT: 36164,
        RENDERBUFFER_RED_SIZE: 36176,
        RENDERBUFFER_GREEN_SIZE: 36177,
        RENDERBUFFER_BLUE_SIZE: 36178,
        RENDERBUFFER_ALPHA_SIZE: 36179,
        RENDERBUFFER_DEPTH_SIZE: 36180,
        RENDERBUFFER_STENCIL_SIZE: 36181,
        FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 36048,
        FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 36049,
        FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 36050,
        FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 36051,
        COLOR_ATTACHMENT0: 36064,
        DEPTH_ATTACHMENT: 36096,
        STENCIL_ATTACHMENT: 36128,
        DEPTH_STENCIL_ATTACHMENT: 33306,
        NONE: 0,
        FRAMEBUFFER_COMPLETE: 36053,
        FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 36054,
        FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 36055,
        FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 36057,
        FRAMEBUFFER_UNSUPPORTED: 36061,
        FRAMEBUFFER_BINDING: 36006,
        RENDERBUFFER_BINDING: 36007,
        MAX_RENDERBUFFER_SIZE: 34024,
        INVALID_FRAMEBUFFER_OPERATION: 1286,
        UNPACK_FLIP_Y_WEBGL: 37440,
        UNPACK_PREMULTIPLY_ALPHA_WEBGL: 37441,
        CONTEXT_LOST_WEBGL: 37442,
        UNPACK_COLORSPACE_CONVERSION_WEBGL: 37443,
        BROWSER_DEFAULT_WEBGL: 37444,
        COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,
        COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777,
        COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778,
        COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,
        COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,
        COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841,
        COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,
        COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843,
        COMPRESSED_RGBA_ASTC_4x4_WEBGL: 37808,
        COMPRESSED_RGB_ETC1_WEBGL: 36196,
        COMPRESSED_RGBA_BPTC_UNORM: 36492,
        HALF_FLOAT_OES: 36193,
        DOUBLE: 5130,
        READ_BUFFER: 3074,
        UNPACK_ROW_LENGTH: 3314,
        UNPACK_SKIP_ROWS: 3315,
        UNPACK_SKIP_PIXELS: 3316,
        PACK_ROW_LENGTH: 3330,
        PACK_SKIP_ROWS: 3331,
        PACK_SKIP_PIXELS: 3332,
        COLOR: 6144,
        DEPTH: 6145,
        STENCIL: 6146,
        RED: 6403,
        RGB8: 32849,
        RGBA8: 32856,
        RGB10_A2: 32857,
        TEXTURE_BINDING_3D: 32874,
        UNPACK_SKIP_IMAGES: 32877,
        UNPACK_IMAGE_HEIGHT: 32878,
        TEXTURE_3D: 32879,
        TEXTURE_WRAP_R: 32882,
        MAX_3D_TEXTURE_SIZE: 32883,
        UNSIGNED_INT_2_10_10_10_REV: 33640,
        MAX_ELEMENTS_VERTICES: 33e3,
        MAX_ELEMENTS_INDICES: 33001,
        TEXTURE_MIN_LOD: 33082,
        TEXTURE_MAX_LOD: 33083,
        TEXTURE_BASE_LEVEL: 33084,
        TEXTURE_MAX_LEVEL: 33085,
        MIN: 32775,
        MAX: 32776,
        DEPTH_COMPONENT24: 33190,
        MAX_TEXTURE_LOD_BIAS: 34045,
        TEXTURE_COMPARE_MODE: 34892,
        TEXTURE_COMPARE_FUNC: 34893,
        CURRENT_QUERY: 34917,
        QUERY_RESULT: 34918,
        QUERY_RESULT_AVAILABLE: 34919,
        STREAM_READ: 35041,
        STREAM_COPY: 35042,
        STATIC_READ: 35045,
        STATIC_COPY: 35046,
        DYNAMIC_READ: 35049,
        DYNAMIC_COPY: 35050,
        MAX_DRAW_BUFFERS: 34852,
        DRAW_BUFFER0: 34853,
        DRAW_BUFFER1: 34854,
        DRAW_BUFFER2: 34855,
        DRAW_BUFFER3: 34856,
        DRAW_BUFFER4: 34857,
        DRAW_BUFFER5: 34858,
        DRAW_BUFFER6: 34859,
        DRAW_BUFFER7: 34860,
        DRAW_BUFFER8: 34861,
        DRAW_BUFFER9: 34862,
        DRAW_BUFFER10: 34863,
        DRAW_BUFFER11: 34864,
        DRAW_BUFFER12: 34865,
        DRAW_BUFFER13: 34866,
        DRAW_BUFFER14: 34867,
        DRAW_BUFFER15: 34868,
        MAX_FRAGMENT_UNIFORM_COMPONENTS: 35657,
        MAX_VERTEX_UNIFORM_COMPONENTS: 35658,
        SAMPLER_3D: 35679,
        SAMPLER_2D_SHADOW: 35682,
        FRAGMENT_SHADER_DERIVATIVE_HINT: 35723,
        PIXEL_PACK_BUFFER: 35051,
        PIXEL_UNPACK_BUFFER: 35052,
        PIXEL_PACK_BUFFER_BINDING: 35053,
        PIXEL_UNPACK_BUFFER_BINDING: 35055,
        FLOAT_MAT2x3: 35685,
        FLOAT_MAT2x4: 35686,
        FLOAT_MAT3x2: 35687,
        FLOAT_MAT3x4: 35688,
        FLOAT_MAT4x2: 35689,
        FLOAT_MAT4x3: 35690,
        SRGB: 35904,
        SRGB8: 35905,
        SRGB8_ALPHA8: 35907,
        COMPARE_REF_TO_TEXTURE: 34894,
        RGBA32F: 34836,
        RGB32F: 34837,
        RGBA16F: 34842,
        RGB16F: 34843,
        VERTEX_ATTRIB_ARRAY_INTEGER: 35069,
        MAX_ARRAY_TEXTURE_LAYERS: 35071,
        MIN_PROGRAM_TEXEL_OFFSET: 35076,
        MAX_PROGRAM_TEXEL_OFFSET: 35077,
        MAX_VARYING_COMPONENTS: 35659,
        TEXTURE_2D_ARRAY: 35866,
        TEXTURE_BINDING_2D_ARRAY: 35869,
        R11F_G11F_B10F: 35898,
        UNSIGNED_INT_10F_11F_11F_REV: 35899,
        RGB9_E5: 35901,
        UNSIGNED_INT_5_9_9_9_REV: 35902,
        TRANSFORM_FEEDBACK_BUFFER_MODE: 35967,
        MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: 35968,
        TRANSFORM_FEEDBACK_VARYINGS: 35971,
        TRANSFORM_FEEDBACK_BUFFER_START: 35972,
        TRANSFORM_FEEDBACK_BUFFER_SIZE: 35973,
        TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: 35976,
        RASTERIZER_DISCARD: 35977,
        MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: 35978,
        MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: 35979,
        INTERLEAVED_ATTRIBS: 35980,
        SEPARATE_ATTRIBS: 35981,
        TRANSFORM_FEEDBACK_BUFFER: 35982,
        TRANSFORM_FEEDBACK_BUFFER_BINDING: 35983,
        RGBA32UI: 36208,
        RGB32UI: 36209,
        RGBA16UI: 36214,
        RGB16UI: 36215,
        RGBA8UI: 36220,
        RGB8UI: 36221,
        RGBA32I: 36226,
        RGB32I: 36227,
        RGBA16I: 36232,
        RGB16I: 36233,
        RGBA8I: 36238,
        RGB8I: 36239,
        RED_INTEGER: 36244,
        RGB_INTEGER: 36248,
        RGBA_INTEGER: 36249,
        SAMPLER_2D_ARRAY: 36289,
        SAMPLER_2D_ARRAY_SHADOW: 36292,
        SAMPLER_CUBE_SHADOW: 36293,
        UNSIGNED_INT_VEC2: 36294,
        UNSIGNED_INT_VEC3: 36295,
        UNSIGNED_INT_VEC4: 36296,
        INT_SAMPLER_2D: 36298,
        INT_SAMPLER_3D: 36299,
        INT_SAMPLER_CUBE: 36300,
        INT_SAMPLER_2D_ARRAY: 36303,
        UNSIGNED_INT_SAMPLER_2D: 36306,
        UNSIGNED_INT_SAMPLER_3D: 36307,
        UNSIGNED_INT_SAMPLER_CUBE: 36308,
        UNSIGNED_INT_SAMPLER_2D_ARRAY: 36311,
        DEPTH_COMPONENT32F: 36012,
        DEPTH32F_STENCIL8: 36013,
        FLOAT_32_UNSIGNED_INT_24_8_REV: 36269,
        FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: 33296,
        FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: 33297,
        FRAMEBUFFER_ATTACHMENT_RED_SIZE: 33298,
        FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: 33299,
        FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: 33300,
        FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: 33301,
        FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: 33302,
        FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: 33303,
        FRAMEBUFFER_DEFAULT: 33304,
        UNSIGNED_INT_24_8: 34042,
        DEPTH24_STENCIL8: 35056,
        UNSIGNED_NORMALIZED: 35863,
        DRAW_FRAMEBUFFER_BINDING: 36006,
        READ_FRAMEBUFFER: 36008,
        DRAW_FRAMEBUFFER: 36009,
        READ_FRAMEBUFFER_BINDING: 36010,
        RENDERBUFFER_SAMPLES: 36011,
        FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: 36052,
        MAX_COLOR_ATTACHMENTS: 36063,
        COLOR_ATTACHMENT1: 36065,
        COLOR_ATTACHMENT2: 36066,
        COLOR_ATTACHMENT3: 36067,
        COLOR_ATTACHMENT4: 36068,
        COLOR_ATTACHMENT5: 36069,
        COLOR_ATTACHMENT6: 36070,
        COLOR_ATTACHMENT7: 36071,
        COLOR_ATTACHMENT8: 36072,
        COLOR_ATTACHMENT9: 36073,
        COLOR_ATTACHMENT10: 36074,
        COLOR_ATTACHMENT11: 36075,
        COLOR_ATTACHMENT12: 36076,
        COLOR_ATTACHMENT13: 36077,
        COLOR_ATTACHMENT14: 36078,
        COLOR_ATTACHMENT15: 36079,
        FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: 36182,
        MAX_SAMPLES: 36183,
        HALF_FLOAT: 5131,
        RG: 33319,
        RG_INTEGER: 33320,
        R8: 33321,
        RG8: 33323,
        R16F: 33325,
        R32F: 33326,
        RG16F: 33327,
        RG32F: 33328,
        R8I: 33329,
        R8UI: 33330,
        R16I: 33331,
        R16UI: 33332,
        R32I: 33333,
        R32UI: 33334,
        RG8I: 33335,
        RG8UI: 33336,
        RG16I: 33337,
        RG16UI: 33338,
        RG32I: 33339,
        RG32UI: 33340,
        VERTEX_ARRAY_BINDING: 34229,
        R8_SNORM: 36756,
        RG8_SNORM: 36757,
        RGB8_SNORM: 36758,
        RGBA8_SNORM: 36759,
        SIGNED_NORMALIZED: 36764,
        COPY_READ_BUFFER: 36662,
        COPY_WRITE_BUFFER: 36663,
        COPY_READ_BUFFER_BINDING: 36662,
        COPY_WRITE_BUFFER_BINDING: 36663,
        UNIFORM_BUFFER: 35345,
        UNIFORM_BUFFER_BINDING: 35368,
        UNIFORM_BUFFER_START: 35369,
        UNIFORM_BUFFER_SIZE: 35370,
        MAX_VERTEX_UNIFORM_BLOCKS: 35371,
        MAX_FRAGMENT_UNIFORM_BLOCKS: 35373,
        MAX_COMBINED_UNIFORM_BLOCKS: 35374,
        MAX_UNIFORM_BUFFER_BINDINGS: 35375,
        MAX_UNIFORM_BLOCK_SIZE: 35376,
        MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: 35377,
        MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: 35379,
        UNIFORM_BUFFER_OFFSET_ALIGNMENT: 35380,
        ACTIVE_UNIFORM_BLOCKS: 35382,
        UNIFORM_TYPE: 35383,
        UNIFORM_SIZE: 35384,
        UNIFORM_BLOCK_INDEX: 35386,
        UNIFORM_OFFSET: 35387,
        UNIFORM_ARRAY_STRIDE: 35388,
        UNIFORM_MATRIX_STRIDE: 35389,
        UNIFORM_IS_ROW_MAJOR: 35390,
        UNIFORM_BLOCK_BINDING: 35391,
        UNIFORM_BLOCK_DATA_SIZE: 35392,
        UNIFORM_BLOCK_ACTIVE_UNIFORMS: 35394,
        UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: 35395,
        UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: 35396,
        UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: 35398,
        INVALID_INDEX: 4294967295,
        MAX_VERTEX_OUTPUT_COMPONENTS: 37154,
        MAX_FRAGMENT_INPUT_COMPONENTS: 37157,
        MAX_SERVER_WAIT_TIMEOUT: 37137,
        OBJECT_TYPE: 37138,
        SYNC_CONDITION: 37139,
        SYNC_STATUS: 37140,
        SYNC_FLAGS: 37141,
        SYNC_FENCE: 37142,
        SYNC_GPU_COMMANDS_COMPLETE: 37143,
        UNSIGNALED: 37144,
        SIGNALED: 37145,
        ALREADY_SIGNALED: 37146,
        TIMEOUT_EXPIRED: 37147,
        CONDITION_SATISFIED: 37148,
        WAIT_FAILED: 37149,
        SYNC_FLUSH_COMMANDS_BIT: 1,
        VERTEX_ATTRIB_ARRAY_DIVISOR: 35070,
        ANY_SAMPLES_PASSED: 35887,
        ANY_SAMPLES_PASSED_CONSERVATIVE: 36202,
        SAMPLER_BINDING: 35097,
        RGB10_A2UI: 36975,
        INT_2_10_10_10_REV: 36255,
        TRANSFORM_FEEDBACK: 36386,
        TRANSFORM_FEEDBACK_PAUSED: 36387,
        TRANSFORM_FEEDBACK_ACTIVE: 36388,
        TRANSFORM_FEEDBACK_BINDING: 36389,
        COMPRESSED_R11_EAC: 37488,
        COMPRESSED_SIGNED_R11_EAC: 37489,
        COMPRESSED_RG11_EAC: 37490,
        COMPRESSED_SIGNED_RG11_EAC: 37491,
        COMPRESSED_RGB8_ETC2: 37492,
        COMPRESSED_SRGB8_ETC2: 37493,
        COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37494,
        COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37495,
        COMPRESSED_RGBA8_ETC2_EAC: 37496,
        COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 37497,
        TEXTURE_IMMUTABLE_FORMAT: 37167,
        MAX_ELEMENT_INDEX: 36203,
        TEXTURE_IMMUTABLE_LEVELS: 33503,
        MAX_TEXTURE_MAX_ANISOTROPY_EXT: 34047,
        CESIUM_3D_TILE_MASK: 128,
        SKIP_LOD_MASK: 112,
        SKIP_LOD_BIT_SHIFT: 4,
        CLASSIFICATION_MASK: 15,
      });
    class Rl {
      constructor(e) {
        (this._ellipsoid = Z(e, wt.WGS84)),
          (this._semimajorAxis = this._ellipsoid.maximumRadius),
          (this._oneOverSemimajorAxis = 1 / this._semimajorAxis);
      }
      get ellipsoid() {
        return this._ellipsoid;
      }
      project(e, i) {
        const n = this._semimajorAxis,
          r = e.longitude * n,
          o = e.latitude * n,
          a = e.height;
        return t(i) ? ((i.x = r), (i.y = o), (i.z = a), i) : new Pt(r, o, a);
      }
      unproject(e, i) {
        const n = this._oneOverSemimajorAxis,
          r = e.x * n,
          o = e.y * n,
          a = e.z;
        return t(i) ? ((i.longitude = r), (i.latitude = o), (i.height = a), i) : new as(r, o, a);
      }
    }
    class Nl {
      constructor(e, t, i, n) {
        (this.west = Z(e, 0)),
          (this.south = Z(t, 0)),
          (this.east = Z(i, 0)),
          (this.north = Z(n, 0));
      }
      get width() {
        return Nl.computeWidth(this);
      }
      get height() {
        return Nl.computeHeight(this);
      }
      static pack(e, t, i) {
        return (
          (i = Z(i, 0)),
          (t[i++] = e.west),
          (t[i++] = e.south),
          (t[i++] = e.east),
          (t[i] = e.north),
          t
        );
      }
      static unpack(e, i, n) {
        return (
          (i = Z(i, 0)),
          t(n) || (n = new Nl()),
          (n.west = e[i++]),
          (n.south = e[i++]),
          (n.east = e[i++]),
          (n.north = e[i]),
          n
        );
      }
      static computeWidth(e) {
        let t = e.east;
        const i = e.west;
        return t < i && (t += Me.CesiumMath.TWO_PI), t - i;
      }
      static computeHeight(e) {
        return e.north - e.south;
      }
      static fromDegrees(e, i, n, r, o) {
        return (
          (e = Me.CesiumMath.toRadians(Z(e, 0))),
          (i = Me.CesiumMath.toRadians(Z(i, 0))),
          (n = Me.CesiumMath.toRadians(Z(n, 0))),
          (r = Me.CesiumMath.toRadians(Z(r, 0))),
          t(o) ? ((o.west = e), (o.south = i), (o.east = n), (o.north = r), o) : new Nl(e, i, n, r)
        );
      }
      static fromRadians(e, i, n, r, o) {
        return t(o)
          ? ((o.west = Z(e, 0)), (o.south = Z(i, 0)), (o.east = Z(n, 0)), (o.north = Z(r, 0)), o)
          : new Nl(e, i, n, r);
      }
      static fromCartographicArray(e, i) {
        let n = Number.MAX_VALUE,
          r = -Number.MAX_VALUE,
          o = Number.MAX_VALUE,
          a = -Number.MAX_VALUE,
          s = Number.MAX_VALUE,
          l = -Number.MAX_VALUE;
        for (let t = 0, i = e.length; t < i; t++) {
          const i = e[t];
          (n = Math.min(n, i.longitude)),
            (r = Math.max(r, i.longitude)),
            (s = Math.min(s, i.latitude)),
            (l = Math.max(l, i.latitude));
          const c = i.longitude >= 0 ? i.longitude : i.longitude + Me.CesiumMath.TWO_PI;
          (o = Math.min(o, c)), (a = Math.max(a, c));
        }
        return (
          r - n > a - o &&
            ((n = o),
            (r = a),
            r > Me.CesiumMath.PI && (r -= Me.CesiumMath.TWO_PI),
            n > Me.CesiumMath.PI && (n -= Me.CesiumMath.TWO_PI)),
          t(i) ? ((i.west = n), (i.south = s), (i.east = r), (i.north = l), i) : new Nl(n, s, r, l)
        );
      }
      static fromCartesianArray(e, i, n) {
        i = Z(i, wt.WGS84);
        let r = Number.MAX_VALUE,
          o = -Number.MAX_VALUE,
          a = Number.MAX_VALUE,
          s = -Number.MAX_VALUE,
          l = Number.MAX_VALUE,
          c = -Number.MAX_VALUE;
        for (let t = 0, n = e.length; t < n; t++) {
          const n = i.cartesianToCartographic(e[t]);
          (r = Math.min(r, n.longitude)),
            (o = Math.max(o, n.longitude)),
            (l = Math.min(l, n.latitude)),
            (c = Math.max(c, n.latitude));
          const u = n.longitude >= 0 ? n.longitude : n.longitude + Me.CesiumMath.TWO_PI;
          (a = Math.min(a, u)), (s = Math.max(s, u));
        }
        return (
          o - r > s - a &&
            ((r = a),
            (o = s),
            o > Me.CesiumMath.PI && (o -= Me.CesiumMath.TWO_PI),
            r > Me.CesiumMath.PI && (r -= Me.CesiumMath.TWO_PI)),
          t(n) ? ((n.west = r), (n.south = l), (n.east = o), (n.north = c), n) : new Nl(r, l, o, c)
        );
      }
      static clone(e, i) {
        if (t(e))
          return t(i)
            ? ((i.west = e.west), (i.south = e.south), (i.east = e.east), (i.north = e.north), i)
            : new Nl(e.west, e.south, e.east, e.north);
      }
      static equalsEpsilon(e, i, n) {
        return (
          (n = Z(n, 0)),
          e === i ||
            (t(e) &&
              t(i) &&
              Math.abs(e.west - i.west) <= n &&
              Math.abs(e.south - i.south) <= n &&
              Math.abs(e.east - i.east) <= n &&
              Math.abs(e.north - i.north) <= n)
        );
      }
      clone(e) {
        return Nl.clone(this, e);
      }
      equals(e) {
        return Nl.equals(this, e);
      }
      static equals(e, i) {
        return (
          e === i ||
          (t(e) &&
            t(i) &&
            e.west === i.west &&
            e.south === i.south &&
            e.east === i.east &&
            e.north === i.north)
        );
      }
      equalsEpsilon(e, t) {
        return Nl.equalsEpsilon(this, e, t);
      }
      static validate(e) {
        const t = e.north;
        if (t < -Me.CesiumMath.PI_OVER_TWO || t > Me.CesiumMath.PI_OVER_TWO)
          throw new Error('north 范围越界！');
        const i = e.south;
        if (i < -Me.CesiumMath.PI_OVER_TWO || i > Me.CesiumMath.PI_OVER_TWO)
          throw new Error('south 范围越界！');
        const n = e.west;
        if (n < -Me.CesiumMath.PI || n > Me.CesiumMath.PI) throw new Error('west 范围越界！');
        const r = e.east;
        if (r < -Me.CesiumMath.PI || r > Me.CesiumMath.PI) throw new Error('east 范围越界！');
      }
      static southwest(e, i) {
        return t(i)
          ? ((i.longitude = e.west), (i.latitude = e.south), (i.height = 0), i)
          : new as(e.west, e.south);
      }
      static northwest(e, i) {
        return t(i)
          ? ((i.longitude = e.west), (i.latitude = e.north), (i.height = 0), i)
          : new as(e.west, e.north);
      }
      static northeast(e, i) {
        return t(i)
          ? ((i.longitude = e.east), (i.latitude = e.north), (i.height = 0), i)
          : new as(e.east, e.north);
      }
      static southeast(e, i) {
        return t(i)
          ? ((i.longitude = e.east), (i.latitude = e.south), (i.height = 0), i)
          : new as(e.east, e.south);
      }
      static center(e, i) {
        let n = e.east;
        const r = e.west;
        n < r && (n += Me.CesiumMath.TWO_PI);
        const o = Me.CesiumMath.negativePiToPi(0.5 * (r + n)),
          a = 0.5 * (e.south + e.north);
        return t(i) ? ((i.longitude = o), (i.latitude = a), (i.height = 0), i) : new as(o, a);
      }
      static intersection(e, i, n) {
        let r = e.east,
          o = e.west,
          a = i.east,
          s = i.west;
        r < o && a > 0
          ? (r += Me.CesiumMath.TWO_PI)
          : a < s && r > 0 && (a += Me.CesiumMath.TWO_PI),
          r < o && s < 0
            ? (s += Me.CesiumMath.TWO_PI)
            : a < s && o < 0 && (o += Me.CesiumMath.TWO_PI);
        const l = Me.CesiumMath.negativePiToPi(Math.max(o, s)),
          c = Me.CesiumMath.negativePiToPi(Math.min(r, a));
        if ((e.west < e.east || i.west < i.east) && c <= l) return;
        const u = Math.max(e.south, i.south),
          h = Math.min(e.north, i.north);
        return u >= h
          ? void 0
          : t(n)
          ? ((n.west = l), (n.south = u), (n.east = c), (n.north = h), n)
          : new Nl(l, u, c, h);
      }
      static simpleIntersection(e, i, n) {
        const r = Math.max(e.west, i.west),
          o = Math.max(e.south, i.south),
          a = Math.min(e.east, i.east),
          s = Math.min(e.north, i.north);
        if (!(o >= s || r >= a))
          return t(n)
            ? ((n.west = r), (n.south = o), (n.east = a), (n.north = s), n)
            : new Nl(r, o, a, s);
      }
      static union(e, i, n) {
        t(n) || (n = new Nl());
        let r = e.east,
          o = e.west,
          a = i.east,
          s = i.west;
        r < o && a > 0
          ? (r += Me.CesiumMath.TWO_PI)
          : a < s && r > 0 && (a += Me.CesiumMath.TWO_PI),
          r < o && s < 0
            ? (s += Me.CesiumMath.TWO_PI)
            : a < s && o < 0 && (o += Me.CesiumMath.TWO_PI);
        const l = Me.CesiumMath.negativePiToPi(Math.min(o, s)),
          c = Me.CesiumMath.negativePiToPi(Math.max(r, a));
        return (
          (n.west = l),
          (n.south = Math.min(e.south, i.south)),
          (n.east = c),
          (n.north = Math.max(e.north, i.north)),
          n
        );
      }
      static expand(e, i, n) {
        return (
          t(n) || (n = new Nl()),
          (n.west = Math.min(e.west, i.longitude)),
          (n.south = Math.min(e.south, i.latitude)),
          (n.east = Math.max(e.east, i.longitude)),
          (n.north = Math.max(e.north, i.latitude)),
          n
        );
      }
      static contains(e, t) {
        let i = t.longitude;
        const n = t.latitude,
          r = e.west;
        let o = e.east;
        return (
          o < r && ((o += Me.CesiumMath.TWO_PI), i < 0 && (i += Me.CesiumMath.TWO_PI)),
          (i > r || Me.CesiumMath.equalsEpsilon(i, r, Me.CesiumMath.EPSILON14)) &&
            (i < o || Me.CesiumMath.equalsEpsilon(i, o, Me.CesiumMath.EPSILON14)) &&
            n >= e.south &&
            n <= e.north
        );
      }
      static subsample(e, i, n, r) {
        (i = Z(i, wt.WGS84)), (n = Z(n, 0));
        const o = new as();
        t(r) || (r = []);
        let a = 0;
        const s = e.north,
          l = e.south,
          c = e.east,
          u = e.west,
          h = o;
        (h.height = n),
          (h.longitude = u),
          (h.latitude = s),
          (r[a] = i.cartographicToCartesian(h, r[a])),
          a++,
          (h.longitude = c),
          (r[a] = i.cartographicToCartesian(h, r[a])),
          a++,
          (h.latitude = l),
          (r[a] = i.cartographicToCartesian(h, r[a])),
          a++,
          (h.longitude = u),
          (r[a] = i.cartographicToCartesian(h, r[a])),
          a++,
          (h.latitude = s < 0 ? s : l > 0 ? l : 0);
        for (let t = 1; t < 8; ++t)
          (h.longitude = -Math.PI + t * Me.CesiumMath.PI_OVER_TWO),
            Nl.contains(e, h) && ((r[a] = i.cartographicToCartesian(h, r[a])), a++);
        return (
          0 === h.latitude &&
            ((h.longitude = u),
            (r[a] = i.cartographicToCartesian(h, r[a])),
            a++,
            (h.longitude = c),
            (r[a] = i.cartographicToCartesian(h, r[a])),
            a++),
          (r.length = a),
          r
        );
      }
    }
    (Nl.packedLength = 4),
      (Nl.MAX_VALUE = Object.freeze(
        new Nl(-Math.PI, -Me.CesiumMath.PI_OVER_TWO, Math.PI, Me.CesiumMath.PI_OVER_TWO),
      ));
    const Ol = new Pt(),
      Dl = new Pt(),
      Fl = new Pt(),
      zl = new Pt(),
      Bl = new Pt(),
      Vl = new Pt(),
      Ul = new Pt(),
      kl = new Pt(),
      Gl = new Pt(),
      Hl = new Pt(),
      Yl = new Pt(),
      ql = new Pt(),
      Xl = new Pt(),
      jl = new Pt(),
      Wl = new Rl(),
      $l = new Pt(),
      Zl = new Pt(),
      Kl = new as(0, 0, 0),
      Ql = new as(0, 0, 0),
      Jl = [],
      ec = new Pt(),
      tc = new Pt(),
      ic = new Pt(),
      nc = new Pt(),
      rc = new Pt(),
      oc = new Pt(),
      ac = new Pt(),
      sc = new Pt(),
      lc = new Pt(),
      cc = new Rl(),
      uc = new Pt(),
      hc = new Pt(),
      dc = new Pt(),
      pc = new Pt(),
      fc = new Pt(),
      mc = new as(),
      _c = new Array(8);
    for (let e = 0; e < 8; ++e) _c[e] = new Pt();
    class gc {
      constructor(e = [0, 0, 0], t = 0) {
        (this.radius = -0), (this.center = new Pt()), this.fromCenterRadius(e, t);
      }
      fromCenterRadius(e, t) {
        return this.center.from(e), (this.radius = t), this;
      }
      fromCornerPoints(e, t) {
        return (
          (t = Ol.from(t)),
          (this.center = new Pt().from(e).add(t).scale(0.5)),
          (this.radius = this.center.distance(t)),
          this
        );
      }
      equals(e) {
        return (
          this === e || (Boolean(e) && this.center.equals(e.center) && this.radius === e.radius)
        );
      }
      clone(e) {
        return gc.clone(this, e);
      }
      union(e) {
        const t = this.center,
          i = this.radius,
          n = e.radius,
          r = Ol.copy(e.center).subtract(t),
          o = r.magnitude();
        if (i >= o + n) return this.clone();
        if (n >= o + i) return e.clone();
        const a = 0.5 * (i + o + n);
        return (
          Dl.copy(r)
            .scale((-i + a) / o)
            .add(t),
          this.center.copy(Dl),
          (this.radius = a),
          this
        );
      }
      expand(e) {
        const t = (e = Ol.from(e)).subtract(this.center).magnitude();
        return t > this.radius && (this.radius = t), this;
      }
      transform(e) {
        this.center.transform(e);
        const t = (function (e, t) {
          var i = t[4],
            n = t[5],
            r = t[6],
            o = t[8],
            a = t[9],
            s = t[10];
          return (
            (e[0] = Math.hypot(t[0], t[1], t[2])),
            (e[1] = Math.hypot(i, n, r)),
            (e[2] = Math.hypot(o, a, s)),
            e
          );
        })(Ol, e);
        return (this.radius = Math.max(t[0], Math.max(t[1], t[2])) * this.radius), this;
      }
      computePlaneDistances(e, t, i) {
        return gc.computePlaneDistances(this, e, t, i);
      }
      distanceSquaredTo(e) {
        const t = this.distanceTo(e);
        return t * t;
      }
      distanceTo(e) {
        const t = (e = Ol.from(e)).subtract(this.center);
        return Math.max(0, t.len() - this.radius);
      }
      intersectPlane(e) {
        const t = this.radius,
          i = e.normal.dot(this.center) + e.distance;
        return i < -t ? Aa.OUTSIDE : i < t ? Aa.INTERSECTING : Aa.INSIDE;
      }
      setFromPoints(e) {
        if (!e || 0 == e.length) return this;
        let t;
        if (a(e[0]) && e[0] instanceof Pt) t = e;
        else {
          t = [];
          for (let i = 0; i < e.length; i += 3) t.push(new Pt([e[i], e[i + 1], e[i + 2]]));
        }
        return gc.fromPoints(t, this);
      }
      static fromPoints(e, i) {
        if ((t(i) || (i = new gc()), !t(e) || 0 === e.length))
          return (i.center = Pt.clone(Pt.ZERO, i.center)), (i.radius = 0), i;
        const n = Pt.clone(e[0], Gl),
          r = Pt.clone(n, Fl),
          o = Pt.clone(n, zl),
          a = Pt.clone(n, Bl),
          s = Pt.clone(n, Vl),
          l = Pt.clone(n, Ul),
          c = Pt.clone(n, kl),
          u = e.length;
        let h;
        for (h = 1; h < u; h++) {
          Pt.clone(e[h], n);
          const t = n.x,
            i = n.y,
            u = n.z;
          t < r.x && Pt.clone(n, r),
            t > s.x && Pt.clone(n, s),
            i < o.y && Pt.clone(n, o),
            i > l.y && Pt.clone(n, l),
            u < a.z && Pt.clone(n, a),
            u > c.z && Pt.clone(n, c);
        }
        const d = Pt.magnitudeSquared(Pt.subtract(s, r, Hl)),
          p = Pt.magnitudeSquared(Pt.subtract(l, o, Hl)),
          f = Pt.magnitudeSquared(Pt.subtract(c, a, Hl));
        let m = r,
          _ = s,
          g = d;
        p > g && ((g = p), (m = o), (_ = l)), f > g && ((g = f), (m = a), (_ = c));
        const y = Yl;
        (y.x = 0.5 * (m.x + _.x)), (y.y = 0.5 * (m.y + _.y)), (y.z = 0.5 * (m.z + _.z));
        let x = Pt.magnitudeSquared(Pt.subtract(_, y, Hl)),
          v = Math.sqrt(x);
        const w = ql;
        (w.x = r.x), (w.y = o.y), (w.z = a.z);
        const T = Xl;
        (T.x = s.x), (T.y = l.y), (T.z = c.z);
        const b = Pt.midpoint(w, T, jl);
        let S = 0;
        for (h = 0; h < u; h++) {
          Pt.clone(e[h], n);
          const t = Pt.magnitude(Pt.subtract(n, b, Hl));
          t > S && (S = t);
          const i = Pt.magnitudeSquared(Pt.subtract(n, y, Hl));
          if (i > x) {
            const e = Math.sqrt(i);
            (v = 0.5 * (v + e)), (x = v * v);
            const t = e - v;
            (y.x = (v * y.x + t * n.x) / e),
              (y.y = (v * y.y + t * n.y) / e),
              (y.z = (v * y.z + t * n.z) / e);
          }
        }
        return (
          v < S ? (Pt.clone(y, i.center), (i.radius = v)) : (Pt.clone(b, i.center), (i.radius = S)),
          i
        );
      }
      static fromRectangle2D(e, t, i) {
        return gc.fromRectangleWithHeights2D(e, t, 0, 0, i);
      }
      static fromRectangleWithHeights2D(e, i, n, r, o) {
        if ((t(o) || (o = new gc()), !t(e)))
          return (o.center = Pt.clone(Pt.ZERO, o.center)), (o.radius = 0), o;
        (i = Z(i, Wl)), Nl.southwest(e, Kl), (Kl.height = n), Nl.northeast(e, Ql), (Ql.height = r);
        const a = i.project(Kl, $l),
          s = i.project(Ql, Zl),
          l = s.x - a.x,
          c = s.y - a.y,
          u = s.z - a.z;
        o.radius = 0.5 * Math.sqrt(l * l + c * c + u * u);
        const h = o.center;
        return (h.x = a.x + 0.5 * l), (h.y = a.y + 0.5 * c), (h.z = a.z + 0.5 * u), o;
      }
      static fromRectangle3D(e, i, n, r) {
        if (((i = Z(i, wt.WGS84)), (n = Z(n, 0)), t(r) || (r = new gc()), !t(e)))
          return (r.center = Pt.clone(Pt.ZERO, r.center)), (r.radius = 0), r;
        const o = Nl.subsample(e, i, n, Jl);
        return gc.fromPoints(o, r);
      }
      static fromVertices(e, i, n, r) {
        if ((t(r) || (r = new gc()), !t(e) || 0 === e.length))
          return (r.center = Pt.clone(Pt.ZERO, r.center)), (r.radius = 0), r;
        (i = Z(i, Pt.ZERO)), (n = Z(n, 3));
        const o = Gl;
        (o.x = e[0] + i.x), (o.y = e[1] + i.y), (o.z = e[2] + i.z);
        const a = Pt.clone(o, Fl),
          s = Pt.clone(o, zl),
          l = Pt.clone(o, Bl),
          c = Pt.clone(o, Vl),
          u = Pt.clone(o, Ul),
          h = Pt.clone(o, kl),
          d = e.length;
        let p;
        for (p = 0; p < d; p += n) {
          const t = e[p] + i.x,
            n = e[p + 1] + i.y,
            r = e[p + 2] + i.z;
          (o.x = t),
            (o.y = n),
            (o.z = r),
            t < a.x && Pt.clone(o, a),
            t > c.x && Pt.clone(o, c),
            n < s.y && Pt.clone(o, s),
            n > u.y && Pt.clone(o, u),
            r < l.z && Pt.clone(o, l),
            r > h.z && Pt.clone(o, h);
        }
        const f = Pt.magnitudeSquared(Pt.subtract(c, a, Hl)),
          m = Pt.magnitudeSquared(Pt.subtract(u, s, Hl)),
          _ = Pt.magnitudeSquared(Pt.subtract(h, l, Hl));
        let g = a,
          y = c,
          x = f;
        m > x && ((x = m), (g = s), (y = u)), _ > x && ((x = _), (g = l), (y = h));
        const v = Yl;
        (v.x = 0.5 * (g.x + y.x)), (v.y = 0.5 * (g.y + y.y)), (v.z = 0.5 * (g.z + y.z));
        let w = Pt.magnitudeSquared(Pt.subtract(y, v, Hl)),
          T = Math.sqrt(w);
        const b = ql;
        (b.x = a.x), (b.y = s.y), (b.z = l.z);
        const S = Xl;
        (S.x = c.x), (S.y = u.y), (S.z = h.z);
        const A = Pt.midpoint(b, S, jl);
        let P = 0;
        for (p = 0; p < d; p += n) {
          (o.x = e[p] + i.x), (o.y = e[p + 1] + i.y), (o.z = e[p + 2] + i.z);
          const t = Pt.magnitude(Pt.subtract(o, A, Hl));
          t > P && (P = t);
          const n = Pt.magnitudeSquared(Pt.subtract(o, v, Hl));
          if (n > w) {
            const e = Math.sqrt(n);
            (T = 0.5 * (T + e)), (w = T * T);
            const t = e - T;
            (v.x = (T * v.x + t * o.x) / e),
              (v.y = (T * v.y + t * o.y) / e),
              (v.z = (T * v.z + t * o.z) / e);
          }
        }
        return (
          T < P ? (Pt.clone(v, r.center), (r.radius = T)) : (Pt.clone(A, r.center), (r.radius = P)),
          r
        );
      }
      static fromEncodedCartesianVertices(e, i, n) {
        if ((t(n) || (n = new gc()), !t(e) || !t(i) || e.length !== i.length || 0 === e.length))
          return (n.center = Pt.clone(Pt.ZERO, n.center)), (n.radius = 0), n;
        const r = Gl;
        (r.x = e[0] + i[0]), (r.y = e[1] + i[1]), (r.z = e[2] + i[2]);
        const o = Pt.clone(r, Fl),
          a = Pt.clone(r, zl),
          s = Pt.clone(r, Bl),
          l = Pt.clone(r, Vl),
          c = Pt.clone(r, Ul),
          u = Pt.clone(r, kl),
          h = e.length;
        let d;
        for (d = 0; d < h; d += 3) {
          const t = e[d] + i[d],
            n = e[d + 1] + i[d + 1],
            h = e[d + 2] + i[d + 2];
          (r.x = t),
            (r.y = n),
            (r.z = h),
            t < o.x && Pt.clone(r, o),
            t > l.x && Pt.clone(r, l),
            n < a.y && Pt.clone(r, a),
            n > c.y && Pt.clone(r, c),
            h < s.z && Pt.clone(r, s),
            h > u.z && Pt.clone(r, u);
        }
        const p = Pt.magnitudeSquared(Pt.subtract(l, o, Hl)),
          f = Pt.magnitudeSquared(Pt.subtract(c, a, Hl)),
          m = Pt.magnitudeSquared(Pt.subtract(u, s, Hl));
        let _ = o,
          g = l,
          y = p;
        f > y && ((y = f), (_ = a), (g = c)), m > y && ((y = m), (_ = s), (g = u));
        const x = Yl;
        (x.x = 0.5 * (_.x + g.x)), (x.y = 0.5 * (_.y + g.y)), (x.z = 0.5 * (_.z + g.z));
        let v = Pt.magnitudeSquared(Pt.subtract(g, x, Hl)),
          w = Math.sqrt(v);
        const T = ql;
        (T.x = o.x), (T.y = a.y), (T.z = s.z);
        const b = Xl;
        (b.x = l.x), (b.y = c.y), (b.z = u.z);
        const S = Pt.midpoint(T, b, jl);
        let A = 0;
        for (d = 0; d < h; d += 3) {
          (r.x = e[d] + i[d]), (r.y = e[d + 1] + i[d + 1]), (r.z = e[d + 2] + i[d + 2]);
          const t = Pt.magnitude(Pt.subtract(r, S, Hl));
          t > A && (A = t);
          const n = Pt.magnitudeSquared(Pt.subtract(r, x, Hl));
          if (n > v) {
            const e = Math.sqrt(n);
            (w = 0.5 * (w + e)), (v = w * w);
            const t = e - w;
            (x.x = (w * x.x + t * r.x) / e),
              (x.y = (w * x.y + t * r.y) / e),
              (x.z = (w * x.z + t * r.z) / e);
          }
        }
        return (
          w < A ? (Pt.clone(x, n.center), (n.radius = w)) : (Pt.clone(S, n.center), (n.radius = A)),
          n
        );
      }
      static fromCornerPoints(e, i, n) {
        t(n) || (n = new gc());
        const r = Pt.midpoint(e, i, n.center);
        return (n.radius = Pt.distance(r, i)), n;
      }
      static fromEllipsoid(e, i) {
        return t(i) || (i = new gc()), Pt.clone(Pt.ZERO, i.center), (i.radius = e.maximumRadius), i;
      }
      static fromBoundingSpheres(e, i) {
        if ((t(i) || (i = new gc()), !t(e) || 0 === e.length))
          return (i.center = Pt.clone(Pt.ZERO, i.center)), (i.radius = 0), i;
        const n = e.length;
        if (1 === n) return gc.clone(e[0], i);
        if (2 === n) return gc.union(e[0], e[1], i);
        const r = [];
        let o;
        for (o = 0; o < n; o++) r.push(e[o].center);
        const a = (i = gc.fromPoints(r, i)).center;
        let s = i.radius;
        for (o = 0; o < n; o++) {
          const t = e[o];
          s = Math.max(s, Pt.distance(a, t.center, ec) + t.radius);
        }
        return (i.radius = s), i;
      }
      static fromOrientedBoundingBox(e, i) {
        t(i) || (i = new gc());
        const n = e.halfAxes,
          r = je.getColumn(n, 0, tc),
          o = je.getColumn(n, 1, ic),
          a = je.getColumn(n, 2, nc);
        return (
          Pt.add(r, o, r),
          Pt.add(r, a, r),
          (i.center = Pt.clone(e.center, i.center)),
          (i.radius = Pt.magnitude(r)),
          i
        );
      }
      static clone(e, i) {
        if (t(e))
          return t(i)
            ? ((i.center = Pt.clone(e.center, i.center)), (i.radius = e.radius), i)
            : new gc(e.center, e.radius);
      }
      static pack(e, t, i) {
        i = Z(i, 0);
        const n = e.center;
        return (t[i++] = n.x), (t[i++] = n.y), (t[i++] = n.z), (t[i] = e.radius), t;
      }
      static unpack(e, i, n) {
        (i = Z(i, 0)), t(n) || (n = new gc());
        const r = n.center;
        return (r.x = e[i++]), (r.y = e[i++]), (r.z = e[i++]), (n.radius = e[i]), n;
      }
      static union(e, i, n) {
        t(n) || (n = new gc());
        const r = e.center,
          o = e.radius,
          a = i.radius,
          s = Pt.subtract(i.center, r, rc),
          l = Pt.magnitude(s);
        if (o >= l + a) return gc.clone(e, n), n;
        if (a >= l + o) return gc.clone(i, n), n;
        const c = 0.5 * (o + l + a),
          u = Pt.multiplyByScalar(s, (-o + c) / l, oc);
        return Pt.add(u, r, u), Pt.clone(u, n.center), (n.radius = c), n;
      }
      static expand(e, t, i) {
        i = gc.clone(e, i);
        const n = Pt.magnitude(Pt.subtract(t, i.center, ac));
        return n > i.radius && (i.radius = n), i;
      }
      static intersectPlane(e, t) {
        const i = e.radius,
          n = Pt.dot(t.normal, e.center) + t.distance;
        return n < -i ? Aa.OUTSIDE : n < i ? Aa.INTERSECTING : Aa.INSIDE;
      }
      static transform(e, i, n) {
        return (
          t(n) || (n = new gc()),
          (n.center = Je.multiplyByPoint(i, e.center, n.center)),
          (n.radius = Je.getMaximumScale(i) * e.radius),
          n
        );
      }
      static distanceSquaredTo(e, t) {
        const i = Pt.subtract(e.center, t, sc),
          n = Pt.magnitude(i) - e.radius;
        return n <= 0 ? 0 : n * n;
      }
      static transformWithoutScale(e, i, n) {
        return (
          t(n) || (n = new gc()),
          (n.center = Je.multiplyByPoint(i, e.center, n.center)),
          (n.radius = e.radius),
          n
        );
      }
      static computePlaneDistances(e, i, n, r) {
        t(r) || (r = new yc());
        const o = Pt.subtract(e.center, i, lc),
          a = Pt.dot(n, o);
        return (r.start = a - e.radius), (r.stop = a + e.radius), r;
      }
      static projectTo2D(e, t, i) {
        const n = (t = Z(t, cc)).ellipsoid;
        let r = e.center;
        const o = e.radius;
        let a;
        a = Pt.equals(r, Pt.ZERO) ? Pt.clone(Pt.UNIT_X, uc) : n.geodeticSurfaceNormal(r, uc);
        const s = Pt.cross(Pt.UNIT_Z, a, hc);
        Pt.normalize(s, s);
        const l = Pt.cross(a, s, dc);
        Pt.normalize(l, l),
          Pt.multiplyByScalar(a, o, a),
          Pt.multiplyByScalar(l, o, l),
          Pt.multiplyByScalar(s, o, s);
        const c = Pt.negate(l, fc),
          u = Pt.negate(s, pc),
          h = _c;
        let d = h[0];
        Pt.add(a, l, d),
          Pt.add(d, s, d),
          (d = h[1]),
          Pt.add(a, l, d),
          Pt.add(d, u, d),
          (d = h[2]),
          Pt.add(a, c, d),
          Pt.add(d, u, d),
          (d = h[3]),
          Pt.add(a, c, d),
          Pt.add(d, s, d),
          Pt.negate(a, a),
          (d = h[4]),
          Pt.add(a, l, d),
          Pt.add(d, s, d),
          (d = h[5]),
          Pt.add(a, l, d),
          Pt.add(d, u, d),
          (d = h[6]),
          Pt.add(a, c, d),
          Pt.add(d, u, d),
          (d = h[7]),
          Pt.add(a, c, d),
          Pt.add(d, s, d);
        const p = h.length;
        for (let e = 0; e < p; ++e) {
          const i = h[e];
          Pt.add(r, i, i);
          const o = n.cartesianToCartographic(i, mc);
          t.project(o, i);
        }
        r = (i = gc.fromPoints(h, i)).center;
        const f = r.x,
          m = r.y;
        return (r.x = r.z), (r.y = f), (r.z = m), i;
      }
      static equals(e, i) {
        return e === i || (t(e) && t(i) && Pt.equals(e.center, i.center) && e.radius === i.radius);
      }
      getBoundingMaximum() {
        return {
          boundingMaxValue: new Pt(
            this.center.x + this.radius,
            this.center.y + this.radius,
            this.center.z + this.radius,
          ),
          boundingMinValue: new Pt(
            this.center.x - this.radius,
            this.center.y - this.radius,
            this.center.z - this.radius,
          ),
        };
      }
    }
    function yc(e, t) {
      (this.start = Z(e, 0)), (this.stop = Z(t, 0));
    }
    gc.packedLength = 4;
    const xc = new Pt(),
      vc = new Pt();
    class wc {
      constructor(e = [0, 0, 0], t = [0, 0, 0], i = null) {
        (i = i || xc.copy(e).add(t).scale(0.5)),
          (this.center = new Pt(i)),
          (this.halfDiagonal = new Pt(t).subtract(this.center)),
          (this.minimum = new Pt(e)),
          (this.maximum = new Pt(t));
      }
      setFromPoints(e) {
        if (!a(e) || 0 === e.length) return this;
        let t;
        if (a(e[0])) t = e;
        else {
          t = [];
          for (let i = 0; i < e.length; i += 3) t.push(new Pt([e[i], e[i + 1], e[i + 2]]));
        }
        return wc.fromPoints(t, this);
      }
      clone() {
        return new wc(this.minimum, this.maximum, this.center);
      }
      equals(e) {
        return (
          this === e ||
          (Boolean(e) && this.minimum.equals(e.minimum) && this.maximum.equals(e.maximum))
        );
      }
      transform(e) {
        return (
          this.center.transformAsPoint(e),
          this.halfDiagonal.transform(e),
          this.minimum.transform(e),
          this.maximum.transform(e),
          this
        );
      }
      intersectPlane(e) {
        const { halfDiagonal: t } = this,
          i = vc.from(e.normal),
          n = t.x * Math.abs(i.x) + t.y * Math.abs(i.y) + t.z * Math.abs(i.z),
          r = this.center.dot(i) + e.distance;
        return r - n > 0 ? Aa.INSIDE : r + n < 0 ? Aa.OUTSIDE : Aa.INTERSECTING;
      }
      distanceTo(e) {
        return Math.sqrt(this.distanceSquaredTo(e));
      }
      distanceSquaredTo(e) {
        const t = xc.from(e).subtract(this.center),
          { halfDiagonal: i } = this;
        let n,
          r = 0;
        return (
          (n = Math.abs(t.x) - i.x),
          n > 0 && (r += n * n),
          (n = Math.abs(t.y) - i.y),
          n > 0 && (r += n * n),
          (n = Math.abs(t.z) - i.z),
          n > 0 && (r += n * n),
          r
        );
      }
      getBoundingMaximum(e = 1) {
        return {
          boundingMinValue: this.minimum.clone().multiplyByScalar(e),
          boundingMaxValue: this.maximum.clone().multiplyByScalar(e),
        };
      }
      static fromPoints(e, i) {
        let n;
        if (a(e[0]) && e[0] instanceof Pt) n = e;
        else {
          n = [];
          for (let t = 0; t < e.length; t += 3) n.push(new Pt([e[t], e[t + 1], e[t + 2]]));
        }
        if ((t(i) || (i = new wc()), !t(n) || 0 === n.length))
          return (
            (i.minimum = Pt.clone(Pt.ZERO, i.minimum)),
            (i.maximum = Pt.clone(Pt.ZERO, i.maximum)),
            (i.center = Pt.clone(Pt.ZERO, i.center)),
            (i.halfDiagonal = Pt.clone(Pt.ZERO, i.halfDiagonal)),
            i
          );
        let r = n[0].x,
          o = n[0].y,
          s = n[0].z,
          l = n[0].x,
          c = n[0].y,
          u = n[0].z;
        const h = n.length;
        for (let e = 1; e < h; e++) {
          const t = n[e],
            i = t.x,
            a = t.y,
            h = t.z;
          (r = Math.min(i, r)),
            (l = Math.max(i, l)),
            (o = Math.min(a, o)),
            (c = Math.max(a, c)),
            (s = Math.min(h, s)),
            (u = Math.max(h, u));
        }
        const d = i.minimum;
        (d.x = r), (d.y = o), (d.z = s);
        const p = i.maximum;
        return (
          (p.x = l),
          (p.y = c),
          (p.z = u),
          (i.center = Pt.midpoint(d, p, i.center)),
          (i.halfDiagonal = new Pt(i.maximum).subtract(i.center)),
          i
        );
      }
      static clone(e) {
        return new wc(e.minimum, e.maximum, e.center);
      }
    }
    const Tc = new Ge(),
      bc = new wc(),
      Sc = new Ja(),
      Ac = new Pt(),
      Pc = new Pt();
    class Ec {
      constructor(e, t) {
        e = (t = Z(t, wt.WGS84)).scaleToGeodeticSurface(e);
        const i = Il.eastNorthUpToFixedFrame(e, t);
        (this._ellipsoid = t),
          (this._origin = e),
          (this._xAxis = Pt.fromCartesian4(Je.getColumn(i, 0, Tc))),
          (this._yAxis = Pt.fromCartesian4(Je.getColumn(i, 1, Tc)));
        const n = Pt.fromCartesian4(Je.getColumn(i, 2, Tc));
        this._plane = Ca.fromPointNormal(e, n);
      }
      get ellipsoid() {
        return this._ellipsoid;
      }
      get origin() {
        return this._origin;
      }
      get plane() {
        return this._plane;
      }
      get xAxis() {
        return this._xAxis;
      }
      get yAxis() {
        return this._yAxis;
      }
      get zAxis() {
        return this._plane.normal;
      }
      static fromPoints(e, t) {
        const i = wc.fromPoints(e, bc);
        return new Ec(i.center, t);
      }
      projectPointOntoPlane(e, i) {
        const n = Sc;
        (n.origin = e), Pt.normalize(e, n.direction);
        let r = ds.rayPlane(n, this._plane, Ac);
        if (
          (t(r) || (Pt.negate(n.direction, n.direction), (r = ds.rayPlane(n, this._plane, Ac))),
          t(r))
        ) {
          const e = Pt.subtract(r, this._origin, r),
            n = Pt.dot(this._xAxis, e),
            o = Pt.dot(this._yAxis, e);
          return t(i) ? ((i.x = n), (i.y = o), i) : new $e(n, o);
        }
      }
      projectPointsOntoPlane(e, i) {
        t(i) || (i = []);
        let n = 0;
        const r = e.length;
        for (let o = 0; o < r; o++) {
          const r = this.projectPointOntoPlane(e[o], i[n]);
          t(r) && ((i[n] = r), n++);
        }
        return (i.length = n), i;
      }
      projectPointToNearestOnPlane(e, i) {
        t(i) || (i = new $e());
        const n = Sc;
        (n.origin = e), Pt.clone(this._plane.normal, n.direction);
        let r = ds.rayPlane(n, this._plane, Ac);
        t(r) || (Pt.negate(n.direction, n.direction), (r = ds.rayPlane(n, this._plane, Ac)));
        const o = Pt.subtract(r, this._origin, r),
          a = Pt.dot(this._xAxis, o),
          s = Pt.dot(this._yAxis, o);
        return (i.x = a), (i.y = s), i;
      }
      projectPointsToNearestOnPlane(e, i) {
        t(i) || (i = []);
        const n = e.length;
        i.length = n;
        for (let t = 0; t < n; t++) i[t] = this.projectPointToNearestOnPlane(e[t], i[t]);
        return i;
      }
      projectPointOntoEllipsoid(e, i) {
        t(i) || (i = new Pt());
        const n = this._ellipsoid,
          r = this._origin,
          o = this._yAxis,
          a = Pc;
        return (
          Pt.multiplyByScalar(this._xAxis, e.x, a),
          (i = Pt.add(r, a, i)),
          Pt.multiplyByScalar(o, e.y, a),
          Pt.add(i, a, i),
          n.scaleToGeocentricSurface(i, i),
          i
        );
      }
      projectPointsOntoEllipsoid(e, i) {
        const n = e.length;
        t(i) ? (i.length = n) : (i = new Array(n));
        for (let t = 0; t < n; ++t) i[t] = this.projectPointOntoEllipsoid(e[t], i[t]);
        return i;
      }
    }
    const Cc = new Pt(),
      Mc = new Pt(),
      Ic = new Pt(),
      Lc = new Pt(),
      Rc = new Pt(),
      Nc = new Pt(),
      Oc = new Pt();
    class Dc {
      constructor(e = [0, 0, 0], t = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {
        (this.center = new Pt().from(e)), (this.halfAxes = new je(t));
      }
      get halfSize() {
        const e = this.halfAxes.getColumn(0),
          t = this.halfAxes.getColumn(1),
          i = this.halfAxes.getColumn(2);
        return [new Pt(e).len(), new Pt(t).len(), new Pt(i).len()];
      }
      get quaternion() {
        const e = this.halfAxes.getColumn(0),
          t = this.halfAxes.getColumn(1),
          i = this.halfAxes.getColumn(2),
          n = new Pt(e).normalize(),
          r = new Pt(t).normalize(),
          o = new Pt(i).normalize();
        return new Et().fromMatrix3(new je([...n, ...r, ...o]));
      }
      fromCenterHalfSizeQuaternion(e, t, i) {
        const n = new Et(i),
          r = new je().fromQuaternion(n);
        return (
          (r[0] = r[0] * t[0]),
          (r[1] = r[1] * t[0]),
          (r[2] = r[2] * t[0]),
          (r[3] = r[3] * t[1]),
          (r[4] = r[4] * t[1]),
          (r[5] = r[5] * t[1]),
          (r[6] = r[6] * t[2]),
          (r[7] = r[7] * t[2]),
          (r[8] = r[8] * t[2]),
          (this.center = new Pt().from(e)),
          (this.halfAxes = r),
          this
        );
      }
      clone() {
        return new Dc(this.center, this.halfAxes);
      }
      equals(e) {
        return (
          this === e ||
          (Boolean(e) && this.center.equals(e.center) && this.halfAxes.equals(e.halfAxes))
        );
      }
      getBoundingSphere(e = new gc()) {
        const t = this.halfAxes,
          i = t.getColumn(0, Ic),
          n = t.getColumn(1, Lc),
          r = t.getColumn(2, Rc),
          o = Cc.copy(i).add(n).add(r);
        return e.center.copy(this.center), (e.radius = o.magnitude()), e;
      }
      getBoundingMaximum(e) {
        e = e || 1;
        const t = this.center.x,
          i = this.center.y,
          n = this.center.z,
          r = new Pt(this.halfAxes[0], this.halfAxes[1], this.halfAxes[2]).scale(e),
          o = new Pt(this.halfAxes[3], this.halfAxes[4], this.halfAxes[5]).scale(e),
          a = new Pt(this.halfAxes[6], this.halfAxes[7], this.halfAxes[8]).scale(e);
        return {
          boundingMaxValue: new Pt(t + r.x + r.y + r.z, i + o.x + o.y + o.z, n + a.x + a.y + a.z),
          boundingMinValue: new Pt(t - r.x - r.y - r.z, i - o.x - o.y - o.z, n - a.x - a.y - a.z),
        };
      }
      intersectPlane(e) {
        const t = this.center,
          i = e.normal,
          n = this.halfAxes,
          r = i.x,
          o = i.y,
          a = i.z,
          s =
            Math.abs(r * n[qe.COL0ROW0] + o * n[qe.COL0ROW1] + a * n[qe.COL0ROW2]) +
            Math.abs(r * n[qe.COL1ROW0] + o * n[qe.COL1ROW1] + a * n[qe.COL1ROW2]) +
            Math.abs(r * n[qe.COL2ROW0] + o * n[qe.COL2ROW1] + a * n[qe.COL2ROW2]),
          l = i.dot(t) + e.distance;
        return l <= -s ? Aa.OUTSIDE : l >= s ? Aa.INSIDE : Aa.INTERSECTING;
      }
      distanceTo(e) {
        return Math.sqrt(this.distanceSquaredTo(e));
      }
      distanceSquaredTo(e) {
        const t = Mc.from(e).subtract(this.center),
          i = this.halfAxes,
          n = i.getColumn(0, Ic),
          r = i.getColumn(1, Lc),
          o = i.getColumn(2, Rc),
          a = n.magnitude(),
          s = r.magnitude(),
          l = o.magnitude();
        n.normalize(), r.normalize(), o.normalize();
        let c,
          u = 0;
        return (
          (c = Math.abs(t.dot(n)) - a),
          c > 0 && (u += c * c),
          (c = Math.abs(t.dot(r)) - s),
          c > 0 && (u += c * c),
          (c = Math.abs(t.dot(o)) - l),
          c > 0 && (u += c * c),
          u
        );
      }
      computePlaneDistances(e, t, i) {
        return Dc.computePlaneDistances(this, e, t, i);
      }
      static computePlaneDistances(e, i, n, r) {
        const o = new Pt(),
          a = new Pt(),
          s = new Pt();
        t(r) || (r = new yc());
        let l = Number.POSITIVE_INFINITY,
          c = Number.NEGATIVE_INFINITY;
        const u = e.center,
          h = e.halfAxes,
          d = je.getColumn(h, 0, o),
          p = je.getColumn(h, 1, a),
          f = je.getColumn(h, 2, s),
          m = Pt.add(d, p, Nc);
        Pt.add(m, f, m), Pt.add(m, u, m);
        const _ = Pt.subtract(m, i, Oc);
        let g = Pt.dot(n, _);
        return (
          (l = Math.min(g, l)),
          (c = Math.max(g, c)),
          Pt.add(u, d, m),
          Pt.add(m, p, m),
          Pt.subtract(m, f, m),
          Pt.subtract(m, i, _),
          (g = Pt.dot(n, _)),
          (l = Math.min(g, l)),
          (c = Math.max(g, c)),
          Pt.add(u, d, m),
          Pt.subtract(m, p, m),
          Pt.add(m, f, m),
          Pt.subtract(m, i, _),
          (g = Pt.dot(n, _)),
          (l = Math.min(g, l)),
          (c = Math.max(g, c)),
          Pt.add(u, d, m),
          Pt.subtract(m, p, m),
          Pt.subtract(m, f, m),
          Pt.subtract(m, i, _),
          (g = Pt.dot(n, _)),
          (l = Math.min(g, l)),
          (c = Math.max(g, c)),
          Pt.subtract(u, d, m),
          Pt.add(m, p, m),
          Pt.add(m, f, m),
          Pt.subtract(m, i, _),
          (g = Pt.dot(n, _)),
          (l = Math.min(g, l)),
          (c = Math.max(g, c)),
          Pt.subtract(u, d, m),
          Pt.add(m, p, m),
          Pt.subtract(m, f, m),
          Pt.subtract(m, i, _),
          (g = Pt.dot(n, _)),
          (l = Math.min(g, l)),
          (c = Math.max(g, c)),
          Pt.subtract(u, d, m),
          Pt.subtract(m, p, m),
          Pt.add(m, f, m),
          Pt.subtract(m, i, _),
          (g = Pt.dot(n, _)),
          (l = Math.min(g, l)),
          (c = Math.max(g, c)),
          Pt.subtract(u, d, m),
          Pt.subtract(m, p, m),
          Pt.subtract(m, f, m),
          Pt.subtract(m, i, _),
          (g = Pt.dot(n, _)),
          (l = Math.min(g, l)),
          (c = Math.max(g, c)),
          (r.start = l),
          (r.stop = c),
          r
        );
      }
      transform(e) {
        this.center.transformAsPoint(e);
        const t = e.clone();
        (t[12] = 0), (t[13] = 0), (t[14] = 0), (t[15] = 1);
        const i = this.halfAxes.getColumn(0, Ic);
        i.transformAsPoint(t);
        const n = this.halfAxes.getColumn(1, Lc);
        n.transformAsPoint(t);
        const r = this.halfAxes.getColumn(2, Rc);
        return r.transformAsPoint(t), (this.halfAxes = new je([...i, ...n, ...r])), this;
      }
      getTransform() {
        return Je.fromRotationTranslation(this.halfAxes, this.center);
      }
      static fromRectangle(e, t, i, n, r) {
        const o = new as(),
          a = new Pt(),
          s = new as(),
          l = new as(),
          c = new as(),
          u = new as(),
          h = new as(),
          d = new Pt(),
          p = new Pt(),
          f = new Pt(),
          m = new Pt(),
          _ = new Pt(),
          g = new $e(),
          y = new $e(),
          x = new $e(),
          v = new $e(),
          w = new $e(),
          T = new Pt(),
          b = new Pt(),
          S = new Pt(),
          A = new Pt(),
          P = new $e(),
          E = new Pt(),
          C = new Pt(),
          M = new Pt(),
          I = new Ca(Pt.UNIT_X, 0);
        let L, R, N, O, D, F, z;
        if (((t = Z(t, 0)), (i = Z(i, 0)), (n = Z(n, wt.WGS84)), e.width <= Me.CesiumMath.PI)) {
          const T = Nl.center(e, o),
            b = n.cartographicToCartesianInRadians(T, a),
            S = new Ec(b, n);
          z = S.plane;
          const A = T.longitude,
            P = e.south < 0 && e.north > 0 ? 0 : T.latitude,
            E = as.fromRadians(A, e.north, i, s),
            C = as.fromRadians(e.west, e.north, i, l),
            M = as.fromRadians(e.west, P, i, c),
            I = as.fromRadians(e.west, e.south, i, u),
            B = as.fromRadians(A, e.south, i, h),
            V = n.cartographicToCartesianInRadians(E, d);
          let U = n.cartographicToCartesianInRadians(C, p);
          const k = n.cartographicToCartesianInRadians(M, f);
          let G = n.cartographicToCartesianInRadians(I, m);
          const H = n.cartographicToCartesianInRadians(B, _),
            Y = S.projectPointToNearestOnPlane(V, g),
            q = S.projectPointToNearestOnPlane(U, y),
            X = S.projectPointToNearestOnPlane(k, x),
            j = S.projectPointToNearestOnPlane(G, v),
            W = S.projectPointToNearestOnPlane(H, w);
          return (
            (L = Math.min(q.x, X.x, j.x)),
            (R = -L),
            (O = Math.max(q.y, Y.y)),
            (N = Math.min(j.y, W.y)),
            (C.height = I.height = t),
            (U = n.cartographicToCartesianInRadians(C, p)),
            (G = n.cartographicToCartesianInRadians(I, m)),
            (D = Math.min(Ca.getPointDistance(z, U), Ca.getPointDistance(z, G))),
            (F = i),
            zc(S.origin, S.xAxis, S.yAxis, S.zAxis, L, R, N, O, D, F, r)
          );
        }
        const B = e.south > 0,
          V = e.north < 0,
          U = B ? e.south : V ? e.north : 0,
          k = Nl.center(e, o).longitude,
          G = Pt.fromRadians(k, U, i, n, T);
        G.z = 0;
        const H =
            Math.abs(G.x) < Me.CesiumMath.EPSILON10 && Math.abs(G.y) < Me.CesiumMath.EPSILON10
              ? Pt.UNIT_X
              : Pt.normalize(G, b),
          Y = Pt.UNIT_Z,
          q = Pt.cross(H, Y, S);
        z = Ca.fromPointNormal(G, H, I);
        const X = Pt.fromRadians(k + Me.CesiumMath.PI_OVER_TWO, U, i, n, A);
        (R = Pt.dot(Ca.projectPointOntoPlane(z, X, P), q)),
          (L = -R),
          (O = Pt.fromRadians(0, e.north, V ? t : i, n, E).z),
          (N = Pt.fromRadians(0, e.south, B ? t : i, n, C).z);
        const j = Pt.fromRadians(e.east, U, i, n, M);
        return (D = Ca.getPointDistance(z, j)), (F = 0), zc(G, q, Y, H, L, R, N, O, D, F, r);
      }
      setFromPoints(e) {
        let t;
        if (a(e[0]) && e[0] instanceof Pt) t = e;
        else {
          t = [];
          for (let i = 0; i < e.length; i += 3) t.push(new Pt([e[i], e[i + 1], e[i + 2]]));
        }
        return Dc.fromPoints(t, this);
      }
      static fromPoints(e, i) {
        const n = new Pt(),
          r = new Pt(),
          o = new Pt(),
          a = new Pt(),
          s = new Pt(),
          l = new Pt(),
          c = new je(),
          u = { unitary: new je(), diagonal: new je() };
        if ((t(i) || (i = new Dc()), !t(e) || 0 === e.length))
          return (i.halfAxes = je.ZERO), (i.center = Pt.ZERO), i;
        let h;
        const d = e.length,
          p = Pt.clone(e[0], n);
        for (h = 1; h < d; h++) Pt.add(p, e[h], p);
        const f = 1 / d;
        Pt.multiplyByScalar(p, f, p);
        let m,
          _ = 0,
          g = 0,
          y = 0,
          x = 0,
          v = 0,
          w = 0;
        for (h = 0; h < d; h++)
          (m = Pt.subtract(e[h], p, r)),
            (_ += m.x * m.x),
            (g += m.x * m.y),
            (y += m.x * m.z),
            (x += m.y * m.y),
            (v += m.y * m.z),
            (w += m.z * m.z);
        (_ *= f), (g *= f), (y *= f), (x *= f), (v *= f), (w *= f);
        const T = c;
        (T[0] = _),
          (T[1] = g),
          (T[2] = y),
          (T[3] = g),
          (T[4] = x),
          (T[5] = v),
          (T[6] = y),
          (T[7] = v),
          (T[8] = w);
        const b = je.computeEigenDecomposition(T, u),
          S = je.clone(b.unitary, i.halfAxes);
        let A = je.getColumn(S, 0, a),
          P = je.getColumn(S, 1, s),
          E = je.getColumn(S, 2, l),
          C = -Number.MAX_VALUE,
          M = -Number.MAX_VALUE,
          I = -Number.MAX_VALUE,
          L = Number.MAX_VALUE,
          R = Number.MAX_VALUE,
          N = Number.MAX_VALUE;
        for (h = 0; h < d; h++)
          (m = e[h]),
            (C = Math.max(Pt.dot(A, m), C)),
            (M = Math.max(Pt.dot(P, m), M)),
            (I = Math.max(Pt.dot(E, m), I)),
            (L = Math.min(Pt.dot(A, m), L)),
            (R = Math.min(Pt.dot(P, m), R)),
            (N = Math.min(Pt.dot(E, m), N));
        (A = Pt.multiplyByScalar(A, 0.5 * (L + C), A)),
          (P = Pt.multiplyByScalar(P, 0.5 * (R + M), P)),
          (E = Pt.multiplyByScalar(E, 0.5 * (N + I), E));
        const O = Pt.add(A, P, i.center);
        Pt.add(O, E, O);
        const D = o;
        return (
          (D.x = C - L),
          (D.y = M - R),
          (D.z = I - N),
          Pt.multiplyByScalar(D, 0.5, D),
          je.multiplyByScale(i.halfAxes, D, i.halfAxes),
          i
        );
      }
      static clone(e) {
        return new Dc(e.center, e.halfAxes);
      }
      static computeCorners(e, i) {
        const n = new Pt(),
          r = new Pt(),
          o = new Pt();
        t(i) ||
          (i = [new Pt(), new Pt(), new Pt(), new Pt(), new Pt(), new Pt(), new Pt(), new Pt()]);
        const a = e.center,
          s = e.halfAxes,
          l = je.getColumn(s, 0, n),
          c = je.getColumn(s, 1, r),
          u = je.getColumn(s, 2, o);
        return (
          Pt.clone(a, i[0]),
          Pt.subtract(i[0], l, i[0]),
          Pt.subtract(i[0], c, i[0]),
          Pt.subtract(i[0], u, i[0]),
          Pt.clone(a, i[1]),
          Pt.subtract(i[1], l, i[1]),
          Pt.subtract(i[1], c, i[1]),
          Pt.add(i[1], u, i[1]),
          Pt.clone(a, i[2]),
          Pt.subtract(i[2], l, i[2]),
          Pt.add(i[2], c, i[2]),
          Pt.subtract(i[2], u, i[2]),
          Pt.clone(a, i[3]),
          Pt.subtract(i[3], l, i[3]),
          Pt.add(i[3], c, i[3]),
          Pt.add(i[3], u, i[3]),
          Pt.clone(a, i[4]),
          Pt.add(i[4], l, i[4]),
          Pt.subtract(i[4], c, i[4]),
          Pt.subtract(i[4], u, i[4]),
          Pt.clone(a, i[5]),
          Pt.add(i[5], l, i[5]),
          Pt.subtract(i[5], c, i[5]),
          Pt.add(i[5], u, i[5]),
          Pt.clone(a, i[6]),
          Pt.add(i[6], l, i[6]),
          Pt.add(i[6], c, i[6]),
          Pt.subtract(i[6], u, i[6]),
          Pt.clone(a, i[7]),
          Pt.add(i[7], l, i[7]),
          Pt.add(i[7], c, i[7]),
          Pt.add(i[7], u, i[7]),
          i
        );
      }
      computeCorners(e) {
        return Dc.computeCorners(this, e);
      }
      union(e, i) {
        if (!(e instanceof Dc)) throw new Error('包围盒的类型不正确！');
        t(i) || (i = new Dc());
        let n = [];
        const r = Dc.computeCorners(this),
          o = Dc.computeCorners(e);
        return (n = n.concat(r, o)), Dc.fromPoints(n);
      }
      static union(e, i, n) {
        if (!(e instanceof Dc && i instanceof Dc)) throw new Error('包围盒的类型不正确！');
        t(n) || (n = new Dc());
        let r = [];
        const o = Dc.computeCorners(e),
          a = Dc.computeCorners(i);
        return (r = r.concat(o, a)), Dc.fromPoints(r);
      }
    }
    const Fc = new Pt();
    function zc(e, i, n, r, o, a, s, l, c, u, h) {
      t(h) || (h = new Dc());
      const d = h.halfAxes;
      je.setColumn(d, 0, i, d), je.setColumn(d, 1, n, d), je.setColumn(d, 2, r, d);
      let p = Mc;
      (p.x = (o + a) / 2), (p.y = (s + l) / 2), (p.z = (c + u) / 2);
      const f = Fc;
      (f.x = (a - o) / 2), (f.y = (l - s) / 2), (f.z = (u - c) / 2);
      const m = h.center;
      return (p = je.multiplyByVector(d, p, p)), Pt.add(e, p, m), je.multiplyByScale(d, f, d), h;
    }
    function Bc() {
      return !0;
    }
    function Vc(e, t) {
      function i() {
        throw new Error(t);
      }
      for (const t in e) 'function' == typeof e[t] && (e[t] = i);
      e.isDestroyed = Bc;
    }
    const Uc = {
      _maximumCombinedTextureImageUnits: 0,
      _maximumCubeMapSize: 0,
      _maximumFragmentUniformVectors: 0,
      _maximumTextureImageUnits: 0,
      _maximumRenderbufferSize: 0,
      _maximumTextureSize: 0,
      _maximumVaryingVectors: 0,
      _maximumVertexAttributes: 0,
      _maximumVertexTextureImageUnits: 0,
      _maximumVertexUniformVectors: 0,
      _minimumAliasedLineWidth: 0,
      _maximumAliasedLineWidth: 0,
      _minimumAliasedPointSize: 0,
      _maximumAliasedPointSize: 0,
      _maximumViewportWidth: 0,
      _maximumViewportHeight: 0,
      _maximumTextureFilterAnisotropy: 0,
      _maximumDrawBuffers: 0,
      _maximumColorAttachments: 0,
      _highpFloatSupported: !1,
      _highpIntSupported: !1,
    };
    Object.defineProperties(Uc, {
      maximumCombinedTextureImageUnits: { get: () => Uc._maximumCombinedTextureImageUnits },
      maximumCubeMapSize: { get: () => Uc._maximumCubeMapSize },
      maximumFragmentUniformVectors: { get: () => Uc._maximumFragmentUniformVectors },
      maximumTextureImageUnits: { get: () => Uc._maximumTextureImageUnits },
      maximumRenderbufferSize: { get: () => Uc._maximumRenderbufferSize },
      maximumTextureSize: { get: () => Uc._maximumTextureSize },
      maximumVaryingVectors: { get: () => Uc._maximumVaryingVectors },
      maximumVertexAttributes: { get: () => Uc._maximumVertexAttributes },
      maximumVertexTextureImageUnits: { get: () => Uc._maximumVertexTextureImageUnits },
      maximumVertexUniformVectors: { get: () => Uc._maximumVertexUniformVectors },
      minimumAliasedLineWidth: { get: () => Uc._minimumAliasedLineWidth },
      maximumAliasedLineWidth: { get: () => Uc._maximumAliasedLineWidth },
      minimumAliasedPointSize: { get: () => Uc._minimumAliasedPointSize },
      maximumAliasedPointSize: { get: () => Uc._maximumAliasedPointSize },
      maximumViewportWidth: { get: () => Uc._maximumViewportWidth },
      maximumViewportHeight: { get: () => Uc._maximumViewportHeight },
      maximumTextureFilterAnisotropy: { get: () => Uc._maximumTextureFilterAnisotropy },
      maximumDrawBuffers: { get: () => Uc._maximumDrawBuffers },
      maximumColorAttachments: { get: () => Uc._maximumColorAttachments },
      highpFloatSupported: { get: () => Uc._highpFloatSupported },
      highpIntSupported: { get: () => Uc._highpIntSupported },
    });
    const kc = {
      NEAREST: Ll.NEAREST,
      LINEAR: Ll.LINEAR,
      validate: function (e) {
        return e === kc.NEAREST || e === kc.LINEAR;
      },
    };
    var Gc = Object.freeze(kc);
    const Hc = {
      NEAREST: Ll.NEAREST,
      LINEAR: Ll.LINEAR,
      NEAREST_MIPMAP_NEAREST: Ll.NEAREST_MIPMAP_NEAREST,
      LINEAR_MIPMAP_NEAREST: Ll.LINEAR_MIPMAP_NEAREST,
      NEAREST_MIPMAP_LINEAR: Ll.NEAREST_MIPMAP_LINEAR,
      LINEAR_MIPMAP_LINEAR: Ll.LINEAR_MIPMAP_LINEAR,
      validate: function (e) {
        return (
          e === Hc.NEAREST ||
          e === Hc.LINEAR ||
          e === Hc.NEAREST_MIPMAP_NEAREST ||
          e === Hc.LINEAR_MIPMAP_NEAREST ||
          e === Hc.NEAREST_MIPMAP_LINEAR ||
          e === Hc.LINEAR_MIPMAP_LINEAR
        );
      },
    };
    var Yc = Object.freeze(Hc);
    const qc = {
      CLAMP_TO_EDGE: Ll.CLAMP_TO_EDGE,
      REPEAT: Ll.REPEAT,
      MIRRORED_REPEAT: Ll.MIRRORED_REPEAT,
      validate: (e) => e === qc.CLAMP_TO_EDGE || e === qc.REPEAT || e === qc.MIRRORED_REPEAT,
    };
    var Xc = Object.freeze(qc);
    class jc {
      constructor(e) {
        const i = (e = e || {}).wrapS || Xc.CLAMP_TO_EDGE,
          n = e.wrapT || Xc.CLAMP_TO_EDGE,
          r = e.minificationFilter || Yc.LINEAR,
          o = e.magnificationFilter || Gc.LINEAR,
          a = t(e.maximumAnisotropy) ? e.maximumAnisotropy : 1;
        if (!Xc.validate(i)) throw new Wa('Invalid sampler.wrapS.');
        if (!Xc.validate(n)) throw new Wa('Invalid sampler.wrapT.');
        if (!Yc.validate(r)) throw new Wa('Invalid sampler.minificationFilter.');
        if (!Gc.validate(o)) throw new Wa('Invalid sampler.magnificationFilter.');
        (this._wrapS = i),
          (this._wrapT = n),
          (this._minificationFilter = r),
          (this._magnificationFilter = o),
          (this._maximumAnisotropy = a);
      }
      get wrapS() {
        return this._wrapS;
      }
      get wrapT() {
        return this._wrapT;
      }
      get minificationFilter() {
        return this._minificationFilter;
      }
      get magnificationFilter() {
        return this._magnificationFilter;
      }
      get maximumAnisotropy() {
        return this._maximumAnisotropy;
      }
      static equals(e, i) {
        return (
          e === i ||
          (t(e) &&
            t(i) &&
            e._wrapS === i._wrapS &&
            e._wrapT === i._wrapT &&
            e._minificationFilter === i._minificationFilter &&
            e._magnificationFilter === i._magnificationFilter &&
            e._maximumAnisotropy === i._maximumAnisotropy)
        );
      }
      static NEAREST = Object.freeze(
        new jc({
          wrapS: Xc.CLAMP_TO_EDGE,
          wrapT: Xc.CLAMP_TO_EDGE,
          minificationFilter: Yc.NEAREST,
          magnificationFilter: Gc.NEAREST,
        }),
      );
    }
    const Wc = {
        ALPHA: Me.COLORTYPEANDLENGTH.ALPHA,
        RGB: Me.COLORTYPEANDLENGTH.RGB,
        RGBA: Me.COLORTYPEANDLENGTH.RGBA,
        LUMINANCE: Me.COLORTYPEANDLENGTH.LUMINANCE,
        LUMINANCE_ALPHA: Me.COLORTYPEANDLENGTH.LUMINANCE_ALPHA,
        RGB_DXT1: Me.COMPRESSED_TEXTURE_TYPE.COMPRESSED_RGB_S3TC.COMPRESSED_RGB_S3TC_DXT1_EXT,
        RGBA_DXT1: Me.COMPRESSED_TEXTURE_TYPE.COMPRESSED_RGB_S3TC.COMPRESSED_RGBA_S3TC_DXT1_EXT,
        RGBA_DXT3: Me.COMPRESSED_TEXTURE_TYPE.COMPRESSED_RGB_S3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT,
        RGBA_DXT5: Me.COMPRESSED_TEXTURE_TYPE.COMPRESSED_RGB_S3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT,
        RGB_PVRTC_4BPPV1:
          Me.COMPRESSED_TEXTURE_TYPE.COMPRESSED_RGB_PVRTC.COMPRESSED_RGB_PVRTC_4BPPV1_IMG,
        RGB_PVRTC_2BPPV1:
          Me.COMPRESSED_TEXTURE_TYPE.COMPRESSED_RGB_PVRTC.COMPRESSED_RGB_PVRTC_2BPPV1_IMG,
        RGBA_PVRTC_4BPPV1:
          Me.COMPRESSED_TEXTURE_TYPE.COMPRESSED_RGB_PVRTC.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,
        RGBA_PVRTC_2BPPV1:
          Me.COMPRESSED_TEXTURE_TYPE.COMPRESSED_RGB_PVRTC.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG,
        RGB_ETC1: Me.COMPRESSED_TEXTURE_TYPE.COMPRESSED_RGB_ETC1_WEBGL,
        isCompressedFormat(e) {
          let t;
          return (
            (t = Array.isArray(e) && e.length > 0 ? e[0].format : e.format || ''),
            t === Wc.RGB_DXT1 ||
              t === Wc.RGBA_DXT1 ||
              t === Wc.RGBA_DXT3 ||
              t === Wc.RGBA_DXT5 ||
              t === Wc.RGB_PVRTC_4BPPV1 ||
              t === Wc.RGB_PVRTC_2BPPV1 ||
              t === Wc.RGBA_PVRTC_4BPPV1 ||
              t === Wc.RGBA_PVRTC_2BPPV1 ||
              t === Wc.RGB_ETC1
          );
        },
        isDXTFormat: (e) =>
          e === Wc.RGB_DXT1 || e === Wc.RGBA_DXT1 || e === Wc.RGBA_DXT3 || e === Wc.RGBA_DXT5,
        isPVRTCFormat: (e) =>
          e === Wc.RGB_PVRTC_4BPPV1 ||
          e === Wc.RGB_PVRTC_2BPPV1 ||
          e === Wc.RGBA_PVRTC_4BPPV1 ||
          e === Wc.RGBA_PVRTC_2BPPV1,
        isETC1Format: (e) => e === Wc.RGB_ETC1,
        compressedTextureSizeInBytes(e, t, i) {
          switch (e) {
            case Wc.RGB_DXT1:
            case Wc.RGBA_DXT1:
            case Wc.RGB_ETC1:
              return Math.floor((t + 3) / 4) * Math.floor((i + 3) / 4) * 8;
            case Wc.RGBA_DXT3:
            case Wc.RGBA_DXT5:
              return Math.floor((t + 3) / 4) * Math.floor((i + 3) / 4) * 16;
            case Wc.RGB_PVRTC_4BPPV1:
            case Wc.RGBA_PVRTC_4BPPV1:
              return Math.floor((Math.max(t, 8) * Math.max(i, 8) * 4 + 7) / 8);
            case Wc.RGB_PVRTC_2BPPV1:
            case Wc.RGBA_PVRTC_2BPPV1:
              return Math.floor((Math.max(t, 16) * Math.max(i, 8) * 2 + 7) / 8);
            default:
              return 0;
          }
        },
        componentsLength(e) {
          switch (e) {
            case Wc.RGB:
              return 3;
            case Wc.RGBA:
              return 4;
            case Wc.LUMINANCE_ALPHA:
              return 2;
            default:
              return 1;
          }
        },
        textureSizeInBytes(e, t, i, n) {
          let r = Wc.componentsLength(e);
          return Wc.isPacked(t) && (r = 1), r * Wc.sizeInBytes(t) * i * n;
        },
        sizeInBytes(e) {
          switch (e) {
            case Me.PixelDatatype.UNSIGNED_BYTE:
              return 1;
            case Me.PixelDatatype.UNSIGNED_SHORT:
            case Me.PixelDatatype.UNSIGNED_SHORT_4_4_4_4:
            case Me.PixelDatatype.UNSIGNED_SHORT_5_5_5_1:
            case Me.PixelDatatype.UNSIGNED_SHORT_5_6_5:
            case Me.PixelDatatype.HALF_FLOAT:
              return 2;
            case Me.PixelDatatype.UNSIGNED_INT:
            case Me.PixelDatatype.FLOAT:
            case Me.PixelDatatype.UNSIGNED_INT_24_8:
              return 4;
          }
        },
        isPacked: (e) =>
          e === Me.PixelDatatype.UNSIGNED_INT_24_8 ||
          e === Me.PixelDatatype.UNSIGNED_SHORT_4_4_4_4 ||
          e === Me.PixelDatatype.UNSIGNED_SHORT_5_5_5_1 ||
          e === Me.PixelDatatype.UNSIGNED_SHORT_5_6_5,
      },
      $c = {
        UNSIGNED_BYTE: Ll.UNSIGNED_BYTE,
        UNSIGNED_SHORT: Ll.UNSIGNED_SHORT,
        UNSIGNED_INT: Ll.UNSIGNED_INT,
        FLOAT: Ll.FLOAT,
        HALF_FLOAT: Ll.HALF_FLOAT_OES,
        UNSIGNED_INT_24_8: Ll.UNSIGNED_INT_24_8,
        UNSIGNED_SHORT_4_4_4_4: Ll.UNSIGNED_SHORT_4_4_4_4,
        UNSIGNED_SHORT_5_5_5_1: Ll.UNSIGNED_SHORT_5_5_5_1,
        UNSIGNED_SHORT_5_6_5: Ll.UNSIGNED_SHORT_5_6_5,
        toWebGLConstant(e, t) {
          switch (e) {
            case $c.UNSIGNED_BYTE:
              return Ll.UNSIGNED_BYTE;
            case $c.UNSIGNED_SHORT:
              return Ll.UNSIGNED_SHORT;
            case $c.UNSIGNED_INT:
              return Ll.UNSIGNED_INT;
            case $c.FLOAT:
              return Ll.FLOAT;
            case $c.HALF_FLOAT:
              return t.webgl2 ? Ll.HALF_FLOAT : Ll.HALF_FLOAT_OES;
            case $c.UNSIGNED_INT_24_8:
              return Ll.UNSIGNED_INT_24_8;
            case $c.UNSIGNED_SHORT_4_4_4_4:
              return Ll.UNSIGNED_SHORT_4_4_4_4;
            case $c.UNSIGNED_SHORT_5_5_5_1:
              return Ll.UNSIGNED_SHORT_5_5_5_1;
            case $c.UNSIGNED_SHORT_5_6_5:
              return $c.UNSIGNED_SHORT_5_6_5;
          }
        },
        isPacked: (e) =>
          e === $c.UNSIGNED_INT_24_8 ||
          e === $c.UNSIGNED_SHORT_4_4_4_4 ||
          e === $c.UNSIGNED_SHORT_5_5_5_1 ||
          e === $c.UNSIGNED_SHORT_5_6_5,
        sizeInBytes(e) {
          switch (e) {
            case $c.UNSIGNED_BYTE:
              return 1;
            case $c.UNSIGNED_SHORT:
            case $c.UNSIGNED_SHORT_4_4_4_4:
            case $c.UNSIGNED_SHORT_5_5_5_1:
            case $c.UNSIGNED_SHORT_5_6_5:
            case $c.HALF_FLOAT:
              return 2;
            case $c.UNSIGNED_INT:
            case $c.FLOAT:
            case $c.UNSIGNED_INT_24_8:
              return 4;
          }
        },
        validate: (e) =>
          e === $c.UNSIGNED_BYTE ||
          e === $c.UNSIGNED_SHORT ||
          e === $c.UNSIGNED_INT ||
          e === $c.FLOAT ||
          e === $c.HALF_FLOAT ||
          e === $c.UNSIGNED_INT_24_8 ||
          e === $c.UNSIGNED_SHORT_4_4_4_4 ||
          e === $c.UNSIGNED_SHORT_5_5_5_1 ||
          e === $c.UNSIGNED_SHORT_5_6_5,
      };
    var Zc = Object.freeze($c);
    const Kc = {
      DEPTH_COMPONENT: Ll.DEPTH_COMPONENT,
      DEPTH_STENCIL: Ll.DEPTH_STENCIL,
      ALPHA: Ll.ALPHA,
      RGB: Ll.RGB,
      RGBA: Ll.RGBA,
      LUMINANCE: Ll.LUMINANCE,
      LUMINANCE_ALPHA: Ll.LUMINANCE_ALPHA,
      RGB_DXT1: Ll.COMPRESSED_RGB_S3TC_DXT1_EXT,
      RGBA_DXT1: Ll.COMPRESSED_RGBA_S3TC_DXT1_EXT,
      RGBA_DXT3: Ll.COMPRESSED_RGBA_S3TC_DXT3_EXT,
      RGBA_DXT5: Ll.COMPRESSED_RGBA_S3TC_DXT5_EXT,
      RGB_PVRTC_4BPPV1: Ll.COMPRESSED_RGB_PVRTC_4BPPV1_IMG,
      RGB_PVRTC_2BPPV1: Ll.COMPRESSED_RGB_PVRTC_2BPPV1_IMG,
      RGBA_PVRTC_4BPPV1: Ll.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,
      RGBA_PVRTC_2BPPV1: Ll.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG,
      RGBA_ASTC: Ll.COMPRESSED_RGBA_ASTC_4x4_WEBGL,
      RGB_ETC1: Ll.COMPRESSED_RGB_ETC1_WEBGL,
      RGB8_ETC2: Ll.COMPRESSED_RGB8_ETC2,
      RGBA8_ETC2_EAC: Ll.COMPRESSED_RGBA8_ETC2_EAC,
      RGBA_BC7: Ll.COMPRESSED_RGBA_BPTC_UNORM,
      componentsLength: function (e) {
        switch (e) {
          case Kc.RGB:
            return 3;
          case Kc.RGBA:
            return 4;
          case Kc.LUMINANCE_ALPHA:
            return 2;
          default:
            return 1;
        }
      },
      validate: function (e) {
        return (
          e === Kc.DEPTH_COMPONENT ||
          e === Kc.DEPTH_STENCIL ||
          e === Kc.ALPHA ||
          e === Kc.RGB ||
          e === Kc.RGBA ||
          e === Kc.LUMINANCE ||
          e === Kc.LUMINANCE_ALPHA ||
          e === Kc.RGB_DXT1 ||
          e === Kc.RGBA_DXT1 ||
          e === Kc.RGBA_DXT3 ||
          e === Kc.RGBA_DXT5 ||
          e === Kc.RGB_PVRTC_4BPPV1 ||
          e === Kc.RGB_PVRTC_2BPPV1 ||
          e === Kc.RGBA_PVRTC_4BPPV1 ||
          e === Kc.RGBA_PVRTC_2BPPV1 ||
          e === Kc.RGBA_ASTC ||
          e === Kc.RGB_ETC1 ||
          e === Kc.RGB8_ETC2 ||
          e === Kc.RGBA8_ETC2_EAC ||
          e === Kc.RGBA_BC7
        );
      },
      isColorFormat: function (e) {
        return (
          e === Kc.ALPHA ||
          e === Kc.RGB ||
          e === Kc.RGBA ||
          e === Kc.LUMINANCE ||
          e === Kc.LUMINANCE_ALPHA
        );
      },
      isDepthFormat: function (e) {
        return e === Kc.DEPTH_COMPONENT || e === Kc.DEPTH_STENCIL;
      },
      isCompressedFormat: function (e) {
        return (
          e === Kc.RGB_DXT1 ||
          e === Kc.RGBA_DXT1 ||
          e === Kc.RGBA_DXT3 ||
          e === Kc.RGBA_DXT5 ||
          e === Kc.RGB_PVRTC_4BPPV1 ||
          e === Kc.RGB_PVRTC_2BPPV1 ||
          e === Kc.RGBA_PVRTC_4BPPV1 ||
          e === Kc.RGBA_PVRTC_2BPPV1 ||
          e === Kc.RGBA_ASTC ||
          e === Kc.RGB_ETC1 ||
          e === Kc.RGB8_ETC2 ||
          e === Kc.RGBA8_ETC2_EAC ||
          e === Kc.RGBA_BC7
        );
      },
      isDXTFormat: function (e) {
        return e === Kc.RGB_DXT1 || e === Kc.RGBA_DXT1 || e === Kc.RGBA_DXT3 || e === Kc.RGBA_DXT5;
      },
      isPVRTCFormat: function (e) {
        return (
          e === Kc.RGB_PVRTC_4BPPV1 ||
          e === Kc.RGB_PVRTC_2BPPV1 ||
          e === Kc.RGBA_PVRTC_4BPPV1 ||
          e === Kc.RGBA_PVRTC_2BPPV1
        );
      },
      isASTCFormat: function (e) {
        return e === Kc.RGBA_ASTC;
      },
      isETC1Format: function (e) {
        return e === Kc.RGB_ETC1;
      },
      isETC2Format: function (e) {
        return e === Kc.RGB8_ETC2 || e === Kc.RGBA8_ETC2_EAC;
      },
      isBC7Format: function (e) {
        return e === Kc.RGBA_BC7;
      },
      compressedTextureSizeInBytes: function (e, t, i) {
        switch (e) {
          case Kc.RGB_DXT1:
          case Kc.RGBA_DXT1:
          case Kc.RGB_ETC1:
          case Kc.RGB8_ETC2:
            return Math.floor((t + 3) / 4) * Math.floor((i + 3) / 4) * 8;
          case Kc.RGBA_DXT3:
          case Kc.RGBA_DXT5:
          case Kc.RGBA_ASTC:
          case Kc.RGBA8_ETC2_EAC:
            return Math.floor((t + 3) / 4) * Math.floor((i + 3) / 4) * 16;
          case Kc.RGB_PVRTC_4BPPV1:
          case Kc.RGBA_PVRTC_4BPPV1:
            return Math.floor((Math.max(t, 8) * Math.max(i, 8) * 4 + 7) / 8);
          case Kc.RGB_PVRTC_2BPPV1:
          case Kc.RGBA_PVRTC_2BPPV1:
            return Math.floor((Math.max(t, 16) * Math.max(i, 8) * 2 + 7) / 8);
          case Kc.RGBA_BC7:
            return Math.ceil(t / 4) * Math.ceil(i / 4) * 16;
          default:
            return 0;
        }
      },
      textureSizeInBytes: function (e, t, i, n) {
        let r = Kc.componentsLength(e);
        return Zc.isPacked(t) && (r = 1), r * Zc.sizeInBytes(t) * i * n;
      },
      alignmentInBytes: function (e, t, i) {
        const n = Kc.textureSizeInBytes(e, t, i, 1) % 4;
        return 0 === n ? 4 : 2 === n ? 2 : 1;
      },
      createTypedArray: function (e, t, i, n) {
        let r;
        const o = Zc.sizeInBytes(t);
        return (
          (r =
            o === Uint8Array.BYTES_PER_ELEMENT
              ? Uint8Array
              : o === Uint16Array.BYTES_PER_ELEMENT
              ? Uint16Array
              : o === Float32Array.BYTES_PER_ELEMENT && t === Zc.FLOAT
              ? Float32Array
              : Uint32Array),
          new r(Kc.componentsLength(e) * i * n)
        );
      },
      flipY: function (e, t, i, n, r) {
        if (1 === r) return e;
        const o = Kc.createTypedArray(t, i, n, r),
          a = Kc.componentsLength(t),
          s = n * a;
        for (let t = 0; t < r; ++t) {
          const i = t * n * a,
            l = (r - t - 1) * n * a;
          for (let t = 0; t < s; ++t) o[l + t] = e[i + t];
        }
        return o;
      },
      toInternalFormat: function (e, t, i) {
        if (!i.webgl2) return e;
        if (e === Kc.DEPTH_STENCIL) return Ll.DEPTH24_STENCIL8;
        if (e === Kc.DEPTH_COMPONENT) {
          if (t === Zc.UNSIGNED_SHORT) return e;
          if (t === Zc.UNSIGNED_INT) return Ll.DEPTH_COMPONENT24;
        }
        if (t === Zc.FLOAT)
          switch (e) {
            case Kc.RGBA:
              return Ll.RGBA32F;
            case Kc.RGB:
              return Ll.RGB32F;
            case Kc.RG:
              return Ll.RG32F;
            case Kc.R:
              return Ll.R32F;
          }
        if (t === Zc.HALF_FLOAT)
          switch (e) {
            case Kc.RGBA:
              return Ll.RGBA16F;
            case Kc.RGB:
              return Ll.RGB16F;
            case Kc.RG:
              return Ll.RG16F;
            case Kc.R:
              return Ll.R16F;
          }
        return e;
      },
    };
    var Qc = Object.freeze(Kc);
    const Jc = {
      supported: !1,
      testSupport: function (e) {
        !iu && tu && (nu ? ru(e) : (eu = e));
      },
    };
    let eu,
      tu,
      iu = !1,
      nu = !1;
    function ru(e) {
      const t = e.createTexture();
      e.bindTexture(e.TEXTURE_2D, t);
      try {
        if ((e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, tu), e.isContextLost()))
          return;
        Jc.supported = !0;
      } catch (e) {}
      e.deleteTexture(t), (iu = !0);
    }
    function ou(e, t) {
      if (t && -1 !== t.indexOf('?')) {
        const i = t.split('?')[1],
          n = new RegExp(`(^|&)${e}=([^&]*)(&|$)`),
          r = i.match(n);
        if (null != r) return unescape(r[2]);
      }
      return null;
    }
    function au(e, t, i) {
      if (1 === arguments.length) return e;
      e.set(e.subarray(t + i), t);
    }
    function su(e) {
      const t = e.responseURL || e.__responseURL,
        i = e.response,
        n = i ? i.byteLength : 0,
        r = ou('token', t) || '',
        o = ou('appKey', t) || '',
        a = ou('key', t) || '';
      return n > 8 ? lu(i, n, a.length > 0 ? a : o.length > 0 ? o : r, e) : i;
    }
    function lu(e, t, i, n) {
      let r = new Uint8Array(e);
      if ('MEMM' === String.fromCharCode.apply(null, r.subarray(0, 4))) {
        const t = new Uint8Array([r[4], r[5], r[6], r[7]]),
          i = new Uint32Array(t.buffer);
        r = new Uint8Array(e, 16 + i[0]);
        const o = new Uint8Array(e, 16, i),
          a = String.fromCharCode.apply(null, o),
          s = JSON.parse(a);
        n.bbx = s;
      }
      const o = String.fromCharCode.apply(null, r.subarray(r.length - 8, r.length)),
        a = String.fromCharCode.apply(null, r.subarray(0, 9));
      if (o && 'minedata' === o.toLowerCase())
        return (
          i &&
            (function (e, t) {
              const i = e.length - 8;
              if (i <= t)
                for (let t = 0; t < i / 2; t++) {
                  const n = e[t];
                  (e[t] = e[i - t - 1]), (e[i - t - 1] = n);
                }
              else {
                const n = parseInt(i / t),
                  r = parseInt(t / 2);
                for (let i = 0; i < n; i++) {
                  const n = i * t,
                    o = (i + 1) * t - 1;
                  for (let t = n, i = 0; t < n + r; t++, i++) {
                    const n = o - i,
                      r = e[t];
                    (e[t] = e[n]), (e[n] = r);
                  }
                }
              }
            })(
              r,
              (function (e) {
                let t = 0;
                const i = e.length;
                for (let n = 0; n < i; n++) t += e.charCodeAt(n);
                return parseInt(t / i);
              })(i),
            ),
          r.slice(0, t - 8)
        );
      if (a && 'mineearth' === a.toLowerCase()) {
        const e = r[9],
          t = r[10];
        return (function (e, t, i) {
          const n = e.length - t * i,
            r = Math.floor(n / t);
          let o = 0,
            a = r;
          for (let n = 0; n < t; n++) au(e, a, i), (o = a), (a = o + r);
          return e.subarray(0, n);
        })(r.slice(11, r.length), e, t);
      }
      return e;
    }
    J.document &&
      ((tu = J.document.createElement('img')),
      (tu.onload = function () {
        eu && ru(eu), (eu = null), (nu = !0);
      }),
      (tu.onerror = function () {
        (iu = !0), (eu = null);
      }),
      (tu.src = 'data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA='));
    const cu = new Set(),
      uu = {
        Unknown: 'Unknown',
        Style: 'Style',
        Source: 'Source',
        Tile: 'Tile',
        Glyphs: 'Glyphs',
        SpriteImage: 'SpriteImage',
        SpriteJSON: 'SpriteJSON',
        Image: 'Image',
        PanoramaImage: 'PanoramaImage',
        PanoramaJson: 'PanoramaJson',
      };
    'function' == typeof Object.freeze && Object.freeze(uu);
    class hu extends Error {
      constructor(e, t, i) {
        401 === t &&
          i.includes('minemap') &&
          (e += ': you may have provided an invalid MineMap key.'),
          super(e),
          (this.status = t),
          (this.url = i);
      }
      toString() {
        return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
      }
    }
    const du = be()
        ? () => self.worker && self.worker.referrer
        : () => ('blob:' === J.location.protocol ? J.parent : J).location.href,
      pu = function (e, t) {
        if (!(/^file:/.test((i = e.url)) || (/^file:/.test(du()) && !/^\w+:/.test(i)))) {
          if (
            J.fetch &&
            J.Request &&
            J.AbortController &&
            J.Request.prototype.hasOwnProperty('signal')
          )
            return (function (e, t) {
              const i = new J.AbortController(),
                n = new J.Request(e.url, {
                  method: e.method || 'GET',
                  body: e.body,
                  credentials: e.credentials,
                  headers: e.headers,
                  referrer: du(),
                  signal: i.signal,
                });
              let r = !1,
                o = !1;
              'json' === e.type && n.headers.set('Accept', 'application/json');
              return (
                o ||
                  cu.has(n.url) ||
                  J.fetch(n)
                    .then((i) =>
                      i.ok
                        ? ((i) => {
                            ('arrayBuffer' === e.type
                              ? i.arrayBuffer()
                              : 'json' === e.type
                              ? i.json()
                              : i.text()
                            )
                              .then((n) => {
                                if (o) return;
                                r = !0;
                                let a = n;
                                const s = i.url.includes('png') || i.url.includes('jpg');
                                let l;
                                'arrayBuffer' !== e.type ||
                                  s ||
                                  ((l = { responseURL: i.url, response: n, bbx: null }),
                                  (a = su(l)),
                                  l.bbx &&
                                    ((l.bbx.minimumHeight = l.bbx.minHeight),
                                    (l.bbx.maximumHeight = l.bbx.maxHeight),
                                    delete l.bbx.minHeight,
                                    delete l.bbx.maxHeight)),
                                  t(
                                    null,
                                    a,
                                    i.headers.get('Cache-Control'),
                                    i.headers.get('Expires'),
                                    l?.bbx,
                                  );
                              })
                              .catch((e) => {
                                o || t(new Error(e.message));
                              });
                          })(i)
                        : (i.text(), (r = !0), t(new hu(i.statusText, i.status, e.url))),
                    )
                    .catch((e) => {
                      20 !== e.code && (cu.add(n.url), t(new Error(e.message)));
                    }),
                {
                  cancel: () => {
                    (o = !0), r || i.abort();
                  },
                }
              );
            })(e, t);
          if (be() && self.worker && self.worker.actor)
            return self.worker.actor.send('getResource', e, t, void 0, !0);
        }
        var i;
        return (function (e, t) {
          const i = new J.XMLHttpRequest();
          i.open(e.method || 'GET', e.url, !0),
            'arrayBuffer' === e.type && (i.responseType = 'arraybuffer');
          for (const t in e.headers) i.setRequestHeader(t, e.headers[t]);
          return (
            'json' === e.type &&
              ((i.responseType = 'text'), i.setRequestHeader('Accept', 'application/json')),
            (i.withCredentials = 'include' === e.credentials),
            (i.onerror = () => {
              t(new Error(i.statusText));
            }),
            (i.onload = () => {
              if (((i.status >= 200 && i.status < 300) || 0 === i.status) && null !== i.response) {
                let n = i.response;
                if ('json' === e.type)
                  try {
                    n = JSON.parse(i.response);
                  } catch (e) {
                    return t(e);
                  }
                let r = n;
                const o = e.url.includes('png') || e.url.includes('jpg');
                'arrayBuffer' !== e.type || o || (r = su(i)),
                  t(null, r, i.getResponseHeader('Cache-Control'), i.getResponseHeader('Expires'));
              } else t(new hu(i.statusText, i.status, e.url));
            }),
            i.send(e.body),
            { cancel: () => i.abort() }
          );
        })(e, t);
      },
      fu = function (e, t) {
        return pu(ce(e, { type: 'arrayBuffer' }), t);
      };
    function mu(e) {
      const t = J.document.createElement('a');
      return (
        (t.href = e),
        t.protocol === J.document.location.protocol && t.host === J.document.location.host
      );
    }
    function _u(e, t) {
      const i = new J.Image(),
        n = J.URL;
      let r = new J.Blob([new Uint8Array(e)], { type: 'image/png' });
      (i.onload = () => {
        (e = null),
          (r = null),
          t(null, i),
          n.revokeObjectURL(i.src),
          (i.onload = null),
          (i.src = null);
      }),
        (i.onerror = () =>
          t(
            new Error(
              'Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.',
            ),
          )),
        (i.src = e.byteLength ? n.createObjectURL(r) : Me.SOURCE.TRANSPARENT_PNG_URL);
    }
    let gu,
      yu,
      xu = !1;
    (gu = []), (yu = 0);
    const vu = function (e, t) {
        if (
          (Jc.supported && (e.headers || (e.headers = {}), (e.headers.accept = 'image/webp,*/*')),
          yu >= Me.SOURCE.MAX_PARALLEL_IMAGE_REQUESTS)
        ) {
          const i = {
            requestParameters: e,
            callback: t,
            cancelled: !1,
            cancel() {
              this.cancelled = !0;
            },
          };
          return gu.push(i), i;
        }
        yu++;
        let i = !1;
        const n = () => {
            if (!i)
              for (i = !0, yu--; gu.length && yu < Me.SOURCE.MAX_PARALLEL_IMAGE_REQUESTS; ) {
                const e = gu.shift(),
                  { requestParameters: t, callback: i, cancelled: n } = e;
                n || (e.cancel = vu(t, i).cancel);
              }
          },
          r = fu(e, (i, r, o, a) => {
            n(),
              i
                ? t(i)
                : r &&
                  (!J.createImageBitmap || e.isImageBitmap || e.isImageBitmap
                    ? _u(r, (e, i) => t(e, i, o, a))
                    : (function (e, t, i) {
                        if (xu) return _u(e, (e, t) => i(e, t));
                        let n = new J.Blob([new Uint8Array(e)], { type: 'image/png' });
                        J.createImageBitmap(n, t)
                          .then((t) => {
                            (n = null), (e = null), i(null, t);
                          })
                          .catch(() => {
                            (xu = !0), _u(e, (e, t) => i(e, t));
                          });
                      })(r, e.imageBitmapOptions, (e, i) => t(e, i, o, a)));
          });
        return {
          cancel: () => {
            r.cancel(), n();
          },
        };
      },
      {
        HTMLImageElement: wu,
        HTMLCanvasElement: Tu,
        HTMLVideoElement: bu,
        ImageData: Su,
        ImageBitmap: Au,
      } = J;
    class Pu {
      constructor(e) {
        const {
          map: t,
          context: i,
          pixelFormat: n,
          compressed: r,
          premultiply: o,
          flipY: a,
          texUrl: s,
          name: l,
          target: c,
          pixelDatatype: u,
          sampler: h,
        } = e;
        (this.map = Z(t, null)),
          (null != i && null != i) || !this.map || (this.context = this.map.painter.context);
        let d = e.image;
        (this.mIsGenerateMipmap = !1),
          (this.anisotropy = Math.min(
            Uc._maximumTextureFilterAnisotropy,
            void 0 === e.anisotropy ? Uc._maximumTextureFilterAnisotropy : e.anisotropy,
          )),
          s && (this.texUrl = s),
          e.warpS && (this.warpS = e.warpS),
          e.warpT && (this.warpT = e.warpT),
          e.minFilter && (this.minFilter = e.minFilter),
          e.magFilter && (this.magFilter = e.magFilter),
          (this.referenceCount = 1),
          (this.name = l || ''),
          i && (this.context = i),
          (this.pixelFormat = Z(n, Qc.RGBA)),
          (this.pixelDatatype = Z(u, Zc.UNSIGNED_BYTE)),
          (this.internalFormat = Qc.toInternalFormat(
            this.pixelFormat,
            this.pixelDatatype,
            this.context,
          )),
          (this.texture = this.context.gl.createTexture()),
          (this._powerOfTwoCalculated = !1),
          (this.powerOfTwoNoneSquareFlag = !1),
          (this.flipY = !!a),
          (this.premultiply = !!o),
          r
            ? ((this.compressed = r),
              (d = { data: d[0].data, width: d[0].width, height: d[0].height }),
              Wc.isDXTFormat(n) && !this.context._s3tc
                ? ve(
                    'When options.pixelFormat is S3TC compressed, this WebGL implementation must support the WEBGL_texture_compression_s3tc extension. Check context.s3tc.',
                  )
                : Wc.isPVRTCFormat(n) && !this.context._pvrtc
                ? ve(
                    'When options.pixelFormat is PVRTC compressed, this WebGL implementation must support the WEBGL_texture_compression_pvrtc extension. Check context.pvrtc.',
                  )
                : Wc.isETC1Format(n) &&
                  !this.context._etc1 &&
                  ve(
                    'When options.pixelFormat is ETC1 compressed, this WebGL implementation must support the WEBGL_texture_compression_etc1 extension. Check context.etc1.',
                  ))
            : (this.compressed = !1),
          (this._target = c || Ll.TEXTURE_2D),
          (this._hasSetSampler = !1),
          this.update(d, e),
          h && (this.sampler = h);
      }
      update(e, t) {
        const i = e?.width || t.width,
          n = e?.height || t.height,
          r = !this.size || this.size[0] !== i || this.size[1] !== n,
          { context: o } = this,
          { gl: a } = o;
        if (
          ((this.useMipmap = Boolean(t?.useMipmap)),
          (this.premultiply = Boolean(t?.premultiply)),
          null == i && null == n && this.map)
        )
          this.useMipmap = Z(t?.useMipmap, !0);
        else {
          if (
            (a.bindTexture(this._target, this.texture),
            o.pixelStoreUnpackFlipY.set(this.flipY),
            o.pixelStoreUnpack.set(1),
            o.pixelStoreUnpackPremultiplyAlpha.set(this.premultiply),
            r)
          )
            if (((this.size = [i, n]), this.compressed))
              a.compressedTexImage2D(this._target, 0, this.internalFormat, i, n, 0, e.data);
            else if (t && t.hasOwnProperty('framebuffer'))
              a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
                a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, !1),
                null !== t.framebuffer && t.framebuffer._bind(),
                a.copyTexImage2D(
                  this._target,
                  0,
                  this.internalFormat,
                  t.xOffset,
                  t.yOffset,
                  i,
                  n,
                  0,
                ),
                null !== t.framebuffer && t.framebuffer._unBind();
            else if (e?.arrayBufferView) {
              let t = 4;
              (t = Qc.alignmentInBytes(this.pixelFormat, this.pixelDatatype, i)),
                a.pixelStorei(a.UNPACK_ALIGNMENT, t),
                a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
                a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, !1),
                a.texImage2D(
                  this._target,
                  0,
                  this.internalFormat,
                  i,
                  n,
                  0,
                  this.pixelFormat,
                  Zc.toWebGLConstant(this.pixelDatatype, o),
                  e.arrayBufferView,
                );
            } else if (
              (o.pixelStoreUnpackPremultiplyAlpha.set(this.premultiply),
              e instanceof wu ||
                e instanceof Tu ||
                e instanceof bu ||
                e instanceof Su ||
                (Au && e instanceof Au))
            )
              a.texImage2D(
                this._target,
                0,
                this.internalFormat,
                this.pixelFormat,
                Zc.toWebGLConstant(this.pixelDatatype, o),
                e,
              );
            else {
              let t = 4;
              (t = Qc.alignmentInBytes(this.pixelFormat, this.pixelDatatype, i)),
                a.pixelStorei(a.UNPACK_ALIGNMENT, t),
                a.texImage2D(
                  this._target,
                  0,
                  this.internalFormat,
                  i,
                  n,
                  0,
                  this.pixelFormat,
                  Zc.toWebGLConstant(this.pixelDatatype, o),
                  e?.data,
                );
            }
          else
            e instanceof wu ||
            e instanceof Tu ||
            e instanceof bu ||
            e instanceof Su ||
            (Au && e instanceof Au)
              ? a.texSubImage2D(
                  this._target,
                  0,
                  0,
                  0,
                  this.pixelFormat,
                  Zc.toWebGLConstant(this.pixelDatatype, o),
                  e,
                )
              : a.texSubImage2D(
                  this._target,
                  0,
                  0,
                  0,
                  i,
                  n,
                  this.pixelFormat,
                  Zc.toWebGLConstant(this.pixelDatatype, o),
                  e?.data,
                );
          (e = null),
            r && (this._powerOfTwoCalculated = !1),
            this.isSizePowerOfTwoNoneSquare() && this.useMipmap
              ? (a.generateMipmap(this._target), (this.mIsGenerateMipmap = !0))
              : (this.mIsGenerateMipmap = !1),
            (this._dimensions = new $e(i, n)),
            (this._width = i),
            (this._height = n);
        }
      }
      get width() {
        return this._width;
      }
      get height() {
        return this._height;
      }
      get sampler() {
        return this._sampler;
      }
      get dimensions() {
        return this._dimensions;
      }
      set sampler(e) {
        if (this._hasSetSampler) return;
        this._hasSetSampler = !0;
        let i = e.minificationFilter,
          n = e.magnificationFilter;
        const r = this.context;
        let o = e.wrapS,
          a = e.wrapT;
        this.isSizePowerOfTwoNoneSquare() ||
          ((i !== Ll.LINEAR_MIPMAP_NEAREST &&
            i !== Ll.LINEAR_MIPMAP_LINEAR &&
            i !== Ll.NEAREST_MIPMAP_NEAREST &&
            i !== Ll.NEAREST_MIPMAP_LINEAR) ||
            (i = Ll.LINEAR),
          o === Ll.REPEAT && (o = Ll.CLAMP_TO_EDGE),
          a === Ll.REPEAT && (a = Ll.CLAMP_TO_EDGE)),
          (i && n) ||
            (this.isSizePowerOfTwoNoneSquare() && this.useMipmap
              ? ((i = Ll.LINEAR_MIPMAP_NEAREST), (n = Ll.LINEAR))
              : ((i = Ll.LINEAR), (n = Ll.LINEAR))),
          this.useMipmap || ((i = Ll.LINEAR), (n = Ll.LINEAR));
        const s = r.gl,
          l = this._target;
        s.activeTexture(s.TEXTURE0),
          s.bindTexture(l, this.texture),
          s.texParameteri(l, Ll.TEXTURE_MIN_FILTER, i),
          s.texParameteri(l, Ll.TEXTURE_MAG_FILTER, n),
          s.texParameteri(l, Ll.TEXTURE_WRAP_S, o),
          s.texParameteri(l, Ll.TEXTURE_WRAP_T, a),
          this.anisotropy &&
            t(r.extTextureFilterAnisotropic) &&
            s.texParameteri(
              l,
              r.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,
              this.anisotropy,
            ),
          s.bindTexture(l, null),
          (this._sampler = e);
      }
      bind(e, t) {
        return (
          (this.sampler = {
            minificationFilter: this.useMipmap ? Ll.LINEAR_MIPMAP_NEAREST : e,
            magnificationFilter: e || Ll.LINEAR,
            wrapS: t || Ll.CLAMP_TO_EDGE,
            wrapT: t || Ll.CLAMP_TO_EDGE,
            continueBindTextureOnExit: !0,
          }),
          this
        );
      }
      addReference() {
        this.referenceCount += 1;
      }
      reduceReference() {
        this.referenceCount -= 1;
      }
      upload(e) {
        const { context: t } = this,
          { gl: i } = t;
        (this.size = [e.width, e.height]),
          i.deleteTexture(this.texture),
          (this.texture = i.createTexture()),
          i.pixelStorei(Ll.UNPACK_FLIP_Y_WEBGL, this.flipY),
          i.bindTexture(this._target, this.texture),
          this.compressed
            ? i.compressedTexImage2D(
                this._target,
                0,
                this.internalFormat,
                e.width,
                e.height,
                0,
                e.data,
              )
            : e instanceof wu ||
              e instanceof Tu ||
              e instanceof bu ||
              e instanceof Su ||
              (Au && e instanceof Au)
            ? i.texImage2D(
                this._target,
                0,
                this.internalFormat,
                this.pixelFormat,
                this.pixelDatatype,
                e,
              )
            : i.texImage2D(
                this._target,
                0,
                this.internalFormat,
                this.size[0],
                this.size[1],
                0,
                this.pixelFormat,
                this.pixelDatatype,
                e.data,
              );
      }
      isSizePowerOfTwo() {
        return this.size[0] === this.size[1] && (Math.log(this.size[0]) / Math.LN2) % 1 == 0;
      }
      isSizePowerOfTwoNoneSquare() {
        return this._powerOfTwoCalculated
          ? this.powerOfTwoNoneSquareFlag
          : !!this.size &&
              ((this._powerOfTwoCalculated = !0),
              (this.powerOfTwoNoneSquareFlag =
                (Math.log(this.size[0]) / Math.LN2) % 1 == 0 &&
                (Math.log(this.size[1]) / Math.LN2) % 1 == 0),
              this.powerOfTwoNoneSquareFlag);
      }
      destroy() {
        if (this.context) {
          if (((this.referenceCount -= 1), 0 === this.referenceCount)) {
            const { gl: e } = this.context;
            e.deleteTexture(this.texture), (this.texture = null), (this.context = null);
          }
          Vc(this);
        }
      }
      copyFrom(e) {
        const i = this.context.gl,
          n = Z(e.xOffset, 0),
          r = Z(e.yOffset, 0);
        if (Qc.isDepthFormat(this.pixelFormat))
          throw new Error(
            'Cannot call copyFrom when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.',
          );
        if (Qc.isCompressedFormat(this.pixelFormat))
          throw new Error('Cannot call copyFrom with a compressed texture pixel format.');
        const o = e.source,
          a = this.context,
          s = this._target;
        i.bindTexture(s, this.texture);
        const l = o.width,
          c = o.height;
        let u = o.arrayBufferView;
        const h = this.internalFormat,
          d = this.pixelFormat,
          p = this.pixelDatatype,
          f = this.flipY;
        let m = 4;
        t(u) && (m = Qc.alignmentInBytes(d, p, l)),
          i.pixelStorei(i.UNPACK_ALIGNMENT, m),
          t(u)
            ? (i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
              i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, !1),
              f && (u = Qc.flipY(u, d, p, l, c)),
              i.texSubImage2D(s, 0, n, r, l, c, d, Zc.toWebGLConstant(p, a), u))
            : (i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
              i.pixelStorei(Ll.UNPACK_FLIP_Y_WEBGL, f),
              i.texImage2D(s, 0, h, d, Zc.toWebGLConstant(p, a), o));
      }
      copyFromFramebuffer(e, t, i, n, r, o) {
        if (
          ((e = Z(e, 0)),
          (t = Z(t, 0)),
          (i = Z(i, 0)),
          (n = Z(n, 0)),
          (r = Z(r, this._width)),
          (o = Z(o, this._height)),
          Qc.isDepthFormat(this.pixelFormat))
        )
          throw new Error(
            'Cannot call copyFromFramebuffer when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.',
          );
        if (this.pixelDatatype === Zc.FLOAT)
          throw new Error(
            'Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT.',
          );
        if (this.pixelDatatype === Zc.HALF_FLOAT)
          throw new Error(
            'Cannot call copyFromFramebuffer when the texture pixel data type is HALF_FLOAT.',
          );
        if (Qc.isCompressedFormat(this.pixelFormat))
          throw new Error('Cannot call copyFrom with a compressed texture pixel format.');
        const a = this.context.gl,
          s = this._target;
        a.activeTexture(a.TEXTURE0),
          a.bindTexture(s, this.texture),
          a.copyTexSubImage2D(s, 0, e, t, i, n, r, o),
          a.bindTexture(s, null),
          (this._initialized = !0);
      }
      async load(e, t) {
        this.texUrl = e;
        const i = await (() =>
          new Promise((t, i) => {
            vu(
              {
                url: this.map._transformRequest(e, uu.Image).url,
                imageBitmapOptions: {
                  imageOrientation: this.flipY ? 'flipY' : 'none',
                  premultiplyAlpha: this.premultiply ? 'premultiply' : 'none',
                },
              },
              (e, n) => {
                e && i(e), t(n);
              },
            );
          }))();
        if (!i.width || !i.height) throw new Error(`load image error, url is ${e}`);
        this.uploadTexData(i), t && t();
      }
      uploadTexData(e) {
        const t = e.width,
          i = e.height,
          { context: n } = this,
          { gl: r } = n;
        r.bindTexture(Ll.TEXTURE_2D, this.texture),
          n.pixelStoreUnpackFlipY.set(this.flipY),
          n.pixelStoreUnpack.set(1),
          n.pixelStoreUnpackPremultiplyAlpha.set(!1),
          (this.size = [t, i]),
          r.texImage2D(
            Ll.TEXTURE_2D,
            0,
            this.internalFormat,
            this.pixelFormat,
            Zc.toWebGLConstant(this.pixelDatatype, n),
            e,
          ),
          (this._powerOfTwoCalculated = !1),
          this.isSizePowerOfTwoNoneSquare() &&
            this.useMipmap &&
            (r.generateMipmap(Ll.TEXTURE_2D), (this.mIsGenerateMipmap = !0)),
          (this._hasSetSampler = !1),
          this.map && this.map.triggerRepaint();
      }
      serialize() {
        let e;
        return t(this.texUrl) && (e = { texUrl: this.texUrl }), e;
      }
      isDestroyed() {
        return !1;
      }
      static fromFramebuffer(e) {
        const i = (e = Z(e, Z.EMPTY_OBJECT)).context,
          n = i.gl,
          r = Z(e.pixelFormat, Qc.RGBA),
          o = Z(e.framebufferXOffset, 0),
          a = Z(e.framebufferYOffset, 0),
          s = Z(e.width, n.drawingBufferWidth),
          l = Z(e.height, n.drawingBufferHeight),
          c = e.framebuffer;
        return new Pu({
          context: i,
          width: s,
          height: l,
          pixelFormat: r,
          framebuffer: t(c) ? c : null,
          xOffset: o,
          yOffset: a,
        });
      }
      static createImageFromTexture(e, t, i, n) {
        const r = e.createFramebuffer();
        e.bindFramebuffer(e.FRAMEBUFFER, r),
          e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0);
        const o = new Uint8Array(i * n * 4);
        e.readPixels(0, 0, i, n, e.RGBA, e.UNSIGNED_BYTE, o), e.deleteFramebuffer(r);
        const a = J.document.createElement('canvas');
        (a.width = i), (a.height = n);
        const s = a.getContext('2d'),
          l = s.createImageData(i, n);
        l.data.set(o), s.putImageData(l, 0, 0);
        const c = new J.Image();
        return (c.src = a.toDataURL('image/png')), c;
      }
      static createDescendantImageFromTexture(e, t, i, n, r, o) {
        const a = e.createFramebuffer();
        e.bindFramebuffer(e.FRAMEBUFFER, a),
          e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0);
        const s = new Uint8Array(o * o);
        e.readPixels(i, n, r, r, e.RGBA, e.UNSIGNED_BYTE, s), e.deleteFramebuffer(a);
        const l = J.document.createElement('canvas');
        (l.width = o / 2), (l.height = o / 2);
        const c = l.getContext('2d'),
          u = c.createImageData(o / 2, o / 2);
        u.data.set(s), c.putImageData(u, 0, 0);
        const h = J.document.createElement('canvas');
        (h.width = o), (h.height = o), h.getContext('2d').drawImage(l, 0, 0, o, o);
        const d = new J.Image();
        return (d.src = h.toDataURL('image/png')), (d.width = o), (d.height = o), d;
      }
    }
    class Eu {
      constructor(e, i, n) {
        if (!t(e)) throw new Error('context is required');
        if (!t(i)) throw new Error('attributes is required');
        if (!t(n)) throw new Error('numberOfInstances is required');
        if (((this._attributes = i), (this._numberOfInstances = n), 0 === i.length)) return;
        const r = (function (e) {
            let t = !1;
            const i = e.length;
            for (let n = 0; n < i; ++n)
              if (e[n].type !== Ll.UNSIGNED_BYTE) {
                t = !0;
                break;
              }
            return t ? Ll.FLOAT : Ll.UNSIGNED_BYTE;
          })(i),
          o = r === Ll.FLOAT && !e.floatingPointTexture,
          a = (function (e, t) {
            const i = new Array(e.length);
            let n = 0;
            const r = e.length;
            for (let o = 0; o < r; ++o) {
              const r = e[o].type;
              (i[o] = n), r !== Ll.UNSIGNED_BYTE && t ? (n += 4) : ++n;
            }
            return i;
          })(i, o),
          s = (function (e, t, i) {
            const n = e.length,
              r = e[n - 1];
            return t[n - 1].type !== Ll.UNSIGNED_BYTE && i ? r + 4 : r + 1;
          })(a, i, o),
          l = Math.floor(Uc.maximumTextureSize / s),
          c = Math.min(n, l),
          u = s * c,
          h = Math.ceil(n / c),
          d = 1 / u,
          p = 0.5 * d,
          f = 1 / h,
          m = 0.5 * f;
        (this._textureDimensions = new $e(u, h)),
          (this._textureStep = new Ge(d, p, f, m)),
          (this._pixelDatatype = o ? Ll.UNSIGNED_BYTE : r),
          (this._packFloats = o),
          (this._offsets = a),
          (this._stride = s),
          (this._texture = void 0);
        const _ = 4 * u * h;
        (this._batchValues = r !== Ll.FLOAT || o ? new Uint8Array(_) : new Float32Array(_)),
          (this._batchValuesDirty = !1);
      }
      get attributes() {
        return this._attributes;
      }
      get numberOfInstances() {
        return this._numberOfInstances;
      }
      getBatchedAttribute(e, i, n) {
        if (e < 0 || e >= this._numberOfInstances)
          throw new Error('instanceIndex is out of range.');
        if (i < 0 || i >= this._attributes.length)
          throw new Error('attributeIndex is out of range');
        const r = this._attributes,
          o = 4 * this._stride * e + 4 * this._offsets[i];
        let a;
        a =
          this._packFloats && r[i].componentDatatype !== Ll.UNSIGNED_BYTE
            ? (function (e, t, i) {
                let n = Ge.unpack(e, t, Mu);
                const r = Ge.unpackFloat(n);
                n = Ge.unpack(e, t + 4, Mu);
                const o = Ge.unpackFloat(n);
                n = Ge.unpack(e, t + 8, Mu);
                const a = Ge.unpackFloat(n);
                n = Ge.unpack(e, t + 12, Mu);
                const s = Ge.unpackFloat(n);
                return Ge.fromElements(r, o, a, s, i);
              })(this._batchValues, o, Cu)
            : Ge.unpack(this._batchValues, o, Cu);
        const s = Iu(r, i);
        return t(s.fromCartesian4) ? s.fromCartesian4(a, n) : t(s.clone) ? s.clone(a, n) : a.x;
      }
      setBatchedAttribute(e, i, n) {
        const r = [void 0, void 0, new $e(), new Pt(), new Ge()],
          o = new Ge();
        if (e < 0 || e >= this._numberOfInstances)
          throw new Error('instanceIndex is out of range.');
        if (i < 0 || i >= this._attributes.length)
          throw new Error('attributeIndex is out of range');
        if (!t(n)) throw new Error('value is required.');
        const a = this._attributes,
          s = this.getBatchedAttribute(e, i, r[a[i].components]),
          l = Iu(this._attributes, i);
        if (t(l.equals) ? l.equals(s, n) : s === n) return;
        const c = o;
        (c.x = t(n.x) ? n.x : n),
          (c.y = t(n.y) ? n.y : 0),
          (c.z = t(n.z) ? n.z : 0),
          (c.w = t(n.w) ? n.w : 0);
        const u = 4 * this._stride * e + 4 * this._offsets[i];
        this._packFloats && a[i].type !== Ll.UNSIGNED_BYTE
          ? (function (e, t, i) {
              let n = Ge.packFloat(e.x, Mu);
              Ge.pack(n, t, i),
                (n = Ge.packFloat(e.y, n)),
                Ge.pack(n, t, i + 4),
                (n = Ge.packFloat(e.z, n)),
                Ge.pack(n, t, i + 8),
                (n = Ge.packFloat(e.w, n)),
                Ge.pack(n, t, i + 12);
            })(c, this._batchValues, u)
          : Ge.pack(c, this._batchValues, u),
          (this._batchValuesDirty = !0);
      }
      createTexture(e) {
        const t = this._textureDimensions;
        this._texture = new Pu({
          context: e,
          pixelFormat: Ll.RGBA,
          pixelDatatype: this._pixelDatatype,
          width: t.x,
          height: t.y,
          sampler: jc.NEAREST,
          flipY: !1,
        });
      }
      updateTexture() {
        const e = this._textureDimensions;
        this._texture.copyFrom({
          source: { width: e.x, height: e.y, arrayBufferView: this._batchValues },
        });
      }
      update(e) {
        (t(this._texture) && !this._batchValuesDirty) ||
          0 === this._attributes.length ||
          ((this._batchValuesDirty = !1),
          t(this._texture) || this.createTexture(e),
          this.updateTexture());
      }
      getUniformMapCallback() {
        const e = new Map(),
          t = this;
        return (
          0 === t._attributes.length ||
            (e.set('batchTableTexture', () => t._texture),
            e.set('batchTextureDimensions', () => t._textureDimensions),
            e.set('batchTextureStep', () => t._textureStep),
            e.set('numberOfAttributes', () => t._attributes.length)),
          e
        );
      }
      destroy() {
        return (this._texture = this._texture && this._texture.destroy()), Vc(this);
      }
    }
    const Cu = new Ge(),
      Mu = new Ge();
    function Iu(e, t) {
      const i = e[t].components;
      return 2 === i ? $e : 3 === i ? Pt : 4 === i ? Ge : Number;
    }
    const Lu = {
      Int8: 'BYTE',
      Uint8: 'UNSIGNED_BYTE',
      Int16: 'SHORT',
      Uint16: 'UNSIGNED_SHORT',
      Int32: 'INT',
      Uint32: 'UNSIGNED_INT',
      Float32: 'FLOAT',
    };
    class Ru {
      constructor(e) {
        const {
          attributes: t,
          dynamicDraw: i,
          context: n,
          buffers: r,
          attributesbuffviewObject: o,
          array: a,
        } = e;
        (this.length = a ? a.length : 0),
          (this.attributes = t),
          (this.dynamicDraw = i),
          (this.context = n),
          (this._isVectorBuffer = !e.hasOwnProperty('attributesbuffviewObject')),
          (this.buffers = {}),
          r
            ? (this.buffers = r)
            : this._isVectorBuffer
            ? ((this.itemSize = a.bytesPerElement), this._parseAttributesOfVector(a))
            : this._parseAttributesbuffviewObject(o);
      }
      getBuffers() {
        return this.buffers;
      }
      bind(e) {
        e && this.context.bindVertexBuffer.set(this.buffers[e]);
      }
      updateData(e) {
        if (!this._isVectorBuffer) return;
        const t = this.context.gl;
        this.bind('default'),
          t.bufferData(
            t.ARRAY_BUFFER,
            e.arrayBuffer,
            this.dynamicDraw ? t.DYNAMIC_DRAW : t.STATIC_DRAW,
          );
      }
      updateDataTest(e, t) {
        const i = this.context.gl;
        this.bind(this._isVectorBuffer ? 'default' : t),
          i.bufferData(
            i.ARRAY_BUFFER,
            e.arrayBuffer ? e.arrayBuffer : e.buffer,
            this.dynamicDraw ? i.DYNAMIC_DRAW : i.STATIC_DRAW,
          );
      }
      enableAttributes(e, t) {
        for (let i = 0; i < this.attributes.length; i++) {
          const n = t.attributes[this.attributes[i].name];
          void 0 !== n && e.enableVertexAttribArray(n);
        }
      }
      setVertexAttribPointers(e, t, i) {
        this._isVectorBuffer
          ? this._setVertexAttribPointersOfVector(e, t, i)
          : this._setVertexAttribPointersOfModel(e, t);
      }
      _setVertexAttribPointersOfVector(e, t, i) {
        for (let n = 0; n < this.attributes.length; n++) {
          const r = this.attributes[n],
            o = t.attributes[r.name];
          this.bind('default'),
            void 0 !== o &&
              e.vertexAttribPointer(
                o,
                r.components,
                Ll[Lu[r.type]],
                !1,
                this.itemSize,
                r.offset + this.itemSize * (i || 0),
              );
        }
      }
      _setVertexAttribPointersOfModel(e, t) {
        for (let i = 0; i < this.attributes.length; i++) {
          const n = this.attributes[i];
          let r = !1;
          -1 !== n.name.indexOf('a_COLOR') && (r = !0), this.bind(n.name);
          const o = t.attributes[n.name];
          void 0 !== o &&
            (n.instance
              ? (e.enableVertexAttribArray(n.attribIndex + o),
                e.vertexAttribPointer(
                  n.attribIndex + o,
                  n.components,
                  Ll.FLOAT,
                  r,
                  n.byteStride,
                  n.offset,
                ),
                this.context.drawInstance.vertexAttribDivisorANGLE(n.attribIndex + o, 1))
              : (e.enableVertexAttribArray(o),
                e.vertexAttribPointer(o, n.components, n.type, r, n.byteStride, n.offset))),
            this.context.bindVertexBuffer.set(null);
        }
      }
      _parseAttributesOfVector(e) {
        const t = this.context,
          i = t.gl;
        (this.buffers.default = i.createBuffer()),
          t.bindVertexBuffer.set(this.buffers.default),
          i.bufferData(
            Ll.ARRAY_BUFFER,
            e.arrayBuffer,
            this.dynamicDraw ? Ll.DYNAMIC_DRAW : Ll.STATIC_DRAW,
          ),
          this.dynamicDraw || delete e.arrayBuffer;
      }
      _parseAttributesbuffviewObject(e) {
        const t = this.context.gl,
          i = Object.keys(e);
        i.forEach((n, r) => {
          const o = e[n];
          let a, s;
          a = Nu(n, '_') ? `a${n}` : `a_${n}`;
          let l,
            c = r - 1,
            u = !1;
          for (; c >= 0; ) {
            if (((u = this._findSameBuffer(i[c], n, e)), u)) {
              l = i[c];
              break;
            }
            c--;
          }
          if (u) this.buffers[a] = Nu(l, '_') ? this.buffers[`a${l}`] : this.buffers[`a_${l}`];
          else {
            (s = t.createBuffer()), this.context.bindVertexBuffer.set(s);
            const e = null != o.bufferView ? o.bufferView.data : o.value;
            t.bufferData(Ll.ARRAY_BUFFER, e, this.dynamicDraw ? Ll.DYNAMIC_DRAW : Ll.STATIC_DRAW),
              (s.length = e?.length),
              (this.buffers[a] = s);
          }
        });
      }
      _findSameBuffer(e, t, i) {
        return null != i[e].bufferView && null != i[t].bufferView
          ? i[e].bufferView.data === i[t].bufferView.data
          : i[e].value === i[t].value;
      }
      destroy() {
        if (!this.context || !this.context.gl) return;
        const e = this.context.gl;
        for (const t in this.buffers) e.deleteBuffer(this.buffers[t]), delete this.buffers[t];
        this.context = null;
      }
    }
    function Nu(e, t) {
      return e.charAt(0) == t;
    }
    class Ou {
      constructor(e) {
        (this.rectangle = Nl.clone(e.rectangle)),
          (this.minimumHeight = Z(e.minimumHeight, 0)),
          (this.maximumHeight = Z(e.maximumHeight, 0)),
          (this.southwestCornerCartesian = new Pt()),
          (this.northeastCornerCartesian = new Pt()),
          (this.westNormal = new Pt()),
          (this.southNormal = new Pt()),
          (this.eastNormal = new Pt()),
          (this.northNormal = new Pt());
        const t = Z(e.ellipsoid, wt.WGS84);
        !(function (e, t, i) {
          i.cartographicToCartesianInRadians(Nl.southwest(t), e.southwestCornerCartesian),
            i.cartographicToCartesianInRadians(Nl.northeast(t), e.northeastCornerCartesian),
            (ku.longitude = t.west),
            (ku.latitude = 0.5 * (t.south + t.north)),
            (ku.height = 0);
          const n = i.cartographicToCartesianInRadians(ku, Vu),
            r = Pt.cross(n, Pt.UNIT_Z, Du);
          Pt.normalize(r, e.westNormal), (ku.longitude = t.east);
          const o = i.cartographicToCartesianInRadians(ku, Uu),
            a = Pt.cross(Pt.UNIT_Z, o, Du);
          Pt.normalize(a, e.eastNormal);
          const s = Pt.subtract(n, o, Du),
            l = Pt.normalize(s, Bu),
            c = t.south;
          let u;
          if (c > 0) {
            (ku.longitude = 0.5 * (t.west + t.east)), (ku.latitude = c);
            const n = i.cartographicToCartesianInRadians(ku, Hu.origin);
            Pt.clone(l, Hu.direction);
            const r = Ca.fromPointNormal(e.southwestCornerCartesian, e.westNormal, Gu);
            ds.rayPlane(Hu, r, e.southwestCornerCartesian), (u = i.geodeticSurfaceNormal(n, Fu));
          } else u = i.geodeticSurfaceNormalCartographic(Nl.southeast(t), Fu);
          const h = Pt.cross(u, s, zu);
          Pt.normalize(h, e.southNormal);
          const d = t.north;
          let p;
          if (d < 0) {
            (ku.longitude = 0.5 * (t.west + t.east)), (ku.latitude = d);
            const n = i.cartographicToCartesianInRadians(ku, Hu.origin);
            Pt.negate(l, Hu.direction);
            const r = Ca.fromPointNormal(e.northeastCornerCartesian, e.eastNormal, Gu);
            ds.rayPlane(Hu, r, e.northeastCornerCartesian), (p = i.geodeticSurfaceNormal(n, Fu));
          } else p = i.geodeticSurfaceNormalCartographic(Nl.northwest(t), Fu);
          const f = Pt.cross(s, p, zu);
          Pt.normalize(f, e.northNormal);
        })(this, e.rectangle, t),
          (this._orientedBoundingBox = void 0),
          (this._boundingSphere = void 0),
          Z(e.computeBoundingVolumes, !0) && this.computeBoundingVolumes(t);
      }
      get boundingVolume() {
        return this._orientedBoundingBox;
      }
      get boundingSphere() {
        return this._boundingSphere;
      }
      computeBoundingVolumes(e) {
        (this._orientedBoundingBox = Dc.fromRectangle(
          this.rectangle,
          this.minimumHeight,
          this.maximumHeight,
          e,
        )),
          (this._boundingSphere = gc.fromOrientedBoundingBox(this._orientedBoundingBox));
      }
      computePlaneDistances(e, t, i) {
        return this._orientedBoundingBox.computePlaneDistances(e, t, i);
      }
      distanceToCamera(e) {
        const i = (function (e, t) {
          const i = t.position,
            n = as.fromVector3(t.position);
          let r = 0;
          if (!Nl.contains(e.rectangle, n)) {
            const t = e.northeastCornerCartesian,
              n = e.westNormal,
              o = e.southNormal,
              a = e.eastNormal,
              s = e.northNormal,
              l = Pt.subtract(i, e.southwestCornerCartesian, Yu),
              c = Pt.dot(l, n),
              u = Pt.dot(l, o),
              h = Pt.subtract(i, t, Yu),
              d = Pt.dot(h, a),
              p = Pt.dot(h, s);
            c > 0 ? (r += c * c) : d > 0 && (r += d * d),
              u > 0 ? (r += u * u) : p > 0 && (r += p * p);
          }
          const o = n.height,
            a = e.minimumHeight,
            s = e.maximumHeight;
          if (o > s) {
            const e = o - s;
            r += e * e;
          } else if (o < a) {
            const e = a - o;
            r += e * e;
          }
          return Math.sqrt(r);
        })(this, e);
        if (t(this._orientedBoundingBox)) {
          const t = Math.sqrt(this._orientedBoundingBox.distanceSquaredTo(e.position));
          return Math.max(i, t);
        }
        return i;
      }
      intersectPlane(e) {
        return this._orientedBoundingBox.intersectPlane(e);
      }
    }
    const Du = new Pt(),
      Fu = new Pt(),
      zu = new Pt(),
      Bu = new Pt(),
      Vu = new Pt(),
      Uu = new Pt(),
      ku = new as(),
      Gu = new Ca(Pt.UNIT_X, 0),
      Hu = new Ja(),
      Yu = new Pt();
    class qu {
      constructor(e) {
        if (((this.collection = e.collection), !t(e.modelMatrix)))
          throw new Error('modelMatrix must be defined!');
        if (!(e.modelMatrix instanceof Je)) throw new Error('modelMatrix must be type of Matrix4!');
        (this._modelMatrix = e.modelMatrix),
          (this._instanceId = Z(e.instanceId, void 0)),
          (this._instanceName = Z(e.instanceName, void 0)),
          (this._show = Z(e.show, !0)),
          (this._color = Z(ai.parse(e.color), new ai(0, 0, 0, 0))),
          (this._scale = new Pt()),
          (this._boundingVolume = void 0),
          (this.scale = Z(e.scale, void 0)),
          (this.rotation = Z(e.rotation, void 0)),
          (this.position = Z(e.position, void 0)),
          (this.pickId = void 0),
          (this._dirty = !0),
          (this._originalMatrix = this._modelMatrix.clone());
      }
      get dirty() {
        return this._dirty;
      }
      set dirty(e) {
        Pe(e) && (e && (this.collection.dirty = !0), (this._dirty = e));
      }
      get instanceId() {
        return this._instanceId;
      }
      get instanceName() {
        return this._instanceName;
      }
      get modelMatrix() {
        return this._modelMatrix.clone();
      }
      set modelMatrix(e) {
        e instanceof Je && ((this._modelMatrix = e.clone()), (this.dirty = !0));
      }
      get show() {
        return this._show;
      }
      set show(e) {
        Pe(e) && ((this._show = e), (this.dirty = !0));
      }
      getBounds() {
        let e, t;
        const i = this._boundingVolume;
        if (
          ((e =
            i instanceof Dc
              ? i.getBoundingMaximum(2)
              : i instanceof Ou
              ? i.boundingVolume.getBoundingMaximum()
              : i.getBoundingMaximum()),
          e)
        ) {
          const i = Il.DefaultEllipsoid.cartesianToCartographic(e.boundingMaxValue),
            n = Il.DefaultEllipsoid.cartesianToCartographic(e.boundingMinValue);
          t = new Lt([n[0], n[1]], [i[0], i[1]]);
        }
        return t;
      }
      get color() {
        return this._color;
      }
      set color(e) {
        const t = ai.parse(e);
        t && ((this._color = t), (this.dirty = !0));
      }
      get scale() {
        return Je.getScale(this._modelMatrix, this._scale);
      }
      set scale(e) {
        e instanceof Pt &&
          (this._modelMatrix.scale(new Pt(1 / this.scale.x, 1 / this.scale.y, 1 / this.scale.z)),
          this._modelMatrix.scale(e),
          (this.dirty = !0));
      }
      get rotation() {
        const e = this._modelMatrix.clone(),
          t = Il.localFrameToFixedFrame(e.getTranslation(new Pt())),
          i = Je.inverse(t, new Je()),
          n = e.multiplyLeft(i),
          r = new Et().fromRotationMatrix4(n.getRotation());
        return Le.fromQuaternion(r);
      }
      set rotation(e) {
        e instanceof Le &&
          (Il.localFrameToFixedFrame(this._modelMatrix.getTranslation(new Pt())).multiplyRight(
            Je.fromTranslationHeadingPitchRollRotationScale(
              new Pt(),
              e,
              new Pt(this.scale.x, this.scale.y, this.scale.z),
            ),
            this._modelMatrix,
          ),
          (this.dirty = !0));
      }
      get position() {
        return this._modelMatrix.getTranslation(new Pt());
      }
      set position(e) {
        e instanceof Pt && (this._modelMatrix.setTranslation(e), (this.dirty = !0));
      }
    }
    class Xu {
      constructor(e) {
        (this._rootId = e.rootId),
          (this._instances = this.createInstance(e.instances)),
          (this._primitivesInstance = []),
          (this.type = Z(e.type, '3d-model')),
          (this._batchTable = void 0),
          (this.boundingVolume = this.#r()),
          (this._center = this.boundingVolume.center),
          (this._rtcTransform = new Je()),
          Je.multiplyByTranslation(new Je(), this._center, this._rtcTransform),
          (this.sprites = e.spriteAtlas),
          (this._insatnceBuffer = void 0),
          (this._attributes = []),
          (this._attributesbuffviewObject = {}),
          (this.allowPick = Z(e.allowPick, !0)),
          this.#o(),
          this.#a(),
          (this.dirty = !1),
          (this.reCreateInstancesData = !1);
      }
      getInstance(e) {
        return this._instances.get(e);
      }
      get instanceBuffer() {
        return this._insatnceBuffer;
      }
      get dirty() {
        return this._dirty;
      }
      set dirty(e) {
        Pe(e) && (this._dirty = e);
      }
      add(e) {
        if ('3d-model-instance' !== this.type) return;
        if (!t(e.position) && !t(e.positions))
          throw new Error("instance's position or positions must be defined!");
        let i;
        if (t(e.positions)) {
          const t = Xu.generateInstanceModelMatrix({
            positions: e.positions,
            scales: e.scales,
            rotations: e.rotations,
            shows: e.shows,
            colors: e.colors,
            instanceNames: e.instanceNames,
          });
          let i = this._instances.size;
          for (let e = 0; e < t.length; e++) (t[e].batchId = i), i++;
          const n = this.createInstance(t);
          this._instances = new Map([...this._instances, ...n]);
        } else {
          const n = e.position,
            r = e.rotation,
            o = e.scale,
            a = e.color,
            s = e.show,
            l = e.instanceName;
          if (!(n instanceof Pt)) throw new Error("instance's position is unKnown type!");
          if (t(r) && !(r instanceof Le)) throw new Error("instance's rotation is unKnown type!");
          if (t(o) && !(o instanceof Pt)) throw new Error("instance's scale is unKnown type!");
          if (t(a) && !(a instanceof ai)) throw new Error("instance's color is unKnown type!");
          if (t(s) && !Pe(s)) throw new Error("instance's show is unKnown type!");
          const c = Il.cartographicToFixedFrame(n);
          (i = new qu({
            collection: this,
            modelMatrix: c,
            instanceId: this._instances.size,
            instanceName: l,
            show: s,
            color: a,
            scale: o,
            rotation: r,
            position: Pt.fromElements(c[12], c[13], c[14]),
          })),
            this._instances.set(i.instanceId, i);
        }
        return (this.reCreateInstancesData = !0), (this.dirty = !0), this.#a(), i;
      }
      remove(e) {
        let i = !1;
        if ('3d-model-instance' !== this.type) return i;
        if (!t(e)) return i;
        if (e instanceof Array)
          for (let t = 0; t < e.length; t++)
            this._instances.has(e[t].instanceId) &&
              (this._instances.delete(e[t].instanceId), (i = !0));
        else this._instances.has(e.instanceId) && (this._instances.delete(e.instanceId), (i = !0));
        const n = [];
        this._instances.forEach((e) => {
          n.push(e);
        });
        const r = new Map();
        for (let e = 0; e < n.length; e++) (n[e]._instanceId = e), (n.dirty = !0), r.set(e, n[e]);
        return (
          this._instances.clear(),
          (this._instances = r),
          (this.reCreateInstancesData = !0),
          (this.dirty = !0),
          this.#a(),
          i
        );
      }
      removeByName(e) {
        if ('3d-model-instance' !== this.type) return !1;
        const t = [];
        if (e instanceof Array)
          for (let i = 0; i < e.length; i++) {
            const n = e[i];
            this._instances.forEach((e) => {
              e.instanceName === n && t.push(e);
            });
          }
        else
          this._instances.forEach((i) => {
            i.instanceName === e && t.push(i);
          });
        return this.remove(t);
      }
      getByName(e) {
        if ('3d-model-instance' !== this.type) return;
        const t = [];
        return (
          this._instances.forEach((i) => {
            i.instanceName === e && t.push(i);
          }),
          t[0]
        );
      }
      removeAll() {
        this._instances.clear(), (this.reCreateInstancesData = !0), (this.dirty = !0), this.#a();
      }
      createInstance(e) {
        const t = new Map();
        return (
          e.forEach((e, i) => {
            const n = e.modelMatrix,
              r = Z(e.batchId, i),
              o = new qu({
                collection: this,
                modelMatrix: n,
                instanceId: r,
                instanceName: e.instanceName,
                show: e.show,
                color: e.color,
                scale: e.scale,
                rotation: e.rotation,
                position: e.position,
              });
            t.set(r, o);
          }),
          t
        );
      }
      #s(e) {
        const t = this._instances;
        for (let i = 0; i < t.size; ++i) t.get(i).pickId = e.createPickId(this.getInstance(i));
      }
      createBuffer(e) {
        this._insatnceBuffer = new Ru({
          context: e,
          attributesbuffviewObject: this._attributesbuffviewObject,
          attributes: this._attributes,
          dynamicDraw: !1,
          buffers: void 0,
        });
      }
      #r() {
        const e = [];
        for (let i = 0; i < this._instances.size; ++i) {
          const n = this._instances.get(i);
          if (t(n)) {
            const t = [];
            if (this._primitivesInstance.length > 0)
              for (let i = 0; i < this._primitivesInstance.length; i++) {
                let r = this._primitivesInstance[i].boundingVolume.clone();
                r = r.transform(n.modelMatrix);
                const o = r.computeCorners();
                for (let i = 0; i < o.length; i++) e.push(o[i]), t.push(o[i]);
              }
            else {
              const i = Je.getTranslation(n.modelMatrix, new Pt());
              e.push(i), t.push(i);
            }
            n._boundingVolume = Dc.fromPoints(t);
          }
        }
        return Dc.fromPoints(e);
      }
      #o() {
        for (let e = 0; e < 4; ++e)
          this._attributes.push({
            name: 'a_InstanceMatrix4',
            type: Ll.FLOAT,
            components: 4,
            instance: !0,
            byteStride: 64,
            offset: 16 * e,
            attribIndex: e,
            divisor: 1,
          });
        this.allowPick &&
          (this._attributes.push({
            name: 'a_BATCHID',
            type: Ll.FLOAT,
            components: 1,
            byteStride: 0,
            offset: 0,
            instance: !0,
            attribIndex: 0,
            divisor: 1,
          }),
          this._attributes.push({
            name: 'a_PickColor',
            type: Ll.FLOAT,
            components: 4,
            byteStride: 0,
            offset: 0,
            instance: !0,
            attribIndex: 0,
            divisor: 1,
          })),
          this.sprites &&
            this._attributes.push({
              name: 'a_UVOffset',
              type: Ll.FLOAT,
              components: 2,
              byteStride: 0,
              offset: 0,
              instance: !0,
              attribIndex: 0,
              divisor: 1,
            }),
          (this.modelInstanceAttributes = [
            {
              name: 'color',
              type: Ll.UNSIGNED_BYTE,
              components: 4,
              byteStride: 0,
              offset: 0,
              instance: !0,
              attribIndex: 0,
              divisor: 1,
              batchTableAttributeIndex: 0,
            },
            {
              name: 'show',
              type: Ll.UNSIGNED_BYTE,
              components: 1,
              byteStride: 0,
              offset: 0,
              instance: !0,
              attribIndex: 0,
              divisor: 1,
              batchTableAttributeIndex: 1,
            },
            {
              name: 'pickColor',
              type: Ll.UNSIGNED_BYTE,
              components: 4,
              byteStride: 0,
              offset: 0,
              instance: !0,
              attribIndex: 0,
              divisor: 1,
              batchTableAttributeIndex: 2,
            },
          ]);
      }
      #a() {
        this.#l('InstanceMatrix4'),
          this.allowPick && this.#l('batchid'),
          this.sprites && this.#l('UVOffset');
      }
      #l(e) {
        if ('InstanceMatrix4' === e) {
          const t = this.#c(e);
          this._attributesbuffviewObject.InstanceMatrix4 = { value: new Float32Array(t) };
        } else if ('batchid' === e) {
          const t = this.#c(e);
          this._attributesbuffviewObject.BATCHID = { value: new Float32Array(t) };
        } else if ('UVOffset' === e) {
          const t = this.#u(e);
          this._attributesbuffviewObject.UVOffset = { value: new Float32Array(t) };
        }
      }
      #h(e, t, i) {
        if ('InstanceMatrix4' === e) {
          const e = new Je(),
            n = Je.clone(t.modelMatrix, e);
          '3d-model-instance' === this.type &&
            ((n[12] -= this._center.x), (n[13] -= this._center.y), (n[14] -= this._center.z));
          for (let e = 0; e < t.modelMatrix.length; e++) i.push(n[e]);
        } else 'batchid' === e && i.push(t.instanceId);
        return i;
      }
      #c(e) {
        let i = [];
        for (let n = 0; n < this._instances.size; n++) {
          const r = this._instances.get(n);
          t(r) && (i = this.#h(e, r, i));
        }
        return i;
      }
      #u(e) {
        const t = [];
        if ('UVOffset' === e)
          for (let e = 0; e < this._instances.size; e++) {
            const i = (e % this.sprites.spriteWidthCount) / this.sprites.spriteWidthCount,
              n = Math.floor(e / this.sprites.spriteWidthCount) / this.sprites.spriteHeightCount;
            t.push(i), t.push(n);
          }
        return t;
      }
      #d(e) {
        t(this._batchTable) && (this._batchTable.destroy(), (this._batchTable = void 0)),
          (this._batchTable = new Eu(e, this.modelInstanceAttributes, this._instances.size));
        for (let i = 0; i < this._instances.size; i++) {
          const n = this._instances.get(i);
          t(n) && (this.#p(n, e), (n.dirty = !1));
        }
      }
      #p(e, i) {
        let n, r, o;
        const a = e.instanceId;
        for (let t = 0; t < this.modelInstanceAttributes.length - 1; ++t)
          (n = this.modelInstanceAttributes[t].name),
            (r = this.modelInstanceAttributes[t].batchTableAttributeIndex),
            e[n] instanceof ai
              ? ((o = ai.clone(e[n])),
                (o.r = ai.floatToByte(o.r)),
                (o.g = ai.floatToByte(o.g)),
                (o.b = ai.floatToByte(o.b)),
                (o.a = ai.floatToByte(o.a)),
                (o = Ge.fromColor(o)))
              : Pe(e[n]) && (o = Number(e[n])),
            this._batchTable.setBatchedAttribute(a, r, o);
        t(e.pickId) || (e.pickId = i.createPickId(e));
        const s = e.pickId.color,
          l = new Ge();
        (l.x = ai.floatToByte(s.r)),
          (l.y = ai.floatToByte(s.g)),
          (l.z = ai.floatToByte(s.b)),
          (l.w = ai.floatToByte(s.a)),
          this._batchTable.setBatchedAttribute(a, this.modelInstanceAttributes.length - 1, l);
      }
      #f() {
        let e;
        for (let i = 0; i < this._instances.size; i++)
          (e = this._instances.get(i)), t(e) && e.dirty && (this.#p(e), (e.dirty = !1));
      }
      update(e) {
        if (
          (e &&
            e.context &&
            !this._insatnceBuffer &&
            this._instances.size > 0 &&
            ('3d-model-instance' === this.type && (this.#s(e.context), this.#d(e.context)),
            this.createBuffer(e.context)),
          '3d-model-instance' === this.type &&
            this.reCreateInstancesData &&
            (this.#s(e.context),
            this.#d(e.context),
            this.createBuffer(e.context),
            (this.reCreateInstancesData = !1)),
          this.dirty)
        ) {
          const e = this.#c('InstanceMatrix4');
          this._insatnceBuffer.updateDataTest(new Float32Array(e), 'a_InstanceMatrix4'),
            (this.boundingVolume = this.#r()),
            t(this._batchTable) && this.#f(),
            (this.dirty = !1);
        }
        t(e.context) && t(this._batchTable) && this._batchTable.update(e.context);
      }
      static generateInstanceObject(e) {
        const t = [];
        return (
          e.forEach((e, i) => {
            t.push({ modelMatrix: new Je().translate(e), batchId: i });
          }),
          t
        );
      }
      static generateInstanceModelMatrix(e) {
        const i = [],
          n = e.positions,
          r = e.instanceNames,
          o = e.scales,
          a = e.rotations,
          s = e.shows,
          l = e.colors;
        if (t(r) && r.length > 0 && r.length !== n.length)
          throw new Error("instanceNames's length  must be equal than positions's length!");
        if (t(o) && o.length > 0 && o.length !== n.length)
          throw new Error("scales's length  must be equal than positions's length!");
        if (t(a) && a.length && a.length !== n.length)
          throw new Error("rotations's length  must be equal than positions's length!");
        if (t(s) && s.length > 0 && s.length !== n.length)
          throw new Error("shows's length  must be equal than positions's length!");
        if (t(l) && l.length > 0 && l.length !== n.length)
          throw new Error("colors's length  must be equal than positions's length!");
        let c, u, h, d, p, f;
        for (let m = 0; m < n.length; m++) {
          let _;
          (c = n[m]),
            t(r) && r.length > 0 && (u = r[m]),
            t(a) && a.length > 0 && (h = a[m]),
            t(o) && o.length > 0 && (d = o[m]),
            t(s) && s.length > 0 && (p = s[m]),
            t(l) && l.length > 0 && (f = l[m]),
            e.cartesian
              ? (_ = Il.cartesianToFixedFrame(c))
              : ((_ = Il.cartographicToFixedFrame(c)), (c = Pt.fromDegrees(c.x, c.y, c.z))),
            i.push({
              modelMatrix: _,
              batchId: m,
              instanceName: Z(u, void 0),
              position: Z(c, void 0),
              scale: Z(d, void 0),
              rotation: Z(h, void 0),
              show: Z(p, !0),
              color: Z(f, void 0),
            });
        }
        return i;
      }
      updateInstanceMatrixByIndex(e, t) {
        (this.dirty = !0), (this._instances.get(e).modelMatrix = t);
      }
      destroy() {
        this._instances && this._instances.clear(),
          this._insatnceBuffer && this._insatnceBuffer.destroy(),
          this._batchTable && this._batchTable.destroy(),
          (this._attributes = []),
          (this._attributesbuffviewObject = null),
          (this.dirty = !1);
      }
    }
    class ju {
      constructor() {
        (this._animationPropertyMap = new Map()), (this._animationPropertyOrders = []);
      }
      add(e) {
        if (this.has(e.id))
          throw new Error(`There is already a animationProperty with this ID: ${e.id}`);
        this._animationPropertyOrders.push(e.id), this._animationPropertyMap.set(e.id, e);
      }
      get(e) {
        return this._animationPropertyMap.get(e);
      }
      getAll() {
        const e = [];
        for (let t = 0; t < this._animationPropertyOrders.length; t++) {
          const i = this.get(this._animationPropertyOrders[t]);
          e.push(i);
        }
        return e;
      }
      has(e) {
        return this._animationPropertyMap.has(e);
      }
      sort(e) {
        this._animationPropertyOrders.sort(e);
      }
      remove(e, t) {
        if (this.has(e)) {
          if (t) {
            const t = this.get(e);
            t.destroy && t.destroy();
          }
          this._animationPropertyMap.delete(e);
          const i = this._animationPropertyOrders.indexOf(e);
          this._animationPropertyOrders.splice(i, 1);
        }
      }
      removeAll(e) {
        for (; this._animationPropertyOrders.length > 0; )
          this.remove(this._animationPropertyOrders[0], e);
      }
      get keys() {
        return this._animationPropertyOrders;
      }
      get size() {
        return this._animationPropertyMap.size;
      }
    }
    var Wu = 8192;
    J.performance && J.performance.now
      ? J.performance.now.bind(J.performance)
      : Date.now.bind(Date);
    const $u =
        J.requestAnimationFrame ||
        J.mozRequestAnimationFrame ||
        J.webkitRequestAnimationFrame ||
        J.msRequestAnimationFrame,
      Zu =
        J.cancelAnimationFrame ||
        J.mozCancelAnimationFrame ||
        J.webkitCancelAnimationFrame ||
        J.msCancelAnimationFrame;
    let Ku;
    const Qu = {
      now: () => (void 0 !== Ku ? Ku : J.performance.now()),
      setNow(e) {
        Ku = e;
      },
      restoreNow() {
        Ku = void 0;
      },
      frame(e) {
        const t = $u(e);
        return { cancel: () => Zu(t) };
      },
      getImageData(e) {
        const t = J.document.createElement('canvas'),
          i = t.getContext('2d');
        if (!i) throw new Error('failed to create canvas 2d context');
        return (
          (t.width = e.width),
          (t.height = e.height),
          i.drawImage(e, 0, 0, e.width, e.height),
          i.getImageData(0, 0, e.width, e.height)
        );
      },
      resolveURL(e) {
        const t = J.document.createElement('a');
        return (t.href = e), t.href;
      },
      hardwareConcurrency: J.navigator.hardwareConcurrency || 4,
      get devicePixelRatio() {
        return J.devicePixelRatio;
      },
      supportsWebp: !1,
    };
    if (J.document) {
      const e = J.document.createElement('img');
      (e.onload = function () {
        Qu.supportsWebp = !0;
      }),
        (e.src = 'data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=');
    }
    function Ju(e) {
      var t = { exports: {} };
      return e(t, t.exports), t.exports;
    }
    class eh {
      constructor(e, i, n, r, o, a) {
        (this.a = e),
          (this.b = i),
          (this.c = n),
          (this.normal = r || new Pt()),
          (this.vertexNormals = Array.isArray(r) ? r : []),
          (this.color = o || new ai()),
          (this.vertexColors = Array.isArray(o) ? o : []),
          (this.materialIndex = t(a) ? a : 0);
      }
      clone() {
        return new eh(this.a, this.b, this.c, this.normal, this.color, this.materialIndex);
      }
      copy(e) {
        (this.a = e.a),
          (this.b = e.b),
          (this.c = e.c),
          this.normal.copy(e.normal),
          this.color.copy(e.color),
          (this.materialIndex = e.materialIndex);
        for (let t = 0, i = e.vertexNormals.length; t < i; t++)
          this.vertexNormals[t] = new Pt(e.vertexNormals[t]);
        for (let t = 0, i = e.vertexColors.length; t < i; t++)
          this.vertexColors[t] = ai.parse(e.vertexColors[t]);
        return this;
      }
    }
    var th = Object.freeze({
      UNPROCESSING: 0,
      PROCESSING: 1,
      PROCESSINGSUCESS: 2,
      PROCESSINGFAIL: 3,
      PROCESSINGFISH: 4,
    });
    class ih {
      constructor() {
        (this.high = Pt.clone(Pt.ZERO)), (this.low = Pt.clone(Pt.ZERO));
      }
      static encode(e, i) {
        let n;
        return (
          t(i) || (i = { high: 0, low: 0 }),
          e >= 0
            ? ((n = 65536 * Math.floor(e / 65536)), (i.high = n), (i.low = e - n))
            : ((n = 65536 * Math.floor(-e / 65536)), (i.high = -n), (i.low = e + n)),
          i
        );
      }
      static fromVector3(e, i) {
        const n = { high: 0, low: 0 };
        t(i) || (i = new ih());
        const r = i.high,
          o = i.low;
        return (
          ih.encode(e.x, n),
          (r.x = n.high),
          (o.x = n.low),
          ih.encode(e.y, n),
          (r.y = n.high),
          (o.y = n.low),
          ih.encode(e.z, n),
          (r.z = n.high),
          (o.z = n.low),
          i
        );
      }
    }
    const nh = new Je(),
      rh = new Ta(),
      oh = new Pt();
    class ah {
      constructor(e = {}) {
        if (
          ((this.dynamicDraw = Z(e.dynamicDraw, !0)),
          (this.type = e.type || ''),
          (this._attributes = e.attributes || void 0),
          (this._indices = e.indices || void 0),
          (this._vertBuffer = e.vertBuffer || void 0),
          (this._indexBuffer = e.indexBuffer || void 0),
          (this.wireframeIndexBuffer = e.wireframeIndexBuffer || void 0),
          (this.primitiveType = t(e.primitiveType) ? e.primitiveType : Ll.TRIANGLES),
          (this._segmentVector = e.segmentVector || void 0),
          (this.dynamicLayoutBuffer1 = e.dynamicLayoutBuffer1 || void 0),
          (this.dynamicLayoutBuffer2 = e.dynamicLayoutBuffer2 || void 0),
          (this.dynamicLayoutBuffer3 = e.dynamicLayoutBuffer3 || void 0),
          (this.vertices = e.vertices || []),
          (this.colors = []),
          (this.faces = []),
          (this.faceVertexUvs = [[]]),
          (this.morphTargets = []),
          (this.morphNormals = []),
          (this.skinWeights = []),
          (this.skinIndices = []),
          (this.lineDistances = []),
          e.tileBoundingRegion)
        )
          (this.boundingSphere = e.tileBoundingRegion._boundingSphere),
            (this.boundingBox = e.tileBoundingRegion._orientedBoundingBox),
            (this.isTileGeometryType = !0);
        else if (this.vertices.length > 0) {
          const e = this.vertices.length,
            t = [];
          for (let i = 0; i < e; i += 3)
            t.push(new Pt(this.vertices[i], this.vertices[i + 1], this.vertices[i + 2]));
          this.computeBoundingSphere(t), this.computeBoundingBox(t), (this.isTileGeometryType = !1);
        } else
          (this.boundingSphere = null), (this.boundingBox = null), (this.isTileGeometryType = !1);
        (this.verticesNeedUpdate = !1),
          (this.uvsNeedUpdate = !1),
          (this.normalsNeedUpdate = !1),
          (this.state = th.PROCESSINGFISH);
      }
      parse() {}
      update() {}
      emplaceVertexBufferOfLines() {
        if ((this._vertexArray.clear(), this._usedDoublePrecision)) {
          let e, t, i;
          for (let n = 0; n < this.vertices.length; n += 3)
            (e = ih.encode(this.vertices[n])),
              (t = ih.encode(this.vertices[n + 1])),
              (i = ih.encode(this.vertices[n + 2])),
              this._vertexArray.emplaceBack(e.high, t.high, i.high, e.low, t.low, i.low);
        } else for (let e = 0; e < this.vertices.length; e += 3) this._vertexArray.emplaceBack(this.vertices[e], this.vertices[e + 1], this.vertices[e + 2]);
      }
      emplaceVertexBufferTriangle() {
        if ((this._vertexArray.clear(), this._usedDoublePrecision)) {
          let e, t, i;
          for (let n = 0; n < this.vertices.length; n += 3)
            (e = ih.encode(this.vertices[n])),
              (t = ih.encode(this.vertices[n + 1])),
              (i = ih.encode(this.vertices[n + 2])),
              this._vertexArray.emplaceBack(
                e.high,
                t.high,
                i.high,
                e.low,
                t.low,
                i.low,
                this.uvs[(n / 3) * 2],
                this.uvs[(n / 3) * 2 + 1],
                this.normals[n],
                this.normals[n + 1],
                this.normals[n + 2],
              );
        } else for (let e = 0; e < this.vertices.length; e += 3) this._vertexArray.emplaceBack(this.vertices[e], this.vertices[e + 1], this.vertices[e + 2], this.uvs[(e / 3) * 2], this.uvs[(e / 3) * 2 + 1], this.normals[e], this.normals[e + 1], this.normals[e + 2]);
      }
      applyMatrix(e) {
        const t = new je().getNormalMatrix(e);
        for (let t = 0, i = this.vertices.length; t < i; t++) this.vertices[t].transform(e);
        for (let e = 0, i = this.faces.length; e < i; e++) {
          const i = this.faces[e];
          i.normal.transformByMatrix3(t).normalize();
          for (let e = 0, n = i.vertexNormals.length; e < n; e++)
            i.vertexNormals[e].transformByMatrix3(t).normalize();
        }
        return (
          null !== this.boundingBox && this.computeBoundingBox(),
          null !== this.boundingSphere && this.computeBoundingSphere(),
          (this.verticesNeedUpdate = !0),
          (this.normalsNeedUpdate = !0),
          this
        );
      }
      rotateX(e) {
        return nh.makeRotationX(e), this.applyMatrix(nh), this;
      }
      rotateY(e) {
        return nh.makeRotationY(e), this.applyMatrix(nh), this;
      }
      rotateZ(e) {
        return nh.makeRotationZ(e), this.applyMatrix(nh), this;
      }
      translate(e, t, i) {
        return nh.makeTranslation(e, t, i), this.applyMatrix(nh), this;
      }
      scale(e, t, i) {
        return nh.makeScale(e, t, i), this.applyMatrix(nh), this;
      }
      lookAt(e) {
        return rh.lookAt(e), rh.updateMatrix(), this.applyMatrix(rh.matrix), this;
      }
      fromBufferGeometry(e) {
        const t = this,
          i = null !== e.index ? e.index.array : void 0,
          n = e.attributes,
          r = n.position.array,
          o = void 0 !== n.normal ? n.normal.array : void 0,
          a = void 0 !== n.color ? n.color.array : void 0,
          s = void 0 !== n.uv ? n.uv.array : void 0,
          l = void 0 !== n.uv2 ? n.uv2.array : void 0;
        void 0 !== l && (this.faceVertexUvs[1] = []);
        for (let e = 0; e < r.length; e += 3)
          t.vertices.push(new Pt().fromArray(r, e)), void 0 !== a && t.colors.push(ai.parse(a[e]));
        function c(e, i, n, r) {
          const c =
              void 0 === a
                ? []
                : [ai.parse(t.colors[e]), ai.parse(t.colors[i]), ai.parse(t.colors[n])],
            u =
              void 0 === o
                ? []
                : [
                    new Pt().fromArray(o, 3 * e),
                    new Pt().fromArray(o, 3 * i),
                    new Pt().fromArray(o, 3 * n),
                  ],
            h = new eh(e, i, n, u, c, r);
          t.faces.push(h),
            void 0 !== s &&
              t.faceVertexUvs[0].push([
                new $e().fromArray(s, 2 * e),
                new $e().fromArray(s, 2 * i),
                new $e().fromArray(s, 2 * n),
              ]),
            void 0 !== l &&
              t.faceVertexUvs[1].push([
                new $e().fromArray(l, 2 * e),
                new $e().fromArray(l, 2 * i),
                new $e().fromArray(l, 2 * n),
              ]);
        }
        const u = e.groups;
        if (u.length > 0)
          for (let e = 0; e < u.length; e++) {
            const t = u[e],
              n = t.start;
            for (let e = n, r = n + t.count; e < r; e += 3)
              void 0 !== i
                ? c(i[e], i[e + 1], i[e + 2], t.materialIndex)
                : c(e, e + 1, e + 2, t.materialIndex);
          }
        else if (void 0 !== i) for (let e = 0; e < i.length; e += 3) c(i[e], i[e + 1], i[e + 2]);
        else for (let e = 0; e < r.length / 3; e += 3) c(e, e + 1, e + 2);
        return (
          this.computeFaceNormals(),
          null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
          null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
          this
        );
      }
      center() {
        return (
          this.computeBoundingBox(),
          this.boundingBox.getCenter(oh).negate(),
          this.translate(oh.x, oh.y, oh.z),
          this
        );
      }
      normalize() {
        this.computeBoundingSphere();
        const e = this.boundingSphere.center,
          t = this.boundingSphere.radius,
          i = 0 === t ? 1 : 1 / t,
          n = new Je();
        return (
          n.setRowMajor(i, 0, 0, -i * e.x, 0, i, 0, -i * e.y, 0, 0, i, -i * e.z, 0, 0, 0, 1),
          this.applyMatrix(n),
          this
        );
      }
      computeFaceNormals() {
        const e = new Pt(),
          t = new Pt();
        for (let i = 0, n = this.faces.length; i < n; i++) {
          const n = this.faces[i],
            r = this.vertices[n.a],
            o = this.vertices[n.b];
          e.subVectors(this.vertices[n.c], o),
            t.subVectors(r, o),
            e.cross(t),
            e.normalize(),
            n.normal.copy(e);
        }
      }
      computeVertexNormals(e) {
        let t, i, n, r, o;
        void 0 === e && (e = !0);
        const a = new Array(this.vertices.length);
        for (t = 0, i = this.vertices.length; t < i; t++) a[t] = new Pt();
        if (e) {
          let e, t, i;
          const s = new Pt(),
            l = new Pt();
          for (n = 0, r = this.faces.length; n < r; n++)
            (o = this.faces[n]),
              (e = this.vertices[o.a]),
              (t = this.vertices[o.b]),
              (i = this.vertices[o.c]),
              s.subVectors(i, t),
              l.subVectors(e, t),
              s.cross(l),
              a[o.a].add(s),
              a[o.b].add(s),
              a[o.c].add(s);
        } else for (this.computeFaceNormals(), n = 0, r = this.faces.length; n < r; n++) (o = this.faces[n]), a[o.a].add(o.normal), a[o.b].add(o.normal), a[o.c].add(o.normal);
        for (t = 0, i = this.vertices.length; t < i; t++) a[t].normalize();
        for (n = 0, r = this.faces.length; n < r; n++) {
          o = this.faces[n];
          const e = o.vertexNormals;
          3 === e.length
            ? (e[0].copy(a[o.a]), e[1].copy(a[o.b]), e[2].copy(a[o.c]))
            : ((e[0] = new Pt(a[o.a])), (e[1] = new Pt(a[o.b])), (e[2] = new Pt(a[o.c])));
        }
        this.faces.length > 0 && (this.normalsNeedUpdate = !0);
      }
      computeFlatVertexNormals() {
        let e, t, i;
        for (this.computeFaceNormals(), e = 0, t = this.faces.length; e < t; e++) {
          i = this.faces[e];
          const t = i.vertexNormals;
          3 === t.length
            ? (t[0].copy(i.normal), t[1].copy(i.normal), t[2].copy(i.normal))
            : ((t[0] = new Pt(i.normal)), (t[1] = new Pt(i.normal)), (t[2] = new Pt(i.normal)));
        }
        this.faces.length > 0 && (this.normalsNeedUpdate = !0);
      }
      computeMorphNormals() {
        let e, t, i, n, r;
        for (i = 0, n = this.faces.length; i < n; i++)
          for (
            r = this.faces[i],
              r.__originalFaceNormal
                ? r.__originalFaceNormal.copy(r.normal)
                : (r.__originalFaceNormal = new Pt(r.normal)),
              r.__originalVertexNormals || (r.__originalVertexNormals = []),
              e = 0,
              t = r.vertexNormals.length;
            e < t;
            e++
          )
            r.__originalVertexNormals[e]
              ? r.__originalVertexNormals[e].copy(r.vertexNormals[e])
              : (r.__originalVertexNormals[e] = new Pt(r.vertexNormals[e]));
        const o = new ah();
        for (o.faces = this.faces, e = 0, t = this.morphTargets.length; e < t; e++) {
          if (!this.morphNormals[e]) {
            (this.morphNormals[e] = {}),
              (this.morphNormals[e].faceNormals = []),
              (this.morphNormals[e].vertexNormals = []);
            const t = this.morphNormals[e].faceNormals,
              r = this.morphNormals[e].vertexNormals;
            let o, a;
            for (i = 0, n = this.faces.length; i < n; i++)
              (o = new Pt()), (a = { a: new Pt(), b: new Pt(), c: new Pt() }), t.push(o), r.push(a);
          }
          const t = this.morphNormals[e];
          let a, s;
          for (
            o.vertices = this.morphTargets[e].vertices,
              o.computeFaceNormals(),
              o.computeVertexNormals(),
              i = 0,
              n = this.faces.length;
            i < n;
            i++
          )
            (r = this.faces[i]),
              (a = t.faceNormals[i]),
              (s = t.vertexNormals[i]),
              a.copy(r.normal),
              s.a.copy(r.vertexNormals[0]),
              s.b.copy(r.vertexNormals[1]),
              s.c.copy(r.vertexNormals[2]);
        }
        for (i = 0, n = this.faces.length; i < n; i++)
          (r = this.faces[i]),
            (r.normal = r.__originalFaceNormal),
            (r.vertexNormals = r.__originalVertexNormals);
      }
      computeBoundingBox(e) {
        let i;
        if ((t(e) || (e = this.vertices), a(e[0]) && e[0] instanceof Pt)) i = e;
        else {
          i = [];
          for (let t = 0; t < e.length; t += 3) i.push(new Pt([e[t], e[t + 1], e[t + 2]]));
        }
        const n = [];
        for (let e = 0; e < i.length; e++)
          isNaN(i[e][0]) || isNaN(i[e][1]) || isNaN(i[e][2]) || n.push(i[e]);
        (i = n), (this.boundingBox = Dc.fromPoints(i));
      }
      computeBoundingSphere(e) {
        let i;
        if ((t(e) || (e = this.vertices), a(e[0]) && e[0] instanceof Pt)) i = e;
        else {
          i = [];
          for (let t = 0; t < e.length; t += 3) i.push(new Pt([e[t], e[t + 1], e[t + 2]]));
        }
        const n = [];
        for (let e = 0; e < i.length; e++)
          isNaN(i[e][0]) || isNaN(i[e][1]) || isNaN(i[e][2]) || n.push(i[e]);
        (i = n), (this.boundingSphere = gc.fromPoints(i));
      }
      merge(e, t, i) {
        if (!e || !e.isGeometry)
          return void console.error(
            'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.',
            e,
          );
        let n;
        const r = this.vertices.length,
          o = this.vertices,
          a = e.vertices,
          s = this.faces,
          l = e.faces,
          c = this.colors,
          u = e.colors;
        void 0 === i && (i = 0), void 0 !== t && (n = new je().getNormalMatrix(t));
        for (let e = 0, i = a.length; e < i; e++) {
          const i = new Pt(a[e]);
          void 0 !== t && i.transform(t), o.push(i);
        }
        for (let e = 0, t = u.length; e < t; e++) c.push(ai.parse(u[e]));
        for (let e = 0, t = l.length; e < t; e++) {
          let t, o;
          const a = l[e],
            c = a.vertexNormals,
            u = a.vertexColors,
            h = new eh(a.a + r, a.b + r, a.c + r);
          h.normal.copy(a.normal), void 0 !== n && h.normal.transformByMatrix3(n).normalize();
          for (let e = 0, i = c.length; e < i; e++)
            (t = c[e].clone()),
              void 0 !== n && t.transformByMatrix3(n).normalize(),
              h.vertexNormals.push(t);
          h.color.copy(a.color);
          for (let e = 0, t = u.length; e < t; e++) (o = u[e]), h.vertexColors.push(ai.parse(o));
          (h.materialIndex = a.materialIndex + i), s.push(h);
        }
        for (let t = 0, i = e.faceVertexUvs.length; t < i; t++) {
          const i = e.faceVertexUvs[t];
          void 0 === this.faceVertexUvs[t] && (this.faceVertexUvs[t] = []);
          for (let e = 0, n = i.length; e < n; e++) {
            const n = i[e],
              r = [];
            for (let e = 0, t = n.length; e < t; e++) r.push(new $e(n[e]));
            this.faceVertexUvs[t].push(r);
          }
        }
      }
      mergeMesh(e) {
        e
          ? (e.matrixAutoUpdate && e.updateMatrix(), this.merge(e.geometry, e.matrix))
          : console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', e);
      }
      mergeVertices() {
        const e = {},
          t = [],
          i = [];
        let n, r;
        const o = Math.pow(10, 4);
        let a, s, l, c, u, h;
        for (a = 0, s = this.vertices.length; a < s; a++)
          (n = this.vertices[a]),
            (r = `${Math.round(n.x * o)}_${Math.round(n.y * o)}_${Math.round(n.z * o)}`),
            void 0 === e[r]
              ? ((e[r] = a), t.push(this.vertices[a]), (i[a] = t.length - 1))
              : (i[a] = i[e[r]]);
        const d = [];
        for (a = 0, s = this.faces.length; a < s; a++) {
          (l = this.faces[a]),
            (l.a = i[l.a]),
            (l.b = i[l.b]),
            (l.c = i[l.c]),
            (c = [l.a, l.b, l.c]);
          for (let e = 0; e < 3; e++)
            if (c[e] === c[(e + 1) % 3]) {
              d.push(a);
              break;
            }
        }
        for (a = d.length - 1; a >= 0; a--) {
          const e = d[a];
          for (this.faces.splice(e, 1), u = 0, h = this.faceVertexUvs.length; u < h; u++)
            this.faceVertexUvs[u].splice(e, 1);
        }
        const p = this.vertices.length - t.length;
        return (this.vertices = t), p;
      }
      setFromPoints(e) {
        this.vertices = [];
        for (let t = 0, i = e.length; t < i; t++) {
          const i = e[t];
          this.vertices.push(new Pt(i.x, i.y, i.z || 0));
        }
        return this;
      }
      sortFacesByMaterialIndex() {
        const e = this.faces,
          t = e.length;
        for (let i = 0; i < t; i++) e[i]._id = i;
        e.sort(function (e, t) {
          return e.materialIndex - t.materialIndex;
        });
        const i = this.faceVertexUvs[0],
          n = this.faceVertexUvs[1];
        let r, o;
        i && i.length === t && (r = []), n && n.length === t && (o = []);
        for (let a = 0; a < t; a++) {
          const t = e[a]._id;
          r && r.push(i[t]), o && o.push(n[t]);
        }
        r && (this.faceVertexUvs[0] = r), o && (this.faceVertexUvs[1] = o);
      }
      static fromBucket(e, i, n) {
        if (!n) throw new Error('检查当前的瓦片没有 tileBoundingRegion！无法创建geometry对象！');
        const r = new ah({ tileBoundingRegion: n });
        return (
          (r._vertBuffer = e.layoutVertexBuffer),
          (r._indexBuffer = e.indexBuffer),
          (r._segmentVector = e.segments),
          (r.primitiveType = t(i) ? i : Ll.TRIANGLES),
          e._animationFlag && (r.animationVertexBuffers = e.animationVertexBuffers),
          r
        );
      }
      static fromPointCloudData(e, i) {
        const n = new ah({});
        return (
          (n._vertBuffer = e.layoutVertexBuffer),
          (n._indexBuffer = e.indexBuffer),
          (n._segmentVector = e.segmentVector),
          (n.primitiveType = t(i) ? i : Ll.POINTS),
          n
        );
      }
      setData() {}
      destroy() {
        (this.type = ''),
          (this._attributes = void 0),
          (this._indices = void 0),
          this._indexBuffer?.destroy(),
          this._vertBuffer?.destroy(),
          this._segmentVector?.destroy(),
          this.wireframeIndexBuffer?.destroy(),
          this.dynamicLayoutBuffer1?.destroy(),
          this.dynamicLayoutBuffer2?.destroy(),
          this.dynamicLayoutBuffer3?.destroy(),
          (this._vertBuffer = void 0),
          (this._indexBuffer = void 0),
          (this.primitiveType = void 0),
          (this.wireframeIndexBuffer = void 0),
          (this._segmentVector = void 0),
          (this.boundingSphere = void 0);
      }
    }
    function sh(e, t, i) {
      if (0 === e) return t * i;
      const n = e * e,
        r = n * n,
        o = r * n,
        a = o * n,
        s = a * n,
        l = s * n,
        c = i;
      return (
        t *
        ((1 -
          n / 4 -
          (3 * r) / 64 -
          (5 * o) / 256 -
          (175 * a) / 16384 -
          (441 * s) / 65536 -
          (4851 * l) / 1048576) *
          c -
          ((3 * n) / 8 +
            (3 * r) / 32 +
            (45 * o) / 1024 +
            (105 * a) / 4096 +
            (2205 * s) / 131072 +
            (6237 * l) / 524288) *
            Math.sin(2 * c) +
          ((15 * r) / 256 +
            (45 * o) / 1024 +
            (525 * a) / 16384 +
            (1575 * s) / 65536 +
            (155925 * l) / 8388608) *
            Math.sin(4 * c) -
          ((35 * o) / 3072 + (175 * a) / 12288 + (3675 * s) / 262144 + (13475 * l) / 1048576) *
            Math.sin(6 * c) +
          ((315 * a) / 131072 + (2205 * s) / 524288 + (43659 * l) / 8388608) * Math.sin(8 * c) -
          ((693 * s) / 1310720 + (6237 * l) / 5242880) * Math.sin(10 * c) +
          ((1001 * l) / 8388608) * Math.sin(12 * c))
      );
    }
    function lh(e, t) {
      if (0 === e) return Math.log(Math.tan(0.5 * (Me.CesiumMath.PI_OVER_TWO + t)));
      const i = e * Math.sin(t);
      return (
        Math.log(Math.tan(0.5 * (Me.CesiumMath.PI_OVER_TWO + t))) -
        (e / 2) * Math.log((1 + i) / (1 - i))
      );
    }
    function ch(e, t, i, n) {
      const r = n.maximumRadius,
        o = n.minimumRadius,
        a = r * r;
      (e._ellipticitySquared = (a - o * o) / a),
        (e._ellipticity = Math.sqrt(e._ellipticitySquared)),
        (e._start = as.clone(t, e._start)),
        (e._start.height = 0),
        (e._end = as.clone(i, e._end)),
        (e._end.height = 0),
        (e._heading = (function (e, t, i, n, r) {
          const o = lh(e._ellipticity, i),
            a = lh(e._ellipticity, r);
          return Math.atan2(Me.CesiumMath.negativePiToPi(n - t), a - o);
        })(e, t.longitude, t.latitude, i.longitude, i.latitude)),
        (e._distance = (function (e, t, i, n, r, o, a) {
          const s = e._heading,
            l = o - n;
          let c = 0;
          if (
            Me.CesiumMath.equalsEpsilon(
              Math.abs(s),
              Me.CesiumMath.PI_OVER_TWO,
              Me.CesiumMath.EPSILON8,
            )
          )
            if (t === i) c = t * Math.cos(r) * Me.CesiumMath.negativePiToPi(l);
            else {
              const i = Math.sin(r);
              c =
                (t * Math.cos(r) * Me.CesiumMath.negativePiToPi(l)) /
                Math.sqrt(1 - e._ellipticitySquared * i * i);
            }
          else {
            const i = sh(e._ellipticity, t, r);
            c = (sh(e._ellipticity, t, a) - i) / Math.cos(s);
          }
          return Math.abs(c);
        })(e, n.maximumRadius, n.minimumRadius, t.longitude, t.latitude, i.longitude, i.latitude));
    }
    function uh(e, i, n, r, o, a) {
      if (0 === n) return as.clone(e, a);
      const s = o * o;
      let l, c, u;
      if (Math.abs(Me.CesiumMath.PI_OVER_TWO - Math.abs(i)) > Me.CesiumMath.EPSILON8) {
        c = (function (e, t, i) {
          const n = e / i;
          if (0 === t) return n;
          const r = n * n,
            o = r * n,
            a = o * n,
            s = t * t,
            l = s * s,
            c = l * s,
            u = c * s,
            h = u * s,
            d = h * s,
            p = Math.sin(2 * n),
            f = Math.cos(2 * n),
            m = Math.sin(4 * n),
            _ = Math.cos(4 * n),
            g = Math.sin(6 * n),
            y = Math.cos(6 * n),
            x = Math.sin(8 * n),
            v = Math.cos(8 * n),
            w = Math.sin(10 * n);
          return (
            n +
            (n * s) / 4 +
            (7 * n * l) / 64 +
            (15 * n * c) / 256 +
            (579 * n * u) / 16384 +
            (1515 * n * h) / 65536 +
            (16837 * n * d) / 1048576 +
            ((3 * n * l) / 16 +
              (45 * n * c) / 256 -
              (n * (32 * r - 561) * u) / 4096 -
              (n * (232 * r - 1677) * h) / 16384 +
              (n * (399985 - 90560 * r + 512 * a) * d) / 5242880) *
              f +
            ((21 * n * c) / 256 +
              (483 * n * u) / 4096 -
              (n * (224 * r - 1969) * h) / 16384 -
              (n * (33152 * r - 112599) * d) / 1048576) *
              _ +
            ((151 * n * u) / 4096 +
              (4681 * n * h) / 65536 +
              (1479 * n * d) / 16384 -
              (453 * o * d) / 32768) *
              y +
            ((1097 * n * h) / 65536 + (42783 * n * d) / 1048576) * v +
            ((8011 * n * d) / 1048576) * Math.cos(10 * n) +
            ((3 * s) / 8 +
              (3 * l) / 16 +
              (213 * c) / 2048 -
              (3 * r * c) / 64 +
              (255 * u) / 4096 -
              (33 * r * u) / 512 +
              (20861 * h) / 524288 -
              (33 * r * h) / 512 +
              (a * h) / 1024 +
              (28273 * d) / 1048576 -
              (471 * r * d) / 8192 +
              (9 * a * d) / 4096) *
              p +
            ((21 * l) / 256 +
              (21 * c) / 256 +
              (533 * u) / 8192 -
              (21 * r * u) / 512 +
              (197 * h) / 4096 -
              (315 * r * h) / 4096 +
              (584039 * d) / 16777216 -
              (12517 * r * d) / 131072 +
              (7 * a * d) / 2048) *
              m +
            ((151 * c) / 6144 +
              (151 * u) / 4096 +
              (5019 * h) / 131072 -
              (453 * r * h) / 16384 +
              (26965 * d) / 786432 -
              (8607 * r * d) / 131072) *
              g +
            ((1097 * u) / 131072 +
              (1097 * h) / 65536 +
              (225797 * d) / 10485760 -
              (1097 * r * d) / 65536) *
              x +
            ((8011 * h) / 2621440 + (8011 * d) / 1048576) * w +
            ((293393 * d) / 251658240) * Math.sin(12 * n)
          );
        })(sh(o, r, e.latitude) + n * Math.cos(i), o, r);
        const t = lh(o, e.latitude),
          a = lh(o, c);
        (u = Math.tan(i) * (a - t)), (l = Me.CesiumMath.negativePiToPi(e.longitude + u));
      } else {
        let t;
        if (((c = e.latitude), 0 === o)) t = r * Math.cos(e.latitude);
        else {
          const i = Math.sin(e.latitude);
          t = (r * Math.cos(e.latitude)) / Math.sqrt(1 - s * i * i);
        }
        (u = n / t), (l = Me.CesiumMath.negativePiToPi(i > 0 ? e.longitude + u : e.longitude - u));
      }
      return t(a) ? ((a.longitude = l), (a.latitude = c), (a.height = 0), a) : new as(l, c, 0);
    }
    function hh(e, i, n) {
      const r = Z(n, wt.WGS84);
      (this._ellipsoid = r),
        (this._start = new as()),
        (this._end = new as()),
        (this._heading = void 0),
        (this._distance = void 0),
        (this._ellipticity = void 0),
        (this._ellipticitySquared = void 0),
        t(e) && t(i) && ch(this, e, i, r);
    }
    function dh(e, t, i, n, r, o) {
      let a, s;
      if (
        (void 0 === o &&
          (o = (function (e, t = {}) {
            const { start: i = 0, end: n = e.length } = t,
              r = t.size || 2;
            let o = 0;
            for (let t = i, a = n - r; t < n; t += r)
              (o += (e[t] - e[a]) * (e[t + 1] + e[a + 1])), (a = t);
            return o / 2;
          })(e, { start: t, end: i, size: n })),
        r === o < 0)
      )
        for (a = t; a < i; a += n) s = Nh(a, e[a], e[a + 1], s);
      else for (a = i - n; a >= t; a -= n) s = Nh(a, e[a], e[a + 1], s);
      return s && Eh(s, s.next) && (Oh(s), (s = s.next)), s;
    }
    function ph(e, t) {
      if (!e) return e;
      t || (t = e);
      let i,
        n = e;
      do {
        if (((i = !1), n.steiner || (!Eh(n, n.next) && 0 !== Ph(n.prev, n, n.next)))) n = n.next;
        else {
          if ((Oh(n), (n = t = n.prev), n === n.next)) break;
          i = !0;
        }
      } while (i || n !== t);
      return t;
    }
    function fh(e, t, i, n, r, o, a) {
      if (!e) return;
      !a &&
        o &&
        (function (e, t, i, n) {
          let r = e;
          do {
            null === r.z && (r.z = Th(r.x, r.y, t, i, n)),
              (r.prevZ = r.prev),
              (r.nextZ = r.next),
              (r = r.next);
          } while (r !== e);
          (r.prevZ.nextZ = null),
            (r.prevZ = null),
            (function (e) {
              let t,
                i,
                n,
                r,
                o,
                a,
                s,
                l,
                c = 1;
              do {
                for (r = e, e = null, l = null, n = 0; r; ) {
                  for (n++, a = r, o = 0, i = 0; i < c && (o++, (a = a.nextZ), a); i++);
                  for (s = c; o > 0 || (s > 0 && a); )
                    0 !== o && (0 === s || !a || r.z <= a.z)
                      ? ((t = r), (r = r.nextZ), o--)
                      : ((t = a), (a = a.nextZ), s--),
                      l ? (l.nextZ = t) : (e = t),
                      (t.prevZ = l),
                      (l = t);
                  r = a;
                }
                (l.nextZ = null), (c *= 2);
              } while (n > 1);
            })(r);
        })(e, n, r, o);
      let s,
        l,
        c = e;
      for (; e.prev !== e.next; )
        if (((s = e.prev), (l = e.next), o ? _h(e, n, r, o) : mh(e)))
          t.push(s.i / i), t.push(e.i / i), t.push(l.i / i), Oh(e), (e = l.next), (c = l.next);
        else if ((e = l) === c) {
          a
            ? 1 === a
              ? fh((e = gh(ph(e), t, i)), t, i, n, r, o, 2)
              : 2 === a && yh(e, t, i, n, r, o)
            : fh(ph(e), t, i, n, r, o, 1);
          break;
        }
    }
    function mh(e) {
      const t = e.prev,
        i = e,
        n = e.next;
      if (Ph(t, i, n) >= 0) return !1;
      let r = e.next.next;
      for (; r !== e.prev; ) {
        if (Sh(t.x, t.y, i.x, i.y, n.x, n.y, r.x, r.y) && Ph(r.prev, r, r.next) >= 0) return !1;
        r = r.next;
      }
      return !0;
    }
    function _h(e, t, i, n) {
      const r = e.prev,
        o = e,
        a = e.next;
      if (Ph(r, o, a) >= 0) return !1;
      const s = r.x > o.x ? (r.x > a.x ? r.x : a.x) : o.x > a.x ? o.x : a.x,
        l = r.y > o.y ? (r.y > a.y ? r.y : a.y) : o.y > a.y ? o.y : a.y,
        c = Th(
          r.x < o.x ? (r.x < a.x ? r.x : a.x) : o.x < a.x ? o.x : a.x,
          r.y < o.y ? (r.y < a.y ? r.y : a.y) : o.y < a.y ? o.y : a.y,
          t,
          i,
          n,
        ),
        u = Th(s, l, t, i, n);
      let h = e.prevZ,
        d = e.nextZ;
      for (; h && h.z >= c && d && d.z <= u; ) {
        if (
          h !== e.prev &&
          h !== e.next &&
          Sh(r.x, r.y, o.x, o.y, a.x, a.y, h.x, h.y) &&
          Ph(h.prev, h, h.next) >= 0
        )
          return !1;
        if (
          ((h = h.prevZ),
          d !== e.prev &&
            d !== e.next &&
            Sh(r.x, r.y, o.x, o.y, a.x, a.y, d.x, d.y) &&
            Ph(d.prev, d, d.next) >= 0)
        )
          return !1;
        d = d.nextZ;
      }
      for (; h && h.z >= c; ) {
        if (
          h !== e.prev &&
          h !== e.next &&
          Sh(r.x, r.y, o.x, o.y, a.x, a.y, h.x, h.y) &&
          Ph(h.prev, h, h.next) >= 0
        )
          return !1;
        h = h.prevZ;
      }
      for (; d && d.z <= u; ) {
        if (
          d !== e.prev &&
          d !== e.next &&
          Sh(r.x, r.y, o.x, o.y, a.x, a.y, d.x, d.y) &&
          Ph(d.prev, d, d.next) >= 0
        )
          return !1;
        d = d.nextZ;
      }
      return !0;
    }
    function gh(e, t, i) {
      let n = e;
      do {
        const r = n.prev,
          o = n.next.next;
        !Eh(r, o) &&
          Ch(r, n, n.next, o) &&
          Lh(r, o) &&
          Lh(o, r) &&
          (t.push(r.i / i), t.push(n.i / i), t.push(o.i / i), Oh(n), Oh(n.next), (n = e = o)),
          (n = n.next);
      } while (n !== e);
      return ph(n);
    }
    function yh(e, t, i, n, r, o) {
      let a = e;
      do {
        let e = a.next.next;
        for (; e !== a.prev; ) {
          if (a.i !== e.i && Ah(a, e)) {
            let s = Rh(a, e);
            return (
              (a = ph(a, a.next)),
              (s = ph(s, s.next)),
              fh(a, t, i, n, r, o),
              void fh(s, t, i, n, r, o)
            );
          }
          e = e.next;
        }
        a = a.next;
      } while (a !== e);
    }
    function xh(e, t) {
      return e.x - t.x;
    }
    function vh(e, t) {
      if (
        ((t = (function (e, t) {
          let i = t;
          const n = e.x,
            r = e.y;
          let o,
            a = -1 / 0;
          do {
            if (r <= i.y && r >= i.next.y && i.next.y !== i.y) {
              const e = i.x + ((r - i.y) * (i.next.x - i.x)) / (i.next.y - i.y);
              if (e <= n && e > a) {
                if (((a = e), e === n)) {
                  if (r === i.y) return i;
                  if (r === i.next.y) return i.next;
                }
                o = i.x < i.next.x ? i : i.next;
              }
            }
            i = i.next;
          } while (i !== t);
          if (!o) return null;
          if (n === a) return o;
          const s = o,
            l = o.x,
            c = o.y;
          let u,
            h = 1 / 0;
          i = o;
          do {
            n >= i.x &&
              i.x >= l &&
              n !== i.x &&
              Sh(r < c ? n : a, r, l, c, r < c ? a : n, r, i.x, i.y) &&
              ((u = Math.abs(r - i.y) / (n - i.x)),
              Lh(i, e) &&
                (u < h || (u === h && (i.x > o.x || (i.x === o.x && wh(o, i))))) &&
                ((o = i), (h = u))),
              (i = i.next);
          } while (i !== s);
          return o;
        })(e, t)),
        t)
      ) {
        const i = Rh(t, e);
        ph(t, t.next), ph(i, i.next);
      }
    }
    function wh(e, t) {
      return Ph(e.prev, e, t.prev) < 0 && Ph(t.next, e, e.next) < 0;
    }
    function Th(e, t, i, n, r) {
      return (
        (e =
          1431655765 &
          ((e =
            858993459 &
            ((e =
              252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | (e << 8))) | (e << 4))) |
              (e << 2))) |
            (e << 1))) |
        ((t =
          1431655765 &
          ((t =
            858993459 &
            ((t =
              252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | (t << 8))) | (t << 4))) |
              (t << 2))) |
            (t << 1))) <<
          1)
      );
    }
    function bh(e) {
      let t = e,
        i = e;
      do {
        (t.x < i.x || (t.x === i.x && t.y < i.y)) && (i = t), (t = t.next);
      } while (t !== e);
      return i;
    }
    function Sh(e, t, i, n, r, o, a, s) {
      return (
        (r - a) * (t - s) - (e - a) * (o - s) >= 0 &&
        (e - a) * (n - s) - (i - a) * (t - s) >= 0 &&
        (i - a) * (o - s) - (r - a) * (n - s) >= 0
      );
    }
    function Ah(e, t) {
      return (
        e.next.i !== t.i &&
        e.prev.i !== t.i &&
        !(function (e, t) {
          let i = e;
          do {
            if (
              i.i !== e.i &&
              i.next.i !== e.i &&
              i.i !== t.i &&
              i.next.i !== t.i &&
              Ch(i, i.next, e, t)
            )
              return !0;
            i = i.next;
          } while (i !== e);
          return !1;
        })(e, t) &&
        ((Lh(e, t) &&
          Lh(t, e) &&
          (function (e, t) {
            let i = e,
              n = !1;
            const r = (e.x + t.x) / 2,
              o = (e.y + t.y) / 2;
            do {
              i.y > o != i.next.y > o &&
                i.next.y !== i.y &&
                r < ((i.next.x - i.x) * (o - i.y)) / (i.next.y - i.y) + i.x &&
                (n = !n),
                (i = i.next);
            } while (i !== e);
            return n;
          })(e, t) &&
          (Ph(e.prev, e, t.prev) || Ph(e, t.prev, t))) ||
          (Eh(e, t) && Ph(e.prev, e, e.next) > 0 && Ph(t.prev, t, t.next) > 0))
      );
    }
    function Ph(e, t, i) {
      return (t.y - e.y) * (i.x - t.x) - (t.x - e.x) * (i.y - t.y);
    }
    function Eh(e, t) {
      return e.x === t.x && e.y === t.y;
    }
    function Ch(e, t, i, n) {
      const r = Ih(Ph(e, t, i)),
        o = Ih(Ph(e, t, n)),
        a = Ih(Ph(i, n, e)),
        s = Ih(Ph(i, n, t));
      return (
        (r !== o && a !== s) ||
        !(0 !== r || !Mh(e, i, t)) ||
        !(0 !== o || !Mh(e, n, t)) ||
        !(0 !== a || !Mh(i, e, n)) ||
        !(0 !== s || !Mh(i, t, n))
      );
    }
    function Mh(e, t, i) {
      return (
        t.x <= Math.max(e.x, i.x) &&
        t.x >= Math.min(e.x, i.x) &&
        t.y <= Math.max(e.y, i.y) &&
        t.y >= Math.min(e.y, i.y)
      );
    }
    function Ih(e) {
      return e > 0 ? 1 : e < 0 ? -1 : 0;
    }
    function Lh(e, t) {
      return Ph(e.prev, e, e.next) < 0
        ? Ph(e, t, e.next) >= 0 && Ph(e, e.prev, t) >= 0
        : Ph(e, t, e.prev) < 0 || Ph(e, e.next, t) < 0;
    }
    function Rh(e, t) {
      const i = new Dh(e.i, e.x, e.y),
        n = new Dh(t.i, t.x, t.y),
        r = e.next,
        o = t.prev;
      return (
        (e.next = t),
        (t.prev = e),
        (i.next = r),
        (r.prev = i),
        (n.next = i),
        (i.prev = n),
        (o.next = n),
        (n.prev = o),
        n
      );
    }
    function Nh(e, t, i, n) {
      const r = new Dh(e, t, i);
      return (
        n
          ? ((r.next = n.next), (r.prev = n), (n.next.prev = r), (n.next = r))
          : ((r.prev = r), (r.next = r)),
        r
      );
    }
    function Oh(e) {
      (e.next.prev = e.prev),
        (e.prev.next = e.next),
        e.prevZ && (e.prevZ.nextZ = e.nextZ),
        e.nextZ && (e.nextZ.prevZ = e.prevZ);
    }
    function Dh(e, t, i) {
      (this.i = e),
        (this.x = t),
        (this.y = i),
        (this.prev = null),
        (this.next = null),
        (this.z = null),
        (this.prevZ = null),
        (this.nextZ = null),
        (this.steiner = !1);
    }
    Object.defineProperties(hh.prototype, {
      ellipsoid: {
        get() {
          return this._ellipsoid;
        },
      },
      surfaceDistance: {
        get() {
          return this._distance;
        },
      },
      start: {
        get() {
          return this._start;
        },
      },
      end: {
        get() {
          return this._end;
        },
      },
      heading: {
        get() {
          return this._heading;
        },
      },
    }),
      (hh.fromStartHeadingDistance = function (e, i, n, r, o) {
        const a = Z(r, wt.WGS84),
          s = a.maximumRadius,
          l = a.minimumRadius,
          c = s * s,
          u = Math.sqrt((c - l * l) / c),
          h = uh(e, (i = Me.CesiumMath.negativePiToPi(i)), n, a.maximumRadius, u);
        return !t(o) || (t(r) && !r.equals(o.ellipsoid))
          ? new hh(e, h, a)
          : (o.setEndPoints(e, h), o);
      }),
      (hh.prototype.setEndPoints = function (e, t) {
        ch(this, e, t, this._ellipsoid);
      }),
      (hh.prototype.interpolateUsingFraction = function (e, t) {
        return this.interpolateUsingSurfaceDistance(e * this._distance, t);
      }),
      (hh.prototype.interpolateUsingSurfaceDistance = function (e, i) {
        if (!t(this._distance) || 0 === this._distance)
          throw new Error('EllipsoidRhumbLine must have distinct start and end set.');
        return uh(
          this._start,
          this._heading,
          e,
          this._ellipsoid.maximumRadius,
          this._ellipticity,
          i,
        );
      }),
      (hh.prototype.findIntersectionWithLongitude = function (e, i) {
        if (!t(this._distance) || 0 === this._distance)
          throw new Error('EllipsoidRhumbLine must have distinct start and end set.');
        const n = this._ellipticity,
          r = this._heading,
          o = Math.abs(r),
          a = this._start;
        if (
          ((e = Me.CesiumMath.negativePiToPi(e)),
          Me.CesiumMath.equalsEpsilon(Math.abs(e), Math.PI, Me.CesiumMath.EPSILON14) &&
            (e = Me.CesiumMath.sign(a.longitude) * Math.PI),
          t(i) || (i = new as()),
          Math.abs(Me.CesiumMath.PI_OVER_TWO - o) <= Me.CesiumMath.EPSILON8)
        )
          return (i.longitude = e), (i.latitude = a.latitude), (i.height = 0), i;
        if (
          Me.CesiumMath.equalsEpsilon(
            Math.abs(Me.CesiumMath.PI_OVER_TWO - o),
            Me.CesiumMath.PI_OVER_TWO,
            Me.CesiumMath.EPSILON8,
          )
        ) {
          if (Me.CesiumMath.equalsEpsilon(e, a.longitude, Me.CesiumMath.EPSILON12)) return;
          return (
            (i.longitude = e),
            (i.latitude =
              Me.CesiumMath.PI_OVER_TWO * Me.CesiumMath.sign(Me.CesiumMath.PI_OVER_TWO - r)),
            (i.height = 0),
            i
          );
        }
        const s = a.latitude,
          l = n * Math.sin(s),
          c =
            Math.tan(0.5 * (Me.CesiumMath.PI_OVER_TWO + s)) *
            Math.exp((e - a.longitude) / Math.tan(r)),
          u = (1 + l) / (1 - l);
        let h,
          d = a.latitude;
        do {
          h = d;
          const e = n * Math.sin(h);
          d = 2 * Math.atan(c * Math.pow((1 + e) / (1 - e) / u, n / 2)) - Me.CesiumMath.PI_OVER_TWO;
        } while (!Me.CesiumMath.equalsEpsilon(d, h, Me.CesiumMath.EPSILON12));
        return (i.longitude = e), (i.latitude = d), (i.height = 0), i;
      }),
      (hh.prototype.findIntersectionWithLatitude = function (e, i) {
        if (!t(this._distance) || 0 === this._distance)
          throw new Error('EllipsoidRhumbLine must have distinct start and end set.');
        const n = this._ellipticity,
          r = this._heading,
          o = this._start;
        if (
          Me.CesiumMath.equalsEpsilon(
            Math.abs(r),
            Me.CesiumMath.PI_OVER_TWO,
            Me.CesiumMath.EPSILON8,
          )
        )
          return;
        const a = lh(n, o.latitude),
          s = lh(n, e),
          l = Math.tan(r) * (s - a),
          c = Me.CesiumMath.negativePiToPi(o.longitude + l);
        return t(i) ? ((i.longitude = c), (i.latitude = e), (i.height = 0), i) : new as(c, e, 0);
      });
    const Fh = Me.CesiumMath,
      zh = {
        computeArea2D: function (e) {
          if (e.length < 3) throw new Error('positions.length must greater than 3.');
          const t = e.length;
          let i = 0;
          for (let n = t - 1, r = 0; r < t; n = r++) {
            const t = e[n],
              o = e[r];
            i += t.x * o.y - o.x * t.y;
          }
          return 0.5 * i;
        },
        computeWindingOrder2D: function (e) {
          return zh.computeArea2D(e) > 0 ? Gh.COUNTER_CLOCKWISE : Gh.CLOCKWISE;
        },
        triangulate: function (e, i) {
          if (!t(t)) throw new Error('positions could not be undefined!');
          return (function (e, t, i, n) {
            i = i || 2;
            const r = t && t.length,
              o = r ? t[0] * i : e.length;
            let a = dh(e, 0, o, i, !0, n);
            const s = [];
            if (!a || a.next === a.prev) return s;
            let l, c, u, h, d, p, f;
            if (
              (r &&
                (a = (function (e, t, i, n, r) {
                  const o = [];
                  let a, s, l, c, u;
                  for (a = 0, s = t.length; a < s; a++)
                    (l = t[a] * n),
                      (c = a < s - 1 ? t[a + 1] * n : e.length),
                      (u = dh(e, l, c, n, !1, r)),
                      u === u.next && (u.steiner = !0),
                      o.push(bh(u));
                  for (o.sort(xh), a = 0; a < o.length; a++) vh(o[a], i), (i = ph(i, i.next));
                  return i;
                })(e, t, a, i, n)),
              e.length > 80 * i)
            ) {
              (h = c = e[0]), (d = u = e[1]);
              for (let t = i; t < o; t += i)
                (p = e[t]),
                  (f = e[t + 1]),
                  p < h && (h = p),
                  f < d && (d = f),
                  p > c && (c = p),
                  f > u && (u = f);
              (l = Math.max(c - h, u - d)), (l = 0 !== l ? 1 / l : 0);
            }
            return fh(a, s, i, h, d, l), s;
          })($e.packArray(e), i, 2);
        },
        computeSubdivision: function (e, i, n, r) {
          const o = new Pt(),
            a = new Pt(),
            s = new Pt(),
            l = new Pt(),
            c = new Pt(),
            u = new Pt(),
            h = new Pt();
          if (((r = Z(r, Fh.RADIANS_PER_DEGREE)), 'object' != typeof e))
            throw new Error('ellipsoid could not be undefined!');
          if (!t(i)) throw new Error('positions could not be undefined!');
          if (!t(n)) throw new Error('indices could not be undefined!');
          if (n.length < 3) throw new Error('indices.length could not less than 3!');
          if (n.length % 3 != 0) throw new Error('indices.length % 3 must equal 0!');
          if (r <= 0) throw new Error('granularity must greater than 0!');
          const d = n.slice(0);
          let p;
          const f = i.length,
            m = new Array(3 * f);
          let _ = 0;
          for (p = 0; p < f; p++) {
            const e = i[p];
            (m[_++] = e.x), (m[_++] = e.y), (m[_++] = e.z);
          }
          const g = [],
            y = {},
            x = e.maximumRadius,
            v = Fh.chordLength(r, x),
            w = v * v;
          for (; d.length > 0; ) {
            const e = d.pop(),
              i = d.pop(),
              n = d.pop(),
              r = Pt.fromArray(m, 3 * n, o),
              f = Pt.fromArray(m, 3 * i, a),
              _ = Pt.fromArray(m, 3 * e, s),
              v = Pt.multiplyByScalar(Pt.normalize(r, l), x, l),
              T = Pt.multiplyByScalar(Pt.normalize(f, c), x, c),
              b = Pt.multiplyByScalar(Pt.normalize(_, u), x, u),
              S = Pt.magnitudeSquared(Pt.subtract(v, T, h)),
              A = Pt.magnitudeSquared(Pt.subtract(T, b, h)),
              P = Pt.magnitudeSquared(Pt.subtract(b, v, h)),
              E = Math.max(S, A, P);
            let C, M;
            E > w
              ? S === E
                ? ((C = `${Math.min(n, i)} ${Math.max(n, i)}`),
                  (p = y[C]),
                  t(p) ||
                    ((M = Pt.add(r, f, h)),
                    Pt.multiplyByScalar(M, 0.5, M),
                    m.push(M.x, M.y, M.z),
                    (p = m.length / 3 - 1),
                    (y[C] = p)),
                  d.push(n, p, e),
                  d.push(p, i, e))
                : A === E
                ? ((C = `${Math.min(i, e)} ${Math.max(i, e)}`),
                  (p = y[C]),
                  t(p) ||
                    ((M = Pt.add(f, _, h)),
                    Pt.multiplyByScalar(M, 0.5, M),
                    m.push(M.x, M.y, M.z),
                    (p = m.length / 3 - 1),
                    (y[C] = p)),
                  d.push(i, p, n),
                  d.push(p, e, n))
                : P === E &&
                  ((C = `${Math.min(e, n)} ${Math.max(e, n)}`),
                  (p = y[C]),
                  t(p) ||
                    ((M = Pt.add(_, r, h)),
                    Pt.multiplyByScalar(M, 0.5, M),
                    m.push(M.x, M.y, M.z),
                    (p = m.length / 3 - 1),
                    (y[C] = p)),
                  d.push(e, p, i),
                  d.push(p, n, i))
              : (g.push(n), g.push(i), g.push(e));
          }
          return { positions: m, indices: g };
        },
      },
      Bh = new as(),
      Vh = new as(),
      Uh = new as(),
      kh = new as();
    (zh.computeRhumbLineSubdivision = function (e, i, n, r) {
      const o = new Pt(),
        a = new Pt(),
        s = new Pt(),
        l = new Pt();
      if (((r = Z(r, Fh.RADIANS_PER_DEGREE)), 'object' != typeof e))
        throw new Error('ellipsoid could not be undefined!');
      if (!t(i)) throw new Error('positions could not be undefined!');
      if (!t(n)) throw new Error('indices could not be undefined!');
      if (n.length < 3) throw new Error('indices.length could not less than 3!');
      if (n.length % 3 != 0) throw new Error('indices.length % 3 must equal 0!');
      if (r <= 0) throw new Error('granularity must greater than 0!');
      const c = n.slice(0);
      let u;
      const h = i.length,
        d = new Array(3 * h);
      let p = 0;
      for (u = 0; u < h; u++) {
        const e = i[u];
        (d[p++] = e.x), (d[p++] = e.y), (d[p++] = e.z);
      }
      const f = [],
        m = {},
        _ = Fh.chordLength(r, e.maximumRadius),
        g = new hh(void 0, void 0, e),
        y = new hh(void 0, void 0, e),
        x = new hh(void 0, void 0, e);
      for (; c.length > 0; ) {
        const i = c.pop(),
          n = c.pop(),
          r = c.pop(),
          h = Pt.fromArray(d, 3 * r, o),
          p = Pt.fromArray(d, 3 * n, a),
          v = Pt.fromArray(d, 3 * i, s),
          w = e.cartesianToCartographic(h, Bh),
          T = e.cartesianToCartographic(p, Vh),
          b = e.cartesianToCartographic(v, Uh);
        g.setEndPoints(w, T);
        const S = g.surfaceDistance;
        y.setEndPoints(T, b);
        const A = y.surfaceDistance;
        x.setEndPoints(b, w);
        const P = x.surfaceDistance,
          E = Math.max(S, A, P);
        let C, M, I, L;
        E > _
          ? S === E
            ? ((C = `${Math.min(r, n)} ${Math.max(r, n)}`),
              (u = m[C]),
              t(u) ||
                ((M = g.interpolateUsingFraction(0.5, kh)),
                (I = 0.5 * (w.height + T.height)),
                (L = Pt.fromRadians(M.longitude, M.latitude, I, e, l)),
                d.push(L.x, L.y, L.z),
                (u = d.length / 3 - 1),
                (m[C] = u)),
              c.push(r, u, i),
              c.push(u, n, i))
            : A === E
            ? ((C = `${Math.min(n, i)} ${Math.max(n, i)}`),
              (u = m[C]),
              t(u) ||
                ((M = y.interpolateUsingFraction(0.5, kh)),
                (I = 0.5 * (T.height + b.height)),
                (L = Pt.fromRadians(M.longitude, M.latitude, I, e, l)),
                d.push(L.x, L.y, L.z),
                (u = d.length / 3 - 1),
                (m[C] = u)),
              c.push(n, u, r),
              c.push(u, i, r))
            : P === E &&
              ((C = `${Math.min(i, r)} ${Math.max(i, r)}`),
              (u = m[C]),
              t(u) ||
                ((M = x.interpolateUsingFraction(0.5, kh)),
                (I = 0.5 * (b.height + w.height)),
                (L = Pt.fromRadians(M.longitude, M.latitude, I, e, l)),
                d.push(L.x, L.y, L.z),
                (u = d.length / 3 - 1),
                (m[C] = u)),
              c.push(i, u, n),
              c.push(u, r, n))
          : (f.push(r), f.push(n), f.push(i));
      }
      return { positions: d, indices: f };
    }),
      (zh.scaleToGeodeticHeight = function (e, i, n, r) {
        n = Z(n, wt.WGS84);
        let o = new Pt(),
          a = new Pt();
        if (((i = Z(i, 0)), (r = Z(r, !0)), t(e))) {
          const t = e.length;
          for (let s = 0; s < t; s += 3)
            Pt.fromArray(e, s, a),
              r && (a = n.scaleToGeodeticSurface(a, a)),
              0 !== i &&
                ((o = n.geodeticSurfaceNormal(a, o)),
                Pt.multiplyByScalar(o, i, o),
                Pt.add(a, o, a)),
              (e[s] = a.x),
              (e[s + 1] = a.y),
              (e[s + 2] = a.z);
        }
        return e;
      }),
      (zh.hierarchyPack = function (e, i) {
        if (t(e.holes)) {
          i.holes = [];
          for (let t = 0; t < e.holes.length; t++) i.holes[t] = zh.hierarchyPack(e.holes[t], {});
        }
        if (t(e.positions)) {
          const t = [];
          for (let i = 0; i < e.positions.length; i++)
            t.push(Pt.pack(e.positions[i], new Array(3)));
          i.positions = t;
        }
        return i;
      }),
      (zh.hierarchyUnpack = function (e, i) {
        if (t(e.holes)) {
          i.holes = [];
          for (const t in e.holes) i.holes[t] = zh.hierarchyUnpack(e.holes[t], {});
        }
        if (t(e.positions)) {
          const t = [];
          for (let i = 0; i < e.positions.length; i++) t.push(Pt.unpack(e.positions[i]));
          i.positions = t;
        }
        return i;
      });
    const Gh = { CLOCKWISE: Ll.CW, COUNTER_CLOCKWISE: Ll.CCW };
    function Hh() {
      (this._array = []), (this._offset = 0), (this._length = 0);
    }
    (Gh.validate = function (e) {
      return e === Gh.CLOCKWISE || e === Gh.COUNTER_CLOCKWISE;
    }),
      Object.defineProperties(Hh.prototype, {
        length: {
          get() {
            return this._length;
          },
        },
      }),
      (Hh.prototype.enqueue = function (e) {
        this._array.push(e), this._length++;
      }),
      (Hh.prototype.dequeue = function () {
        if (0 === this._length) return;
        const e = this._array;
        let t = this._offset;
        const i = e[t];
        return (
          (e[t] = void 0),
          t++,
          t > 10 && 2 * t > e.length && ((this._array = e.slice(t)), (t = 0)),
          (this._offset = t),
          this._length--,
          i
        );
      }),
      (Hh.prototype.peek = function () {
        if (0 !== this._length) return this._array[this._offset];
      }),
      (Hh.prototype.contains = function (e) {
        return -1 !== this._array.indexOf(e);
      }),
      (Hh.prototype.clear = function () {
        this._array.length = this._offset = this._length = 0;
      }),
      (Hh.prototype.sort = function (e) {
        this._offset > 0 && ((this._array = this._array.slice(this._offset)), (this._offset = 0)),
          this._array.sort(e);
      });
    class Yh {
      constructor(e) {
        this.segments = e || [];
      }
      pushSegment(e) {
        this.segments.push(e);
      }
      prepareSegment(e, t, i) {
        let n = this.segments[this.segments.length - 1];
        return (
          (!n || n.vertexLength + e > Yh.MAX_VERTEX_ARRAY_LENGTH) &&
            ((n = {
              vertexOffset: t.length,
              primitiveOffset: i.length,
              vertexLength: 0,
              primitiveLength: 0,
            }),
            this.segments.push(n)),
          n
        );
      }
      static simpleSegment(e, t, i, n) {
        return new Yh([
          {
            vertexOffset: e,
            primitiveOffset: t,
            vertexLength: i,
            primitiveLength: n,
            vaos: {},
            sortKey: 0,
          },
        ]);
      }
      get() {
        return this.segments;
      }
      destroy() {
        for (const e of this.segments) for (const t in e.vaos) e.vaos[t].destroy();
      }
    }
    (Yh.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1), fo('SegmentVector', Yh);
    const qh = Gt([
        { name: 'a_PositionHigh', type: 'Float32', components: 3 },
        { name: 'a_PositionLow', type: 'Float32', components: 3 },
        { name: 'a_TEXCOORD_0', type: 'Float32', components: 2 },
        { name: 'a_NORMAL', type: 'Float32', components: 3 },
      ]),
      Xh = Gt(
        [
          { name: 'a_POSITION', type: 'Float32', components: 3 },
          { name: 'a_TEXCOORD_0', type: 'Float32', components: 2 },
          { name: 'a_NORMAL', type: 'Float32', components: 3 },
        ],
        4,
      ),
      jh = Me.TRANSFORM.EPSILON10;
    function Wh(e, i, n, r) {
      if (!t(e)) return;
      n = Z(n, !1);
      const o = t(r),
        a = e.length;
      if (a < 2) return e;
      let s,
        l,
        c,
        u = e[0],
        h = 0,
        d = -1;
      for (s = 1; s < a; ++s)
        (l = e[s]),
          i(u, l, jh)
            ? (t(c) || ((c = e.slice(0, s)), (h = s - 1), (d = 0)), o && r.push(s))
            : (t(c) && (c.push(l), (h = s), o && (d = r.length)), (u = l));
      return (
        n &&
          i(e[0], e[a - 1], jh) &&
          (o && (t(c) ? r.splice(d, 0, h) : r.push(a - 1)),
          t(c) ? (c.length -= 1) : (c = e.slice(0, -1))),
        t(c) ? c : e
      );
    }
    function $h(e, t, i, n) {
      (this.x = Z(e, 0)), (this.y = Z(t, 0)), (this.width = Z(i, 0)), (this.height = Z(n, 0));
    }
    ($h.packedLength = 4),
      ($h.pack = function (e, t, i) {
        return (
          (i = Z(i, 0)), (t[i++] = e.x), (t[i++] = e.y), (t[i++] = e.width), (t[i] = e.height), t
        );
      }),
      ($h.unpack = function (e, i, n) {
        return (
          (i = Z(i, 0)),
          t(n) || (n = new $h()),
          (n.x = e[i++]),
          (n.y = e[i++]),
          (n.width = e[i++]),
          (n.height = e[i]),
          n
        );
      }),
      ($h.fromPoints = function (e, i) {
        if ((t(i) || (i = new $h()), !t(e) || 0 === e.length))
          return (i.x = 0), (i.y = 0), (i.width = 0), (i.height = 0), i;
        const n = e.length;
        let r = e[0].x,
          o = e[0].y,
          a = e[0].x,
          s = e[0].y;
        for (let t = 1; t < n; t++) {
          const i = e[t],
            n = i.x,
            l = i.y;
          (r = Math.min(n, r)), (a = Math.max(n, a)), (o = Math.min(l, o)), (s = Math.max(l, s));
        }
        return (i.x = r), (i.y = o), (i.width = a - r), (i.height = s - o), i;
      }),
      ($h.clone = function (e, i) {
        if (t(e))
          return t(i)
            ? ((i.x = e.x), (i.y = e.y), (i.width = e.width), (i.height = e.height), i)
            : new $h(e.x, e.y, e.width, e.height);
      }),
      ($h.union = function (e, i, n) {
        t(n) || (n = new $h());
        const r = Math.min(e.x, i.x),
          o = Math.min(e.y, i.y),
          a = Math.max(e.x + e.width, i.x + i.width),
          s = Math.max(e.y + e.height, i.y + i.height);
        return (n.x = r), (n.y = o), (n.width = a - r), (n.height = s - o), n;
      }),
      ($h.expand = function (e, t, i) {
        i = $h.clone(e, i);
        const n = t.x - i.x,
          r = t.y - i.y;
        return (
          n > i.width ? (i.width = n) : n < 0 && ((i.width -= n), (i.x = t.x)),
          r > i.height ? (i.height = r) : r < 0 && ((i.height -= r), (i.y = t.y)),
          i
        );
      }),
      ($h.equals = function (e, i) {
        return (
          e === i ||
          (t(e) &&
            t(i) &&
            e.x === i.x &&
            e.y === i.y &&
            e.width === i.width &&
            e.height === i.height)
        );
      }),
      ($h.prototype.clone = function (e) {
        return $h.clone(this, e);
      }),
      ($h.prototype.equals = function (e) {
        return $h.equals(this, e);
      });
    const Zh = { NONE: 0, GEODESIC: 1, RHUMB: 2 },
      Kh = Zh;
    class Qh {
      constructor() {}
      static adjustPosHeightsForNormal(e, t, i, n) {
        const r = new as(),
          o = new as(),
          a = n.cartesianToCartographic(e, r);
        ct(a, a);
        const s = a.height,
          l = n.cartesianToCartographic(t, o);
        ct(l, l), (l.height = s), n.cartographicToCartesian(l, t);
        const c = n.cartesianToCartographic(i, o);
        ct(c, c), (c.height = s - 100), n.cartographicToCartesian(c, i);
      }
      static combineGeometries(e) {
        const i = e.length;
        let n, r, o, a;
        const s = t(e[0].indices);
        for (r = 1; r < i; ++r)
          if (t(e[r].indices) !== s)
            throw new Error('All geometries must have an indices or not have one.');
        const l = this.findAttributesInAllGeometries(e);
        let c, u, h, d;
        for (n in l)
          if (l.hasOwnProperty(n))
            for (c = l[n], a = 0, r = 0; r < i; ++r)
              for (u = e[r][n], h = u.length, o = 0; o < h; ++o) c[a++] = u[o];
        if (s) {
          let t = 0;
          for (r = 0; r < i; ++r) t += e[r].indices.length;
          const n = new Uint16Array(t);
          let o = 0,
            s = 0;
          for (r = 0; r < i; ++r) {
            const t = e[r].indices,
              i = t.length;
            for (a = 0; a < i; ++a) n[o++] = s + t[a];
            s += e[r].positions.length / 3;
          }
          d = n;
        }
        return { positions: l.positions, normals: l.normals, uvs: l.uvs, indices: d };
      }
      static computeAttributes(e) {
        const t = new Pt(),
          i = new Pt(),
          n = new Pt(),
          r = new Pt(),
          o = new Pt(),
          a = new Pt(),
          s = new Pt(),
          l = new je(),
          c = e.geometry,
          u = c.positions;
        let h = u.length;
        const d = e.wall,
          p = e.top || d,
          f = e.bottom || d,
          m = e.boundingRectangle,
          _ = e.tangentPlane,
          g = e.ellipsoid,
          y = e.perPositionHeight,
          x = o;
        (x.x = m.x), (x.y = m.y);
        const v = new Float32Array((h / 3) * 2);
        let w;
        w = y && p && !d ? c.normals : new Float32Array(h);
        let T = 0,
          b = 0,
          S = i,
          A = !0,
          P = l;
        P = je.clone(je.IDENTITY, P);
        let E = 0,
          C = 0;
        p && f && ((E = h / 2), (C = h / 3), (h /= 2));
        for (let i = 0; i < h; i += 3) {
          const o = Pt.fromArray(u, i, s);
          let l = je.multiplyByVector(P, o, t);
          l = g.scaleToGeodeticSurface(l, l);
          const c = _.projectPointOntoPlane(l, a);
          $e.subtract(c, x, c);
          const M = se(c.x / m.width, 0, 1),
            I = se(c.y / m.height, 0, 1);
          f && ((v[T + C] = M), (v[T + 1 + C] = I)), p && ((v[T] = M), (v[T + 1] = I)), (T += 2);
          const L = b + 1,
            R = b + 2;
          if (d) {
            if (i + 3 < h) {
              const e = Pt.fromArray(u, i + 3, n);
              if (A) {
                const t = Pt.fromArray(u, i + h, r);
                y && this.adjustPosHeightsForNormal(o, e, t, g),
                  Pt.subtract(e, o, e),
                  Pt.subtract(t, o, t),
                  (S = Pt.normalize(Pt.cross(t, e, S), S)),
                  (A = !1);
              }
              Pt.equalsEpsilon(e, o, Me.CesiumMath.EPSILON10) && (A = !0);
            }
          } else S = g.geodeticSurfaceNormal(o, S);
          e.wall
            ? ((w[b + E] = S.x), (w[L + E] = S.y), (w[R + E] = S.z))
            : f && ((w[b + E] = -S.x), (w[L + E] = -S.y), (w[R + E] = -S.z)),
            ((p && !y) || d) && ((w[b] = S.x), (w[L] = S.y), (w[R] = S.z)),
            (b += 3);
        }
        return (c.uvs = v), (c.normals = w), c;
      }
      static computeBoundingBox(e) {
        const t = [];
        for (let i = 0; i < e.length; i += 3) t.push(new Pt(e[i], e[i + 1], e[i + 2]));
        return new Dc().setFromPoints(t);
      }
      static computeBoundingSphere(e) {
        const t = [];
        for (let i = 0; i < e.length; i += 3) t.push(new Pt(e[i], e[i + 1], e[i + 2]));
        return gc.fromPoints(t);
      }
      static computeBoundingRectangle(e, i, n, r = 0, o) {
        const a = new Et().fromAxisRotation(new Pt(e.x, e.y, e.z), r),
          s = new je().fromQuaternion(a);
        let l = Number.POSITIVE_INFINITY,
          c = Number.NEGATIVE_INFINITY,
          u = Number.POSITIVE_INFINITY,
          h = Number.NEGATIVE_INFINITY;
        const d = n.length;
        for (let e = 0; e < d; ++e) {
          const t = Pt.clone(n[e]);
          je.multiplyByVector(s, t, t);
          const r = i(t);
          (l = Math.min(l, r.x)),
            (c = Math.max(c, r.x)),
            (u = Math.min(u, r.y)),
            (h = Math.max(h, r.y));
        }
        return (
          t(o) || (o = new $h()), (o.x = l), (o.y = u), (o.width = c - l), (o.height = h - u), o
        );
      }
      static computeNormal(e, t) {
        const i = new Pt(),
          n = new Pt(),
          r = new Pt(),
          o = new Pt(),
          a = e.length / 3,
          s = t.length,
          l = new Array(a),
          c = new Array(s / 3),
          u = new Array(s);
        let h;
        for (h = 0; h < a; h++) l[h] = { indexOffset: 0, count: 0, currentCount: 0 };
        let d = 0;
        for (h = 0; h < s; h += 3) {
          const i = t[h],
            a = t[h + 1],
            s = t[h + 2],
            u = 3 * i,
            p = 3 * a,
            f = 3 * s;
          (n.x = e[u]),
            (n.y = e[u + 1]),
            (n.z = e[u + 2]),
            (r.x = e[p]),
            (r.y = e[p + 1]),
            (r.z = e[p + 2]),
            (o.x = e[f]),
            (o.y = e[f + 1]),
            (o.z = e[f + 2]),
            l[i].count++,
            l[a].count++,
            l[s].count++,
            Pt.subtract(r, n, r),
            Pt.subtract(o, n, o),
            (c[d] = Pt.cross(r, o, new Pt())),
            d++;
        }
        let p,
          f = 0;
        for (h = 0; h < a; h++) (l[h].indexOffset += f), (f += l[h].count);
        for (d = 0, h = 0; h < s; h += 3) {
          p = l[t[h]];
          let e = p.indexOffset + p.currentCount;
          (u[e] = d),
            p.currentCount++,
            (p = l[t[h + 1]]),
            (e = p.indexOffset + p.currentCount),
            (u[e] = d),
            p.currentCount++,
            (p = l[t[h + 2]]),
            (e = p.indexOffset + p.currentCount),
            (u[e] = d),
            p.currentCount++,
            d++;
        }
        const m = [];
        for (h = 0; h < a; h++) {
          const e = 3 * h;
          if (((p = l[h]), Pt.clone(Pt.ZERO, i), p.count > 0)) {
            for (d = 0; d < p.count; d++) Pt.add(i, c[u[p.indexOffset + d]], i);
            Pt.equalsEpsilon(Pt.ZERO, i, Me.CesiumMath.EPSILON10) &&
              Pt.clone(c[u[p.indexOffset]], i);
          }
          Pt.equalsEpsilon(Pt.ZERO, i, Me.CesiumMath.EPSILON10) && (i.z = 1),
            Pt.normalize(i, i),
            (m[e] = i.x),
            (m[e + 1] = i.y),
            (m[e + 2] = i.z);
        }
        return m;
      }
      static createGeometryFromPositions(e, t, i, n, r) {
        let o = zh.triangulate(t.positions2D, t.holes);
        o.length < 3 && (o = [0, 1, 2]);
        const a = t.positions;
        if (n) {
          const e = a.length,
            t = new Array(3 * e);
          let i = 0;
          for (let n = 0; n < e; n++) {
            const e = a[n];
            (t[i++] = e.x), (t[i++] = e.y), (t[i++] = e.z);
          }
          return { positions: t, indices: o, normals: this.computeNormal(t, o) };
        }
        return r === Kh.GEODESIC
          ? zh.computeSubdivision(e, a, o, i)
          : r === Kh.RHUMB
          ? zh.computeRhumbLineSubdivision(e, a, o, i)
          : void 0;
      }
      static createOutlineGeometryFromPositions(e, t, i, n, r) {
        const o = [],
          a = Ec.fromPoints(t, e).projectPointsOntoPlane(t, []);
        let s, l;
        zh.computeWindingOrder2D(a) === Gh.CLOCKWISE && (a.reverse(), (t = t.slice().reverse()));
        let c = t.length,
          u = 0;
        if (n)
          for (s = new Float64Array(2 * c * 3), l = 0; l < c; l++) {
            const e = t[l],
              i = t[(l + 1) % c];
            (s[u++] = e.x),
              (s[u++] = e.y),
              (s[u++] = e.z),
              (s[u++] = i.x),
              (s[u++] = i.y),
              (s[u++] = i.z);
          }
        else {
          let n = 0;
          if (r === Kh.GEODESIC)
            for (l = 0; l < c; l++) n += Qh.subdivideLineCount(t[l], t[(l + 1) % c], i);
          else if (r === Kh.RHUMB)
            for (l = 0; l < c; l++) n += Qh.subdivideRhumbLineCount(e, t[l], t[(l + 1) % c], i);
          for (s = new Float64Array(3 * n), l = 0; l < c; l++) {
            let n;
            r === Kh.GEODESIC
              ? (n = Qh.subdivideLine(t[l], t[(l + 1) % c], i, o))
              : r === Kh.RHUMB && (n = Qh.subdivideRhumbLine(e, t[l], t[(l + 1) % c], i, o));
            const a = n.length;
            for (let e = 0; e < a; ++e) s[u++] = n[e];
          }
        }
        c = s.length / 3;
        const h = new Uint16Array(2 * c);
        for (u = 0, l = 0; l < c - 1; l++) (h[u++] = l), (h[u++] = l + 1);
        return (h[u++] = c - 1), (h[u++] = 0), { positions: s, indices: h };
      }
      static createGeometryFromPositionsExtruded(e, t, i, n, r, o, a, s) {
        const l = [],
          c = { walls: [] };
        let u;
        if (o || a) {
          const n = this.createGeometryFromPositions(e, t, i, r, s),
            l = n.positions,
            h = n.indices;
          let d, p;
          if (o && a) {
            const e = l.concat(l);
            (d = e.length / 3), (p = new Uint16Array(2 * h.length)), p.set(h);
            const t = h.length,
              i = d / 2;
            for (u = 0; u < t; u += 3) {
              const e = p[u] + i,
                n = p[u + 1] + i;
              (p[u + t] = p[u + 2] + i), (p[u + 1 + t] = n), (p[u + 2 + t] = e);
            }
            if (((n.positions = e), r)) {
              const t = n.normals;
              (n.normals = new Float32Array(e.length)), n.normals.set(t);
            }
            n.indices = p;
          } else if (a) {
            for (d = l.length / 3, p = new Float32Array(h.length), u = 0; u < h.length; u += 3)
              (p[u] = h[u + 2]), (p[u + 1] = h[u + 1]), (p[u + 2] = h[u]);
            n.indices = p;
          }
          c.topAndBottom = n;
        }
        let h = n.outerRing,
          d = Ec.fromPoints(h, e),
          p = d.projectPointsOntoPlane(h, l),
          f = zh.computeWindingOrder2D(p);
        f === Gh.CLOCKWISE && (h = h.slice().reverse());
        let m = this.computeWallGeometry(h, e, i, r, s);
        c.walls.push(m);
        const _ = n.holes;
        for (u = 0; u < _.length; u++) {
          let t = _[u];
          (d = Ec.fromPoints(t, e)),
            (p = d.projectPointsOntoPlane(t, l)),
            (f = zh.computeWindingOrder2D(p)),
            f === Gh.COUNTER_CLOCKWISE && (t = t.slice().reverse()),
            (m = this.computeWallGeometry(t, e, i, r, s)),
            c.walls.push(m);
        }
        return c;
      }
      static createOutlineGeometryFromPositionsExtruded(e, t, i, n, r) {
        const o = [],
          a = Ec.fromPoints(t, e).projectPointsOntoPlane(t, []);
        let s, l;
        zh.computeWindingOrder2D(a) === Gh.CLOCKWISE && (a.reverse(), (t = t.slice().reverse()));
        let c = t.length;
        const u = new Array(c);
        let h = 0;
        if (n)
          for (s = new Float64Array(2 * c * 3 * 2), l = 0; l < c; ++l) {
            u[l] = h / 3;
            const e = t[l],
              i = t[(l + 1) % c];
            (s[h++] = e.x),
              (s[h++] = e.y),
              (s[h++] = e.z),
              (s[h++] = i.x),
              (s[h++] = i.y),
              (s[h++] = i.z);
          }
        else {
          let n = 0;
          if (r === Kh.GEODESIC)
            for (l = 0; l < c; l++) n += Qh.subdivideLineCount(t[l], t[(l + 1) % c], i);
          else if (r === Kh.RHUMB)
            for (l = 0; l < c; l++) n += Qh.subdivideRhumbLineCount(e, t[l], t[(l + 1) % c], i);
          for (s = new Float64Array(3 * n * 2), l = 0; l < c; ++l) {
            let n;
            (u[l] = h / 3),
              r === Kh.GEODESIC
                ? (n = Qh.subdivideLine(t[l], t[(l + 1) % c], i, o))
                : r === Kh.RHUMB && (n = Qh.subdivideRhumbLine(e, t[l], t[(l + 1) % c], i, o));
            const a = n.length;
            for (let e = 0; e < a; ++e) s[h++] = n[e];
          }
        }
        c = s.length / 6;
        const d = u.length,
          p = new Uint16Array(2 * (2 * c + d));
        for (h = 0, l = 0; l < c; ++l)
          (p[h++] = l), (p[h++] = (l + 1) % c), (p[h++] = l + c), (p[h++] = ((l + 1) % c) + c);
        for (l = 0; l < d; l++) {
          const e = u[l];
          (p[h++] = e), (p[h++] = e + c);
        }
        return { positions: s, indices: p };
      }
      static computeWallGeometry(e, t, i, n, r) {
        const o = [],
          a = new Pt(),
          s = new Pt();
        let l,
          c,
          u,
          h,
          d,
          p = e.length,
          f = 0;
        if (n)
          for (c = 3 * p * 2, l = new Array(2 * c), u = 0; u < p; u++)
            (h = e[u]),
              (d = e[(u + 1) % p]),
              (l[f] = l[f + c] = h.x),
              ++f,
              (l[f] = l[f + c] = h.y),
              ++f,
              (l[f] = l[f + c] = h.z),
              ++f,
              (l[f] = l[f + c] = d.x),
              ++f,
              (l[f] = l[f + c] = d.y),
              ++f,
              (l[f] = l[f + c] = d.z),
              ++f;
        else {
          const n = Me.CesiumMath.chordLength(i, t.maximumRadius);
          let a = 0;
          if (r === Kh.GEODESIC)
            for (u = 0; u < p; u++) a += this.subdivideLineCount(e[u], e[(u + 1) % p], n);
          else if (r === Kh.RHUMB)
            for (u = 0; u < p; u++) a += this.subdivideRhumbLineCount(t, e[u], e[(u + 1) % p], n);
          for (c = 3 * (a + p), l = new Array(2 * c), u = 0; u < p; u++) {
            let i;
            (h = e[u]),
              (d = e[(u + 1) % p]),
              r === Kh.GEODESIC
                ? (i = this.subdivideLine(h, d, n, o))
                : r === Kh.RHUMB && (i = this.subdivideRhumbLine(t, h, d, n, o));
            const a = i.length;
            for (let e = 0; e < a; ++e, ++f) (l[f] = i[e]), (l[f + c] = i[e]);
            (l[f] = d.x),
              (l[f + c] = d.x),
              ++f,
              (l[f] = d.y),
              (l[f + c] = d.y),
              ++f,
              (l[f] = d.z),
              (l[f + c] = d.z),
              ++f;
          }
        }
        p = l.length;
        const m = new Uint16Array(p - 6 * e.length);
        let _ = 0;
        for (p /= 6, u = 0; u < p; u++) {
          const e = u,
            t = e + 1,
            i = e + p,
            n = i + 1;
          (h = Pt.fromArray(l, 3 * e, a)),
            (d = Pt.fromArray(l, 3 * t, s)),
            Pt.equalsEpsilon(h, d, Me.CesiumMath.EPSILON10, Me.CesiumMath.EPSILON10) ||
              ((m[_++] = e), (m[_++] = i), (m[_++] = t), (m[_++] = t), (m[_++] = i), (m[_++] = n));
        }
        return { positions: l, indices: m };
      }
      static findAttributesInAllGeometries(e) {
        const i = e.length,
          n = {};
        let r;
        for (r in e[0]) {
          const o = e[0][r];
          let a = o.length,
            s = !0;
          for (let n = 1; n < i; ++n) {
            const i = e[n][r];
            if (
              !t(i) ||
              o.componentDatatype !== i.componentDatatype ||
              o.componentsPerAttribute !== i.componentsPerAttribute ||
              o.normalize !== i.normalize
            ) {
              s = !1;
              break;
            }
            a += i.length;
          }
          s &&
            ('positions' === r
              ? (n[r] = new Float64Array(a))
              : ('normals' !== r && 'uvs' !== r) || (n[r] = new Float32Array(a)));
        }
        return n;
      }
      static getPointAtDistance(e, t, i, n) {
        const r = new Pt();
        return (
          Pt.subtract(t, e, r), Pt.multiplyByScalar(r, i / n, r), Pt.add(e, r, r), [r.x, r.y, r.z]
        );
      }
      static scaleToGeodeticHeightExtruded(e, i, n, r, o) {
        const a = new Pt(),
          s = new Pt(),
          l = new Pt(),
          c = new Pt();
        r = Z(r, wt.WGS84);
        const u = a;
        let h = s;
        const d = l;
        let p = c;
        if (t(e) && t(e.positions)) {
          const t = e.positions,
            a = t.length / 2;
          for (let e = 0; e < a; e += 3)
            Pt.fromArray(t, e, d),
              r.geodeticSurfaceNormal(d, u),
              (p = r.scaleToGeodeticSurface(d, p)),
              (h = Pt.multiplyByScalar(u, n, h)),
              (h = Pt.add(p, h, h)),
              (t[e + a] = h.x),
              (t[e + 1 + a] = h.y),
              (t[e + 2 + a] = h.z),
              o && (p = Pt.clone(d, p)),
              (h = Pt.multiplyByScalar(u, i, h)),
              (h = Pt.add(p, h, h)),
              (t[e] = h.x),
              (t[e + 1] = h.y),
              (t[e + 2] = h.z);
        }
        return e;
      }
      static subdivideLine(e, i, n, r) {
        const o = this.subdivideLineCount(e, i, n),
          a = Pt.distance(e, i),
          s = a / o;
        t(r) || (r = []);
        const l = r;
        l.length = 3 * o;
        let c = 0;
        for (let t = 0; t < o; t++) {
          const n = this.getPointAtDistance(e, i, t * s, a);
          (l[c++] = n[0]), (l[c++] = n[1]), (l[c++] = n[2]);
        }
        return l;
      }
      static subdivideLineCount(e, t, i) {
        const n = Pt.distance(e, t),
          r = Math.max(0, Math.ceil(Me.CesiumMath.log2(n / i)));
        return Math.pow(2, r);
      }
      static subdivideRhumbLine(e, i, n, r, o) {
        const a = new as(),
          s = new as(),
          l = new as(),
          c = new Pt(),
          u = new hh(e.cartesianToCartographic(i, a), e.cartesianToCartographic(n, s), e),
          h = Math.max(0, Math.ceil(Me.CesiumMath.log2(u.surfaceDistance / r))),
          d = Math.pow(2, h),
          p = u.surfaceDistance / d;
        t(o) || (o = []);
        const f = o;
        f.length = 3 * d;
        let m = 0;
        for (let t = 0; t < d; t++) {
          const i = u.interpolateUsingSurfaceDistance(t * p, l),
            n = e.cartographicToCartesian(i, c);
          (f[m++] = n.x), (f[m++] = n.y), (f[m++] = n.z);
        }
        return f;
      }
      static subdivideRhumbLineCount(e, t, i, n) {
        const r = new as(),
          o = new as(),
          a = new hh(e.cartesianToCartographic(t, r), e.cartesianToCartographic(i, o), e),
          s = Math.max(0, Math.ceil(Me.CesiumMath.log2(a.surfaceDistance / n)));
        return Math.pow(2, s);
      }
      static polygonsFromHierarchy(e, i, n, r) {
        const o = [],
          a = [],
          s = new Hh();
        for (s.enqueue(e); 0 !== s.length; ) {
          const e = s.dequeue();
          let l = e.positions;
          const c = e.holes;
          let u, h;
          if (n) for (h = l.length, u = 0; u < h; u++) r.scaleToGeodeticSurface(l[u], l[u]);
          if (((l = Wh(l, Pt.equalsEpsilon, !0)), l.length < 3)) continue;
          let d = i(l);
          if (!t(d)) continue;
          const p = [];
          let f = zh.computeWindingOrder2D(d);
          f === Gh.CLOCKWISE && (d.reverse(), (l = l.slice().reverse()));
          let m = l.slice();
          const _ = t(c) ? c.length : 0,
            g = [];
          let y;
          for (u = 0; u < _; u++) {
            const e = c[u];
            let o = e.positions;
            if (n) for (h = o.length, y = 0; y < h; ++y) r.scaleToGeodeticSurface(o[y], o[y]);
            if (((o = Wh(o, Pt.equalsEpsilon, !0)), o.length < 3)) continue;
            const a = i(o);
            if (!t(a)) continue;
            (f = zh.computeWindingOrder2D(a)),
              f === Gh.CLOCKWISE && (a.reverse(), (o = o.slice().reverse())),
              g.push(o),
              p.push(m.length),
              (m = m.concat(o)),
              (d = d.concat(a));
            let l = 0;
            for (t(e.holes) && (l = e.holes.length), y = 0; y < l; y++) s.enqueue(e.holes[y]);
          }
          o.push({ outerRing: l, holes: g }), a.push({ positions: m, positions2D: d, holes: p });
        }
        return { hierarchy: o, polygons: a };
      }
      static polygonOutlinesFromHierarchy(e, i, n) {
        const r = [],
          o = new Hh();
        let a, s, l;
        for (o.enqueue(e); 0 !== o.length; ) {
          const e = o.dequeue();
          let c = e.positions;
          if (i) for (l = c.length, a = 0; a < l; a++) n.scaleToGeodeticSurface(c[a], c[a]);
          if (((c = Wh(c, Pt.equalsEpsilon, !0)), c.length < 3)) continue;
          const u = e.holes ? e.holes.length : 0;
          for (a = 0; a < u; a++) {
            const c = e.holes[a];
            let u = c.positions;
            if (i) for (l = u.length, s = 0; s < l; ++s) n.scaleToGeodeticSurface(u[s], u[s]);
            if (((u = Wh(u, Pt.equalsEpsilon, !0)), u.length < 3)) continue;
            r.push(u);
            let h = 0;
            for (t(c.holes) && (h = c.holes.length), s = 0; s < h; s++) o.enqueue(c.holes[s]);
          }
          r.push(c);
        }
        return r;
      }
    }
    class Jh extends ah {
      constructor(e) {
        super(e), this.setData(e);
      }
      updateProperty(e) {
        this.setData(e);
      }
      setData(e) {
        super.setData(e), this.#m(e), e.adaptTerrain ? this.#_() : this.#g();
      }
      #m(e) {
        if (t(e.perPositionHeight) && e.perPositionHeight && t(e.height))
          throw new Error('Cannot use both options.perPositionHeight and options.height');
        if (t(e.arcType) && e.arcType !== Kh.GEODESIC && e.arcType !== Kh.RHUMB)
          throw new Error(
            'Invalid arcType. Valid options are minemap.ARCTYPE.GEODESIC and minemap.ARCTYPE.RHUMB.',
          );
        if (!t(e.polygonHierarchy) || !t(e.polygonHierarchy.positions))
          throw new Error('positions must be defined!');
        let i;
        if (
          (e.polygonHierarchy.positions instanceof Function && (i = e.polygonHierarchy.positions),
          (this._positionsCallBack = i),
          (this._polygonHierarchy = e.polygonHierarchy),
          (this._granularity = Z(e.granularity, Me.CesiumMath.RADIANS_PER_DEGREE)),
          (this._ellipsoid = Z(e.ellipsoid, wt.WGS84)),
          (this._perPositionHeight = Z(e.perPositionHeight, !1)),
          (this._perPositionHeightExtrude = this._perPositionHeight && t(e.extrudedHeight)),
          (this._height = Z(e.height, 0)),
          (this._extrudedHeight = Z(e.extrudedHeight, this._height)),
          !this._perPositionHeightExtrude)
        ) {
          const e = Math.max(this._height, this._extrudedHeight);
          (this._extrudedHeight = Math.min(this._height, this._extrudedHeight)), (this._height = e);
        }
        (this._closeTop = Z(e.closeTop, !0)),
          (this._closeBottom = Z(e.closeBottom, !0)),
          (this._arcType = Z(e.arcType, Kh.GEODESIC)),
          (this.type = 'PolygonGeometry'),
          (this.vertices = void 0),
          (this.normals = void 0),
          (this.indices = void 0),
          (this.uvs = void 0),
          (this._referenceCenter = Z(e.referenceCenter, new Pt())),
          (this._usedDoublePrecision = !t(e.referenceCenter)),
          (this._vertexArray = this._usedDoublePrecision ? new Co() : new bo()),
          (this._indices = new ea()),
          (this._needUpdate = !0),
          (this._initialized = !1),
          (this.primitiveType = Ll.TRIANGLES);
      }
      #g() {
        let e;
        if (
          ((e = this._positionsCallBack
            ? this._positionsCallBack()
            : this._polygonHierarchy.positions),
          e.length < 3)
        )
          return;
        this._needUpdate = !0;
        const i = Ec.fromPoints(e, this._ellipsoid),
          n = Qh.polygonsFromHierarchy(
            t(this._positionsCallBack) ? { positions: e } : this._polygonHierarchy,
            i.projectPointsOntoPlane.bind(i),
            !this._perPositionHeight,
            this._ellipsoid,
          ),
          r = n.hierarchy,
          o = n.polygons;
        if (0 === r.length) return;
        e = r[0].outerRing;
        const a = Qh.computeBoundingRectangle(i.plane.normal, i.projectPointOntoPlane.bind(i), e),
          s = [],
          l = this._height,
          c = this._extrudedHeight,
          u =
            this._perPositionHeightExtrude ||
            !Me.CesiumMath.equalsEpsilon(l, c, 0, Me.CesiumMath.EPSILON2),
          h = {
            perPositionHeight: this._perPositionHeight,
            tangentPlane: i,
            boundingRectangle: a,
            ellipsoid: this._ellipsoid,
            bottom: !1,
            top: !0,
            wall: !1,
            extrude: !1,
            arcType: this._arcType,
          };
        let d;
        if (u)
          for (
            h.extrude = !0, h.top = this._closeTop, h.bottom = this._closeBottom, d = 0;
            d < o.length;
            d++
          ) {
            const e = Qh.createGeometryFromPositionsExtruded(
                this._ellipsoid,
                o[d],
                this._granularity,
                r[d],
                this._perPositionHeight,
                this._closeTop,
                this._closeBottom,
                this._arcType,
              ),
              t = e.topAndBottom;
            this._closeTop && this._closeBottom
              ? (h.geometry = Qh.scaleToGeodeticHeightExtruded(
                  t,
                  l,
                  c,
                  this._ellipsoid,
                  this._perPositionHeight,
                ))
              : this._closeTop
              ? ((t.positions = zh.scaleToGeodeticHeight(
                  t.positions,
                  l,
                  this._ellipsoid,
                  !this._perPositionHeight,
                )),
                (h.geometry = t))
              : this._closeBottom &&
                ((t.position = zh.scaleToGeodeticHeight(t.positions, c, this._ellipsoid, !0)),
                (h.geometry = t)),
              (this._closeTop || this._closeBottom) &&
                ((h.wall = !1), (t.geometry = Qh.computeAttributes(h)), s.push(t));
            const i = e.walls;
            h.wall = !0;
            for (let e = 0; e < i.length; e++)
              (h.geometry = Qh.scaleToGeodeticHeightExtruded(
                i[e],
                l,
                c,
                this._ellipsoid,
                this._perPositionHeight,
              )),
                (h.geometry = Qh.computeAttributes(h)),
                s.push(h.geometry);
          }
        else
          for (d = 0; d < o.length; d++)
            (h.geometry = Qh.createGeometryFromPositions(
              this._ellipsoid,
              o[d],
              this._granularity,
              this._perPositionHeight,
              this._arcType,
            )),
              (h.geometry = Qh.computeAttributes(h)),
              s.push(h.geometry);
        const p = Qh.combineGeometries(s);
        (this.normals = p.normals),
          (this.indices = p.indices),
          (this.uvs = p.uvs),
          this._indices.clear();
        for (let e = 0; e < this.indices.length; e += 3)
          this._indices.emplaceBack(this.indices[e], this.indices[e + 1], this.indices[e + 2]);
        this.vertices = zh.scaleToGeodeticHeight(
          p.positions,
          l,
          this._ellipsoid,
          !this._perPositionHeight,
        );
        const f = new Pt();
        for (let e = 0; e < this.vertices.length; e += 3)
          Pt.fromArray(this.vertices, e, f),
            Pt.subtract(f, this._referenceCenter, f),
            (this.vertices[e] = f.x),
            (this.vertices[e + 1] = f.y),
            (this.vertices[e + 2] = f.z);
        this.emplaceVertexBufferTriangle(),
          (this._initialized = !0),
          this.computeBoundingSphere(),
          this.computeBoundingBox();
      }
      #_() {
        let e;
        if (
          ((e = this._positionsCallBack
            ? this._positionsCallBack()
            : this._polygonHierarchy.positions),
          e.length < 3)
        )
          return;
        this._needUpdate = !0;
        const i = Ec.fromPoints(e, this._ellipsoid),
          n = Qh.polygonsFromHierarchy(
            t(this._positionsCallBack) ? { positions: e } : this._polygonHierarchy,
            i.projectPointsOntoPlane.bind(i),
            !1,
            this._ellipsoid,
          ),
          r = n.hierarchy,
          o = n.polygons;
        if (0 === r.length) return;
        e = r[0].outerRing;
        const a = Qh.computeBoundingRectangle(i.plane.normal, i.projectPointOntoPlane.bind(i), e),
          s = [],
          l = -100,
          c = {
            perPositionHeight: !0,
            tangentPlane: i,
            boundingRectangle: a,
            ellipsoid: this._ellipsoid,
            bottom: !0,
            top: !0,
            wall: !1,
            extrude: !0,
            arcType: this._arcType,
          };
        for (let e = 0; e < o.length; e++) {
          const t = Qh.createGeometryFromPositionsExtruded(
              c.ellipsoid,
              o[e],
              this._granularity,
              r[e],
              c.perPositionHeight,
              c.top,
              c.bottom,
              c.arcType,
            ),
            i = t.topAndBottom;
          (c.geometry = Qh.scaleToGeodeticHeightExtruded(
            i,
            l,
            3e3,
            c.ellipsoid,
            c.perPositionHeight,
          )),
            (c.wall = !1),
            (i.geometry = Qh.computeAttributes(c)),
            s.push(i);
          const n = t.walls;
          c.wall = !0;
          for (let e = 0; e < n.length; e++)
            (c.geometry = Qh.scaleToGeodeticHeightExtruded(
              n[e],
              l,
              3e3,
              c.ellipsoid,
              c.perPositionHeight,
            )),
              (c.geometry = Qh.computeAttributes(c)),
              s.push(c.geometry);
        }
        const u = Qh.combineGeometries(s);
        (this.normals = u.normals),
          (this.indices = u.indices),
          (this.uvs = u.uvs),
          this._indices.clear();
        for (let e = 0; e < this.indices.length; e += 3)
          this._indices.emplaceBack(this.indices[e], this.indices[e + 1], this.indices[e + 2]);
        this.vertices = zh.scaleToGeodeticHeight(u.positions, l, c.ellipsoid, !c.perPositionHeight);
        const h = new Pt();
        for (let e = 0; e < this.vertices.length; e += 3)
          Pt.fromArray(this.vertices, e, h),
            (this.vertices[e] = h.x),
            (this.vertices[e + 1] = h.y),
            (this.vertices[e + 2] = h.z);
        this.emplaceVertexBufferTriangle(),
          (this._initialized = !0),
          this.computeBoundingSphere(),
          this.computeBoundingBox();
      }
      update(e) {
        if (
          (t(this._positionsCallBack) && (e.primitive?._adaptTerrain ? this.#_() : this.#g()),
          this._initialized && this._needUpdate && e.painter)
        ) {
          const t = e.painter.context;
          this._vertBuffer && this._indexBuffer
            ? (this._vertBuffer.updateData(this._vertexArray),
              this._indexBuffer.updateData(this._indices))
            : ((this._vertBuffer = t.createVertexBuffer(
                this._vertexArray,
                this._usedDoublePrecision ? qh.members : Xh.members,
                this.dynamicDraw,
              )),
              (this._indexBuffer = t.createIndexBuffer(this._indices, this.dynamicDraw))),
            (this._segmentVector = Yh.simpleSegment(
              0,
              0,
              this.vertices.length / 3,
              this.indices.length / 3,
            )),
            (this._needUpdate = !1),
            (this._initialized = !1);
          const { primitive: i } = e;
          i.computeBounding();
        }
      }
      serialize() {
        const e = {
          type: this.type,
          polygonHierarchy: zh.hierarchyPack(this._polygonHierarchy, {}),
          perPositionHeight: this._perPositionHeight,
          arcType: this._arcType,
        };
        return (
          (this._perPositionHeightExtrude ||
            !Me.CesiumMath.equalsEpsilon(
              this._height,
              this._extrudedHeight,
              0,
              Me.CesiumMath.EPSILON2,
            )) &&
            (e.extrudedHeight = this._extrudedHeight),
          this._perPositionHeight || (e.height = this._height),
          e
        );
      }
      setAdaptTerrain(e) {
        (this._vertexArray = this._usedDoublePrecision ? new Co() : new bo()),
          (this._indices = new ea()),
          e ? this.#_() : this.#g();
      }
      destroy() {
        return (
          super.destroy(),
          (this._polygonHierarchy = void 0),
          (this._granularity = void 0),
          (this._ellipsoid = void 0),
          (this._perPositionHeight = void 0),
          (this._perPositionHeightExtrude = void 0),
          (this._height = void 0),
          (this._extrudedHeight = void 0),
          (this._closeTop = void 0),
          (this._closeBottom = void 0),
          (this._arcType = void 0),
          (this.type = void 0),
          (this._vertexArray = void 0),
          (this._indices = void 0),
          (this._initialized = void 0),
          (this._needUpdate = void 0),
          (this.primitiveType = void 0),
          (this.vertices = void 0),
          (this.normals = void 0),
          (this.indices = void 0),
          (this.uvs = void 0),
          (this.boundingBox = void 0),
          (this.boundingSphere = void 0),
          (this._vertBuffer = void 0),
          (this._indexBuffer = void 0),
          (this._segmentVector = void 0),
          Vc(this)
        );
      }
    }
    const ed = function (e, t) {
      return 256 * (e = se(Math.floor(e), 0, 255)) + se(Math.floor(t), 0, 255);
    };
    class td {
      constructor() {
        this.first = !0;
      }
      update(e, t) {
        const i = Math.floor(e);
        return this.first
          ? ((this.first = !1),
            (this.lastIntegerZoom = i),
            (this.lastIntegerZoomTime = 0),
            (this.lastZoom = e),
            (this.lastFloorZoom = i),
            !0)
          : (this.lastFloorZoom > i
              ? ((this.lastIntegerZoom = i + 1), (this.lastIntegerZoomTime = t))
              : this.lastFloorZoom < i &&
                ((this.lastIntegerZoom = i), (this.lastIntegerZoomTime = t)),
            e !== this.lastZoom && ((this.lastZoom = e), (this.lastFloorZoom = i), !0));
      }
    }
    const id = 'deferred',
      nd = 'loading',
      rd = 'loaded';
    let od = null,
      ad = 'unavailable',
      sd = null;
    const ld = function (e) {
      e && 'string' == typeof e && e.indexOf('NetworkError') > -1 && (ad = 'error'), od && od(e);
    };
    function cd() {
      ud.fire(new _a('pluginStateChange', { pluginStatus: ad, pluginURL: sd }));
    }
    const ud = new ya(),
      hd = function () {
        return ad;
      },
      dd = function () {
        if (ad !== id || !sd)
          throw new Error('rtl-text-plugin cannot be downloaded unless a pluginURL is specified');
        (ad = nd),
          cd(),
          sd &&
            fu({ url: sd }, (e) => {
              e ? ld(e) : ((ad = rd), cd());
            });
      },
      pd = {
        applyArabicShaping: null,
        processBidirectionalText: null,
        processStyledBidirectionalText: null,
        isLoaded: () => ad === rd || null != pd.applyArabicShaping,
        isLoading: () => ad === nd,
        setState(e) {
          (ad = e.pluginStatus), (sd = e.pluginURL);
        },
        isParsed: () =>
          null != pd.applyArabicShaping &&
          null != pd.processBidirectionalText &&
          null != pd.processStyledBidirectionalText,
        getPluginURL: () => sd,
      };
    class fd {
      constructor(e, t) {
        (this.zoom = e),
          t
            ? ((this.now = t.now),
              (this.fadeDuration = t.fadeDuration),
              (this.zoomHistory = t.zoomHistory),
              (this.transition = t.transition))
            : ((this.now = 0),
              (this.fadeDuration = 0),
              (this.zoomHistory = new td()),
              (this.transition = {}));
      }
      isSupportedScript(e) {
        return (function (e, t) {
          for (const i of e) if (!Fi(i.charCodeAt(0), t)) return !1;
          return !0;
        })(e, pd.isLoaded());
      }
      crossFadingFactor() {
        return 0 === this.fadeDuration
          ? 1
          : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
      }
      getCrossfadeParameters() {
        const e = this.zoom,
          t = e - Math.floor(e),
          i = this.crossFadingFactor();
        return e > this.zoomHistory.lastIntegerZoom
          ? { fromScale: 2, toScale: 1, t: t + (1 - t) * i }
          : { fromScale: 0.5, toScale: 1, t: 1 - (1 - i) * t };
      }
    }
    function md(e, t, i) {
      const n = _d(256 * e, 256 * (t = Math.pow(2, i) - t - 1), i),
        r = _d(256 * (e + 1), 256 * (t + 1), i);
      return `${n[0]},${n[1]},${r[0]},${r[1]}`;
    }
    function _d(e, t, i) {
      const n = (2 * Math.PI * 6378137) / 256 / Math.pow(2, i);
      return [e * n - (2 * Math.PI * 6378137) / 2, t * n - (2 * Math.PI * 6378137) / 2];
    }
    const gd = 2 * Math.PI * Rt;
    function yd(e) {
      return gd * Math.cos((e * Math.PI) / 180);
    }
    function xd(e) {
      return (360 / Math.PI) * Math.atan(Math.exp(((180 - 360 * e) * Math.PI) / 180)) - 90;
    }
    class vd {
      constructor(e, t, i = 0) {
        (this.x = +e), (this.y = +t), (this.z = +i);
      }
      static fromLngLat(e, t = 0) {
        const i = Nt.convert(e);
        return new vd(
          (180 + i.lng) / 360,
          (180 - (180 / Math.PI) * Math.log(Math.tan(Math.PI / 4 + (i.lat * Math.PI) / 360))) / 360,
          (function (e, t) {
            return e / yd(t);
          })(t, i.lat),
        );
      }
      toLngLat() {
        return new Nt(360 * this.x - 180, xd(this.y));
      }
      toAltitude() {
        return this.z * yd(xd(this.y));
      }
      meterInMercatorCoordinateUnits() {
        return (1 / gd) * ((e = xd(this.y)), 1 / Math.cos((e * Math.PI) / 180));
        var e;
      }
    }
    class wd {
      constructor(e, t, i, n) {
        (this.z = e), (this.x = t), (this.y = i), (this.key = Sd(0, e, t, i));
      }
      equals(e) {
        return this.z === e.z && this.x === e.x && this.y === e.y;
      }
      containsOrContained(e) {
        const t = this.z - e.z;
        if (0 == t) {
          if (this.z === e.z && this.x === e.x && this.y === e.y) return !0;
        } else if (t > 0) {
          if (this.x >> t === e.x && this.y >> t === e.y) return !0;
        } else if (this.x === e.x >> t && this.y === e.y >> t) return !0;
        return !1;
      }
      url(e) {
        const t = md(this.x, this.y, this.z),
          i = Ad(this.z, this.x, this.y),
          n = this.x,
          r = this.y;
        return e[(this.x + this.y) % e.length]
          .replace('{prefix}', (this.x % 16).toString(16) + (this.y % 16).toString(16))
          .replace(/\{z\}/g, String(this.z))
          .replace(/\{x\}/g, String(n))
          .replace(/\{y\}/g, String(r))
          .replace(/\{m\}/g, String(Math.floor(this.x / 16)))
          .replace(/\{n\}/g, String(Math.floor(r / 16)))
          .replace('{quadkey}', i)
          .replace('{bbox-epsg-3857}', t)
          .replace(/\{c\}/g, this._getC())
          .replace(/\{r\}/g, this._getR());
      }
      wmtsUrl(e, t) {
        let i = e[(this.x + this.y) % e.length]
          .replace(/\{TileMatrixSet\}/g, t.matrixSet)
          .replace(/\{TileMatrix\}/g, String(this.z))
          .replace(/\{TileCol\}/g, String(this.x))
          .replace(/\{TileRow\}/g, String(this.y));
        return (
          t.dimensions &&
            t.dimensions.forEach((e, t) => {
              i = i.replace(new RegExp(`{${t}}`), String(e));
            }),
          i
        );
      }
      tmsUrl(e) {
        const t = md(this.x, this.y, this.z),
          i = Ad(this.z, this.x, this.y),
          n = this.x,
          r = Math.pow(2, this.z) - this.y - 1;
        return e[(this.x + this.y) % e.length]
          .replace('{prefix}', (this.x % 16).toString(16) + (this.y % 16).toString(16))
          .replace(/\{z\}/g, String(this.z))
          .replace(/\{x\}/g, String(n))
          .replace(/\{y\}/g, String(r))
          .replace(/\{m\}/g, String(Math.floor(this.x / 16)))
          .replace(/\{n\}/g, String(Math.floor(r / 16)))
          .replace('{quadkey}', i)
          .replace('{bbox-epsg-3857}', t)
          .replace(/\{c\}/g, this._getC())
          .replace(/\{r\}/g, this._getR());
      }
      baiduUrl(e) {
        const t = this.x - Math.pow(2, this.z) / 2,
          i = Math.pow(2, this.z) / 2 - this.y - 1;
        return e[(this.x + this.y) % e.length]
          .replace('{prefix}', (this.x % 16).toString(16) + (this.y % 16).toString(16))
          .replace(/\{z\}/g, String(this.z))
          .replace(/\{x\}/g, String(t))
          .replace(/\{y\}/g, String(i));
      }
      _getC() {
        return this.z > 6 ? `C${Math.floor(Math.floor(this.x / (1 << (this.z - 5))))}` : 'C0';
      }
      _getR() {
        return this.z > 6 ? `R${Math.floor(Math.floor(this.y / (1 << (this.z - 5))))}` : 'R0';
      }
      toRealCoord(e) {
        const t = 'tms' === e ? Math.pow(2, this.z) - this.y - 1 : this.y;
        return { x: this.x, y: t, z: this.z };
      }
      getTilePoint(e) {
        return new te((e.x - this.x) * Wu, (e.y - this.y) * Wu);
      }
    }
    class Td {
      constructor(e, t) {
        (this.wrap = e), (this.canonical = t), (this.key = Sd(0, t.z, t.x, t.y));
      }
    }
    class bd {
      constructor(e, t, i, n, r, o) {
        (this.projection = o),
          (this.overscaledZ = e),
          (this.wrap = t),
          (this.canonical = new wd(i, +n, +r, this.projection)),
          (this.key = Sd(0, e, n, r));
      }
      equals(e) {
        return (
          this.overscaledZ === e.overscaledZ &&
          this.wrap === e.wrap &&
          this.canonical.equals(e.canonical)
        );
      }
      static getParentTileId(e) {
        return new bd(
          e.overscaledZ - 1,
          0,
          e.canonical.z - 1,
          Math.floor(e.canonical.x / 2),
          Math.floor(e.canonical.y / 2),
          e.projection,
        );
      }
      scaledTo(e) {
        const t = this.canonical.z - e;
        return e > this.canonical.z
          ? new bd(
              e,
              this.wrap,
              this.canonical.z,
              this.canonical.x,
              this.canonical.y,
              this.projection,
            )
          : new bd(e, this.wrap, e, this.canonical.x >> t, this.canonical.y >> t, this.projection);
      }
      isChildOf(e) {
        const t = this.canonical.z - e.canonical.z;
        return (
          0 === e.overscaledZ ||
          (e.overscaledZ < this.overscaledZ &&
            e.canonical.x === this.canonical.x >> t &&
            e.canonical.y === this.canonical.y >> t)
        );
      }
      children(e) {
        if (this.overscaledZ >= e)
          return [
            new bd(
              this.overscaledZ + 1,
              this.wrap,
              this.canonical.z,
              this.canonical.x,
              this.canonical.y,
              this.projection,
            ),
          ];
        const t = this.canonical.z + 1,
          i = 2 * this.canonical.x,
          n = 2 * this.canonical.y;
        return [
          new bd(t, this.wrap, t, i, n, this.projection),
          new bd(t, this.wrap, t, i + 1, n, this.projection),
          new bd(t, this.wrap, t, i, n + 1, this.projection),
          new bd(t, this.wrap, t, i + 1, n + 1, this.projection),
        ];
      }
      isLessThan(e) {
        return (
          'string' != typeof e &&
          (this.wrap < e.wrap ||
            (!(this.wrap > e.wrap) &&
              (this.overscaledZ < e.overscaledZ ||
                (!(this.overscaledZ > e.overscaledZ) &&
                  (this.canonical.x < e.canonical.x ||
                    (!(this.canonical.x > e.canonical.x) && this.canonical.y < e.canonical.y))))))
        );
      }
      wrapped() {
        return new bd(
          this.overscaledZ,
          0,
          this.canonical.z,
          this.canonical.x,
          this.canonical.y,
          this.projection,
        );
      }
      unwrapTo(e) {
        return new bd(
          this.overscaledZ,
          e,
          this.canonical.z,
          this.canonical.x,
          this.canonical.y,
          this.projection,
        );
      }
      overscaleFactor() {
        return Math.pow(2, this.overscaledZ - this.canonical.z);
      }
      toUnwrapped() {
        return new Td(this.wrap, this.canonical);
      }
      toString() {
        return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
      }
      toCoordinate() {
        return new ee(
          this.canonical.x + Math.pow(2, this.wrap),
          this.canonical.y,
          this.canonical.z,
        );
      }
      getTilePoint(e) {
        return this.canonical.getTilePoint(new vd(e.x - this.wrap, e.y));
      }
    }
    function Sd(e, t, i, n) {
      return `${t}_${i}_${n}`;
    }
    function Ad(e, t, i) {
      let n,
        r = '';
      for (let o = e; o > 0; o--) (n = 1 << (o - 1)), (r += (t & n ? 1 : 0) + (i & n ? 2 : 0));
      return r;
    }
    fo('CanonicalTileID', wd), fo('OverscaledTileID', bd, { omit: ['posMatrix'] });
    class Pd {
      constructor(e, t) {
        (this.property = e),
          (this.value = t),
          (this.expression = lo(void 0 === t ? e.specification.default : t, e.specification));
      }
      isDataDriven() {
        return 'source' === this.expression.kind || 'composite' === this.expression.kind;
      }
      possiblyEvaluate(e, t, i) {
        return this.property.possiblyEvaluate(this, e, t, i);
      }
    }
    class Ed {
      constructor(e) {
        (this.property = e), (this.value = new Pd(e, void 0));
      }
      transitioned(e, t) {
        return new Md(this.property, this.value, t, ce({}, e.transition, this.transition), e.now);
      }
      untransitioned() {
        return new Md(this.property, this.value, null, {}, 0);
      }
    }
    class Cd {
      constructor(e) {
        (this._properties = e),
          (this._values = Object.create(e.defaultTransitionablePropertyValues));
      }
      getValue(e) {
        return ye(this._values[e].value.value);
      }
      setValue(e, t) {
        this._values.hasOwnProperty(e) || (this._values[e] = new Ed(this._values[e].property)),
          (this._values[e].value = new Pd(this._values[e].property, null === t ? void 0 : ye(t)));
      }
      getTransition(e) {
        return ye(this._values[e].transition);
      }
      setTransition(e, t) {
        this._values.hasOwnProperty(e) || (this._values[e] = new Ed(this._values[e].property)),
          (this._values[e].transition = ye(t) || void 0);
      }
      serialize() {
        const e = {};
        for (const t of Object.keys(this._values)) {
          const i = this.getValue(t);
          void 0 !== i && (e[t] = i);
          const n = this.getTransition(t);
          void 0 !== n && (e[`${t}-transition`] = n);
        }
        return e;
      }
      transitioned(e, t) {
        const i = new Id(this._properties);
        for (const n of Object.keys(this._values))
          i._values[n] = this._values[n].transitioned(e, t._values[n]);
        return i;
      }
      untransitioned() {
        const e = new Id(this._properties);
        for (const t of Object.keys(this._values)) e._values[t] = this._values[t].untransitioned();
        return e;
      }
    }
    class Md {
      constructor(e, t, i, n, r) {
        (this.property = e),
          (this.value = t),
          (this.begin = r + n.delay || 0),
          (this.end = this.begin + n.duration || 0),
          e.specification.transition && (n.delay || n.duration) && (this.prior = i);
      }
      possiblyEvaluate(e, t, i) {
        const n = e.now || 0,
          r = this.value.possiblyEvaluate(e, t, i),
          o = this.prior;
        if (o) {
          if (n > this.end) return (this.prior = null), r;
          if (this.value.isDataDriven()) return (this.prior = null), r;
          if (n < this.begin) return o.possiblyEvaluate(e, t, i);
          {
            const a = (n - this.begin) / (this.end - this.begin);
            return this.property.interpolate(o.possiblyEvaluate(e, t, i), r, re(a));
          }
        }
        return r;
      }
    }
    class Id {
      constructor(e) {
        (this._properties = e),
          (this._values = Object.create(e.defaultTransitioningPropertyValues));
      }
      possiblyEvaluate(e, t, i) {
        const n = new Nd(this._properties);
        for (const r of Object.keys(this._values))
          n._values[r] = this._values[r].possiblyEvaluate(e, t, i);
        return n;
      }
      hasTransition() {
        for (const e of Object.keys(this._values)) if (this._values[e].prior) return !0;
        return !1;
      }
    }
    class Ld {
      constructor(e) {
        (this._properties = e), (this._values = Object.create(e.defaultPropertyValues));
      }
      getValue(e) {
        return ye(this._values[e].value);
      }
      setValue(e, t) {
        this._values[e] = new Pd(this._values[e].property, null === t ? void 0 : ye(t));
      }
      serialize() {
        const e = {};
        for (const t of Object.keys(this._values)) {
          const i = this.getValue(t);
          void 0 !== i && (e[t] = i);
        }
        return e;
      }
      possiblyEvaluate(e, t, i) {
        const n = new Nd(this._properties);
        for (const r of Object.keys(this._values))
          n._values[r] = this._values[r].possiblyEvaluate(e, t, i);
        return n;
      }
    }
    class Rd {
      constructor(e, t, i) {
        (this.property = e), (this.value = t), (this.parameters = i);
      }
      isConstant() {
        return 'constant' === this.value.kind;
      }
      constantOr(e) {
        return 'constant' === this.value.kind ? this.value.value : e;
      }
      evaluate(e, t, i, n) {
        return this.property.evaluate(this.value, this.parameters, e, t, i, n);
      }
    }
    class Nd {
      constructor(e) {
        (this._properties = e), (this._values = Object.create(e.defaultPossiblyEvaluatedValues));
      }
      get(e) {
        return this._values[e];
      }
    }
    class Od {
      constructor(e) {
        this.specification = e;
      }
      possiblyEvaluate(e, t) {
        return e.expression.evaluate(t);
      }
      interpolate(e, t, i) {
        const n = Bn[this.specification.type];
        return n ? n(e, t, i) : e;
      }
    }
    class Dd {
      constructor(e, t) {
        (this.specification = e), (this.overrides = t);
      }
      possiblyEvaluate(e, t, i, n) {
        return new Rd(
          this,
          'constant' === e.expression.kind || 'camera' === e.expression.kind
            ? { kind: 'constant', value: e.expression.evaluate(t, null, {}, i, n) }
            : e.expression,
          t,
        );
      }
      interpolate(e, t, i) {
        if ('constant' !== e.value.kind || 'constant' !== t.value.kind) return e;
        if (void 0 === e.value.value || void 0 === t.value.value)
          return new Rd(this, { kind: 'constant', value: void 0 }, e.parameters);
        const n = Bn[this.specification.type];
        return n
          ? new Rd(
              this,
              { kind: 'constant', value: n(e.value.value, t.value.value, i) },
              e.parameters,
            )
          : e;
      }
      evaluate(e, t, i, n, r, o) {
        return 'constant' === e.kind ? e.value : e.evaluate(t, i, n, r, o);
      }
    }
    class Fd extends Dd {
      possiblyEvaluate(e, t, i, n) {
        if (void 0 === e.value) return new Rd(this, { kind: 'constant', value: void 0 }, t);
        if ('constant' === e.expression.kind) {
          const r = e.expression.evaluate(t, null, {}, i, n),
            o =
              'resolvedImage' === e.property.specification.type && 'string' != typeof r
                ? r.name
                : r,
            a = this._calculate(o, o, o, t);
          return new Rd(this, { kind: 'constant', value: a }, t);
        }
        if ('camera' === e.expression.kind) {
          const i = this._calculate(
            e.expression.evaluate({ zoom: t.zoom - 1 }),
            e.expression.evaluate({ zoom: t.zoom }),
            e.expression.evaluate({ zoom: t.zoom + 1 }),
            t,
          );
          return new Rd(this, { kind: 'constant', value: i }, t);
        }
        return new Rd(this, e.expression, t);
      }
      evaluate(e, t, i, n, r, o) {
        if ('source' === e.kind) {
          const a = e.evaluate(t, i, n, r, o);
          return this._calculate(a, a, a, t);
        }
        return 'composite' === e.kind
          ? this._calculate(
              e.evaluate({ zoom: Math.floor(t.zoom) - 1 }, i, n),
              e.evaluate({ zoom: Math.floor(t.zoom) }, i, n),
              e.evaluate({ zoom: Math.floor(t.zoom) + 1 }, i, n),
              t,
            )
          : e.value;
      }
      _calculate(e, t, i, n) {
        return n.zoom > n.zoomHistory.lastIntegerZoom ? { from: e, to: t } : { from: i, to: t };
      }
      interpolate(e) {
        return e;
      }
    }
    class zd {
      constructor(e) {
        this.specification = e;
      }
      possiblyEvaluate(e, t, i, n) {
        if (void 0 !== e.value) {
          if ('constant' === e.expression.kind) {
            const r = e.expression.evaluate(t, null, {}, i, n);
            return this._calculate(r, r, r, t);
          }
          return this._calculate(
            e.expression.evaluate(new fd(Math.floor(t.zoom - 1), t)),
            e.expression.evaluate(new fd(Math.floor(t.zoom), t)),
            e.expression.evaluate(new fd(Math.floor(t.zoom + 1), t)),
            t,
          );
        }
      }
      _calculate(e, t, i, n) {
        return n.zoom > n.zoomHistory.lastIntegerZoom ? { from: e, to: t } : { from: i, to: t };
      }
      interpolate(e) {
        return e;
      }
    }
    class Bd {
      constructor(e) {
        this.specification = e;
      }
      possiblyEvaluate(e, t, i, n) {
        return !!e.expression.evaluate(t, null, {}, i, n);
      }
      interpolate() {
        return !1;
      }
    }
    class Vd {
      constructor(e) {
        (this.properties = e),
          (this.defaultPropertyValues = {}),
          (this.defaultTransitionablePropertyValues = {}),
          (this.defaultTransitioningPropertyValues = {}),
          (this.defaultPossiblyEvaluatedValues = {}),
          (this.overridableProperties = []);
        for (const t in e) {
          const i = e[t];
          i.specification.overridable && this.overridableProperties.push(t);
          const n = (this.defaultPropertyValues[t] = new Pd(i, void 0)),
            r = (this.defaultTransitionablePropertyValues[t] = new Ed(i));
          (this.defaultTransitioningPropertyValues[t] = r.untransitioned()),
            (this.defaultPossiblyEvaluatedValues[t] = n.possiblyEvaluate({}));
        }
      }
    }
    fo('DataDrivenProperty', Dd),
      fo('DataConstantProperty', Od),
      fo('CrossFadedDataDrivenProperty', Fd),
      fo('CrossFadedProperty', zd),
      fo('ColorRampProperty', Bd);
    const Ud = Gt([
      { name: 'a_pattern_from', components: 4, type: 'Uint16' },
      { name: 'a_pattern_to', components: 4, type: 'Uint16' },
      { name: 'a_pixel_ratio_from', components: 1, type: 'Uint16' },
      { name: 'a_pixel_ratio_to', components: 1, type: 'Uint16' },
    ]);
    class kd {
      constructor(e, t) {
        (this.gl = e.gl), (this.location = t);
      }
    }
    class Gd extends kd {
      constructor(e, t) {
        super(e, t), (this.current = 0);
      }
      set(e) {
        this.current !== e && ((this.current = e), this.gl.uniform1f(this.location, e));
      }
    }
    class Hd extends kd {
      constructor(e, t) {
        super(e, t), (this.current = [0, 0]);
      }
      set(e) {
        (e[0] === this.current[0] && e[1] === this.current[1]) ||
          ((this.current = e), this.gl.uniform2f(this.location, e[0], e[1]));
      }
    }
    class Yd extends kd {
      constructor(e, t) {
        super(e, t), (this.current = [0, 0, 0]);
      }
      set(e) {
        (e[0] === this.current[0] && e[1] === this.current[1] && e[2] === this.current[2]) ||
          ((this.current = e), this.gl.uniform3f(this.location, e[0], e[1], e[2]));
      }
    }
    class qd extends kd {
      constructor(e, t) {
        super(e, t), (this.current = [0, 0, 0, 0]);
      }
      set(e) {
        (e[0] === this.current[0] &&
          e[1] === this.current[1] &&
          e[2] === this.current[2] &&
          e[3] === this.current[3]) ||
          ((this.current = e), this.gl.uniform4f(this.location, e[0], e[1], e[2], e[3]));
      }
    }
    class Xd extends kd {
      constructor(e, t) {
        super(e, t), (this.current = ai.transparent);
      }
      set(e) {
        (e.r === this.current.r &&
          e.g === this.current.g &&
          e.b === this.current.b &&
          e.a === this.current.a) ||
          ((this.current = e), this.gl.uniform4f(this.location, e.r, e.g, e.b, e.a));
      }
    }
    var jd = Ju(function (e) {
        e.exports = function (e, t) {
          var i, n, r, o, a, s, l, c;
          for (
            n = e.length - (i = 3 & e.length), r = t, a = 3432918353, s = 461845907, c = 0;
            c < n;

          )
            (l =
              (255 & e.charCodeAt(c)) |
              ((255 & e.charCodeAt(++c)) << 8) |
              ((255 & e.charCodeAt(++c)) << 16) |
              ((255 & e.charCodeAt(++c)) << 24)),
              ++c,
              (r =
                27492 +
                (65535 &
                  (o =
                    (5 *
                      (65535 &
                        (r =
                          ((r ^= l =
                            ((65535 &
                              (l =
                                ((l =
                                  ((65535 & l) * a + ((((l >>> 16) * a) & 65535) << 16)) &
                                  4294967295) <<
                                  15) |
                                (l >>> 17))) *
                              s +
                              ((((l >>> 16) * s) & 65535) << 16)) &
                            4294967295) <<
                            13) |
                          (r >>> 19))) +
                      (((5 * (r >>> 16)) & 65535) << 16)) &
                    4294967295)) +
                (((58964 + (o >>> 16)) & 65535) << 16));
          switch (((l = 0), i)) {
            case 3:
              l ^= (255 & e.charCodeAt(c + 2)) << 16;
            case 2:
              l ^= (255 & e.charCodeAt(c + 1)) << 8;
            case 1:
              r ^= l =
                ((65535 &
                  (l =
                    ((l =
                      ((65535 & (l ^= 255 & e.charCodeAt(c))) * a +
                        ((((l >>> 16) * a) & 65535) << 16)) &
                      4294967295) <<
                      15) |
                    (l >>> 17))) *
                  s +
                  ((((l >>> 16) * s) & 65535) << 16)) &
                4294967295;
          }
          return (
            (r ^= e.length),
            (r =
              (2246822507 * (65535 & (r ^= r >>> 16)) +
                (((2246822507 * (r >>> 16)) & 65535) << 16)) &
              4294967295),
            (r =
              (3266489909 * (65535 & (r ^= r >>> 13)) +
                (((3266489909 * (r >>> 16)) & 65535) << 16)) &
              4294967295),
            (r ^= r >>> 16) >>> 0
          );
        };
      }),
      Wd = Ju(function (e) {
        e.exports = function (e, t) {
          for (var i, n = e.length, r = t ^ n, o = 0; n >= 4; )
            (i =
              1540483477 *
                (65535 &
                  (i =
                    (255 & e.charCodeAt(o)) |
                    ((255 & e.charCodeAt(++o)) << 8) |
                    ((255 & e.charCodeAt(++o)) << 16) |
                    ((255 & e.charCodeAt(++o)) << 24))) +
              (((1540483477 * (i >>> 16)) & 65535) << 16)),
              (r =
                (1540483477 * (65535 & r) + (((1540483477 * (r >>> 16)) & 65535) << 16)) ^
                (i =
                  1540483477 * (65535 & (i ^= i >>> 24)) +
                  (((1540483477 * (i >>> 16)) & 65535) << 16))),
              (n -= 4),
              ++o;
          switch (n) {
            case 3:
              r ^= (255 & e.charCodeAt(o + 2)) << 16;
            case 2:
              r ^= (255 & e.charCodeAt(o + 1)) << 8;
            case 1:
              r =
                1540483477 * (65535 & (r ^= 255 & e.charCodeAt(o))) +
                (((1540483477 * (r >>> 16)) & 65535) << 16);
          }
          return (
            (r =
              1540483477 * (65535 & (r ^= r >>> 13)) + (((1540483477 * (r >>> 16)) & 65535) << 16)),
            (r ^= r >>> 15) >>> 0
          );
        };
      }),
      $d = jd,
      Zd = Wd;
    ($d.murmur3 = jd), ($d.murmur2 = Zd);
    class Kd {
      constructor() {
        (this.ids = []), (this.positions = []), (this.indexed = !1);
      }
      add(e, t, i, n) {
        this.ids.push(Jd(e)), this.positions.push(t, i, n);
      }
      getPositions(e) {
        const t = Jd(e);
        let i = 0,
          n = this.ids.length - 1;
        for (; i < n; ) {
          const e = (i + n) >> 1;
          this.ids[e] >= t ? (n = e) : (i = e + 1);
        }
        const r = [];
        for (; this.ids[i] === t; )
          r.push({
            index: this.positions[3 * i],
            start: this.positions[3 * i + 1],
            end: this.positions[3 * i + 2],
          }),
            i++;
        return r;
      }
      static serialize(e, t) {
        const i = new Float64Array(e.ids),
          n = new Uint32Array(e.positions);
        return ep(i, n, 0, i.length - 1), t && t.push(i.buffer, n.buffer), { ids: i, positions: n };
      }
      static deserialize(e) {
        const t = new Kd();
        return (t.ids = e.ids), (t.positions = e.positions), (t.indexed = !0), t;
      }
    }
    const Qd = Math.pow(2, 53) - 1;
    function Jd(e) {
      const t = +e;
      return !isNaN(t) && t <= Qd ? t : $d(String(e));
    }
    function ep(e, t, i, n) {
      for (; i < n; ) {
        const r = e[(i + n) >> 1];
        let o = i - 1,
          a = n + 1;
        for (;;) {
          do {
            o++;
          } while (e[o] < r);
          do {
            a--;
          } while (e[a] > r);
          if (o >= a) break;
          tp(e, o, a),
            tp(t, 3 * o, 3 * a),
            tp(t, 3 * o + 1, 3 * a + 1),
            tp(t, 3 * o + 2, 3 * a + 2);
        }
        a - i < n - a ? (ep(e, t, i, a), (i = a + 1)) : (ep(e, t, a + 1, n), (n = a));
      }
    }
    function tp(e, t, i) {
      const n = e[t];
      (e[t] = e[i]), (e[i] = n);
    }
    function ip(e) {
      return [ed(255 * e.r, 255 * e.g), ed(255 * e.b, 255 * e.a)];
    }
    fo('FeaturePositionMap', Kd);
    class np {
      constructor(e, t, i) {
        (this.value = e), (this.uniformNames = t.map((e) => `u_${e}`)), (this.type = i);
      }
      setUniform(e, t, i, n) {
        let r = i.constantOr(this.value);
        'u_translate_anchor' === n && (r = 'map' === r ? 0 : 1), e.set(r);
      }
      getBinding(e, t, i) {
        switch (this.type) {
          case 'color':
            return new Xd(e, t);
          case 'array':
            switch (this.value.length) {
              case 1:
                return new Gd(e, t);
              case 2:
                return new Hd(e, t);
              case 3:
                return new Yd(e, t);
              default:
                return new qd(e, t);
            }
          default:
            return new Gd(e, t);
        }
      }
    }
    class rp {
      constructor(e, t) {
        (this.uniformNames = t.map((e) => `u_${e}`)),
          (this.patternFrom = null),
          (this.patternTo = null),
          (this.pixelRatioFrom = 1),
          (this.pixelRatioTo = 1);
      }
      setConstantPatternPositions(e, t) {
        (this.pixelRatioFrom = t.pixelRatio),
          (this.pixelRatioTo = e.pixelRatio),
          (this.patternFrom = t.tlbr),
          (this.patternTo = e.tlbr);
      }
      setUniform(e, t, i, n) {
        const r =
          'u_pattern_to' === n
            ? this.patternTo
            : 'u_pattern_from' === n
            ? this.patternFrom
            : 'u_pixel_ratio_to' === n
            ? this.pixelRatioTo
            : 'u_pixel_ratio_from' === n
            ? this.pixelRatioFrom
            : null;
        r && e.set(r);
      }
      getBinding(e, t, i) {
        return 'u_pattern' === i.substr(0, 9) ? new qd(e, t) : new Gd(e, t);
      }
    }
    class op {
      constructor(e, t, i, n) {
        (this.expression = e),
          (this.type = i),
          (this.maxValue = 0),
          (this.paintVertexAttributes = t.map((e) => ({
            name: `a_${e}`,
            type: 'Float32',
            components: 'color' === i ? 2 : 1,
            offset: 0,
          }))),
          (this.paintVertexArray = new n());
      }
      populatePaintArray(e, t, i, n, r) {
        const o = this.paintVertexArray.length,
          a = this.expression.evaluate(new fd(0), t, {}, n, [], r);
        this.paintVertexArray.resize(e), this._setPaintValue(o, e, a);
      }
      updatePaintArray(e, t, i, n) {
        const r = this.expression.evaluate({ zoom: 0 }, i, n);
        this._setPaintValue(e, t, r);
      }
      _setPaintValue(e, t, i) {
        if ('color' === this.type) {
          const n = ip(i);
          for (let i = e; i < t; i++) this.paintVertexArray.emplace(i, n[0], n[1]);
        } else {
          for (let n = e; n < t; n++) this.paintVertexArray.emplace(n, i);
          this.maxValue = Math.max(this.maxValue, Math.abs(i));
        }
      }
      upload(e) {
        this.paintVertexArray &&
          this.paintVertexArray.arrayBuffer &&
          (this.paintVertexBuffer && this.paintVertexBuffer.buffers
            ? this.paintVertexBuffer.updateData(this.paintVertexArray)
            : (this.paintVertexBuffer = e.createVertexBuffer(
                this.paintVertexArray,
                this.paintVertexAttributes,
                this.expression.isStateDependent,
              )));
      }
      destroy() {
        this.paintVertexBuffer && this.paintVertexBuffer.destroy();
      }
    }
    class ap {
      constructor(e, t, i, n, r, o) {
        (this.expression = e),
          (this.uniformNames = t.map((e) => `u_${e}_t`)),
          (this.type = i),
          (this.useIntegerZoom = n),
          (this.zoom = r),
          (this.maxValue = 0),
          (this.paintVertexAttributes = t.map((e) => ({
            name: `a_${e}`,
            type: 'Float32',
            components: 'color' === i ? 4 : 2,
            offset: 0,
          }))),
          (this.paintVertexArray = new o());
      }
      populatePaintArray(e, t, i, n, r) {
        const o = this.expression.evaluate(new fd(this.zoom), t, {}, n, [], r),
          a = this.expression.evaluate(new fd(this.zoom + 1), t, {}, n, [], r),
          s = this.paintVertexArray.length;
        this.paintVertexArray.resize(e), this._setPaintValue(s, e, o, a);
      }
      updatePaintArray(e, t, i, n) {
        const r = this.expression.evaluate({ zoom: this.zoom }, i, n),
          o = this.expression.evaluate({ zoom: this.zoom + 1 }, i, n);
        this._setPaintValue(e, t, r, o);
      }
      _setPaintValue(e, t, i, n) {
        if ('color' === this.type) {
          const r = ip(i),
            o = ip(n);
          for (let i = e; i < t; i++) this.paintVertexArray.emplace(i, r[0], r[1], o[0], o[1]);
        } else {
          for (let r = e; r < t; r++) this.paintVertexArray.emplace(r, i, n);
          this.maxValue = Math.max(this.maxValue, Math.abs(i), Math.abs(n));
        }
      }
      upload(e) {
        this.paintVertexArray &&
          this.paintVertexArray.arrayBuffer &&
          (this.paintVertexBuffer && this.paintVertexBuffer.buffers
            ? this.paintVertexBuffer.updateData(this.paintVertexArray)
            : (this.paintVertexBuffer = e.createVertexBuffer(
                this.paintVertexArray,
                this.paintVertexAttributes,
                this.expression.isStateDependent,
              )));
      }
      destroy() {
        this.paintVertexBuffer && this.paintVertexBuffer.destroy();
      }
      setUniform(e, t) {
        const i = this.useIntegerZoom ? Math.floor(t.zoom) : t.zoom,
          n = se(this.expression.interpolationFactor(i, this.zoom, this.zoom + 1), 0, 1);
        e.set(n);
      }
      getBinding(e, t, i) {
        return new Gd(e, t);
      }
    }
    class sp {
      constructor(e, t, i, n, r, o) {
        (this.expression = e),
          (this.type = t),
          (this.useIntegerZoom = i),
          (this.zoom = n),
          (this.layerId = o),
          (this.zoomInPaintVertexArray = new r()),
          (this.zoomOutPaintVertexArray = new r());
      }
      populatePaintArray(e, t, i) {
        const n = this.zoomInPaintVertexArray.length;
        this.zoomInPaintVertexArray.resize(e),
          this.zoomOutPaintVertexArray.resize(e),
          this._setPaintValues(n, e, t.patterns && t.patterns[this.layerId], i);
      }
      updatePaintArray(e, t, i, n, r) {
        this._setPaintValues(e, t, i.patterns && i.patterns[this.layerId], r);
      }
      _setPaintValues(e, t, i, n) {
        if (!n || !i) return;
        const { min: r, mid: o, max: a } = i,
          s = n[r],
          l = n[o],
          c = n[a];
        if (s && l && c)
          for (let i = e; i < t; i++)
            this.zoomInPaintVertexArray.emplace(
              i,
              l.tl[0],
              l.tl[1],
              l.br[0],
              l.br[1],
              s.tl[0],
              s.tl[1],
              s.br[0],
              s.br[1],
              l.pixelRatio,
              s.pixelRatio,
            ),
              this.zoomOutPaintVertexArray.emplace(
                i,
                l.tl[0],
                l.tl[1],
                l.br[0],
                l.br[1],
                c.tl[0],
                c.tl[1],
                c.br[0],
                c.br[1],
                l.pixelRatio,
                c.pixelRatio,
              );
      }
      upload(e) {
        this.zoomInPaintVertexArray &&
          this.zoomInPaintVertexArray.arrayBuffer &&
          this.zoomOutPaintVertexArray &&
          this.zoomOutPaintVertexArray.arrayBuffer &&
          ((this.zoomInPaintVertexBuffer = e.createVertexBuffer(
            this.zoomInPaintVertexArray,
            Ud.members,
            this.expression.isStateDependent,
          )),
          (this.zoomOutPaintVertexBuffer = e.createVertexBuffer(
            this.zoomOutPaintVertexArray,
            Ud.members,
            this.expression.isStateDependent,
          )));
      }
      destroy() {
        this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(),
          this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
      }
    }
    class lp {
      constructor(e, t, i) {
        (this.binders = {}), (this._buffers = []);
        const n = [];
        if (e)
          for (const r in e.paint._values) {
            if (!i(r)) continue;
            const o = e.paint.get(r);
            if (!(o instanceof Rd && Pr(o.property.specification))) continue;
            const a = up(r, e.type),
              s = o.value,
              l = o.property.specification.type,
              c = o.property.useIntegerZoom,
              u = o.property.specification['property-type'],
              h = 'cross-faded' === u || 'cross-faded-data-driven' === u;
            if ('constant' === s.kind)
              (this.binders[r] = h ? new rp(s.value, a) : new np(s.value, a, l)), n.push(`/u_${r}`);
            else if ('source' === s.kind || h) {
              const i = hp(r, l, 'source');
              (this.binders[r] = h ? new sp(s, l, c, t, i, e.id) : new op(s, a, l, i)),
                n.push(`/a_${r}`);
            } else {
              const e = hp(r, l, 'composite');
              (this.binders[r] = new ap(s, a, l, c, t, e)), n.push(`/z_${r}`);
            }
          }
        this.cacheKey = n.sort().join('');
      }
      getMaxValue(e) {
        const t = this.binders[e];
        return t instanceof op || t instanceof ap ? t.maxValue : 0;
      }
      populatePaintArrays(e, t, i, n, r) {
        for (const o in this.binders) {
          const a = this.binders[o];
          (a instanceof op || a instanceof ap || a instanceof sp) &&
            a.populatePaintArray(e, t, i, n, r);
        }
      }
      setConstantPatternPositions(e, t) {
        for (const i in this.binders) {
          const n = this.binders[i];
          n instanceof rp && n.setConstantPatternPositions(e, t);
        }
      }
      updatePaintArrays(e, t, i, n, r) {
        let o = !1;
        for (const a in e) {
          const s = t.getPositions(a);
          for (const t of s) {
            const s = i.feature(t.index);
            for (const i in this.binders) {
              const l = this.binders[i];
              if (
                (l instanceof op || l instanceof ap || l instanceof sp) &&
                !0 === l.expression.isStateDependent
              ) {
                const c = n.paint.get(i);
                (l.expression = c.value), l.updatePaintArray(t.start, t.end, s, e[a], r), (o = !0);
              }
            }
          }
        }
        return o;
      }
      defines() {
        const e = [];
        for (const t in this.binders) {
          const i = this.binders[t];
          (i instanceof np || i instanceof rp) &&
            e.push(...i.uniformNames.map((e) => `#define HAS_UNIFORM_${e}`));
        }
        return e;
      }
      getBinderAttributes() {
        const e = [];
        for (const t in this.binders) {
          const i = this.binders[t];
          if (i instanceof op || i instanceof ap)
            for (let t = 0; t < i.paintVertexAttributes.length; t++)
              e.push(i.paintVertexAttributes[t].name);
          else if (i instanceof sp)
            for (let t = 0; t < Ud.members.length; t++) e.push(Ud.members[t].name);
        }
        return e;
      }
      getBinderUniforms() {
        const e = [];
        for (const t in this.binders) {
          const i = this.binders[t];
          if (i instanceof np || i instanceof rp || i instanceof ap)
            for (const t of i.uniformNames) e.push(t);
        }
        return e;
      }
      getPaintVertexBuffers() {
        return this._buffers;
      }
      getUniforms(e, t) {
        const i = [];
        for (const n in this.binders) {
          const r = this.binders[n];
          if (r instanceof np || r instanceof rp || r instanceof ap)
            for (const o of r.uniformNames)
              if (t[o]) {
                const a = r.getBinding(e, t[o], o);
                i.push({ name: o, property: n, binding: a });
              }
        }
        return i;
      }
      setUniforms(e, t, i, n) {
        for (const { name: e, property: r, binding: o } of t)
          this.binders[r].setUniform(o, n, i.get(r), e);
      }
      updatePaintBuffers(e) {
        this._buffers = [];
        for (const t in this.binders) {
          const i = this.binders[t];
          if (e && i instanceof sp) {
            const t = 2 === e.fromScale ? i.zoomInPaintVertexBuffer : i.zoomOutPaintVertexBuffer;
            t && this._buffers.push(t);
          } else
            (i instanceof op || i instanceof ap) &&
              i.paintVertexBuffer &&
              this._buffers.push(i.paintVertexBuffer);
        }
      }
      upload(e) {
        for (const t in this.binders) {
          const i = this.binders[t];
          (i instanceof op || i instanceof ap || i instanceof sp) && i.upload(e);
        }
        this.updatePaintBuffers();
      }
      destroy() {
        for (const e in this.binders) {
          const t = this.binders[e];
          (t instanceof op || t instanceof ap || t instanceof sp) && t.destroy();
        }
      }
    }
    class cp {
      constructor(e, t, i, n = () => !0) {
        this.programConfigurations = {};
        for (const r of t)
          (this.programConfigurations[r.id] = new lp(r, i, n)),
            (this.programConfigurations[r.id].layoutAttributes = e);
        (this.needsUpload = !1), (this._featureMap = new Kd()), (this._bufferOffset = 0);
      }
      populatePaintArrays(e, t, i, n, r, o) {
        for (const i in this.programConfigurations)
          this.programConfigurations[i].populatePaintArrays(e, t, n, r, o);
        void 0 !== t.id && this._featureMap.add(t.id, i, this._bufferOffset, e),
          (this._bufferOffset = e),
          (this.needsUpload = !0);
      }
      updatePaintArrays(e, t, i, n) {
        for (const r of i)
          this.needsUpload =
            this.programConfigurations[r.id].updatePaintArrays(e, this._featureMap, t, r, n) ||
            this.needsUpload;
      }
      get(e) {
        return this.programConfigurations[e];
      }
      upload(e) {
        if (this.needsUpload) {
          for (const t in this.programConfigurations) this.programConfigurations[t].upload(e);
          this.needsUpload = !1;
        }
      }
      destroy() {
        for (const e in this.programConfigurations) this.programConfigurations[e].destroy();
      }
    }
    function up(e, t) {
      return (
        {
          'line-border-opacity': ['borderopacity'],
          'line-border-width': ['borderwidth'],
          'line-border-color': ['bordercolor'],
          'line-offset': ['offset'],
          'text-opacity': ['opacity'],
          'icon-opacity': ['opacity'],
          'text-color': ['fill_color'],
          'icon-color': ['fill_color'],
          'text-halo-color': ['halo_color'],
          'icon-halo-color': ['halo_color'],
          'text-halo-blur': ['halo_blur'],
          'icon-halo-blur': ['halo_blur'],
          'text-halo-width': ['halo_width'],
          'icon-halo-width': ['halo_width'],
          'line-gap-width': ['gapwidth'],
          'text-translate': ['translate'],
          'icon-translate': ['translate'],
          'line-translate': ['translate'],
          'fill-translate': ['translate'],
          'extrusion-translate': ['translate'],
          'sprite-translate': ['translate'],
          'icon-translate-anchor': ['translate_anchor'],
          'text-translate-anchor': ['translate_anchor'],
          'line-translate-anchor': ['translate_anchor'],
          'fill-translate-anchor': ['translate_anchor'],
          'extrusion-translate-anchor': ['translate_anchor'],
          'sprite-translate-anchor': ['translate_anchor'],
          'sprite-pattern': ['pattern_to', 'pattern_from', 'pixel_ratio_to', 'pixel_ratio_from'],
          'line-pattern': ['pattern_to', 'pattern_from', 'pixel_ratio_to', 'pixel_ratio_from'],
          'fill-pattern': ['pattern_to', 'pattern_from', 'pixel_ratio_to', 'pixel_ratio_from'],
          'extrusion-pattern': ['pattern_to', 'pattern_from', 'pixel_ratio_to', 'pixel_ratio_from'],
        }[e] || [e.replace(`${t}-`, '').replace(/-/g, '_')]
      );
    }
    function hp(e, t, i) {
      const n = {
          color: { source: Ho, composite: na },
          number: { source: Wo, composite: Ho },
          boolean: { source: Wo, composite: Ho },
        },
        r = (function (e) {
          return {
            'line-pattern': { source: Fo, composite: Fo },
            'sprite-pattern': { source: Fo, composite: Fo },
            'fill-pattern': { source: Fo, composite: Fo },
            'extrusion-pattern': { source: Fo, composite: Fo },
          }[e];
        })(e);
      return (r && r[i]) || n[t][i];
    }
    function dp(e, i, n = !1) {
      const r = {},
        o = t(e),
        a = t(i);
      let s, l, c;
      if (o)
        for (s in e)
          e.hasOwnProperty(s) &&
            ((l = e[s]),
            a && n && 'object' == typeof l && i.hasOwnProperty(s)
              ? ((c = i[s]), (r[s] = 'object' == typeof c ? dp(l, c, n) : l))
              : (r[s] = l));
      if (a) for (s in i) i.hasOwnProperty(s) && !r.hasOwnProperty(s) && ((c = i[s]), (r[s] = c));
      return r;
    }
    fo('ConstantBinder', np),
      fo('CrossFadedConstantBinder', rp),
      fo('SourceExpressionBinder', op),
      fo('CrossFadedCompositeBinder', sp),
      fo('CompositeExpressionBinder', ap),
      fo('ProgramConfiguration', lp, { omit: ['_buffers'] }),
      fo('ProgramConfigurationSet', cp);
    const pp = {
      SUB_GLOBE_PASS: 1,
      SUB_VECTOR_OPAQUE_PASS: 2,
      SUB_VECTOR_TRANSLUCENT_PASS: 3,
      SUB_MODEL_OPAQUE_PASS: 4,
      SUB_MODEL_TRANSLUCENT_PASS: 5,
      _USER_DEFINED_PRE_PASS: 6,
      PICK_PASS: 7,
      SHADOW_PASS: 8,
      VIEWSHED_PASS: 9,
      REAL_RENDER_PASS: 10,
      FXAA_PASS: 11,
      BLOOM_PASS: 12,
      TOON_SHADING_PASS: 13,
      HDR_PASS: 12,
      USER_DEFINED_POST_PROCESS_PASS: 14,
      PICK_COLOR_PASS: 15,
      CUBE_MAP_RENDER_FOR_SKYBOX: 16,
      CUBE_MAP_RENDER: 16,
      EARTH_EFFECT_PASS: 17,
    };
    let fp = 0,
      mp = {};
    class _p {
      constructor(e) {
        const t = Z(e, Z.EMPTY_OBJECT),
          i = Z(t.cull, Z.EMPTY_OBJECT),
          n = Z(t.polygonOffset, Z.EMPTY_OBJECT),
          r = Z(t.scissorTest, Z.EMPTY_OBJECT),
          o = Z(r.rectangle, Z.EMPTY_OBJECT),
          a = Z(t.depthRange, Z.EMPTY_OBJECT),
          s = Z(t.depthTest, Z.EMPTY_OBJECT),
          l = Z(t.colorMask, Z.EMPTY_OBJECT),
          c = Z(t.blending, Z.EMPTY_OBJECT),
          u = Z(c.color, Z.EMPTY_OBJECT),
          h = Z(t.stencilTest, Z.EMPTY_OBJECT),
          d = Z(h.frontOperation, Z.EMPTY_OBJECT),
          p = Z(h.backOperation, Z.EMPTY_OBJECT),
          f = Z(t.sampleCoverage, Z.EMPTY_OBJECT),
          m = t.viewport;
        (this.frontFace = Z(t.frontFace, Ll.CCW)),
          (this.cull = { enabled: Z(i.enabled, !1), face: Z(i.face, Ll.BACK) }),
          (this.lineWidth = Z(t.lineWidth, 1)),
          (this.polygonOffset = {
            enabled: Z(n.enabled, !1),
            factor: Z(n.factor, 0),
            units: Z(n.units, 0),
          }),
          (this.scissorTest = { enabled: Z(r.enabled, !1), rectangle: o }),
          (this.depthRange = { near: Z(a.near, 0), far: Z(a.far, 1) }),
          (this.depthTest = { enabled: Z(s.enabled, !1), func: Z(s.func, Ll.LESS) }),
          (this.colorMask = {
            red: Z(l.red, !0),
            green: Z(l.green, !0),
            blue: Z(l.blue, !0),
            alpha: Z(l.alpha, !0),
          }),
          (this.depthMask = Z(t.depthMask, !0)),
          (this.stencilMask = Z(t.stencilMask, -1)),
          (this.blending = {
            enabled: Z(c.enabled, !1),
            color: {
              red: Z(u.red, 0),
              green: Z(u.green, 0),
              blue: Z(u.blue, 0),
              alpha: Z(u.alpha, 0),
            },
            equationRgb: Z(c.equationRgb, Ll.FUNC_ADD),
            equationAlpha: Z(c.equationAlpha, Ll.FUNC_ADD),
            functionSourceRgb: Z(c.functionSourceRgb, Ll.ONE),
            functionSourceAlpha: Z(c.functionSourceAlpha, Ll.ONE),
            functionDestinationRgb: Z(c.functionDestinationRgb, Ll.ZERO),
            functionDestinationAlpha: Z(c.functionDestinationAlpha, Ll.ZERO),
          }),
          (this.stencilTest = {
            enabled: Z(h.enabled, !1),
            frontFunction: Z(h.frontFunction, Ll.ALWAYS),
            backFunction: Z(h.backFunction, Ll.ALWAYS),
            reference: Z(h.reference, 0),
            mask: Z(h.mask, -1),
            frontOperation: {
              fail: Z(d.fail, Ll.KEEP),
              zFail: Z(d.zFail, Ll.KEEP),
              zPass: Z(d.zPass, Ll.KEEP),
            },
            backOperation: {
              fail: Z(p.fail, Ll.KEEP),
              zFail: Z(p.zFail, Ll.KEEP),
              zPass: Z(p.zPass, Ll.KEEP),
            },
          }),
          (this.sampleCoverage = {
            enabled: Z(f.enabled, !1),
            value: Z(f.value, 1),
            invert: Z(f.invert, !1),
          }),
          (this.viewport = Z(m, null)),
          (this.id = 0);
      }
      static fromCache(e = {}) {
        const i = JSON.stringify(e);
        let n = mp[i];
        if (t(n)) return ++n.referenceCount, n.state;
        let r = new _p(e);
        const o = JSON.stringify(r);
        return (
          (n = mp[o]),
          t(n) ||
            ((r.id = fp++),
            (r = gp(r)),
            (n = { referenceCount: 0, state: r, partialKey: i }),
            (mp[o] = n)),
          ++n.referenceCount,
          (mp[i] = { referenceCount: 1, state: n.state }),
          n.state
        );
      }
      static removeFromCache(e) {
        let i, n, r, o;
        if (e instanceof _p) (i = JSON.stringify(e)), (r = mp[i]), (n = r.partialKey), (o = mp[n]);
        else {
          const t = new _p(e);
          (i = JSON.stringify(t)), (r = mp[i]), (n = JSON.stringify(e)), (o = mp[n]);
        }
        t(o) &&
          (--o.referenceCount,
          0 === o.referenceCount && (delete mp[n], t(r) && --r.referenceCount)),
          t(r) && 0 === r.referenceCount && delete mp[i];
      }
      static getCache() {
        return mp;
      }
      static clearCache() {
        mp = {};
      }
      static applyRenderState(e, i, n) {
        !(function (e, t) {
          e._frontFace.set(t.frontFace);
        })(e, i),
          (function (e, t) {
            e._cullFace.set(t.cull);
          })(e, i),
          (function (e, t) {
            e._polygonOffset.set(t.polygonOffset);
          })(e, i),
          (function (e, t) {
            e._depthRange.set(t.depthRange);
          })(e, i),
          (function (e, t) {
            e._depthTest.set(t.depthTest);
          })(e, i),
          (function (e, t) {
            e._colorMask.set(t.colorMask);
          })(e, i),
          (function (e, t) {
            e._depthMask.set(t.depthMask);
          })(e, i),
          (function (e, t) {
            e._stencilMask.set(t.stencilMask);
          })(e, i),
          (function (e, t) {
            e._stencilTest.set(t.stencilTest);
          })(e, i),
          (function (e, t) {
            e._sampleCoverage.set(t.sampleCoverage);
          })(e, i),
          (function (e, t) {
            e._scissorTest.set(e._scissorTest ? e._scissorTest.current : t.scissorTest.rectangle);
          })(e, i),
          (function (e, t, i = {}) {
            e._blending.set(t.blending),
              (i?.frameState?.passType === pp.PICK_PASS ||
                i?.frameState?.passType === pp.PICK_COLOR_PASS) &&
                e._blending.set(yp.disableBlending);
          })(e, i, n),
          (function (e, i) {
            let n = Z(i.viewport, e._viewport && e._viewport.current);
            t(n) ||
              (n = {
                x: 0,
                y: 0,
                width: e.gl.drawingBufferWidth,
                height: e.gl.drawingBufferHeight,
              }),
              e._viewport.set(n);
          })(e, i);
      }
      static generateSimpleRenderState() {
        return {
          depthTest: { enabled: !1 },
          blending: {
            enabled: !0,
            equationRgb: Ll.FUNC_ADD,
            equationAlpha: Ll.FUNC_ADD,
            functionSourceRgb: Ll.SRC_ALPHA,
            functionSourceAlpha: Ll.ONE,
            functionDestinationRgb: Ll.ONE_MINUS_SRC_ALPHA,
            functionDestinationAlpha: Ll.ONE_MINUS_SRC_ALPHA,
          },
          depthMask: !0,
        };
      }
      static getrenderstateParms(e) {
        return (
          (function (e) {
            (e.cull = Z(e.cull, Z.EMPTY_OBJECT)),
              (e.polygonOffset = Z(e.polygonOffset, Z.EMPTY_OBJECT)),
              (e.scissorTest = Z(e.scissorTest, Z.EMPTY_OBJECT)),
              (e.scissorTest.rectangle = Z(e.scissorTest.rectangle, Z.EMPTY_OBJECT)),
              (e.depthRange = Z(e.depthRange, Z.EMPTY_OBJECT)),
              (e.depthTest = Z(e.depthTest, Z.EMPTY_OBJECT)),
              (e.colorMask = Z(e.colorMask, Z.EMPTY_OBJECT)),
              (e.blending = Z(e.blending, Z.EMPTY_OBJECT)),
              (e.blending.color = Z(e.blending.color, Z.EMPTY_OBJECT)),
              (e.stencilTest = Z(e.stencilTest, Z.EMPTY_OBJECT)),
              (e.stencilTest.frontOperation = Z(e.stencilTest.frontOperation, Z.EMPTY_OBJECT)),
              (e.stencilTest.backOperation = Z(e.stencilTest.backOperation, Z.EMPTY_OBJECT)),
              (e.sampleCoverage = Z(e.sampleCoverage, Z.EMPTY_OBJECT));
          })(e),
          {
            frontFace: Z(e.frontFace, Ll.CCW),
            cull: { enabled: Z(e.cull.enabled, !1), face: Z(e.cull.face, Ll.BACK) },
            polygonOffset: {
              enabled: Z(e.polygonOffset.enabled, !1),
              factor: Z(e.polygonOffset.factor, 0),
              units: Z(e.polygonOffset.units, 0),
            },
            scissorTest: {
              enabled: Z(e.scissorTest.enabled, !1),
              rectangle: {
                x: Z(e.scissorTest.rectangle.x, 0),
                y: Z(e.scissorTest.rectangle.y, 0),
                width: Z(e.scissorTest.rectangle.width, 0),
                height: Z(e.scissorTest.rectangle.height, 0),
              },
            },
            depthRange: { near: Z(e.depthRange.near, 0), far: Z(e.depthRange.far, 1) },
            depthTest: { enabled: Z(e.depthTest.enabled, !1), func: Z(e.depthTest.func, Ll.LESS) },
            colorMask: {
              red: Z(e.colorMask.red, !0),
              green: Z(e.colorMask.green, !0),
              blue: Z(e.colorMask.blue, !0),
              alpha: Z(e.colorMask.alpha, !0),
            },
            depthMask: Z(e.depthMask, !0),
            stencilMask: Z(e.stencilMask, -1),
            blending: {
              enabled: Z(e.blending.enabled, !1),
              color: {
                red: Z(e.blending.color.red, 0),
                green: Z(e.blending.color.green, 0),
                blue: Z(e.blending.color.blue, 0),
                alpha: Z(e.blending.color.alpha, 0),
              },
              equationRgb: Z(e.blending.equationRgb, Ll.ADD),
              equationAlpha: Z(e.blending.equationAlpha, Ll.ADD),
              functionSourceRgb: Z(e.blending.functionSourceRgb, Ll.ONE),
              functionSourceAlpha: Z(e.blending.functionSourceAlpha, Ll.ONE),
              functionDestinationRgb: Z(e.blending.functionDestinationRgb, Ll.ZERO),
              functionDestinationAlpha: Z(e.blending.functionDestinationAlpha, Ll.ZERO),
            },
            stencilTest: {
              enabled: Z(e.stencilTest.enabled, !1),
              frontFunction: Z(e.stencilTest.frontFunction, Ll.ALWAYS),
              backFunction: Z(e.stencilTest.backFunction, Ll.ALWAYS),
              reference: Z(e.stencilTest.reference, 0),
              mask: Z(e.stencilTest.mask, -1),
              frontOperation: {
                fail: Z(e.stencilTest.frontOperation.fail, Ll.KEEP),
                zFail: Z(e.stencilTest.frontOperation.zFail, Ll.KEEP),
                zPass: Z(e.stencilTest.frontOperation.zPass, Ll.KEEP),
              },
              backOperation: {
                fail: Z(e.stencilTest.backOperation.fail, Ll.KEEP),
                zFail: Z(e.stencilTest.backOperation.zFail, Ll.KEEP),
                zPass: Z(e.stencilTest.backOperation.zPass, Ll.KEEP),
              },
            },
            sampleCoverage: {
              enabled: Z(e.sampleCoverage.enabled, !1),
              value: Z(e.sampleCoverage.value, 1),
              invert: Z(e.sampleCoverage.invert, !1),
            },
          }
        );
      }
    }
    function gp(e) {
      if ('object' != typeof e || null === e) return e;
      let t;
      const i = Object.keys(e);
      for (let n = 0; n < i.length; n++) (t = i[n]), e.hasOwnProperty(t) && (e[t] = gp(e[t]));
      return Object.freeze(e);
    }
    const yp = Object.freeze({
      enableBlending: Object.freeze({
        enabled: !0,
        color: { red: 0, green: 0, blue: 0, alpha: 0 },
        equationRgb: Ll.FUNC_ADD,
        equationAlpha: Ll.FUNC_ADD,
        functionSourceRgb: Ll.SRC_ALPHA,
        functionSourceAlpha: Ll.ONE,
        functionDestinationRgb: Ll.ONE_MINUS_SRC_ALPHA,
        functionDestinationAlpha: Ll.ONE_MINUS_SRC_ALPHA,
      }),
      disableBlending: Object.freeze({
        color: { red: 0, green: 0, blue: 0, alpha: 0 },
        enabled: !1,
        equationRgb: Ll.FUNC_ADD,
        equationAlpha: Ll.FUNC_ADD,
        functionSourceRgb: Ll.SRC_ALPHA,
        functionSourceAlpha: Ll.ONE,
        functionDestinationRgb: Ll.ONE_MINUS_SRC_ALPHA,
        functionDestinationAlpha: Ll.ONE_MINUS_SRC_ALPHA,
      }),
      enableDepthTest: Object.freeze({ enabled: !0, func: Ll.LESS }),
      enableDepthTestWithLEQUAL: Object.freeze({ enabled: !0, func: Ll.LEQUAL }),
      disableDepthTest: Object.freeze({ enabled: !1, func: Ll.LEQUAL }),
      enableDepthMask: !0,
      disableDepthMask: !1,
      enableStencilMask: 255,
      disableStencilMask: 0,
      enableCull: Object.freeze({ enabled: !0, face: Ll.BACK }),
      disableCull: Object.freeze({ enabled: !1, face: Ll.BACK }),
      depthRange: Object.freeze({ near: 0, far: 1 }),
      enableClassificationStencilTest: Object.freeze({
        enabled: !0,
        frontFunction: Ll.ALWAYS,
        backFunction: Ll.ALWAYS,
        reference: 0,
        mask: 255,
        frontOperation: { fail: Ll.KEEP, zFail: Ll.DECR_WRAP, zPass: Ll.KEEP },
        backOperation: { fail: Ll.KEEP, zFail: Ll.INCR_WRAP, zPass: Ll.KEEP },
      }),
      openClassificationStencilTest: Object.freeze({
        enabled: !0,
        frontFunction: Ll.NOTEQUAL,
        backFunction: Ll.NOTEQUAL,
        reference: 0,
        mask: 255,
        frontOperation: { fail: Ll.ZERO, zFail: Ll.ZERO, zPass: Ll.ZERO },
        backOperation: { fail: Ll.ZERO, zFail: Ll.ZERO, zPass: Ll.ZERO },
      }),
      disableStencilTest: Object.freeze({
        enabled: !1,
        frontFunction: Ll.NOTEQUAL,
        backFunction: Ll.NOTEQUAL,
        reference: 0,
        mask: 255,
        frontOperation: { fail: Ll.ZERO, zFail: Ll.ZERO, zPass: Ll.ZERO },
        backOperation: { fail: Ll.ZERO, zFail: Ll.ZERO, zPass: Ll.ZERO },
      }),
      disabledColorMask: Object.freeze({ red: !1, green: !1, blue: !1, alpha: !1 }),
      enableColorMask: Object.freeze({ red: !0, green: !0, blue: !0, alpha: !0 }),
      stencilModeForClip: Object.freeze({
        enabled: !0,
        frontFunction: Ll.EQUAL,
        backFunction: Ll.EQUAL,
        reference: 0,
        mask: 255,
        frontOperation: { fail: Ll.KEEP, zFail: Ll.KEEP, zPass: Ll.REPLACE },
        backOperation: { fail: Ll.KEEP, zFail: Ll.KEEP, zPass: Ll.REPLACE },
      }),
    });
    var xp =
        '#define GLSLIFY 1\nvec2 unpack_float(const float packedValue){int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity){int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor){return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0);}float unpack_mix_vec2(const vec2 packedValue,const float t){return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_vec4(const vec4 packedColors,const float t){vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}',
      vp =
        '#define GLSLIFY 1\n#include <c_define>\n#include <c_symbolF>\n#include <pragma_symbol_define>\n#include <u_BaseColorSampler>\n#ifdef M_PICK_COLOR\nvarying vec4 v_pick_color;\n#endif\nvoid main(){\n#include <pragma_symbol_initialize>\n#ifdef M_SYM_TRACKING\nif(v_seq<0.0){discard;}\n#endif\n#ifdef M_PICK_COLOR\nif(v_fade_opacity==0.0){discard;}gl_FragColor=v_pick_color;\n#else\nlowp float alpha=opacity*v_fade_opacity;vec4 tempColor=texture2D(u_BaseColorSampler,v_tex);gl_FragColor=vec4(tempColor.rgb,tempColor.a*alpha);\n#ifdef M_OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n#endif\n}',
      wp =
        '#define GLSLIFY 1\n#include <a_POSITION3>\n#include <u_ModelViewProjectionMatrix>\n#include <u_ModelMatrix>\n#include <u_ViewProjectionMatrix>\n#include <c_define>\n#include <c_symbolV>\n#include <pragma_symbol_define>\n#include <fn_rayEllipsoidIntersectionInterval>\n#include <fn_rotateXYZ>\n#ifdef M_PICK_COLOR\nattribute vec4 a_pick_color;varying vec4 v_pick_color;\n#endif\n#ifdef M_SYM_TRACKING\nbool findRangeMatch(){float num=u_seq*a_extra.y;if(u_seq<1.0){return num>=a_extra.x&&num<(a_extra.x+1.0);}else{return a_extra.x>=a_extra.y-1.0;}}bool findTimeRangeMatch(){float currentStamp=a_extra.x;float beforeStamp=a_extra.y;float endStamp=a_extra.z;float totalStartStamp=u_timestamp_se.x;float totalEndStamp=u_timestamp_se.y;float clockStamp=u_seq+totalStartStamp;if(clockStamp<=endStamp){if(clockStamp>beforeStamp&&clockStamp<=currentStamp){return true;}}else{if(currentStamp==endStamp){return true;}}return false;}\n#endif\nvoid main(){\n#include <pragma_symbol_initialize>\n#ifdef M_SYM_TRACKING\nif(u_display_mode==2.0){if(!findTimeRangeMatch()){v_seq=-100.0;}else{v_seq=100.0;}}else if(u_display_mode==1.0){if(!findRangeMatch()){v_seq=-100.0;}else{v_seq=100.0;}}else if(u_display_mode==0.0){float a_seq=a_extra.x;if(a_seq!=u_seq){v_seq=-100.0;}else{v_seq=100.0;}}\n#endif\nvec4 spacePos=u_ModelMatrix*vec4(a_POSITION,1.0);vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;highp float segment_angle=-a_projected_pos[2];float size;if(!u_is_size_zoom_constant&&!u_is_size_feature_constant){size=mix(a_size[0],a_size[1],u_size_t)/10.0;}else if(u_is_size_zoom_constant&&!u_is_size_feature_constant){size=a_size[0]/10.0;}else if(!u_is_size_zoom_constant&&u_is_size_feature_constant){size=u_size;}else{size=u_size;}float fontScale=u_is_text ? size/24.0 : size;if(!u_rotate_with_map&&!u_pitch_with_map){highp float angle_sin=0.;highp float angle_cos=1.;gl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION.xyz,1.0);gl_Position/=gl_Position.w;angle_sin=sin(segment_angle);angle_cos=cos(segment_angle);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);gl_Position.xy+=rotation_matrix*a_offset/32.0*fontScale/u_GlUnitsToPixels;}else if(u_rotate_with_map&&u_pitch_with_map&&u_along_line){gl_Position=u_ModelViewProjectionMatrix*vec4(a_CARTESIAN,1.0);}else if(u_rotate_with_map&&!u_pitch_with_map&&!u_along_line){gl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION.xyz,1.0);gl_Position/=gl_Position.w;mat3 rotation_matrix=rotateXYZ(0.,0.,u_Bearing);gl_Position.xyz+=rotation_matrix*vec3(a_offset.x,a_offset.y,0.)/32.0*fontScale/vec3(u_GlUnitsToPixels.xyx);}else if(u_rotate_with_map&&u_pitch_with_map&&!u_along_line){gl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION.xyz,1.0);gl_Position/=gl_Position.w;mat3 rotation_matrix=rotateXYZ(u_pitch,0.,u_Bearing);gl_Position.xyz+=rotation_matrix*vec3(a_offset.x,a_offset.y,0.)/32.0*fontScale/vec3(u_GlUnitsToPixels.xyx);}else if(!u_rotate_with_map&&u_pitch_with_map){gl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION.xyz,1.0);gl_Position/=gl_Position.w;mat3 rotation_matrix=rotateXYZ(u_pitch,0.,0.);gl_Position.xyz+=rotation_matrix*vec3(a_offset.x,a_offset.y,0.)/32.0*fontScale/vec3(u_GlUnitsToPixels.xyx);}else if(u_rotate_with_map&&!u_pitch_with_map&&u_along_line){gl_Position=u_ModelViewProjectionMatrix*vec4(a_CARTESIAN,1.0);}vec2 translate=u_translate;float translate_anchor=u_translate_anchor;if(translate_anchor==0.0){float sinA=sin(-u_Bearing);float cosA=cos(-u_Bearing);translate=vec2(translate[0]*cosA-translate[1]*sinA,translate[0]*sinA+translate[1]*cosA);}gl_Position.xy+=translate/u_GlUnitsToPixels;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1]>0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));vec3 rayDir=spacePos.xyz-u_CameraPosition;vec3 normalizedRayDir=normalize(rayDir);vec2 interval=rayEllipsoidIntersectionInterval(u_CameraPosition,normalizedRayDir);if(interval.x!=-infinity){float distanceToSymbol=length(rayDir);if(abs(interval.x-distanceToSymbol)>abs(interval.y-distanceToSymbol)){interpolated_fade_opacity=0.0;}}if(dot(normalizedRayDir,u_CameraDirection)>0.){interpolated_fade_opacity=0.0;}v_fade_opacity=interpolated_fade_opacity;\n#ifdef M_PICK_COLOR\nv_pick_color=a_pick_color;\n#endif\n}',
      Tp =
        '#define GLSLIFY 1\n#include <c_define>\n#include <c_symbolF>\n#include <pragma_symbol_define>\n#include <u_BaseColorSampler>\n#ifdef M_PICK_COLOR\nvarying vec4 v_pick_color;\n#endif\nvoid main(){\n#include <pragma_symbol_initialize>\n#ifdef M_SYM_TRACKING\nif(v_seq<0.0){discard;}\n#endif\nvec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];\n#ifdef M_PICK_COLOR\nif(fade_opacity==0.0){discard;}gl_FragColor=v_pick_color;\n#else\nfloat fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/fontScale;lowp float buff=(256.0-64.0)/256.0;if(u_is_halo){color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/fontScale;buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_BaseColorSampler,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=vec4(color.rgb,color.a*alpha*opacity*fade_opacity);\n#ifdef M_OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n#endif\n}',
      bp =
        'precision highp float;\n#define GLSLIFY 1\n#include <a_POSITION3>\n#include <u_ModelViewProjectionMatrix>\n#include <u_ViewProjectionMatrix>\n#include <u_ModelMatrix>\n#include <c_define>\n#include <c_symbolV>\n#include <pragma_symbol_define>\n#include <fn_rayEllipsoidIntersectionInterval>\n#include <fn_rotateXYZ>\n#ifdef M_PICK_COLOR\nattribute vec4 a_pick_color;varying vec4 v_pick_color;\n#endif\n#ifdef M_SYM_TRACKING\nbool findRangeMatch(){float num=u_seq*a_extra.y;if(u_seq<1.0){return num>=a_extra.x&&num<(a_extra.x+1.0);}else{return a_extra.x>=a_extra.y-1.0;}}bool findTimeRangeMatch(){float currentStamp=a_extra.x;float beforeStamp=a_extra.y;float endStamp=a_extra.z;float totalStartStamp=u_timestamp_se.x;float totalEndStamp=u_timestamp_se.y;float clockStamp=u_seq+totalStartStamp;if(clockStamp<=endStamp){if(clockStamp>beforeStamp&&clockStamp<=currentStamp){return true;}}else{if(currentStamp==endStamp){return true;}}return false;}\n#endif\nvoid main(){\n#include <pragma_symbol_initialize>\n#ifdef M_SYM_TRACKING\nif(u_display_mode==2.0){if(!findTimeRangeMatch()){v_seq=-100.0;}else{v_seq=100.0;}}else if(u_display_mode==1.0){if(!findRangeMatch()){v_seq=-100.0;}else{v_seq=100.0;}}else if(u_display_mode==0.0){float a_seq=a_extra.x;if(a_seq!=u_seq){v_seq=-100.0;}else{v_seq=100.0;}}\n#endif\nvec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;highp float segment_angle=-a_projected_pos[2];float size;if(!u_is_size_zoom_constant&&!u_is_size_feature_constant){size=mix(a_size[0],a_size[1],u_size_t)/10.0;}else if(u_is_size_zoom_constant&&!u_is_size_feature_constant){size=a_size[0]/10.0;}else if(!u_is_size_zoom_constant&&u_is_size_feature_constant){size=u_size;}else{size=u_size;}float fontScale=u_is_text ? size/24.0 : size;highp float angle_sin=0.;highp float angle_cos=0.;highp float angle_sin_mv=0.;highp float angle_cos_mv=0.;float lineRotAngle=0.;if(!u_rotate_with_map&&!u_pitch_with_map){gl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION.xyz,1.0);gl_Position/=gl_Position.w;gl_Position.xy+=a_offset/32.0*fontScale/u_GlUnitsToPixels;}else if(u_rotate_with_map&&u_pitch_with_map&&u_along_line){gl_Position=u_ModelViewProjectionMatrix*vec4(a_CARTESIAN,1.0);}else if(u_rotate_with_map&&!u_pitch_with_map&&!u_along_line){gl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION.xyz,1.0);gl_Position/=gl_Position.w;mat3 rotation_matrix=rotateXYZ(0.,0.,u_Bearing);gl_Position.xyz+=rotation_matrix*vec3(a_offset.x,a_offset.y,0.)/32.0*fontScale/vec3(u_GlUnitsToPixels.xyx);}else if(u_rotate_with_map&&u_pitch_with_map&&!u_along_line){gl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION.xyz,1.0);gl_Position/=gl_Position.w;mat3 rotation_matrix=rotateXYZ(u_pitch,0.,u_Bearing);gl_Position.xyz+=rotation_matrix*vec3(a_offset.x,a_offset.y,0.)/32.0*fontScale/vec3(u_GlUnitsToPixels.xyx);}else if(!u_rotate_with_map&&u_pitch_with_map){gl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION.xyz,1.0);gl_Position/=gl_Position.w;mat3 rotation_matrix=rotateXYZ(u_pitch,0.,0.);gl_Position.xyz+=rotation_matrix*vec3(a_offset.x,a_offset.y,0.)/32.0*fontScale/vec3(u_GlUnitsToPixels.xyx);}else if(u_rotate_with_map&&!u_pitch_with_map&&u_along_line){gl_Position=u_ModelViewProjectionMatrix*vec4(a_CARTESIAN,1.0);}vec2 translate=u_translate;float translate_anchor=u_translate_anchor;if(translate_anchor==0.0){float sinA=sin(-u_Bearing);float cosA=cos(-u_Bearing);translate=vec2(translate[0]*cosA-translate[1]*sinA,translate[0]*sinA+translate[1]*cosA);}gl_Position.xy+=translate/u_GlUnitsToPixels;vec2 tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1]>0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));vec4 spacePos=u_ModelMatrix*vec4(a_POSITION,1.0);vec3 rayDir=spacePos.xyz-u_CameraPosition;vec3 normalizedRayDir=normalize(rayDir);vec2 interval=rayEllipsoidIntersectionInterval(u_CameraPosition,normalizedRayDir);if(interval.x!=-infinity){float distanceToSymbol=length(rayDir);if(abs(interval.x-distanceToSymbol)>abs(interval.y-distanceToSymbol)){interpolated_fade_opacity=0.0;}}if(dot(normalizedRayDir,u_CameraDirection)>0.){interpolated_fade_opacity=0.0;}v_data0=vec2(tex.x,tex.y);v_data1=vec3(1.,size,interpolated_fade_opacity);\n#ifdef M_PICK_COLOR\nv_pick_color=a_pick_color;\n#endif\n}',
      Sp =
        '#define GLSLIFY 1\n#include <u_ModelMatrix>\n#include <v_LocalPosition>\n#ifdef M_HAS_BASECOLORMAP\n#include <u_BaseColorSampler>\n#endif\nuniform vec4 u_BaseColorFactor;\n#include <c_define>\n#include <s_HighlightColorInfo>\n#include <s_LightMaterial>\n#include <fn_phong>\n#include <fn_writeLogDepth>\nuniform sampler2D u_MaskSample;\n#include <u_ClipMatrix>\nuniform vec2 u_TextureSize;uniform bool u_ClipVideo;\n#if (defined M_NUM_VIDEOS) && (M_NUM_VIDEOS>0)\nuniform highp mat4 u_VIDEOMATCH_MVPMATRIX[M_NUM_VIDEOS];uniform highp vec3 u_VIDEOMATCH_RTP[M_NUM_VIDEOS];uniform bool u_HAS_VIDEOMATCHMAP[M_NUM_VIDEOS];uniform float u_Alpha[M_NUM_VIDEOS];uniform highp sampler2D u_VideoSampler[M_NUM_VIDEOS];uniform bool u_ActiveClipVideoTexture[M_NUM_VIDEOS];uniform vec3 u_ClipColors[M_NUM_VIDEOS];\n#endif\nuniform bool u_useKhr;uniform bool u_HAS_NORMALS;uniform bool u_HAS_TANGENTS;varying vec3 v_Position;varying vec2 v_TexCoord;varying mat3 v_TBN;\n#include <v_Normal3>\nvarying vec3 v_NormalOrigin;varying vec4 v_COLOR_0;\n#include <u_Opacity>\nuniform vec2 u_satExp;uniform vec4 u_diffSpec;uniform float u_reflect;uniform vec4 u_pbrPer;\n#include <u_LightMaterial>\nuniform sampler2D u_model_clippingPlanes;uniform vec4 u_model_clippingPlanesEdgeStyle;uniform mat4 u_model_clippingPlanesMatrix;\n#include <u_Viewport>\nuniform mat4 u_ViewportTransformation;uniform mat4 u_InverseProjection;\n#include <u_PixelRatio>\n#include <u_CurrentFrustum>\n#include <u_FrustumPlanes>\nuniform samplerCube u_DiffuseEnvSampler;uniform samplerCube u_SpecularEnvSampler;uniform sampler2D u_brdfLUT;\n#ifdef M_HAS_NORMALMAP\nuniform sampler2D u_NormalSampler;\n#endif\nuniform float u_NormalScale;\n#ifdef M_HAS_EMISSIVEMAP\nuniform sampler2D u_EmissiveSampler;\n#endif\nuniform vec3 u_EmissiveFactor;\n#ifdef M_HAS_METALROUGHNESSMAP\nuniform sampler2D u_MetallicRoughnessSampler;\n#endif\nuniform vec2 u_MetallicRoughnessValues;\n#ifdef M_HAS_OCCLUSIONMAP\nuniform sampler2D u_OcclusionSampler;\n#endif\nuniform float u_OcclusionStrength;\n#include <s_PBRInfo>\n#include <fn_sRGB2Linear>\n#include <fn_getIBLContribution>\n#include <fn_pbrDiffuse>\n#include <fn_geometricOcculusion>\n#include <fn_specularReflection>\n#include <fn_getNormal>\n#include <fn_microfacetDistribution>\nuniform vec3 u_cameraLocalPosition;uniform vec3 u_sunLightDirectionSpecial;uniform float u_Shininess;uniform float u_Reflectivity;\n#ifdef M_ShadowEnable\nuniform sampler2D u_ShadowDepthSampler;uniform float u_EPSILON;uniform float u_MapSizeScale;\n#include <fn_shadow>\nuniform vec2 u_Resolution;varying vec4 v_PositionFromLight;\n#endif\nvec4 getPBRColor(vec4 baseColor){float perceptualRoughness=u_MetallicRoughnessValues.y;float metallic=u_MetallicRoughnessValues.x;\n#ifdef M_HAS_METALROUGHNESSMAP\nvec4 mrSample=texture2D(u_MetallicRoughnessSampler,v_TexCoord);perceptualRoughness=mrSample.g*perceptualRoughness;metallic=mrSample.b*metallic;\n#endif\nperceptualRoughness=clamp(perceptualRoughness,c_MinRoughness,1.0);metallic=clamp(metallic,0.0,1.0);float alphaRoughness=perceptualRoughness*perceptualRoughness;vec3 f0=vec3(0.04);vec3 diffuseColor=baseColor.rgb*(vec3(1.0)-f0);diffuseColor*=1.0-metallic;vec3 specularColor=mix(f0,baseColor.rgb,metallic);float reflectance=max(max(specularColor.r,specularColor.g),specularColor.b);float reflectance90=clamp(reflectance*25.0,0.0,1.0);vec3 specularEnvironmentR0=specularColor.rgb;vec3 specularEnvironmentR90=vec3(1.0,1.0,1.0)*reflectance90;\n#ifdef M_HAS_NORMALMAP\nvec3 n=getNormalFromMap(u_HAS_TANGENTS,u_HAS_NORMALS,v_TexCoord,v_LocalPosition.xyz,v_NormalOrigin,v_TBN,u_NormalSampler);\n#else\nvec3 n=getNormal(u_HAS_TANGENTS,u_HAS_NORMALS,v_TexCoord,v_LocalPosition.xyz,v_NormalOrigin,v_TBN);\n#endif\nvec3 v=normalize(u_cameraLocalPosition-v_LocalPosition.xyz);vec3 l=normalize(u_sunLightDirectionSpecial);vec3 h=normalize(l+v);vec3 reflection=-normalize(reflect(v,n));float NdotL=clamp(dot(n,l),0.0,1.0);float NdotV=clamp(abs(dot(n,v)),0.0,1.0);float NdotH=clamp(dot(n,h),0.0,1.0);float LdotH=clamp(dot(l,h),0.0,1.0);float VdotH=clamp(dot(v,h),0.0,1.0);PBRInfo pbrInputs=PBRInfo(NdotL,NdotV,NdotH,LdotH,VdotH,perceptualRoughness,metallic,specularEnvironmentR0,specularEnvironmentR90,alphaRoughness,diffuseColor,specularColor);vec3 F=specularReflection(pbrInputs);float G=geometricOcclusion(pbrInputs);float D=microfacetDistribution(pbrInputs);vec3 diffuseContrib=(1.0-F)*pbrDiffuse(pbrInputs);vec3 specContrib=F*G*D/(4.0*NdotL*NdotV);vec3 color=NdotL*u_SunLightColor*(u_pbrPer[1]*diffuseContrib+u_pbrPer[2]*specContrib);\n#if (defined M_USE_IBL) && (defined M_TEXTURE_LOD_SUPPORTED)\nvec3 iblColor=getIBLContribution(pbrInputs,n,reflection,v_TexCoord,u_brdfLUT,u_DiffuseEnvSampler,u_SpecularEnvSampler);color+=u_pbrPer[0]*iblColor;\n#endif\n#ifdef M_HAS_OCCLUSIONMAP\nfloat ao=texture2D(u_OcclusionSampler,v_TexCoord).r;color=mix(color,color*ao,u_OcclusionStrength);\n#endif\n#ifdef M_HAS_EMISSIVEMAP\nvec3 emissive=texture2D(u_EmissiveSampler,v_TexCoord).rgb*u_EmissiveFactor;color+=emissive;\n#endif\ncolor=pow(color,vec3(1.0/2.2));const vec3 luminanceWeight=vec3(0.2125,0.7154,0.0721);float luminance=dot(color,luminanceWeight);vec3 grayColor=vec3(luminance,luminance,luminance);color=mix(grayColor,color,u_satExp[0]);color=u_satExp[1]*color;return vec4(color,baseColor.a);}\n#include <fn_encodeFloat>\n#include <fn_getBatchTextureColor>\n#include <fn_pixelInVideo>\n#include <fn_primitiveClippingPlanes>\n#ifdef M_MODEL_INSTANCE_BATCH_TEXTURE\nvarying vec4 v_modelInstanceColor;\n#endif\nvoid main(){vec4 baseColor=u_BaseColorFactor;\n#if defined M_HAS_BASECOLORMAP\nbaseColor=sRGB2Linear(texture2D(u_BaseColorSampler,v_TexCoord))*u_BaseColorFactor;\n#endif\n#if defined M_VERTEX_COLOR\nbaseColor*=v_COLOR_0;\n#endif\nif(baseColor.a==0.){discard;}\n#ifdef M_HAS_CLIPPING_PLANES\nmodelClippingPlanesStage(baseColor);\n#endif\n#if (defined M_USE_PBR) && (defined M_TEXTURE_LOD_SUPPORTED)\ngl_FragColor=getPBRColor(baseColor);\n#else\nvec4 temp_baseColor=vec4(pow(baseColor.rgb,vec3(1.0/2.2)),baseColor.a);\n#ifdef M_PHONG_LIGHT\nvec4 phongColor=vec4(phong(u_Reflectivity,v_Normal,u_SunLightDirectionGlobal,v_Position,u_Shininess),1.0);gl_FragColor=temp_baseColor*phongColor;\n#else\ngl_FragColor=temp_baseColor;\n#endif\n#endif\nfloat visibility;\n#ifdef M_ShadowEnable\n#ifdef M_ShadowMapping\nvisibility=0.6+0.4*ifShadow2(v_PositionFromLight,u_ShadowDepthSampler,u_EPSILON,1./u_Resolution.x,1./u_Resolution.y,u_MapSizeScale);\n#else\n#ifdef M_PCF\nvisibility=ShadowPCF(v_PositionFromLight,u_Resolution,u_ShadowDepthSampler);\n#endif\n#endif\n#else\nvisibility=1.0;\n#endif\ngl_FragColor=vec4(gl_FragColor.xyz*visibility,gl_FragColor.w*u_Opacity);\n#if (defined M_NUM_VIDEOS) && (M_NUM_VIDEOS>0)\nfor(int i=0;i<M_NUM_VIDEOS;i++){if(u_HAS_VIDEOMATCHMAP[i]){if(u_ClipVideo){if(pixelInVideo(u_VIDEOMATCH_MVPMATRIX[i],u_VIDEOMATCH_RTP[i],u_ModelMatrix,v_LocalPosition,u_VideoSampler[i],u_Alpha[i],u_ClipMatrix,u_MaskSample,u_TextureSize,u_ActiveClipVideoTexture[i],u_ClipColors[i])){continue;}}else{if(pixelInVideo(u_VIDEOMATCH_MVPMATRIX[i],u_VIDEOMATCH_RTP[i],u_ModelMatrix,v_LocalPosition,u_VideoSampler[i],u_Alpha[i],u_ClipMatrix,u_MaskSample,u_TextureSize,false,u_ClipColors[i])){continue;}}}}\n#endif\n#if defined(M_ONE_DIMENSION_BATCH_TEXTURE)||defined(M_TWO_DIMENSION_BATCH_TEXTURE)\ngetBatchTextureColor(batch_featureColor);\n#endif\n#ifdef M_MODEL_INSTANCE_BATCH_TEXTURE\nbaseColor.rgb=mix(gl_FragColor.rgb,v_modelInstanceColor.rgb,v_modelInstanceColor.a);\n#ifdef M_PHONG_LIGHT\ngl_FragColor=baseColor*vec4(phong(u_Reflectivity,v_Normal,u_SunLightDirectionGlobal,v_Position,u_Shininess),u_Opacity);\n#else\ngl_FragColor=vec4(baseColor.rgb,u_Opacity);\n#endif\n#endif\n#ifdef M_LOG_DEPTH\nwriteLogDepth(v_depthFromNearPlusOne,u_CurrentFrustum);\n#endif\n}',
      Ap =
        '#define GLSLIFY 1\n#include <c_define>\n#ifdef M_DOUBLEPRECISION\n#include <a_DOUBLE_PRECISION_POSITION>\n#else\n#include <a_POSITION3>\n#endif\n#include <a_NORMAL3>\n#include <a_TANGENT>\n#include <a_TEXCOORD_0>\n#ifdef M_USE_MORPHTARGETS\n#include <a_POSITION3_1>\n#include <a_POSITION3_2>\nuniform vec2 u_morphTargetInfluences;\n#include <a_normal3_1>\n#include <a_NORMAL3_2>\n#include <a_TANGENT_1>\n#include <a_TANGENT_2>\n#endif\n#include <u_ModelViewProjectionMatrix>\n#include <u_ModelMatrix>\n#include <u_NormalMatrix>\n#include <v_LocalPosition>\n#include <a_COLOR4_0>\n#include <a_BATCHID>\n#ifdef M_JOINT_MATRIX_CNT\nattribute vec4 a_JOINTS_0;attribute vec4 a_WEIGHTS_0;\n#endif\n#ifdef M_INSTANCE_MATRIX\nattribute mat4 a_InstanceMatrix4;uniform mat4 vpmatrix;\n#endif\nuniform bool u_HAS_NORMALS;uniform bool u_HAS_TANGENTS;uniform bool u_useKhr;uniform vec4 u_khrValues;varying vec3 v_Position;\n#ifdef M_ShadowEnable\nvarying vec4 v_PositionFromLight;uniform mat4 u_ShadowModelViewProjectionMatrix;\n#endif\nvarying vec2 v_TexCoord;varying mat3 v_TBN;\n#include <v_Normal3>\nvarying vec3 v_NormalOrigin;varying vec4 v_COLOR_0;\n#include <s_JointMatrix>\n#include <fn_vertexLogDepth>\n#include <u_HasSkinning>\n#ifdef M_JOINT_MATRIX_CNT\nuniform highp mat4 u_jointMatrix[M_JOINT_MATRIX_CNT];\n#else\nuniform highp mat4 u_jointMatrix[19];\n#endif\n#include <fn_getKHRCoord>\n#include <c_computeSTParsVert>\n#include <u_ModelViewProjectionRelativeToEye>\n#include <u_EncodedCameraPosition>\n#include <fn_translateRelativeToEye>\n#include <fn_getAnimatedGLPosition>\n#include <u_LIGHT>\n#include <v_LIGHT>\n#ifdef M_INSTANCE_MATRIX\nuniform mat4 u_ModelInstanceRTCTransformMatrix;\n#endif\nvoid main(){\n#ifdef M_DOUBLEPRECISION\n#ifdef M_INSTANCE_MATRIX\nvec4 pos=u_ModelInstanceRTCTransformMatrix*a_InstanceMatrix4*u_ModelMatrix*vec4(a_PositionHigh+a_PositionLow,1.0);v_Position=vec3(pos.xyz)/pos.w;v_LocalPosition=vec4(a_PositionHigh+a_PositionLow,1.0);\n#else\nvec4 pos=u_ModelMatrix*vec4(a_PositionHigh+a_PositionLow,1.0);v_Position=vec3(pos.xyz)/pos.w;v_LocalPosition=vec4(a_PositionHigh+a_PositionLow,1.0);\n#endif\n#ifdef M_ShadowEnable\nv_PositionFromLight=u_ShadowModelViewProjectionMatrix*vec4(a_PositionHigh+a_PositionLow,1.0);\n#endif\n#else\n#ifdef M_INSTANCE_MATRIX\nvec4 pos=u_ModelInstanceRTCTransformMatrix*a_InstanceMatrix4*u_ModelMatrix*vec4(a_POSITION,1.0);v_Position=vec3(pos.xyz)/pos.w;v_LocalPosition=vec4(a_POSITION,1.0);\n#else\nvec4 pos=u_ModelMatrix*vec4(a_POSITION,1.0);v_Position=vec3(pos.xyz)/pos.w;v_LocalPosition=vec4(a_POSITION,1.0);\n#endif\n#ifdef M_ShadowEnable\nv_PositionFromLight=u_ShadowModelViewProjectionMatrix*vec4(a_POSITION,1.0);\n#endif\n#endif\n#if defined(M_enableLight) && defined(M_PointLight) && defined(M_ShadowEnable)\nfor(int i=0;i<int(M_PointLightCount);i++){vec4 positionToLight=u_PointLightModelMatrixInverse[i]*vec4(v_Position,1.0);v_PointDirection[i]=positionToLight.xyz;}\n#endif\nv_COLOR_0=a_COLOR_0;v_NormalOrigin=vec3(1);\n#ifdef M_INSTANCE_MATRIX\nvec4 delt=a_InstanceMatrix4*u_ModelMatrix*vec4(a_NORMAL,1.0)-a_InstanceMatrix4*u_ModelMatrix*vec4(0.0,0.0,0.0,1.0);v_Normal=normalize(delt.xyz);\n#else\nvec4 delt=u_ModelMatrix*vec4(a_NORMAL,1.0)-u_ModelMatrix*vec4(0.0,0.0,0.0,1.0);v_Normal=normalize(delt.xyz);\n#endif\nif(u_useKhr){v_TexCoord=getKHRCoord(a_TEXCOORD_0,u_khrValues);}else{v_TexCoord=a_TEXCOORD_0;}getAnimatedGLPosition();\n#ifdef M_LOG_DEPTH\nv_depthFromNearPlusOne=vertexLogDepth(u_CurrentFrustum);\n#endif\n#include <c_computeSTMainVert>\n}',
      Pp =
        '#define GLSLIFY 1\n#include <a_POSITION2>\n#include <u_ModelViewProjectionMatrix>\n#include <u_World>\n#include <v_TexCoord2>\nvoid main(){gl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION*u_World,0,1);v_TexCoord.x=a_POSITION.x;v_TexCoord.y=1.0-a_POSITION.y;}',
      Ep =
        '#define GLSLIFY 1\n#include <a_POSITION2>\nvarying vec2 vUv;void main(){gl_Position=vec4(a_POSITION,0.0,1.0);vUv=a_POSITION;}';
    const Cp = {
      basicVertex:
        '#define GLSLIFY 1\n#ifdef M_DOUBLEPRECISION\n#include <a_DOUBLE_PRECISION_POSITION>\n#else\n#include <a_POSITION3>\n#endif\n#include <u_ModelMatrix>\n#include <u_ModelViewProjectionMatrix>\n#include <u_ModelViewProjectionRelativeToEye>\n#include <u_EncodedCameraPosition>\n#include <fn_translateRelativeToEye>\n',
      a_BATCHID: '#define GLSLIFY 1\nattribute float a_BATCHID;',
      a_COLOR3_0: '#define GLSLIFY 1\nattribute vec3 a_COLOR_0;',
      a_COLOR4_0: '#define GLSLIFY 1\nattribute vec4 a_COLOR_0;',
      a_POSITION2: '#define GLSLIFY 1\nattribute vec2 a_POSITION;',
      a_POSITION3: '#define GLSLIFY 1\nattribute vec3 a_POSITION;',
      a_POSITION3_1: '#define GLSLIFY 1\nattribute vec3 a_POSITION_1;',
      a_POSITION3_2: '#define GLSLIFY 1\nattribute vec3 a_POSITION_2;',
      a_POSITION4: '#define GLSLIFY 1\nattribute vec4 a_POSITION;',
      a_DOUBLE_PRECISION_POSITION:
        '#define GLSLIFY 1\n#ifdef M_DOUBLEPRECISION\nattribute vec3 a_PositionHigh;attribute vec3 a_PositionLow;\n#endif\n',
      a_NORMAL3: '#define GLSLIFY 1\nattribute vec3 a_NORMAL;',
      a_normal3_1: '#define GLSLIFY 1\nattribute vec3 a_NORMAL_1;',
      a_NORMAL3_2: '#define GLSLIFY 1\nattribute vec3 a_NORMAL_2;',
      a_NORMAL2: '#define GLSLIFY 1\nattribute vec2 a_NORMAL;',
      a_TANGENT: '#define GLSLIFY 1\nattribute vec4 a_TANGENT;',
      a_TANGENT_1: '#define GLSLIFY 1\nattribute vec3 a_TANGENT_1;',
      a_TANGENT_2: '#define GLSLIFY 1\nattribute vec3 a_TANGENT_2;',
      a_TEXCOORD_0: '#define GLSLIFY 1\nattribute vec2 a_TEXCOORD_0;',
      u_ModelMatrix: '#define GLSLIFY 1\nuniform mat4 u_ModelMatrix;',
      u_ProjectionMatrix: '#define GLSLIFY 1\nuniform mat4 u_ProjectionMatrix;',
      u_ModelViewMatrix: '#define GLSLIFY 1\nuniform mat4 u_ModelViewMatrix;',
      u_ViewProjectionMatrix: '#define GLSLIFY 1\nuniform mat4 u_ViewProjectionMatrix;',
      u_ModelViewProjectionMatrix: '#define GLSLIFY 1\nuniform mat4 u_ModelViewProjectionMatrix;',
      u_NormalMatrix: '#define GLSLIFY 1\nuniform mat4 u_NormalMatrix;',
      u_ClipMatrix: '#define GLSLIFY 1\nuniform mat4 u_ClipMatrix;',
      u_BaseColorSampler: '#define GLSLIFY 1\nuniform sampler2D u_BaseColorSampler;',
      u_Resolution: '#define GLSLIFY 1\nuniform highp vec2 u_Resolution;',
      u_PixelMatrix: '#define GLSLIFY 1\nuniform mat2 u_PixelMatrix;',
      u_PixelRatio: '#define GLSLIFY 1\nuniform float u_PixelRatio;',
      u_Opacity: '#define GLSLIFY 1\nuniform float u_Opacity;',
      u_LightMaterial: '#define GLSLIFY 1\nuniform LightMaterial u_LightMaterial;',
      u_Color4: '#define GLSLIFY 1\nuniform vec4 u_Color;',
      u_Color3: '#define GLSLIFY 1\nuniform vec3 u_Color;',
      u_World:
        '#define GLSLIFY 1\n#ifndef _U_WORLD_\n#define _U_WORLD_\nuniform vec2 u_World;\n#endif\n',
      u_Zoom: '#define GLSLIFY 1\nuniform float u_Zoom;',
      u_ViewMatrix: '#define GLSLIFY 1\nuniform mat4 u_ViewMatrix;',
      u_TileNumber: '#define GLSLIFY 1\nuniform vec4 u_TileNumber;',
      u_Viewport: '#define GLSLIFY 1\nuniform vec4 u_Viewport;',
      u_RotateMatrixInverse: '#define GLSLIFY 1\nuniform mat4 u_RotateMatrixInverse;',
      u_ShadowViewProjectionMatrix: '#define GLSLIFY 1\nuniform mat4 u_ShadowViewProjectionMatrix;',
      u_ModelViewProjectionRelativeToEye:
        '#define GLSLIFY 1\nuniform mat4 u_ModelViewProjectionRelativeToEye;',
      u_CurrentFrustum: '#define GLSLIFY 1\nuniform vec2 u_CurrentFrustum;',
      u_EncodedCameraPosition:
        '#define GLSLIFY 1\nuniform vec3 u_EncodedCameraPositionMCLow;uniform vec3 u_EncodedCameraPositionMCHigh;',
      u_FrameNumber: '#define GLSLIFY 1\nuniform float u_FrameNumber;',
      u_FrustumPlanes: '#define GLSLIFY 1\nuniform vec4 u_FrustumPlanes;',
      u_Gamma: '#define GLSLIFY 1\nuniform float u_Gamma;',
      u_HasSkinning: '#define GLSLIFY 1\nuniform bool u_HasSkinning;',
      u_LIGHT:
        '#define GLSLIFY 1\n#ifdef M_enableLight\n#ifdef M_AmbientLight\nuniform float u_AmbientLightsColor[M_AmbientLightCount*3];uniform float u_AmbientLightsIntensity[M_AmbientLightCount];\n#endif\n#ifdef M_DirectionalLight\nuniform float u_DirectionalLightColor[M_DirectionalLightCount*3];uniform float u_DirectionalLightIntensity[M_DirectionalLightCount];uniform float u_DirectionalLightDir[M_DirectionalLightCount*3];\n#endif\n#ifdef M_PointLight\nuniform float u_PointLightColor[M_PointLightCount*3];uniform float u_PointLightIntensity[M_PointLightCount];uniform float u_PointLightPosition[M_PointLightCount*3];\n#ifdef M_ShadowEnable\nuniform mat4 u_PointLightModelMatrixInverse[M_PointLightCount];uniform float u_PointLightFar[M_PointLightCount];uniform samplerCube u_PointLightDepthCubeTexture;uniform float u_PointLightEpsilon[M_PointLightCount];uniform float u_DiskRadius[M_PointLightCount];uniform samplerCube u_PointLightDepthCubeTexture0;uniform samplerCube u_PointLightDepthCubeTexture1;uniform samplerCube u_PointLightDepthCubeTexture2;uniform samplerCube u_PointLightDepthCubeTexture3;uniform samplerCube u_PointLightDepthCubeTexture4;uniform samplerCube u_PointLightDepthCubeTexture5;\n#endif\n#endif\n#endif\n',
      u_Bearing: '#define GLSLIFY 1\nuniform float u_Bearing;',
      v_TexCoord2: '#define GLSLIFY 1\nvarying vec2 v_TexCoord;',
      v_TexCoord3: '#define GLSLIFY 1\nvarying vec3 v_TexCoord;',
      v_Normal3: '#define GLSLIFY 1\nvarying vec3 v_Normal;',
      v_Normal2: '#define GLSLIFY 1\nvarying vec2 v_Normal;',
      v_LocalPosition: '#define GLSLIFY 1\nvarying vec4 v_LocalPosition;',
      v_LIGHT:
        '#define GLSLIFY 1\n#ifdef M_enableLight\n#ifdef M_PointLight\n#ifdef M_ShadowEnable\nvarying vec3 v_PointDirection[M_PointLightCount];\n#endif\n#endif\n#endif\n',
      c_define:
        '#define GLSLIFY 1\n#define scale 0.015873016\n#define GAUSS_COEF 0.3989422804014327\n#define ANTIALIASING 1.0 / M_DEVICE_PIXEL_RATIO / 2.0\n#define LINE_DISTANCE_SCALE 2.0\n#define SDF_PX 8.0\n#define EDGE_GAMMA 0.105/M_DEVICE_PIXEL_RATIO\n#ifdef M_LOG_DEPTH\nvarying float v_depthFromNearPlusOne;\n#include <u_CurrentFrustum>\n#endif\nconst highp float ZERO=1.0/255.0/16.0;const float c_MinRoughness=0.04;',
      c_extrusionF:
        '#define GLSLIFY 1\n#include <v_Normal3>\nvarying highp float v_is_top;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform bool u_body_tex_rend;uniform vec2 u_top_pattern_tl_a;uniform vec2 u_top_pattern_br_a;uniform vec2 u_top_pattern_tl_b;uniform vec2 u_top_pattern_br_b;uniform bool u_top_tex_rend;uniform vec2 u_texsize;uniform float u_mix;varying float v_directional;varying float v_opacity;varying vec4 v_color;varying float v_height;uniform lowp float u_depth_render;uniform vec4 u_color_a;uniform vec4 u_color_b;uniform vec4 u_color_c;uniform vec4 u_color_d;uniform vec4 u_color_e;uniform float u_max_height;',
      c_extrusionV:
        '#define GLSLIFY 1\nuniform float u_is_max_length;attribute vec4 a_NORMAL_ED;attribute vec3 a_ST;\n#include <v_Normal3>\nvarying highp float v_is_top;\n#include <fn_getPatternPos>\nuniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_top_pattern_size_a;uniform vec2 u_top_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;uniform vec2 u_translate;uniform float u_translate_anchor;\n#include <u_World>\nvarying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;',
      c_fillF:
        '#define GLSLIFY 1\nuniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;',
      c_fillV:
        '#define GLSLIFY 1\nuniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_translate;uniform float u_translate_anchor;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;',
      c_lineF:
        '#define GLSLIFY 1\n#include <fn_writeLogDepth>\nuniform mediump float u_HasBorder;varying vec2 v_width2;\n#include <v_Normal2>\nvarying float v_gamma_scale;',
      c_lineV:
        '#define GLSLIFY 1\n#include <fn_vertexLogDepth>\nattribute float a_NORMAL;attribute vec4 a_data;\n#include <u_PixelMatrix>\nuniform mediump float u_Ratio;uniform vec2 u_GlUnitsToPixels;uniform lowp float u_HalfRender;uniform lowp float normaldirection;uniform mediump float u_HasBorder;uniform vec2 u_translate;uniform float u_translate_anchor;\n#include <v_Normal2>\nvarying vec2 v_width2;varying float v_gamma_scale;',
      c_symbolF:
        '#define GLSLIFY 1\nuniform bool u_is_halo;uniform bool u_is_text;varying vec2 v_tex;varying float v_fade_opacity;varying vec2 v_data0;varying vec3 v_data1;varying float v_seq;',
      c_symbolV:
        '#define GLSLIFY 1\nattribute vec2 a_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute vec3 a_CARTESIAN;attribute float a_fade_opacity;attribute vec3 a_extra;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform vec2 u_GlUnitsToPixels;uniform highp float u_Bearing;uniform bool u_along_line;uniform bool u_pitch_with_map;uniform bool u_rotate_with_map;uniform bool u_rotate_symbol;uniform bool u_is_text;uniform highp float u_pitch;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform vec2 u_texsize;uniform float u_display_mode;uniform vec2 u_timestamp_se;uniform highp float u_seq;uniform vec2 u_translate;uniform float u_translate_anchor;varying vec2 v_data0;varying vec3 v_data1;varying vec2 v_tex;varying float v_fade_opacity;varying float v_seq;',
      c_computeSTParsVert:
        '#define GLSLIFY 1\n#if defined(M_ONE_DIMENSION_BATCH_TEXTURE)\nuniform sampler2D batchTexture;uniform vec4 batch_textureStep;varying vec4 batch_featureColor;varying vec2 batch_featureSt;vec2 computeSt(float batchId){float stepX=batch_textureStep.x;float centerX=batch_textureStep.y;return vec2(centerX+(batchId*stepX),0.5);}\n#endif\n#if defined(M_TWO_DIMENSION_BATCH_TEXTURE)\nuniform sampler2D batchTexture;uniform vec4 batch_textureStep;uniform vec2 batch_textureDimensions;varying vec2 batch_featureSt;varying vec4 batch_featureColor;vec2 computeSt(float batchId){float stepX=batch_textureStep.x;float centerX=batch_textureStep.y;float stepY=batch_textureStep.z;float centerY=batch_textureStep.w;float xId=mod(batchId,batch_textureDimensions.x);float yId=floor(batchId/batch_textureDimensions.x);return vec2(centerX+(xId*stepX),centerY+(yId*stepY));}\n#endif\n#if defined(M_MODEL_INSTANCE_BATCH_TEXTURE)\nuniform sampler2D batchTableTexture;uniform vec4 batchTextureStep;uniform float numberOfAttributes;varying vec4 v_modelInstanceColor;varying vec4 v_pickColor;attribute vec4 a_PickColor;vec2 computeModelSt(float batchId){float stepX=batchTextureStep.x;float centerX=batchTextureStep.y;return vec2(centerX+(batchId*numberOfAttributes*stepX),0.5);}vec4 batchTable_color(float batchId){vec2 st=computeModelSt(batchId);st.x+=batchTextureStep.x*float(0);vec4 textureValue=texture2D(batchTableTexture,st);return textureValue;}float batchTable_show(float batchId){vec2 st=computeModelSt(batchId);st.x+=batchTextureStep.x*float(1);vec4 textureValue=texture2D(batchTableTexture,st);float value=textureValue.x;value*=255.0;return value;}vec4 batchTable_pickColor(float batchId){vec2 st=computeModelSt(batchId);st.x+=batchTextureStep.x*float(2);vec4 textureValue=texture2D(batchTableTexture,st);vec4 value=textureValue;return value;}\n#endif\n',
      c_computeSTMainVert:
        '#define GLSLIFY 1\n#if defined(M_ONE_DIMENSION_BATCH_TEXTURE)||defined(M_TWO_DIMENSION_BATCH_TEXTURE)\nbatch_featureSt=computeSt(a_BATCHID);batch_featureColor=texture2D(batchTexture,batch_featureSt);float show=ceil(batch_featureColor.a);gl_Position*=show;\n#endif\n#ifdef M_MODEL_INSTANCE_BATCH_TEXTURE\ngl_Position*=batchTable_show(a_BATCHID);v_modelInstanceColor=batchTable_color(a_BATCHID);v_pickColor=batchTable_pickColor(a_BATCHID);\n#endif\n',
      pragma_base_define:
        '#define GLSLIFY 1\n#pragma minemap: define highp vec4 color\n#pragma minemap: define lowp float blur\n#pragma minemap: define lowp float opacity\n',
      pragma_base_initialize:
        '#define GLSLIFY 1\n#pragma minemap: initialize highp vec4 color\n#pragma minemap: initialize lowp float blur\n#pragma minemap: initialize lowp float opacity\n',
      pragma_border_define:
        '#define GLSLIFY 1\n#pragma minemap: define highp vec4 bordercolor\n#pragma minemap: define mediump float borderwidth\n#pragma minemap: define lowp float borderopacity\n',
      pragma_border_initialize:
        '#define GLSLIFY 1\n#pragma minemap: initialize highp vec4 bordercolor\n#pragma minemap: initialize mediump float borderwidth\n#pragma minemap: initialize lowp float borderopacity\n',
      pragma_circle_define:
        '#define GLSLIFY 1\n#include <pragma_base_define>\n#pragma minemap: define mediump float radius\n#pragma minemap: define highp vec4 stroke_color\n#pragma minemap: define mediump float stroke_width\n#pragma minemap: define lowp float stroke_opacity\n',
      pragma_circle_initialize:
        '#define GLSLIFY 1\n#include <pragma_base_initialize>\n#pragma minemap: initialize mediump float radius\n#pragma minemap: initialize highp vec4 stroke_color\n#pragma minemap: initialize mediump float stroke_width\n#pragma minemap: initialize lowp float stroke_opacity\n',
      pragma_extrusion_define:
        '#define GLSLIFY 1\n#include <pragma_base_define>\n#pragma minemap: define lowp float base\n#pragma minemap: define lowp float height\n',
      pragma_extrusion_initialize:
        '#define GLSLIFY 1\n#include <pragma_base_initialize>\n#pragma minemap: initialize lowp float base\n#pragma minemap: initialize lowp float height\n',
      pragma_heatmap_define:
        '#define GLSLIFY 1\n#pragma minemap: define highp float weight\n#pragma minemap: define mediump float radius\n',
      pragma_heatmap_initialize:
        '#define GLSLIFY 1\n#pragma minemap: initialize highp float weight\n#pragma minemap: initialize mediump float radius\n',
      pragma_line_define:
        '#define GLSLIFY 1\n#include <pragma_base_define>\n#pragma minemap: define mediump float gapwidth\n#pragma minemap: define lowp float offset\n#pragma minemap: define mediump float width\n#pragma minemap: define lowp float floorwidth\n#pragma minemap: define lowp float normal_direction\n#pragma minemap: define lowp float speed_factor\n',
      pragma_line_initialize:
        '#define GLSLIFY 1\n#include <pragma_base_initialize>\n#pragma minemap: initialize mediump float gapwidth\n#pragma minemap: initialize lowp float offset\n#pragma minemap: initialize mediump float width\n#pragma minemap: initialize lowp float floorwidth\n#pragma minemap: initialize lowp float normal_direction\n#pragma minemap: initialize lowp float speed_factor\n',
      pragma_fill_define: '#define GLSLIFY 1\n#pragma minemap: define highp vec4 outline_color\n',
      pragma_fill_initialize:
        '#define GLSLIFY 1\n#pragma minemap: initialize highp vec4 outline_color\n',
      pragma_symbol_define:
        '#define GLSLIFY 1\n#pragma minemap: define highp vec4 fill_color\n#pragma minemap: define highp vec4 halo_color\n#pragma minemap: define lowp float opacity\n#pragma minemap: define lowp float halo_width\n#pragma minemap: define lowp float halo_blur\n',
      pragma_symbol_initialize:
        '#define GLSLIFY 1\n#pragma minemap: initialize highp vec4 fill_color\n#pragma minemap: initialize highp vec4 halo_color\n#pragma minemap: initialize lowp float opacity\n#pragma minemap: initialize lowp float halo_width\n#pragma minemap: initialize lowp float halo_blur\n',
      pragma_water_define:
        '#define GLSLIFY 1\n#pragma minemap: define lowp float watercalm\n#pragma minemap: define lowp float waterspeed\n',
      pragma_water_initialize:
        '#define GLSLIFY 1\n#pragma minemap: initialize lowp float watercalm\n#pragma minemap: initialize lowp float waterspeed\n',
      fn_basic:
        '#define GLSLIFY 1\nvec4 getGLPosition(){\n#ifdef M_DOUBLEPRECISION\nvec4 position=u_ModelViewProjectionRelativeToEye*translateRelativeToEye(a_PositionHigh,a_PositionLow);\n#else\nvec4 position=u_ModelViewProjectionMatrix*vec4(a_POSITION,1.0);\n#endif\nreturn position;}vec4 getWorldPosition(){\n#ifdef M_DOUBLEPRECISION\nvec4 position=u_ModelMatrix*vec4(a_PositionHigh+a_PositionLow,1);\n#else\nvec4 position=u_ModelMatrix*vec4(a_POSITION,1.0);\n#endif\nreturn position;}',
      fn_translateRelativeToEye:
        '#define GLSLIFY 1\nvec4 translateRelativeToEye(vec3 high,vec3 low){vec3 highDifference=high-u_EncodedCameraPositionMCHigh;vec3 lowDifference=low-u_EncodedCameraPositionMCLow;return vec4(highDifference+lowDifference,1.0);}',
      fn_rotateXYZ:
        '#define GLSLIFY 1\n#ifndef _fn_rotateXYZ_\n#define _fn_rotateXYZ_\nmat3 rotateXYZ(float x,float y,float z){float cx=cos(x);float sx=sin(x);float cy=cos(y);float sy=sin(y);float cz=cos(z);float sz=sin(z);return mat3(cy*cz,-cy*sz,sy,cz*sx*sy+cx*sz,cx*cz-sx*sy*sz,-cy*sx,sx*sz-cx*cz*sy,cx*sy*sz+cz*sx,cx*cy);}\n#endif\n',
      fn_shadow:
        '#define GLSLIFY 1\n#include <fn_decodeFloat>\nfloat getDepthUseWPAndVP(vec3 worldPosition,mat4 viewProjectionMatrix,sampler2D depthSampler){vec4 clipPos=viewProjectionMatrix*vec4(worldPosition,1.0);clipPos=clipPos/clipPos.w;vec2 texPos=vec2(clipPos.x,clipPos.y)*0.5+0.5;vec4 depthTexture=texture2D(depthSampler,texPos);return unpackDepth(depthTexture);}bool ifShadow(vec3 worldPosition,mat4 viewProjectionMatrix,sampler2D depthSampler){vec4 clipPos=viewProjectionMatrix*vec4(worldPosition,1.0);clipPos=clipPos/clipPos.w;vec2 texPos=vec2(clipPos.x,clipPos.y)*0.5+0.5;vec4 depthTexture=texture2D(depthSampler,texPos);float depthValue=unpackDepth(depthTexture);if(texPos.x<0.0||texPos.y<0.0||texPos.x>1.0||texPos.y>1.0||depthValue==0.0){return false;}else{return depthValue<((clipPos.z*0.5)+0.5)-0.01;}}bool ifShadow(vec4 clipPos,sampler2D depthSampler){vec3 shadowPos=clipPos.xyz/clipPos.w;vec2 texPos=vec2(shadowPos.x,shadowPos.y)*0.5+0.5;vec4 depthTexture=texture2D(depthSampler,texPos);float depthValue=unpackDepth(depthTexture);if(texPos.x<0.0||texPos.y<0.0||texPos.x>1.0||texPos.y>1.0||depthValue==0.0){return false;}else{return depthValue<((shadowPos.z*0.5)+0.5)-0.0015;}}float ShadowPCF(vec4 clipPos,vec2 resolution,sampler2D depthSampler){vec3 shadowPos=clipPos.xyz/clipPos.w;vec2 texPos=vec2(shadowPos.x,shadowPos.y)*0.5+0.5;const int size=2;const float num=25.0;int cout=0;for(int x=-size;x<=size;x++){for(int y=-size;y<=size;y++){vec2 coordinate=texPos+vec2(x,y)/resolution;if(coordinate.x<0.0||coordinate.y<0.0||coordinate.x>1.0||coordinate.y>1.0){continue;}else{vec4 depthTexture=texture2D(depthSampler,coordinate);float depthValue=unpackDepth(depthTexture);if(depthValue<((clipPos.z*0.5)+0.5)-0.025){cout=cout+1;}}}}return 1.0-0.3*(float(cout)/num);}vec4 getColor(vec3 worldPosition,mat4 viewProjectionMatrix,sampler2D depthSampler){vec4 clipPos=viewProjectionMatrix*vec4(worldPosition,1.0);clipPos=clipPos/clipPos.w;vec2 texPos=vec2(clipPos.x,clipPos.y)*0.5+0.5;if(texPos.x<0.0||texPos.y<0.0||texPos.x>1.0&&texPos.y>1.0){return vec4(0.0,0.0,1.0,1.0);}vec4 depthTexture=texture2D(depthSampler,texPos);if(unpackDepth(depthTexture)==0.0000){return vec4(1.0,0.0,0.0,1.0);}else if(unpackDepth(depthTexture)<((clipPos.z*0.5)+0.5)){return vec4(0.0,1.0,0.0,1.0);}else{return vec4(1.0,1.0,1.0,1.0);}}bool ifShadowMin(vec4 fragCoord,vec2 u_Resolution,mat4 u_InverseViewProjectionMatrix,mat4 viewProjectionMatrix2,sampler2D depthSampler,sampler2D shadowDepthSampler){int cout=0;for(float x=-1.0;x<=1.0;x++){for(float y=-1.0;y<=1.0;y++){float x_coord=fragCoord.x+x;float y_coord=fragCoord.y+y;if(x_coord<0.0||y_coord<0.0||x_coord>u_Resolution.x||y_coord>u_Resolution.y){continue;}else{x_coord=x_coord/u_Resolution.x;y_coord=y_coord/u_Resolution.y;float z_coord=unpackDepth(texture2D(depthSampler,vec2(x_coord,y_coord)));vec4 coordinate=vec4(x_coord*2.0-1.0,y_coord*2.0-1.0,z_coord*2.0-1.0,1.0);coordinate=u_InverseViewProjectionMatrix*coordinate;coordinate=coordinate/coordinate.w;if(ifShadow(coordinate.xyz,viewProjectionMatrix2,shadowDepthSampler)){cout=cout+1;}}}}return cout==9;}float ifShadow2(vec4 clipPos,sampler2D depthSampler,float EPSILON,float deltX,float deltY,float scaleShadow){float Factor=0.0;clipPos=clipPos/clipPos.w;float z=(clipPos.z*0.5)+0.5;vec2 texPos=vec2(clipPos.x,clipPos.y)*0.5+0.5;if(texPos.x<0.0||texPos.y<0.0||texPos.x>1.0||texPos.y>1.0){return 1.0;}else{float indexIJ[10];indexIJ[0]=-1.0;indexIJ[1]=0.0;indexIJ[2]=0.0;indexIJ[3]=0.0;indexIJ[4]=1.0;indexIJ[5]=0.0;indexIJ[6]=0.0;indexIJ[7]=-1.0;indexIJ[8]=0.0;indexIJ[9]=1.0;float xOffset=deltX*scaleShadow;float yOffset=deltY*scaleShadow;for(int i=0;i<5;i++){vec2 Offsets=vec2(indexIJ[2*i]*xOffset,indexIJ[2*i+1]*yOffset);vec2 UVC=vec2(texPos+Offsets);vec4 rgbaDepth=texture2D(depthSampler,UVC);float Depth=unpackDepth(rgbaDepth);if(Depth+EPSILON>z){Factor+=1.0;}}Factor=Factor*0.2;return Factor;}}',
      fn_isBackOfEarth:
        '#define GLSLIFY 1\nbool isBackOfEarth(vec3 spacePos,vec3 camPos,float tangentAngle){float val=dot(normalize(spacePos),normalize(camPos));float angle=acos(val);return angle>tangentAngle;}',
      fn_pixelInVideo:
        '#define GLSLIFY 1\nfloat EPSILON4=0.0001;bool pixelInVideo(mat4 videoMatrix,vec3 cameraPosition,mat4 modelMatrix,vec4 posOrigin,sampler2D videoSampler,float videoAlpha,mat4 clipMatrix,sampler2D maskSample,vec2 textureSize,bool activeClipVideoTexture,vec3 polygonColor){modelMatrix[3]=modelMatrix[3]-vec4(cameraPosition,0.);vec4 VideoProjectPostion=videoMatrix*modelMatrix*posOrigin;vec4 clipProjectPostion=clipMatrix*modelMatrix*posOrigin;VideoProjectPostion=VideoProjectPostion/VideoProjectPostion.w;clipProjectPostion=clipProjectPostion/clipProjectPostion.w;vec2 UV=VideoProjectPostion.xy*0.5+0.5;vec2 clipUV=clipProjectPostion.xy*0.5+0.5;UV.y=1.0-UV.y;bool isGap=false;if(UV.x>=0.0&&UV.x<=1.0&&UV.y>=0.0&&UV.y<=1.0){if(activeClipVideoTexture){vec2 offsetXY=vec2(1./textureSize.x,1./textureSize.y);vec4 c_Color=texture2D(maskSample,clipUV);vec4 c_Color1=texture2D(maskSample,clipUV+vec2(-offsetXY.x,0.0));vec4 c_Color2=texture2D(maskSample,clipUV+vec2(offsetXY.x,0.0));vec4 c_Color3=texture2D(maskSample,clipUV+vec2(0.0,-offsetXY.y));vec4 c_Color4=texture2D(maskSample,clipUV+vec2(0.0,offsetXY.y));vec4 avgZ=(c_Color+c_Color1+c_Color2+c_Color3+c_Color4)/5.0;bool isInPolygon=false;if(abs(avgZ.x-polygonColor.x)<EPSILON4&&abs(avgZ.y-polygonColor.y)<EPSILON4&&abs(avgZ.z-polygonColor.z)<EPSILON4){isInPolygon=true;}else if(abs(c_Color.x-polygonColor.x)<EPSILON4&&abs(c_Color.y-polygonColor.y)<EPSILON4&&abs(c_Color.z-polygonColor.z)<EPSILON4){isInPolygon=true;}if(isInPolygon){vec4 videoColor=texture2D(videoSampler,UV);gl_FragColor=mix(gl_FragColor.rgba,videoColor,videoAlpha);return true;}else{return false;}}else{vec4 videoColor=texture2D(videoSampler,UV);gl_FragColor=mix(gl_FragColor.rgba,videoColor,videoAlpha);return true;}}return false;}',
      fn_nvidia_fxaa:
        '#define GLSLIFY 1\n#if (M_FXAA_QUALITY_PRESET == 10)\n#define FXAA_QUALITY_PS 3\n#define FXAA_QUALITY_P0 1.5\n#define FXAA_QUALITY_P1 3.0\n#define FXAA_QUALITY_P2 12.0\n#endif\n#if (M_FXAA_QUALITY_PRESET == 11)\n#define FXAA_QUALITY_PS 4\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 3.0\n#define FXAA_QUALITY_P3 12.0\n#endif\n#if (M_FXAA_QUALITY_PRESET == 12)\n#define FXAA_QUALITY_PS 5\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 4.0\n#define FXAA_QUALITY_P4 12.0\n#endif\n#if (M_FXAA_QUALITY_PRESET == 13)\n#define FXAA_QUALITY_PS 6\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 4.0\n#define FXAA_QUALITY_P5 12.0\n#endif\n#if (M_FXAA_QUALITY_PRESET == 14)\n#define FXAA_QUALITY_PS 7\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 4.0\n#define FXAA_QUALITY_P6 12.0\n#endif\n#if (M_FXAA_QUALITY_PRESET == 15)\n#define FXAA_QUALITY_PS 8\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 2.0\n#define FXAA_QUALITY_P6 4.0\n#define FXAA_QUALITY_P7 12.0\n#endif\n#if (M_FXAA_QUALITY_PRESET == 20)\n#define FXAA_QUALITY_PS 3\n#define FXAA_QUALITY_P0 1.5\n#define FXAA_QUALITY_P1 2.0\n#define FXAA_QUALITY_P2 8.0\n#endif\n#if (M_FXAA_QUALITY_PRESET == 21)\n#define FXAA_QUALITY_PS 4\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 8.0\n#endif\n#if (M_FXAA_QUALITY_PRESET == 22)\n#define FXAA_QUALITY_PS 5\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 8.0\n#endif\n#if (M_FXAA_QUALITY_PRESET == 23)\n#define FXAA_QUALITY_PS 6\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 8.0\n#endif\n#if (M_FXAA_QUALITY_PRESET == 24)\n#define FXAA_QUALITY_PS 7\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 3.0\n#define FXAA_QUALITY_P6 8.0\n#endif\n#if (M_FXAA_QUALITY_PRESET == 25)\n#define FXAA_QUALITY_PS 8\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 2.0\n#define FXAA_QUALITY_P6 4.0\n#define FXAA_QUALITY_P7 8.0\n#endif\n#if (M_FXAA_QUALITY_PRESET == 26)\n#define FXAA_QUALITY_PS 9\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 2.0\n#define FXAA_QUALITY_P6 2.0\n#define FXAA_QUALITY_P7 4.0\n#define FXAA_QUALITY_P8 8.0\n#endif\n#if (M_FXAA_QUALITY_PRESET == 27)\n#define FXAA_QUALITY_PS 10\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 2.0\n#define FXAA_QUALITY_P6 2.0\n#define FXAA_QUALITY_P7 2.0\n#define FXAA_QUALITY_P8 4.0\n#define FXAA_QUALITY_P9 8.0\n#endif\n#if (M_FXAA_QUALITY_PRESET == 28)\n#define FXAA_QUALITY_PS 11\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 2.0\n#define FXAA_QUALITY_P6 2.0\n#define FXAA_QUALITY_P7 2.0\n#define FXAA_QUALITY_P8 2.0\n#define FXAA_QUALITY_P9 4.0\n#define FXAA_QUALITY_P10 8.0\n#endif\n#if (M_FXAA_QUALITY_PRESET == 29)\n#define FXAA_QUALITY_PS 12\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 2.0\n#define FXAA_QUALITY_P6 2.0\n#define FXAA_QUALITY_P7 2.0\n#define FXAA_QUALITY_P8 2.0\n#define FXAA_QUALITY_P9 2.0\n#define FXAA_QUALITY_P10 4.0\n#define FXAA_QUALITY_P11 8.0\n#endif\n#if (M_FXAA_QUALITY_PRESET == 39)\n#define FXAA_QUALITY_PS 12\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.0\n#define FXAA_QUALITY_P2 1.0\n#define FXAA_QUALITY_P3 1.0\n#define FXAA_QUALITY_P4 1.0\n#define FXAA_QUALITY_P5 1.5\n#define FXAA_QUALITY_P6 2.0\n#define FXAA_QUALITY_P7 2.0\n#define FXAA_QUALITY_P8 2.0\n#define FXAA_QUALITY_P9 2.0\n#define FXAA_QUALITY_P10 4.0\n#define FXAA_QUALITY_P11 8.0\n#endif\n#define FxaaBool bool\n#define FxaaFloat float\n#define FxaaFloat2 vec2\n#define FxaaFloat3 vec3\n#define FxaaFloat4 vec4\n#define FxaaHalf float\n#define FxaaHalf2 vec2\n#define FxaaHalf3 vec3\n#define FxaaHalf4 vec4\n#define FxaaInt2 vec2\n#define FxaaTex sampler2D\n#define FxaaSat(x) clamp(x, 0.0, 1.0)\n#define FxaaTexTop(t, p) texture2D(t, p)\n#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r))\nFxaaFloat FxaaLuma(FxaaFloat4 rgba){return rgba.y;}FxaaFloat4 FxaaPixelShader(FxaaFloat2 pos,FxaaTex tex,FxaaFloat2 fxaaQualityRcpFrame,FxaaFloat fxaaQualitySubpix,FxaaFloat fxaaQualityEdgeThreshold,FxaaFloat fxaaQualityEdgeThresholdMin){FxaaFloat2 posM;posM.x=pos.x;posM.y=pos.y;FxaaFloat4 rgbyM=FxaaTexTop(tex,posM);\n#define lumaM rgbyM.y\nFxaaFloat lumaS=FxaaLuma(FxaaTexOff(tex,posM,FxaaInt2(0,1),fxaaQualityRcpFrame.xy));FxaaFloat lumaE=FxaaLuma(FxaaTexOff(tex,posM,FxaaInt2(1,0),fxaaQualityRcpFrame.xy));FxaaFloat lumaN=FxaaLuma(FxaaTexOff(tex,posM,FxaaInt2(0,-1),fxaaQualityRcpFrame.xy));FxaaFloat lumaW=FxaaLuma(FxaaTexOff(tex,posM,FxaaInt2(-1,0),fxaaQualityRcpFrame.xy));FxaaFloat maxSM=max(lumaS,lumaM);FxaaFloat minSM=min(lumaS,lumaM);FxaaFloat maxESM=max(lumaE,maxSM);FxaaFloat minESM=min(lumaE,minSM);FxaaFloat maxWN=max(lumaN,lumaW);FxaaFloat minWN=min(lumaN,lumaW);FxaaFloat rangeMax=max(maxWN,maxESM);FxaaFloat rangeMin=min(minWN,minESM);FxaaFloat rangeMaxScaled=rangeMax*fxaaQualityEdgeThreshold;FxaaFloat range=rangeMax-rangeMin;FxaaFloat rangeMaxClamped=max(fxaaQualityEdgeThresholdMin,rangeMaxScaled);FxaaBool earlyExit=range<rangeMaxClamped;if(earlyExit)return rgbyM;FxaaFloat lumaNW=FxaaLuma(FxaaTexOff(tex,posM,FxaaInt2(-1,-1),fxaaQualityRcpFrame.xy));FxaaFloat lumaSE=FxaaLuma(FxaaTexOff(tex,posM,FxaaInt2(1,1),fxaaQualityRcpFrame.xy));FxaaFloat lumaNE=FxaaLuma(FxaaTexOff(tex,posM,FxaaInt2(1,-1),fxaaQualityRcpFrame.xy));FxaaFloat lumaSW=FxaaLuma(FxaaTexOff(tex,posM,FxaaInt2(-1,1),fxaaQualityRcpFrame.xy));FxaaFloat lumaNS=lumaN+lumaS;FxaaFloat lumaWE=lumaW+lumaE;FxaaFloat subpixRcpRange=1.0/range;FxaaFloat subpixNSWE=lumaNS+lumaWE;FxaaFloat edgeHorz1=(-2.0*lumaM)+lumaNS;FxaaFloat edgeVert1=(-2.0*lumaM)+lumaWE;FxaaFloat lumaNESE=lumaNE+lumaSE;FxaaFloat lumaNWNE=lumaNW+lumaNE;FxaaFloat edgeHorz2=(-2.0*lumaE)+lumaNESE;FxaaFloat edgeVert2=(-2.0*lumaN)+lumaNWNE;FxaaFloat lumaNWSW=lumaNW+lumaSW;FxaaFloat lumaSWSE=lumaSW+lumaSE;FxaaFloat edgeHorz4=(abs(edgeHorz1)*2.0)+abs(edgeHorz2);FxaaFloat edgeVert4=(abs(edgeVert1)*2.0)+abs(edgeVert2);FxaaFloat edgeHorz3=(-2.0*lumaW)+lumaNWSW;FxaaFloat edgeVert3=(-2.0*lumaS)+lumaSWSE;FxaaFloat edgeHorz=abs(edgeHorz3)+edgeHorz4;FxaaFloat edgeVert=abs(edgeVert3)+edgeVert4;FxaaFloat subpixNWSWNESE=lumaNWSW+lumaNESE;FxaaFloat lengthSign=fxaaQualityRcpFrame.x;FxaaBool horzSpan=edgeHorz>=edgeVert;FxaaFloat subpixA=subpixNSWE*2.0+subpixNWSWNESE;if(!horzSpan)lumaN=lumaW;if(!horzSpan)lumaS=lumaE;if(horzSpan)lengthSign=fxaaQualityRcpFrame.y;FxaaFloat subpixB=(subpixA*(1.0/12.0))-lumaM;FxaaFloat gradientN=lumaN-lumaM;FxaaFloat gradientS=lumaS-lumaM;FxaaFloat lumaNN=lumaN+lumaM;FxaaFloat lumaSS=lumaS+lumaM;FxaaBool pairN=abs(gradientN)>=abs(gradientS);FxaaFloat gradient=max(abs(gradientN),abs(gradientS));if(pairN)lengthSign=-lengthSign;FxaaFloat subpixC=FxaaSat(abs(subpixB)*subpixRcpRange);FxaaFloat2 posB;posB.x=posM.x;posB.y=posM.y;FxaaFloat2 offNP;offNP.x=(!horzSpan)? 0.0 : fxaaQualityRcpFrame.x;offNP.y=(horzSpan)? 0.0 : fxaaQualityRcpFrame.y;if(!horzSpan)posB.x+=lengthSign*0.5;if(horzSpan)posB.y+=lengthSign*0.5;FxaaFloat2 posN;posN.x=posB.x-offNP.x*FXAA_QUALITY_P0;posN.y=posB.y-offNP.y*FXAA_QUALITY_P0;FxaaFloat2 posP;posP.x=posB.x+offNP.x*FXAA_QUALITY_P0;posP.y=posB.y+offNP.y*FXAA_QUALITY_P0;FxaaFloat subpixD=((-2.0)*subpixC)+3.0;FxaaFloat lumaEndN=FxaaLuma(FxaaTexTop(tex,posN));FxaaFloat subpixE=subpixC*subpixC;FxaaFloat lumaEndP=FxaaLuma(FxaaTexTop(tex,posP));if(!pairN)lumaNN=lumaSS;FxaaFloat gradientScaled=gradient*1.0/4.0;FxaaFloat lumaMM=lumaM-lumaNN*0.5;FxaaFloat subpixF=subpixD*subpixE;FxaaBool lumaMLTZero=lumaMM<0.0;lumaEndN-=lumaNN*0.5;lumaEndP-=lumaNN*0.5;FxaaBool doneN=abs(lumaEndN)>=gradientScaled;FxaaBool doneP=abs(lumaEndP)>=gradientScaled;if(!doneN)posN.x-=offNP.x*FXAA_QUALITY_P1;if(!doneN)posN.y-=offNP.y*FXAA_QUALITY_P1;FxaaBool doneNP=(!doneN)||(!doneP);if(!doneP)posP.x+=offNP.x*FXAA_QUALITY_P1;if(!doneP)posP.y+=offNP.y*FXAA_QUALITY_P1;if(doneNP){if(!doneN)lumaEndN=FxaaLuma(FxaaTexTop(tex,posN.xy));if(!doneP)lumaEndP=FxaaLuma(FxaaTexTop(tex,posP.xy));if(!doneN)lumaEndN=lumaEndN-lumaNN*0.5;if(!doneP)lumaEndP=lumaEndP-lumaNN*0.5;doneN=abs(lumaEndN)>=gradientScaled;doneP=abs(lumaEndP)>=gradientScaled;if(!doneN)posN.x-=offNP.x*FXAA_QUALITY_P2;if(!doneN)posN.y-=offNP.y*FXAA_QUALITY_P2;doneNP=(!doneN)||(!doneP);if(!doneP)posP.x+=offNP.x*FXAA_QUALITY_P2;if(!doneP)posP.y+=offNP.y*FXAA_QUALITY_P2;\n#if (FXAA_QUALITY_PS > 3)\nif(doneNP){if(!doneN)lumaEndN=FxaaLuma(FxaaTexTop(tex,posN.xy));if(!doneP)lumaEndP=FxaaLuma(FxaaTexTop(tex,posP.xy));if(!doneN)lumaEndN=lumaEndN-lumaNN*0.5;if(!doneP)lumaEndP=lumaEndP-lumaNN*0.5;doneN=abs(lumaEndN)>=gradientScaled;doneP=abs(lumaEndP)>=gradientScaled;if(!doneN)posN.x-=offNP.x*FXAA_QUALITY_P3;if(!doneN)posN.y-=offNP.y*FXAA_QUALITY_P3;doneNP=(!doneN)||(!doneP);if(!doneP)posP.x+=offNP.x*FXAA_QUALITY_P3;if(!doneP)posP.y+=offNP.y*FXAA_QUALITY_P3;\n#if (FXAA_QUALITY_PS > 4)\nif(doneNP){if(!doneN)lumaEndN=FxaaLuma(FxaaTexTop(tex,posN.xy));if(!doneP)lumaEndP=FxaaLuma(FxaaTexTop(tex,posP.xy));if(!doneN)lumaEndN=lumaEndN-lumaNN*0.5;if(!doneP)lumaEndP=lumaEndP-lumaNN*0.5;doneN=abs(lumaEndN)>=gradientScaled;doneP=abs(lumaEndP)>=gradientScaled;if(!doneN)posN.x-=offNP.x*FXAA_QUALITY_P4;if(!doneN)posN.y-=offNP.y*FXAA_QUALITY_P4;doneNP=(!doneN)||(!doneP);if(!doneP)posP.x+=offNP.x*FXAA_QUALITY_P4;if(!doneP)posP.y+=offNP.y*FXAA_QUALITY_P4;\n#if (FXAA_QUALITY_PS > 5)\nif(doneNP){if(!doneN)lumaEndN=FxaaLuma(FxaaTexTop(tex,posN.xy));if(!doneP)lumaEndP=FxaaLuma(FxaaTexTop(tex,posP.xy));if(!doneN)lumaEndN=lumaEndN-lumaNN*0.5;if(!doneP)lumaEndP=lumaEndP-lumaNN*0.5;doneN=abs(lumaEndN)>=gradientScaled;doneP=abs(lumaEndP)>=gradientScaled;if(!doneN)posN.x-=offNP.x*FXAA_QUALITY_P5;if(!doneN)posN.y-=offNP.y*FXAA_QUALITY_P5;doneNP=(!doneN)||(!doneP);if(!doneP)posP.x+=offNP.x*FXAA_QUALITY_P5;if(!doneP)posP.y+=offNP.y*FXAA_QUALITY_P5;\n#if (FXAA_QUALITY_PS > 6)\nif(doneNP){if(!doneN)lumaEndN=FxaaLuma(FxaaTexTop(tex,posN.xy));if(!doneP)lumaEndP=FxaaLuma(FxaaTexTop(tex,posP.xy));if(!doneN)lumaEndN=lumaEndN-lumaNN*0.5;if(!doneP)lumaEndP=lumaEndP-lumaNN*0.5;doneN=abs(lumaEndN)>=gradientScaled;doneP=abs(lumaEndP)>=gradientScaled;if(!doneN)posN.x-=offNP.x*FXAA_QUALITY_P6;if(!doneN)posN.y-=offNP.y*FXAA_QUALITY_P6;doneNP=(!doneN)||(!doneP);if(!doneP)posP.x+=offNP.x*FXAA_QUALITY_P6;if(!doneP)posP.y+=offNP.y*FXAA_QUALITY_P6;\n#if (FXAA_QUALITY_PS > 7)\nif(doneNP){if(!doneN)lumaEndN=FxaaLuma(FxaaTexTop(tex,posN.xy));if(!doneP)lumaEndP=FxaaLuma(FxaaTexTop(tex,posP.xy));if(!doneN)lumaEndN=lumaEndN-lumaNN*0.5;if(!doneP)lumaEndP=lumaEndP-lumaNN*0.5;doneN=abs(lumaEndN)>=gradientScaled;doneP=abs(lumaEndP)>=gradientScaled;if(!doneN)posN.x-=offNP.x*FXAA_QUALITY_P7;if(!doneN)posN.y-=offNP.y*FXAA_QUALITY_P7;doneNP=(!doneN)||(!doneP);if(!doneP)posP.x+=offNP.x*FXAA_QUALITY_P7;if(!doneP)posP.y+=offNP.y*FXAA_QUALITY_P7;\n#if (FXAA_QUALITY_PS > 8)\nif(doneNP){if(!doneN)lumaEndN=FxaaLuma(FxaaTexTop(tex,posN.xy));if(!doneP)lumaEndP=FxaaLuma(FxaaTexTop(tex,posP.xy));if(!doneN)lumaEndN=lumaEndN-lumaNN*0.5;if(!doneP)lumaEndP=lumaEndP-lumaNN*0.5;doneN=abs(lumaEndN)>=gradientScaled;doneP=abs(lumaEndP)>=gradientScaled;if(!doneN)posN.x-=offNP.x*FXAA_QUALITY_P8;if(!doneN)posN.y-=offNP.y*FXAA_QUALITY_P8;doneNP=(!doneN)||(!doneP);if(!doneP)posP.x+=offNP.x*FXAA_QUALITY_P8;if(!doneP)posP.y+=offNP.y*FXAA_QUALITY_P8;\n#if (FXAA_QUALITY_PS > 9)\nif(doneNP){if(!doneN)lumaEndN=FxaaLuma(FxaaTexTop(tex,posN.xy));if(!doneP)lumaEndP=FxaaLuma(FxaaTexTop(tex,posP.xy));if(!doneN)lumaEndN=lumaEndN-lumaNN*0.5;if(!doneP)lumaEndP=lumaEndP-lumaNN*0.5;doneN=abs(lumaEndN)>=gradientScaled;doneP=abs(lumaEndP)>=gradientScaled;if(!doneN)posN.x-=offNP.x*FXAA_QUALITY_P9;if(!doneN)posN.y-=offNP.y*FXAA_QUALITY_P9;doneNP=(!doneN)||(!doneP);if(!doneP)posP.x+=offNP.x*FXAA_QUALITY_P9;if(!doneP)posP.y+=offNP.y*FXAA_QUALITY_P9;\n#if (FXAA_QUALITY_PS > 10)\nif(doneNP){if(!doneN)lumaEndN=FxaaLuma(FxaaTexTop(tex,posN.xy));if(!doneP)lumaEndP=FxaaLuma(FxaaTexTop(tex,posP.xy));if(!doneN)lumaEndN=lumaEndN-lumaNN*0.5;if(!doneP)lumaEndP=lumaEndP-lumaNN*0.5;doneN=abs(lumaEndN)>=gradientScaled;doneP=abs(lumaEndP)>=gradientScaled;if(!doneN)posN.x-=offNP.x*FXAA_QUALITY_P10;if(!doneN)posN.y-=offNP.y*FXAA_QUALITY_P10;doneNP=(!doneN)||(!doneP);if(!doneP)posP.x+=offNP.x*FXAA_QUALITY_P10;if(!doneP)posP.y+=offNP.y*FXAA_QUALITY_P10;\n#if (FXAA_QUALITY_PS > 11)\nif(doneNP){if(!doneN)lumaEndN=FxaaLuma(FxaaTexTop(tex,posN.xy));if(!doneP)lumaEndP=FxaaLuma(FxaaTexTop(tex,posP.xy));if(!doneN)lumaEndN=lumaEndN-lumaNN*0.5;if(!doneP)lumaEndP=lumaEndP-lumaNN*0.5;doneN=abs(lumaEndN)>=gradientScaled;doneP=abs(lumaEndP)>=gradientScaled;if(!doneN)posN.x-=offNP.x*FXAA_QUALITY_P11;if(!doneN)posN.y-=offNP.y*FXAA_QUALITY_P11;doneNP=(!doneN)||(!doneP);if(!doneP)posP.x+=offNP.x*FXAA_QUALITY_P11;if(!doneP)posP.y+=offNP.y*FXAA_QUALITY_P11;\n#if (FXAA_QUALITY_PS > 12)\nif(doneNP){if(!doneN)lumaEndN=FxaaLuma(FxaaTexTop(tex,posN.xy));if(!doneP)lumaEndP=FxaaLuma(FxaaTexTop(tex,posP.xy));if(!doneN)lumaEndN=lumaEndN-lumaNN*0.5;if(!doneP)lumaEndP=lumaEndP-lumaNN*0.5;doneN=abs(lumaEndN)>=gradientScaled;doneP=abs(lumaEndP)>=gradientScaled;if(!doneN)posN.x-=offNP.x*FXAA_QUALITY_P12;if(!doneN)posN.y-=offNP.y*FXAA_QUALITY_P12;doneNP=(!doneN)||(!doneP);if(!doneP)posP.x+=offNP.x*FXAA_QUALITY_P12;if(!doneP)posP.y+=offNP.y*FXAA_QUALITY_P12;}\n#endif\n}\n#endif\n}\n#endif\n}\n#endif\n}\n#endif\n}\n#endif\n}\n#endif\n}\n#endif\n}\n#endif\n}\n#endif\n}FxaaFloat dstN=posM.x-posN.x;FxaaFloat dstP=posP.x-posM.x;if(!horzSpan)dstN=posM.y-posN.y;if(!horzSpan)dstP=posP.y-posM.y;FxaaBool goodSpanN=(lumaEndN<0.0)!=lumaMLTZero;FxaaFloat spanLength=(dstP+dstN);FxaaBool goodSpanP=(lumaEndP<0.0)!=lumaMLTZero;FxaaFloat spanLengthRcp=1.0/spanLength;FxaaBool directionN=dstN<dstP;FxaaFloat dst=min(dstN,dstP);FxaaBool goodSpan=directionN ? goodSpanN : goodSpanP;FxaaFloat subpixG=subpixF*subpixF;FxaaFloat pixelOffset=(dst*(-spanLengthRcp))+0.5;FxaaFloat subpixH=subpixG*fxaaQualitySubpix;FxaaFloat pixelOffsetGood=goodSpan ? pixelOffset : 0.0;FxaaFloat pixelOffsetSubpix=max(pixelOffsetGood,subpixH);if(!horzSpan)posM.x+=pixelOffsetSubpix*lengthSign;if(horzSpan)posM.y+=pixelOffsetSubpix*lengthSign;return FxaaFloat4(FxaaTexTop(tex,posM).xyz,lumaM);}',
      fn_getBlinnPhongColor:
        '#define GLSLIFY 1\nvec4 getBlinnPhongColor(vec3 normal,vec3 world_pos,vec3 lightPos,vec3 lightColor,vec3 camPos,vec3 Ka,vec3 Kd,vec3 Ks,vec4 texColor,float shininess){vec3 N=normalize(normal);vec3 L=normalize(lightPos);vec3 V=normalize(camPos-world_pos);vec3 H=normalize(L+V);vec3 ambient=Ka*lightColor;float dv=dot(N,L);float diffuseLight=max(dot(N,L),0.);vec3 diffuse=Kd*lightColor*diffuseLight;if(dv<0.){ambient*=(1.+dv*4.0);diffuse*=4.0;}float specularLight=pow(max(dot(H,N),0.),32.*shininess);if(diffuseLight<=0.)specularLight=0.;vec3 specular=Ks*lightColor*specularLight;vec4 color=vec4(1.0);color.xyz=texColor.xyz*(ambient+diffuse+specular);color.w=texColor.a;return color;}',
      fn_phong:
        '#define GLSLIFY 1\n#include <u_LIGHT>\n#include <v_LIGHT>\n#ifdef M_enableLight\n#ifdef M_PointLight\n#ifdef M_ShadowEnable\nfloat getDepthFromDiffPointInfo(int pointNum,vec3 direction){\n#if M_PointLightCount > 5\nif(pointNum==0){return textureCube(u_PointLightDepthCubeTexture0,direction).r;}else if(pointNum==1){return textureCube(u_PointLightDepthCubeTexture1,direction).r;}else if(pointNum==2){return textureCube(u_PointLightDepthCubeTexture2,direction).r;}else if(pointNum==3){return textureCube(u_PointLightDepthCubeTexture3,direction).r;}else if(pointNum==4){return textureCube(u_PointLightDepthCubeTexture4,direction).r;}else if(pointNum==5){return textureCube(u_PointLightDepthCubeTexture5,direction).r;}\n#endif\n#if M_PointLightCount > 4\nif(pointNum==0){return textureCube(u_PointLightDepthCubeTexture0,direction).r;}else if(pointNum==1){return textureCube(u_PointLightDepthCubeTexture1,direction).r;}else if(pointNum==2){return textureCube(u_PointLightDepthCubeTexture2,direction).r;}else if(pointNum==3){return textureCube(u_PointLightDepthCubeTexture3,direction).r;}else if(pointNum==4){return textureCube(u_PointLightDepthCubeTexture4,direction).r;}\n#endif\n#if M_PointLightCount > 3\nif(pointNum==0){return textureCube(u_PointLightDepthCubeTexture0,direction).r;}else if(pointNum==1){return textureCube(u_PointLightDepthCubeTexture1,direction).r;}else if(pointNum==2){return textureCube(u_PointLightDepthCubeTexture2,direction).r;}else if(pointNum==3){return textureCube(u_PointLightDepthCubeTexture3,direction).r;}\n#endif\n#if M_PointLightCount > 2\nif(pointNum==0){return textureCube(u_PointLightDepthCubeTexture0,direction).r;}else if(pointNum==1){return textureCube(u_PointLightDepthCubeTexture1,direction).r;}else if(pointNum==2){return textureCube(u_PointLightDepthCubeTexture2,direction).r;}\n#endif\n#if M_PointLightCount > 1\nif(pointNum==0){return textureCube(u_PointLightDepthCubeTexture0,direction).r;}else if(pointNum==1){return textureCube(u_PointLightDepthCubeTexture1,direction).r;}\n#endif\nreturn textureCube(u_PointLightDepthCubeTexture0,direction).r;}\n#endif\n#endif\n#endif\nvec3 phong(vec3 pos,vec3 tnormal,LightMaterial lightMaterial,vec3 lightDirection,vec3 cameraPosition){vec3 ambient=lightMaterial.Ambient;vec3 norm=normalize(tnormal);vec3 lightDir=normalize(lightDirection);float diff=max(dot(norm,lightDir),0.0);vec3 diffuse=lightMaterial.Diffuse*diff;vec3 viewDir=normalize(cameraPosition-pos);vec3 reflectDir=reflect(-lightDir,norm);float spec=pow(max(dot(viewDir,reflectDir),0.0),lightMaterial.Shininess);vec3 specular=lightMaterial.SpecularColor*spec;vec3 fColor=ambient+diffuse+specular;return fColor;}vec3 phong(float reflectivity,vec3 normal,vec3 sunLightGlobal,vec3 worldPosition,float shininess){vec3 ambient=vec3(0.0,0.0,0.0);vec3 diffuse=vec3(0.0,0.0,0.0);vec3 specular=vec3(0.0,0.0,.0);\n#ifdef M_enableLight\n#ifdef M_AmbientLight\nfor(int i=0;i<int(M_AmbientLightCount);++i){vec3 ambientColor=vec3(u_AmbientLightsColor[i*3],u_AmbientLightsColor[i*3+1],u_AmbientLightsColor[i*3+2]);float ambientIntensity=u_AmbientLightsIntensity[i];ambient=ambient+ambientIntensity*reflectivity*ambientColor;}\n#endif\n#ifdef M_SunLight\nif(u_SunLightDirectionLocal.z>0.0){diffuse=diffuse+reflectivity*max(dot(normal,sunLightGlobal),0.)*u_SunLightColor*u_SunLightIntensity;}\n#endif\n#ifdef M_SunLight\nvec3 H=normalize(sunLightGlobal+normalize(u_CameraPosition-worldPosition));specular=specular+reflectivity*pow(max(dot(H,normal),0.),shininess)*u_SunLightColor*u_SunLightIntensity;\n#endif\n#ifdef M_DirectionalLight\nfor(int i=0;i<int(M_DirectionalLightCount);++i){vec3 directLightColor=vec3(u_DirectionalLightColor[i*3],u_DirectionalLightColor[i*3+1],u_DirectionalLightColor[i*3+2]);float directLightIntensity=u_DirectionalLightIntensity[i];vec3 directLightDir=vec3(u_DirectionalLightDir[i*3],u_DirectionalLightDir[i*3+1],u_DirectionalLightDir[i*3+2]);diffuse=diffuse+reflectivity*max(dot(normal,directLightDir),0.)*directLightColor*directLightIntensity;vec3 H=normalize(directLightDir+normalize(u_CameraPosition-worldPosition));specular=specular+reflectivity*pow(max(dot(H,normal),0.),shininess)*directLightColor*directLightIntensity;}\n#endif\n#ifdef M_PointLight\nfor(int i=0;i<int(M_PointLightCount);i++){float pointShadow=1.0;vec3 pointLightPosition=vec3(u_PointLightPosition[i*3],u_PointLightPosition[i*3+1],u_PointLightPosition[i*3+2]);float dis=distance(pointLightPosition,worldPosition);float pointLightIntensity=u_PointLightIntensity[i];float pointFragIntensity=pointLightIntensity*1000.0/(dis*dis);if(pointFragIntensity<0.1){continue;}\n#ifdef M_ShadowEnable\nif(i>5){pointShadow=1.0;}else{\n#ifdef M_ShadowMapping\nfloat depth=getDepthFromDiffPointInfo(i,normalize(v_PointDirection[i]));vec3 light=vec3(u_PointLightPosition[i*3],u_PointLightPosition[i*3+1],u_PointLightPosition[i*3+2]);if((dis/u_PointLightFar[i])-u_PointLightEpsilon[i]>depth){pointShadow=0.3;}\n#else\n#ifdef M_PCF\nfloat shadow=0.0;float diskRadius=u_DiskRadius[i];vec3 sampleOffsetDirections[20];sampleOffsetDirections[0]=vec3(1,1,1);sampleOffsetDirections[1]=vec3(1,-1,1);sampleOffsetDirections[2]=vec3(-1,-1,1);sampleOffsetDirections[3]=vec3(-1,1,1);sampleOffsetDirections[4]=vec3(1,1,-1);sampleOffsetDirections[5]=vec3(1,-1,-1);sampleOffsetDirections[6]=vec3(-1,-1,-1);sampleOffsetDirections[7]=vec3(-1,1,-1);sampleOffsetDirections[8]=vec3(1,1,0);sampleOffsetDirections[9]=vec3(1,-1,0);sampleOffsetDirections[10]=vec3(-1,-1,0);sampleOffsetDirections[11]=vec3(-1,1,0);sampleOffsetDirections[12]=vec3(1,0,1);sampleOffsetDirections[13]=vec3(-1,0,1);sampleOffsetDirections[14]=vec3(1,0,-1);sampleOffsetDirections[15]=vec3(-1,0,-1);sampleOffsetDirections[16]=vec3(0,1,1);sampleOffsetDirections[17]=vec3(0,-1,1);sampleOffsetDirections[18]=vec3(0,-1,-1);sampleOffsetDirections[19]=vec3(0,1,-1);for(int j=0;j<20;j++){vec3 pointDirection=normalize(v_PointDirection[i])+sampleOffsetDirections[j]*diskRadius;float depth=getDepthFromDiffPointInfo(i,pointDirection);vec3 light=vec3(u_PointLightPosition[i*3],u_PointLightPosition[i*3+1],u_PointLightPosition[i*3+2]);if((dis/u_PointLightFar[i])-u_PointLightEpsilon[i]>depth){shadow=shadow+1.0;}}pointShadow=1.0-0.7*shadow/20.0;\n#endif\n#endif\n}\n#endif\nvec3 pointLightColor=vec3(u_PointLightColor[i*3],u_PointLightColor[i*3+1],u_PointLightColor[i*3+2]);vec3 pointLightDir=normalize(pointLightPosition-worldPosition);diffuse=diffuse+reflectivity*max(dot(normal,pointLightDir),0.)*pointLightColor*pointFragIntensity*pointShadow;vec3 H=normalize(pointLightDir+normalize(u_CameraPosition-worldPosition));specular=specular+reflectivity*pow(max(dot(H,normal),0.),shininess)*pointLightColor*pointFragIntensity*pointShadow;}\n#endif\n#endif\nreturn ambient+diffuse+specular;}vec3 phong(float reflectivity,vec3 normal,vec3 sunLightGlobal,vec3 worldPosition,float shininess,float roughness){vec3 ambient=vec3(0.0,0.0,0.0);vec3 diffuse=vec3(0.0,0.0,0.0);vec3 specular=vec3(0.0,0.0,.0);\n#ifdef M_enableLight\n#ifdef M_AmbientLight\nfor(int i=0;i<int(M_AmbientLightCount);++i){vec3 ambientColor=vec3(u_AmbientLightsColor[i*3],u_AmbientLightsColor[i*3+1],u_AmbientLightsColor[i*3+2]);float ambientIntensity=u_AmbientLightsIntensity[i];ambient=ambient+ambientIntensity*reflectivity*ambientColor;}\n#endif\n#ifdef M_SunLight\nif(u_SunLightDirectionLocal.z>0.0){diffuse=diffuse+reflectivity*max(dot(normal,sunLightGlobal),0.)*u_SunLightColor*u_SunLightIntensity;diffuse=(1.0-roughness)*diffuse;}\n#endif\n#ifdef M_SunLight\nvec3 H=normalize(sunLightGlobal+normalize(u_CameraPosition-worldPosition));specular=specular+reflectivity*pow(max(dot(H,normal),0.),shininess)*u_SunLightColor*u_SunLightIntensity;specular=0.16*reflectivity*reflectivity*roughness+specular*(1.0-roughness);\n#endif\n#ifdef M_DirectionalLight\nfor(int i=0;i<int(M_DirectionalLightCount);++i){vec3 directLightColor=vec3(u_DirectionalLightColor[i*3],u_DirectionalLightColor[i*3+1],u_DirectionalLightColor[i*3+2]);float directLightIntensity=u_DirectionalLightIntensity[i];vec3 directLightDir=vec3(u_DirectionalLightDir[i*3],u_DirectionalLightDir[i*3+1],u_DirectionalLightDir[i*3+2]);diffuse=diffuse+reflectivity*max(dot(normal,directLightDir),0.)*directLightColor*directLightIntensity;diffuse=(1.0-roughness)*diffuse;vec3 H=normalize(directLightDir+normalize(u_CameraPosition-worldPosition));specular=specular+reflectivity*pow(max(dot(H,normal),0.),shininess)*directLightColor*directLightIntensity;specular=0.16*reflectivity*reflectivity*roughness+specular*(1.0-roughness);}\n#endif\n#ifdef M_PointLight\nfor(int i=0;i<int(M_PointLightCount);i++){float pointShadow=1.0;vec3 pointLightPosition=vec3(u_PointLightPosition[i*3],u_PointLightPosition[i*3+1],u_PointLightPosition[i*3+2]);float dis=distance(pointLightPosition,worldPosition);float pointLightIntensity=u_PointLightIntensity[i];float pointFragIntensity=pointLightIntensity*1000.0/(dis*dis);if(pointFragIntensity<0.1){continue;}\n#ifdef M_ShadowEnable\nif(i>5){pointShadow=1.0;}else{\n#ifdef M_ShadowMapping\nfloat depth=getDepthFromDiffPointInfo(i,normalize(v_PointDirection[i]));vec3 light=vec3(u_PointLightPosition[i*3],u_PointLightPosition[i*3+1],u_PointLightPosition[i*3+2]);if((dis/u_PointLightFar[i])-u_PointLightEpsilon[i]>depth){pointShadow=0.3;}\n#else\n#ifdef M_PCF\nfloat shadow=0.0;float diskRadius=u_DiskRadius[i];vec3 sampleOffsetDirections[20];sampleOffsetDirections[0]=vec3(1,1,1);sampleOffsetDirections[1]=vec3(1,-1,1);sampleOffsetDirections[2]=vec3(-1,-1,1);sampleOffsetDirections[3]=vec3(-1,1,1);sampleOffsetDirections[4]=vec3(1,1,-1);sampleOffsetDirections[5]=vec3(1,-1,-1);sampleOffsetDirections[6]=vec3(-1,-1,-1);sampleOffsetDirections[7]=vec3(-1,1,-1);sampleOffsetDirections[8]=vec3(1,1,0);sampleOffsetDirections[9]=vec3(1,-1,0);sampleOffsetDirections[10]=vec3(-1,-1,0);sampleOffsetDirections[11]=vec3(-1,1,0);sampleOffsetDirections[12]=vec3(1,0,1);sampleOffsetDirections[13]=vec3(-1,0,1);sampleOffsetDirections[14]=vec3(1,0,-1);sampleOffsetDirections[15]=vec3(-1,0,-1);sampleOffsetDirections[16]=vec3(0,1,1);sampleOffsetDirections[17]=vec3(0,-1,1);sampleOffsetDirections[18]=vec3(0,-1,-1);sampleOffsetDirections[19]=vec3(0,1,-1);for(int j=0;j<20;j++){vec3 pointDirection=normalize(v_PointDirection[i])+sampleOffsetDirections[j]*diskRadius;float depth=getDepthFromDiffPointInfo(i,pointDirection);vec3 light=vec3(u_PointLightPosition[i*3],u_PointLightPosition[i*3+1],u_PointLightPosition[i*3+2]);if((dis/u_PointLightFar[i])-u_PointLightEpsilon[i]>depth){shadow=shadow+1.0;}}pointShadow=1.0-0.7*shadow/20.0;\n#endif\n#endif\n}\n#endif\nvec3 pointLightColor=vec3(u_PointLightColor[i*3],u_PointLightColor[i*3+1],u_PointLightColor[i*3+2]);vec3 pointLightDir=normalize(pointLightPosition-worldPosition);diffuse=diffuse+reflectivity*max(dot(normal,pointLightDir),0.)*pointLightColor*pointFragIntensity*pointShadow;diffuse=(1.0-roughness)*diffuse;vec3 H=normalize(pointLightDir+normalize(u_CameraPosition-worldPosition));specular=specular+reflectivity*pow(max(dot(H,normal),0.),shininess)*pointLightColor*pointFragIntensity*pointShadow;specular=0.16*reflectivity*reflectivity*roughness+specular*(1.0-roughness);}\n#endif\n#endif\nreturn ambient+diffuse+specular;}vec3 ambient(){vec3 ambient=vec3(0.0,0.0,0.0);\n#ifdef M_enableLight\n#ifdef M_AmbientLight\nfor(int i=0;i<int(M_AmbientLightCount);++i){vec3 ambientColor=vec3(u_AmbientLightsColor[i*3],u_AmbientLightsColor[i*3+1],u_AmbientLightsColor[i*3+2]);float ambientIntensity=u_AmbientLightsIntensity[i];ambient=ambient+ambientIntensity*1.0*ambientColor;}\n#endif\n#endif\nreturn ambient;}',
      fn_reverseLogDepth:
        '#define GLSLIFY 1\n#ifndef _REVERSE_LOG_DEPTH_\n#define _REVERSE_LOG_DEPTH_\nfloat reverseLogDepth(float logZ,vec2 currentFrustum){float near=currentFrustum.x;float far=currentFrustum.y;float farDepthFromNearPlusOne=currentFrustum.y-currentFrustum.x+1.0;float log2FarDepthFromNearPlusOne=log2(farDepthFromNearPlusOne);float log2Depth=logZ*log2FarDepthFromNearPlusOne;float depthFromNear=pow(2.0,log2Depth)-1.0;return far*(1.0-near/(depthFromNear+near))/(far-near);}float reverseLogDepth(float logZ){\n#ifdef M_LOG_DEPTH\nfloat near=czm_currentFrustum.x;float far=czm_currentFrustum.y;float log2Depth=logZ*czm_log2FarDepthFromNearPlusOne;float depthFromNear=pow(2.0,log2Depth)-1.0;return far*(1.0-near/(depthFromNear+near))/(far-near);\n#endif\nreturn logZ;}\n#endif\n',
      fn_RGBToHSB:
        '#define GLSLIFY 1\nconst vec4 K_RGB2HSB=vec4(0.0,-1.0/3.0,2.0/3.0,-1.0);vec3 RGBToHSB(vec3 rgb){vec4 p=mix(vec4(rgb.bg,K_RGB2HSB.wz),vec4(rgb.gb,K_RGB2HSB.xy),step(rgb.b,rgb.g));vec4 q=mix(vec4(p.xyw,rgb.r),vec4(rgb.r,p.yzx),step(p.x,rgb.r));float d=q.x-min(q.w,q.y);return vec3(abs(q.z+(q.w-q.y)/(6.0*d+czm_epsilon7)),d/(q.x+czm_epsilon7),q.x);}',
      fn_RGBToHSL:
        '#define GLSLIFY 1\nvec3 RGBtoHCV(vec3 rgb){vec4 p=(rgb.g<rgb.b)? vec4(rgb.bg,-1.0,2.0/3.0): vec4(rgb.gb,0.0,-1.0/3.0);vec4 q=(rgb.r<p.x)? vec4(p.xyw,rgb.r): vec4(rgb.r,p.yzx);float c=q.x-min(q.w,q.y);float h=abs((q.w-q.y)/(6.0*c+czm_epsilon7)+q.z);return vec3(h,c,q.x);}vec3 RGBToHSL(vec3 rgb){vec3 hcv=RGBtoHCV(rgb);float l=hcv.z-hcv.y*0.5;float s=hcv.y/(1.0-abs(l*2.0-1.0)+czm_epsilon7);return vec3(hcv.x,s,l);}',
      fn_RGBToXYZ:
        '#define GLSLIFY 1\nvec3 RGBToXYZ(vec3 rgb){const mat3 RGB2XYZ=mat3(0.4124,0.2126,0.0193,0.3576,0.7152,0.1192,0.1805,0.0722,0.9505);vec3 xyz=RGB2XYZ*rgb;vec3 Yxy;Yxy.r=xyz.g;float temp=dot(vec3(1.0),xyz);Yxy.gb=xyz.rg/temp;return Yxy;}',
      fn_vertexLogDepth:
        '#define GLSLIFY 1\nvec4 updatePositionDepth(vec4 coords){coords.z=clamp(coords.z/coords.w,-1.0,1.0)*coords.w;return coords;}float vertexLogDepth(vec2 currentFrustum){gl_Position=updatePositionDepth(gl_Position);float depthFromNearPlusOne=(gl_Position.w-currentFrustum.x)+1.0;return depthFromNearPlusOne;}',
      fn_webMercatorInTileCoordToLngLat:
        '#define GLSLIFY 1\n#ifndef _fn_webMercatorInTileCoordToLngLat_\n#define _fn_webMercatorInTileCoordToLngLat_\nvec2 webMercatorInTileCoordToLngLatDegree(vec2 inTileCoord,vec3 tileCoordXYZ){vec2 coord=vec2(inTileCoord.x+tileCoordXYZ.x,inTileCoord.y+tileCoordXYZ.y);float worldSize=pow(2.0,tileCoordXYZ.z);float lng=(coord.x*360.0)/worldSize-180.0;float y2=180.-(coord.y*360.)/worldSize;float lat=(360./PI)*atan(exp((y2*PI)/180.0))-90.0;return vec2(lng,lat);}vec2 webMercatorInTileCoordToLngLatRadian(vec2 inTileCoord,vec3 tileCoordXYZ){vec2 coord=vec2(inTileCoord.x+tileCoordXYZ.x,inTileCoord.y+tileCoordXYZ.y);float worldSize=pow(2.0,tileCoordXYZ.z);float lng=(coord.x*360.0)/worldSize-180.0;float y2=180.-(coord.y*360.)/worldSize;float lat=(360./PI)*atan(exp((y2*PI)/180.0))-90.0;return vec2(lng*PI/180.0,lat*PI/180.0);}\n#endif\n',
      fn_writeLogDepth:
        '#define GLSLIFY 1\nvoid writeLogDepth(float depth,vec2 currentFrustum){float farDepthFromNearPlusOne=currentFrustum.y-currentFrustum.x+1.0;float log2FarDepthFromNearPlusOne=log2(farDepthFromNearPlusOne);float oneOverLog2FarDepthFromNearPlusOne=1.0/log2FarDepthFromNearPlusOne;if(depth<=0.9999999||depth>farDepthFromNearPlusOne){discard;}\n#ifdef M_DEPTH_EXT\ngl_FragDepthEXT=log2(depth)*oneOverLog2FarDepthFromNearPlusOne;\n#endif\n}',
      fn_atan2:
        '#define GLSLIFY 1\n#ifndef _fn_atan2_\n#define _fn_atan2_\nfloat fn_atan2(float dx,float dy){float ax=abs(dx),ay=abs(dy);float a=min(ax,ay)/(max(ax,ay)+0.00000001);float s=a*a;float r=((-0.0464964749*s+0.15931422)*s-0.327622764)*s*a+a;if(ay>ax)r=1.57079637-r;if(dx<0.)r=3.14159274-r;if(dy<0.)r=-r;return r;}\n#endif\n',
      fn_decodeFloat:
        '#define GLSLIFY 1\n#ifndef _DECODE_FLOAT_\n#define _DECODE_FLOAT_\nfloat unpackDepth(const in vec4 rgbaDepth){const vec4 bitShift=vec4(1.0,1./255.0,1./65025.0,1./16581375.0);float depth=dot(rgbaDepth,bitShift);return depth;}\n#endif\n',
      fn_encodeFloat:
        '#define GLSLIFY 1\n#ifndef _ENCODE_FLOAT_\n#define _ENCODE_FLOAT_\nvec4 encodeFloat(float depth){vec4 enc=vec4(1.0,255.0,65025.0,16581375.0)*depth;enc=fract(enc);enc-=enc.yzww*vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);return enc;}\n#endif\n',
      fn_transformCartesianToGeographic:
        '#define GLSLIFY 1\n#ifndef _fn_transformCartesianToGeographic_\n#define _fn_transformCartesianToGeographic_\nconst float a=6378137.0;const float b=6356752.3142;const float f=(a-b)/a;const float e_sq=2.0*f-f*f;vec3 transformCartesianToGeographicDegree(vec3 cartesianCoords){float x=cartesianCoords.x;float y=cartesianCoords.y;float z=cartesianCoords.z;float lon=atan(y,x);float p=sqrt(x*x+y*y);float lat=atan(z/(p*(1.0-e_sq)));float sinLat=sin(lat);float N=a/sqrt(1.0-e_sq*sinLat*sinLat);float alt=(p/cos(lat))-N;return vec3(degrees(lon),degrees(lat),alt);}vec3 transformCartesianToGeographicRadian(vec3 cartesianCoords){float x=cartesianCoords.x;float y=cartesianCoords.y;float z=cartesianCoords.z;float lon=atan(y,x);float p=sqrt(x*x+y*y);float lat=atan(z/(p*(1.0-e_sq)));float sinLat=sin(lat);float N=a/sqrt(1.0-e_sq*sinLat*sinLat);float alt=(p/cos(lat))-N;return vec3(lon,lat,alt);}\n#endif\n',
      fn_transformGeographicToCartesian:
        '#define GLSLIFY 1\n#ifndef _fn_transformGeographicToCartesian_\n#define _fn_transformGeographicToCartesian_\nvec3 transformGeographicInDegreeToCartesian(vec3 cartographic){float longitude=cartographic.x;float latitude=cartographic.y;float height=cartographic.z;const float semiMajorAxis=6378137.0;const float flattening=1.0/298.257223563;float cosLatitude=cos(radians(latitude));float sinLatitude=sin(radians(latitude));float cosLongitude=cos(radians(longitude));float sinLongitude=sin(radians(longitude));float C=1.0/sqrt(cosLatitude*cosLatitude+(1.0-flattening)*(1.0-flattening)*sinLatitude*sinLatitude);float S=C*(1.0-flattening)*(1.0-flattening);float x=(semiMajorAxis*C+height)*cosLatitude*cosLongitude;float y=(semiMajorAxis*C+height)*cosLatitude*sinLongitude;float z=(semiMajorAxis*S+height)*sinLatitude;return vec3(x,y,z);}vec3 transformGeographicInRadianToCartesian(vec3 cartographic){float longitude=cartographic.x;float latitude=cartographic.y;float height=cartographic.z;const float semiMajorAxis=6378137.0;const float flattening=1.0/298.257223563;float cosLatitude=cos(latitude);float sinLatitude=sin(latitude);float cosLongitude=cos(longitude);float sinLongitude=sin(longitude);float C=1.0/sqrt(cosLatitude*cosLatitude+(1.0-flattening)*(1.0-flattening)*sinLatitude*sinLatitude);float S=C*(1.0-flattening)*(1.0-flattening);float x=(semiMajorAxis*C+height)*cosLatitude*cosLongitude;float y=(semiMajorAxis*C+height)*cosLatitude*sinLongitude;float z=(semiMajorAxis*S+height)*sinLatitude;return vec3(x,y,z);}\n#endif\n',
      fn_lngLatProjectionInTileCoordToLngLat:
        '#define GLSLIFY 1\n#ifndef _fn_lngLatProjectionInTileCoordToLngLat_\n#define _fn_lngLatProjectionInTileCoordToLngLat_\nvec2 lngLatProjectionInTileCoordToLngLatDegree(vec2 inTileCoord,vec3 tileCoordXYZ){vec2 coord=vec2(inTileCoord.x+tileCoordXYZ.x,inTileCoord.y+tileCoordXYZ.y);float worldSize=pow(2.0,tileCoordXYZ.z);float lng=(coord.x*360.0)/worldSize-180.0;float lat=90.0-(coord.y/(0.5*worldSize))*180.0;return vec2(lng,lat);}vec2 lngLatProjectionInTileCoordToLngLatRadian(vec2 inTileCoord,vec3 tileCoordXYZ){vec2 coord=vec2(inTileCoord.x+tileCoordXYZ.x,inTileCoord.y+tileCoordXYZ.y);float worldSize=pow(2.0,tileCoordXYZ.z);float lng=(coord.x*360.0)/worldSize-180.0;float lat=90.0-(coord.y/(0.5*worldSize))*180.0;return vec2(lng*PI/180.0,lat*PI/180.0);}\n#endif\n',
      fn_lngLatToWebMercatorInTileCoord:
        '#define GLSLIFY 1\n#ifndef _fn_lngLatToWebMercatorInTileCoord_\n#define _fn_lngLatToWebMercatorInTileCoord_\nvec2 lngLatDegreeToWebMercatorTileCoord(vec2 lngLat,vec3 tileCoordXYZ){float worldSize=pow(2.0,tileCoordXYZ[2]);float x=(180.0+lngLat.x)*worldSize/360.0;float y=180.0/PI*log(tan(PI/4.0+lngLat.y*PI/360.0));y=(180.-y)*worldSize/360.0;return vec2(x-tileCoordXYZ[0],y-tileCoordXYZ[1]);}vec2 lngLatRadianToWebMercatorTileCoord(vec2 lngLat,vec3 tileCoordXYZ){float worldSize=pow(2.0,tileCoordXYZ[2]);float x=(180.0+lngLat.x/PI*180.0)*worldSize/360.0;float y=180.0/PI*log(tan(PI/4.0+lngLat.y));y=(180.-y)*worldSize/360.0;return vec2(x-tileCoordXYZ[0],y-tileCoordXYZ[1]);}\n#endif\n',
      fn_lngLatToLngLatProjectionInTileCoord:
        '#define GLSLIFY 1\n#ifndef _fn_lngLatToLngLatProjectionInTileCoord_\n#define _fn_lngLatToLngLatProjectionInTileCoord_\nvec2 lngLatInDegreeToLngLatProjectionInTileCoord(vec2 lngLat,vec3 tileCoordXYZ){float worldSize=pow(2.0,tileCoordXYZ[2]);float x=(180.0+lngLat.x)*worldSize/360.0;float y=(90.0-lngLat.y)/180.0*worldSize*0.5;return vec2(x-tileCoordXYZ[0],y-tileCoordXYZ[1]);}vec2 lngLatInRadianToLngLatProjectionInTileCoord(vec2 lngLat,vec3 tileCoordXYZ){float worldSize=pow(2.0,tileCoordXYZ[2]);float x=(180.0+lngLat.x*180.0/PI)*worldSize/360.0;float y=(90.0-lngLat.y*180.0/PI)/180.0*worldSize*0.5;return vec2(x-tileCoordXYZ[0],y-tileCoordXYZ[1]);}\n#endif\n',
      fn_luminance:
        '#define GLSLIFY 1\nfloat luminance(vec3 rgb){const vec3 W=vec3(0.2125,0.7154,0.0721);return dot(rgb,W);}',
      fn_createRotateMat4:
        '#define GLSLIFY 1\nmat4 createRotateMat4(float rad,vec3 axis){float x=axis[0],y=axis[1],z=axis[2];float len=sqrt(x*x+y*y+z*z);float s,c,t;float a00,a01,a02,a03;float a10,a11,a12,a13;float a20,a21,a22,a23;float b00,b01,b02;float b10,b11,b12;float b20,b21,b22;if(len<0.00000001){return mat4(0.);};len=1./len;x*=len;y*=len;z*=len;s=sin(rad);c=cos(rad);t=1.-c;a00=1.;a01=0.;a02=0.;a03=0.;a10=0.;a11=1.;a12=0.;a13=0.;a20=0.;a21=0.;a22=1.;a23=0.;b00=x*x*t+c;b01=y*x*t+z*s;b02=z*x*t-y*s;b10=x*y*t-z*s;b11=y*y*t+c;b12=z*y*t+x*s;b20=x*z*t+y*s;b21=y*z*t-x*s;b22=z*z*t+c;mat4 outd=mat4(0.);outd[0][0]=a00*b00+a10*b01+a20*b02;outd[0][1]=a01*b00+a11*b01+a21*b02;outd[0][2]=a02*b00+a12*b01+a22*b02;outd[0][3]=a03*b00+a13*b01+a23*b02;outd[1][0]=a00*b10+a10*b11+a20*b12;outd[1][1]=a01*b10+a11*b11+a21*b12;outd[1][2]=a02*b10+a12*b11+a22*b12;outd[1][3]=a03*b10+a13*b11+a23*b12;outd[2][0]=a00*b20+a10*b21+a20*b22;outd[2][1]=a01*b20+a11*b21+a21*b22;outd[2][2]=a02*b20+a12*b21+a22*b22;outd[2][3]=a03*b20+a13*b21+a23*b22;outd[3][0]=0.;outd[3][1]=0.;outd[3][2]=0.;outd[3][3]=1.;return outd;}',
      fn_acesTonemapping:
        '#define GLSLIFY 1\n#ifndef _AES_TONE_MAPPTING_\n#define _AES_TONE_MAPPTING_\nvec3 acesTonemapping(vec3 color){float g=0.985;float a=0.065;float b=0.0001;float c=0.433;float d=0.238;color=(color*(color+a)-b)/(color*(g*color+c)+d);color=clamp(color,0.0,1.0);return color;}\n#endif\n',
      fn_getPatternPos:
        '#define GLSLIFY 1\nvec2 getPatternPos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos){vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return(tile_units_to_pixels*pos+offset)/pattern_size;}',
      fn_HSBToRGB:
        '#define GLSLIFY 1\nconst vec4 K_HSB2RGB=vec4(1.0,2.0/3.0,1.0/3.0,3.0);vec3 HSBToRGB(vec3 hsb){vec3 p=abs(fract(hsb.xxx+K_HSB2RGB.xyz)*6.0-K_HSB2RGB.www);return hsb.z*mix(K_HSB2RGB.xxx,clamp(p-K_HSB2RGB.xxx,0.0,1.0),hsb.y);}',
      fn_HSLToRGB:
        '#define GLSLIFY 1\nvec3 hueToRGB(float hue){float r=abs(hue*6.0-3.0)-1.0;float g=2.0-abs(hue*6.0-2.0);float b=2.0-abs(hue*6.0-4.0);return clamp(vec3(r,g,b),0.0,1.0);}vec3 HSLToRGB(vec3 hsl){vec3 rgb=hueToRGB(hsl.x);float c=(1.0-abs(2.0*hsl.z-1.0))*hsl.y;return(rgb-0.5)*c+hsl.z;}',
      fn_inverseGamma:
        '#define GLSLIFY 1\nvec3 inverseGamma(vec3 color,float gamma){return pow(color,vec3(1./gamma));}',
      fn_unpackDepth:
        '#define GLSLIFY 1\n#ifndef _UNPACK_DEPTH_\n#define _UNPACK_DEPTH_\nfloat unpackDepth(vec4 packedDepth){return dot(packedDepth,vec4(1.0,1.0/255.0,1.0/65025.0,1.0/16581375.0));}\n#endif\n',
      fn_geometricOcculusion:
        '#define GLSLIFY 1\nfloat geometricOcclusion(PBRInfo pbrInputs){float NdotL=pbrInputs.NdotL;float NdotV=pbrInputs.NdotV;float r=pbrInputs.alphaRoughness;float attenuationL=2.0*NdotL/(NdotL+sqrt(r*r+(1.0-r*r)*(NdotL*NdotL)));float attenuationV=2.0*NdotV/(NdotV+sqrt(r*r+(1.0-r*r)*(NdotV*NdotV)));return attenuationL*attenuationV;}',
      fn_getEllipsoidNormal:
        '#define GLSLIFY 1\nconst float xSquaredVal=1.0/6378137.0/6378137.0;const float zSquaredVal=1.0/6356752.3142451793/6356752.3142451793;const vec3 ellipsoid_oneOverRadiiSquared=vec3(xSquaredVal,xSquaredVal,zSquaredVal);\n#include <infinity>\nvec3 getEllipsoidNormal(vec3 position){vec3 result=normalize(position*ellipsoid_oneOverRadiiSquared);return result;}',
      fn_getIBLContribution:
        '#define GLSLIFY 1\nvec3 getIBLContribution(PBRInfo pbrInputs,vec3 n,vec3 reflection,vec2 modelUV,sampler2D brdfLUT,samplerCube diffuseEnvSampler,samplerCube specularEnvSampler){float mipCount=9.0;float lod=(pbrInputs.perceptualRoughness*mipCount);vec3 brdf=texture2D(brdfLUT,vec2(pbrInputs.NdotV,1.0-pbrInputs.perceptualRoughness)).rgb;vec3 specularLight=textureCubeLodEXT(specularEnvSampler,reflection,lod).rgb;vec3 diffuseLight=textureCube(diffuseEnvSampler,n).rgb;vec3 diffuse=diffuseLight*pbrInputs.diffuseColor;vec3 specular=specularLight*(pbrInputs.specularColor*brdf.x+brdf.y);return diffuse+specular;}',
      fn_getKHRCoord:
        '#define GLSLIFY 1\nvec2 getKHRCoord(vec2 a_coord,vec4 khrValues){vec2 coord=vec2(0.);mat3 translation=mat3(1,0,0,0,1,0,khrValues.x,khrValues.y,1);mat3 scaleKHR=mat3(khrValues.z,0,0,0,khrValues.w,0,0,0,1);mat3 matrix=translation*scaleKHR;coord=(matrix*vec3(a_coord,1)).xy;return coord;}',
      fn_getNormal:
        '#define GLSLIFY 1\nvec3 getNormal(bool hasTangent,bool hasNormal,vec2 UV,vec3 pos,vec3 normal,mat3 TBN){mat3 tbn=mat3(0.0);if(!hasTangent){vec3 pos_dx=dFdx(pos);vec3 pos_dy=dFdy(pos);vec3 tex_dx=dFdx(vec3(UV,0.0));vec3 tex_dy=dFdy(vec3(UV,0.0));vec3 t=(tex_dy.t*pos_dx-tex_dx.t*pos_dy)/(tex_dx.s*tex_dy.t-tex_dy.s*tex_dx.t);vec3 ng=vec3(0.0);if(hasNormal){ng=normalize(normal);}else{ng=cross(pos_dx,pos_dy);}t=normalize(t-ng*dot(ng,t));vec3 b=normalize(cross(ng,t));tbn=mat3(t,b,ng);}else{tbn=TBN;}vec3 n=normalize(tbn[2].xyz);return n;}vec3 getNormalFromMap(bool hasTangent,bool hasNormal,vec2 UV,vec3 pos,vec3 normal,mat3 TBN,sampler2D normalSampler){mat3 tbn=mat3(0.0);if(!hasTangent){vec3 pos_dx=dFdx(pos);vec3 pos_dy=dFdy(pos);vec3 tex_dx=dFdx(vec3(UV,0.0));vec3 tex_dy=dFdy(vec3(UV,0.0));vec3 t=(tex_dy.t*pos_dx-tex_dx.t*pos_dy)/(tex_dx.s*tex_dy.t-tex_dy.s*tex_dx.t);vec3 ng=vec3(0.0);if(hasNormal){ng=normalize(normal);}else{ng=cross(pos_dx,pos_dy);}t=normalize(t-ng*dot(ng,t));vec3 b=normalize(cross(ng,t));tbn=mat3(t,b,ng);}else{tbn=TBN;}vec3 n=vec3(0.0);n=texture2D(normalSampler,UV).rgb;n=normalize(tbn*((2.0*n-1.0)));return n;}',
      fn_getMetallicAndRoughness:
        '#define GLSLIFY 1\nconst float c_MinRoughness=0.04;\n#ifdef M_HAS_METALROUGHNESSMAP\nvec3 getMetallicAndRoughness(vec2 UV,vec2 metallicRoughnessValue,sampler2D metallicRoughnessSampler){float perceptualRoughness=metallicRoughnessValue.y;float metallic=metallicRoughnessValue.x;vec4 mrSample=texture2D(metallicRoughnessSampler,v_TexCoord);perceptualRoughness=mrSample.g*perceptualRoughness;metallic=mrSample.b*metallic;perceptualRoughness=clamp(perceptualRoughness,c_MinRoughness,1.0);metallic=clamp(metallic,0.0,1.0);float alphaRoughness=perceptualRoughness*perceptualRoughness;return vec3(metallic,perceptualRoughness,alphaRoughness);}\n#else\nvec3 getMetallicAndRoughness(vec2 UV,vec2 metallicRoughnessValue){float perceptualRoughness=metallicRoughnessValue.y;float metallic=metallicRoughnessValue.x;perceptualRoughness=clamp(perceptualRoughness,c_MinRoughness,1.0);metallic=clamp(metallic,0.0,1.0);float alphaRoughness=perceptualRoughness*perceptualRoughness;return vec3(metallic,perceptualRoughness,alphaRoughness);}\n#endif\n',
      fn_getAnimatedGLPosition:
        '#define GLSLIFY 1\nmat4 calcSkinMatrix(){mat4 skinMatrix=mat4(1.0);if(u_HasSkinning){\n#ifdef M_JOINT_MATRIX_CNT\nskinMatrix=a_WEIGHTS_0.x*u_jointMatrix[int(a_JOINTS_0.x)]+a_WEIGHTS_0.y*u_jointMatrix[int(a_JOINTS_0.y)]+a_WEIGHTS_0.z*u_jointMatrix[int(a_JOINTS_0.z)]+a_WEIGHTS_0.w*u_jointMatrix[int(a_JOINTS_0.w)];\n#endif\n}return skinMatrix;}void getAnimatedGLPosition(vec4 position,mat4 viewportOrthographic){gl_Position=viewportOrthographic*position;}\n#ifdef M_DOUBLEPRECISION\nvoid getAnimatedGLPosition(){\n#ifdef M_INSTANCE_MATRIX\ngl_Position=u_ModelViewProjectionMatrix*a_InstanceMatrix4*u_ModelMatrix*vec4(a_PositionHigh+a_PositionLow,1.0);\n#else\ngl_Position=u_ModelViewProjectionRelativeToEye*translateRelativeToEye(a_PositionHigh,a_PositionLow);\n#endif\n}\n#else\nvec3 transformed=vec3(0.0);mat4 instanceMatrix4=mat4(1.0);void getAnimatedGLPosition(){transformed=vec3(0.0);instanceMatrix4=mat4(1.0);\n#ifdef M_USE_MORPHTARGETS\ntransformed=a_POSITION_1.xyz*u_morphTargetInfluences[0];transformed+=a_POSITION_2.xyz*u_morphTargetInfluences[1];\n#ifdef M_USE_MORPHNORMALS\nvec3 transformedNormal=a_NORMAL_1.xyz*u_morphTargetInfluences[0];transformedNormal+=a_NORMAL_2.xyz*u_morphTargetInfluences[1];v_Normal=v_Normal+transformedNormal;\n#endif\n#endif\n#ifdef M_INSTANCE_MATRIX\ninstanceMatrix4=a_InstanceMatrix4*u_ModelMatrix;\n#endif\ngl_Position=u_ModelViewProjectionMatrix*instanceMatrix4*calcSkinMatrix()*vec4(a_POSITION.xyz+transformed,1.0);}\n#endif\n',
      fn_microfacetDistribution:
        '#define GLSLIFY 1\nfloat microfacetDistribution(PBRInfo pbrInputs){float roughnessSq=pbrInputs.alphaRoughness*pbrInputs.alphaRoughness;float f=(pbrInputs.NdotH*roughnessSq-pbrInputs.NdotH)*pbrInputs.NdotH+1.0;return roughnessSq/(PI*f*f);}',
      fn_nearFarScalar:
        '#define GLSLIFY 1\nfloat nearFarScalar(vec4 nearFarScalar,float cameraDistSq){float valueAtMin=nearFarScalar.y;float valueAtMax=nearFarScalar.w;float nearDistanceSq=nearFarScalar.x*nearFarScalar.x;float farDistanceSq=nearFarScalar.z*nearFarScalar.z;float t=(cameraDistSq-nearDistanceSq)/(farDistanceSq-nearDistanceSq);t=pow(clamp(t,0.0,1.0),0.2);return mix(valueAtMin,valueAtMax,t);}',
      fn_pbrDiffuse:
        '#define GLSLIFY 1\nvec3 pbrDiffuse(PBRInfo pbrInputs){return pbrInputs.diffuseColor/PI;}',
      fn_packDepth:
        '#define GLSLIFY 1\n#ifndef _PACK_DEPTH_\n#define _PACK_DEPTH_\nvec4 packDepth(float depth){vec4 enc=vec4(1.0,255.0,65025.0,16581375.0)*depth;enc=fract(enc);enc-=enc.yzww*vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);return enc;}\n#endif\n',
      fn_specularReflection:
        '#define GLSLIFY 1\nvec3 specularReflection(PBRInfo pbrInputs){return pbrInputs.reflectance0+(pbrInputs.reflectance90-pbrInputs.reflectance0)*pow(clamp(1.0-pbrInputs.VdotH,0.0,1.0),5.0);}',
      fn_sRGB2Linear:
        '#define GLSLIFY 1\nvec4 sRGB2Linear(vec4 srgbIn){vec3 linOut=pow(srgbIn.xyz,vec3(2.2));return vec4(linOut,srgbIn.w);}',
      fn_getBatchTextureColor:
        '#define GLSLIFY 1\n#if defined(M_ONE_DIMENSION_BATCH_TEXTURE)||defined(M_TWO_DIMENSION_BATCH_TEXTURE)\nvarying vec4 batch_featureColor;void getBatchTextureColor(vec4 tile_featureColor){float sumValue=(tile_featureColor.r+tile_featureColor.g+tile_featureColor.b+tile_featureColor.a)/4.0;if(sumValue>0.01&&sumValue<0.98&&tile_featureColor.a>0.0){if(tile_featureColor.a>0.99&&length(batch_featureColor.rgb)>0.01){gl_FragColor.rgb=batch_featureColor.rgb;}else{if(tile_featureColor.a>0.0){gl_FragColor.rgb=mix(tile_featureColor.rgb,gl_FragColor.rgb,tile_featureColor.a);}}}}\n#endif\n',
      fn_branchFreeTernary:
        '#define GLSLIFY 1\nfloat branchFreeTernary(bool comparison,float a,float b){float useA=float(comparison);return a*useA+b*(1.0-useA);}vec2 branchFreeTernary(bool comparison,vec2 a,vec2 b){float useA=float(comparison);return a*useA+b*(1.0-useA);}vec3 branchFreeTernary(bool comparison,vec3 a,vec3 b){float useA=float(comparison);return a*useA+b*(1.0-useA);}vec4 branchFreeTernary(bool comparison,vec4 a,vec4 b){float useA=float(comparison);return a*useA+b*(1.0-useA);}',
      fn_metersPerPixel:
        '#define GLSLIFY 1\nfloat metersPerPixel(vec4 positionEC,float pixelRatio){float width=u_Viewport.z;float height=u_Viewport.w;float top=u_FrustumPlanes.x;float bottom=u_FrustumPlanes.y;float left=u_FrustumPlanes.z;float right=u_FrustumPlanes.w;float distanceToPixel=-positionEC.z;float inverseNear=1.0/u_CurrentFrustum.x;float tanTheta=top*inverseNear;float pixelHeight=2.0*distanceToPixel*tanTheta/height;tanTheta=right*inverseNear;float pixelWidth=2.0*distanceToPixel*tanTheta/width;return max(pixelWidth,pixelHeight)*pixelRatio;}float metersPerPixel(vec4 positionEC){return metersPerPixel(positionEC,u_PixelRatio);}',
      fn_octDecode:
        '#define GLSLIFY 1\nfloat signNotZero(float value){return value>=0.0 ? 1.0 :-1.0;}vec2 signNotZero(vec2 value){return vec2(signNotZero(value.x),signNotZero(value.y));}vec3 octDecode(vec2 encoded,float range){if(encoded.x==0.0&&encoded.y==0.0){return vec3(0.0,0.0,0.0);}encoded=encoded/range*2.0-1.0;vec3 v=vec3(encoded.x,encoded.y,1.0-abs(encoded.x)-abs(encoded.y));if(v.z<0.0){v.xy=(1.0-abs(v.yx))*signNotZero(v.xy);}return normalize(v);}vec3 octDecode(vec2 encoded){return octDecode(encoded,255.0);}vec3 octDecode(float encoded){float temp=encoded/256.0;float x=floor(temp);float y=(temp-x)*256.0;return octDecode(vec2(x,y));}void octDecode(vec2 encoded,out vec3 vector1,out vec3 vector2,out vec3 vector3){float temp=encoded.x/65536.0;float x=floor(temp);float encodedFloat1=(temp-x)*65536.0;temp=encoded.y/65536.0;float y=floor(temp);float encodedFloat2=(temp-y)*65536.0;vector1=octDecode(encodedFloat1);vector2=octDecode(encodedFloat2);vector3=octDecode(vec2(x,y));}',
      fn_transformPlane:
        '#define GLSLIFY 1\nvec4 transformPlane(vec4 plane,mat4 transform){vec4 transformedPlane=transform*plane;float normalMagnitude=length(transformedPlane.xyz);return transformedPlane/normalMagnitude;}',
      fn_unpackFloatVec4:
        '#define GLSLIFY 1\nfloat unpackFloatVec4(vec4 packedFloat){packedFloat=floor(packedFloat*255.0+0.5);float sign=1.0-step(128.0,packedFloat[3])*2.0;float exponent=2.0*mod(packedFloat[3],128.0)+step(128.0,packedFloat[2])-127.0;if(exponent==-127.0){return 0.0;}float mantissa=mod(packedFloat[2],128.0)*65536.0+packedFloat[1]*256.0+packedFloat[0]+float(0x800000);float result=sign*exp2(exponent-23.0)*mantissa;return result;}',
      fn_windowToEyeCoordinates:
        '#define GLSLIFY 1\nvec4 windowToEyeCoordinates(vec4 fragmentCoordinate){float x=2.0*(fragmentCoordinate.x-u_Viewport.x)/u_Viewport.z-1.0;float y=2.0*(fragmentCoordinate.y-u_Viewport.y)/u_Viewport.w-1.0;float z=(fragmentCoordinate.z-u_ViewportTransformation[3][2])/u_ViewportTransformation[2][2];vec4 q=vec4(x,y,z,1.0);q/=fragmentCoordinate.w;if(!(u_InverseProjection==mat4(0.0))){q=u_InverseProjection*q;}else{float top=u_FrustumPlanes.x;float bottom=u_FrustumPlanes.y;float left=u_FrustumPlanes.z;float right=u_FrustumPlanes.w;float near=u_CurrentFrustum.x;float far=u_CurrentFrustum.y;q.x=(q.x*(right-left)+left+right)*0.5;q.y=(q.y*(top-bottom)+bottom+top)*0.5;q.z=(q.z*(near-far)-near-far)*0.5;q.w=1.0;}return q;}vec4 windowToEyeCoordinates(vec2 fragmentCoordinateXY,float depthOrLogDepth){\n#ifdef LOG_DEPTH\nfloat near=u_CurrentFrustum.x;float far=u_CurrentFrustum.y;float log2Depth=depthOrLogDepth*log2FarDepthFromNearPlusOne;float depthFromNear=pow(2.0,log2Depth)-1.0;float depthFromCamera=depthFromNear+near;vec4 windowCoord=vec4(fragmentCoordinateXY,far*(1.0-near/depthFromCamera)/(far-near),1.0);vec4 eyeCoordinate=windowToEyeCoordinates(windowCoord);eyeCoordinate.w=1.0/depthFromCamera;return eyeCoordinate;\n#else\nvec4 windowCoord=vec4(fragmentCoordinateXY,depthOrLogDepth,1.0);vec4 eyeCoordinate=windowToEyeCoordinates(windowCoord);\n#endif\nreturn eyeCoordinate;}',
      fn_primitiveClippingPlanes:
        '#define GLSLIFY 1\n#include <fn_branchFreeTernary>\n#include <fn_metersPerPixel>\n#include <fn_octDecode>\n#include <fn_transformPlane>\n#include <fn_unpackFloatVec4>\n#include <fn_windowToEyeCoordinates>\n#ifdef M_USE_CLIPPING_PLANES_FLOAT_TEXTURE\nvec4 getClippingPlane(highp sampler2D packedClippingPlanes,int clippingPlaneNumber,mat4 transform){int pixY=clippingPlaneNumber/M_CLIPPING_PLANES_TEXTURE_WIDTH;int pixX=clippingPlaneNumber-(pixY*M_CLIPPING_PLANES_TEXTURE_WIDTH);float pixelWidth=1.0/float(M_CLIPPING_PLANES_TEXTURE_WIDTH);float pixelHeight=1.0/float(M_CLIPPING_PLANES_TEXTURE_HEIGHT);float u=(float(pixX)+0.5)*pixelWidth;float v=(float(pixY)+0.5)*pixelHeight;vec4 plane=texture2D(packedClippingPlanes,vec2(u,v));return transformPlane(plane,transform);}\n#else\nvec4 getClippingPlane(highp sampler2D packedClippingPlanes,int clippingPlaneNumber,mat4 transform){int clippingPlaneStartIndex=clippingPlaneNumber*2;int pixY=clippingPlaneStartIndex/M_CLIPPING_PLANES_TEXTURE_WIDTH;int pixX=clippingPlaneStartIndex-(pixY*M_CLIPPING_PLANES_TEXTURE_WIDTH);float pixelWidth=1.0/float(M_CLIPPING_PLANES_TEXTURE_WIDTH);float pixelHeight=1.0/float(M_CLIPPING_PLANES_TEXTURE_HEIGHT);float u=(float(pixX)+0.5)*pixelWidth;float v=(float(pixY)+0.5)*pixelHeight;vec4 oct32=texture2D(packedClippingPlanes,vec2(u,v))*255.0;vec2 oct=vec2(oct32.x*256.0+oct32.y,oct32.z*256.0+oct32.w);vec4 plane;plane.xyz=octDecode(oct,65535.0);plane.w=unpackFloatVec4(texture2D(packedClippingPlanes,vec2(u+pixelWidth,v)));return transformPlane(plane,transform);}\n#endif\nfloat clip(vec4 fragCoord,sampler2D clippingPlanes,mat4 clippingPlanesMatrix){vec4 position=windowToEyeCoordinates(fragCoord);vec3 clipNormal=vec3(0.0);vec3 clipPosition=vec3(0.0);float pixelWidth=metersPerPixel(position);\n#ifdef M_UNION_CLIPPING_REGIONS\nfloat clipAmount;\n#else\nfloat clipAmount=0.0;bool clipped=true;\n#endif\nfor(int i=0;i<M_CLIPPING_PLANES_LENGTH;++i){vec4 clippingPlane=getClippingPlane(clippingPlanes,i,clippingPlanesMatrix);clipNormal=clippingPlane.xyz;clipPosition=-clippingPlane.w*clipNormal;float amount=dot(clipNormal,(position.xyz-clipPosition))/pixelWidth;\n#ifdef M_UNION_CLIPPING_REGIONS\nclipAmount=branchFreeTernary(i==0,amount,min(amount,clipAmount));if(amount<=0.0){discard;}\n#else\nclipAmount=max(amount,clipAmount);clipped=clipped&&(amount<=0.0);\n#endif\n}\n#ifndef M_UNION_CLIPPING_REGIONS\nif(clipped){discard;}\n#endif\nreturn clipAmount;}void modelClippingPlanesStage(inout vec4 color){float clipDistance=clip(gl_FragCoord,u_model_clippingPlanes,u_model_clippingPlanesMatrix);vec4 clippingPlanesEdgeColor=vec4(1.0);clippingPlanesEdgeColor.rgb=u_model_clippingPlanesEdgeStyle.rgb;float clippingPlanesEdgeWidth=u_model_clippingPlanesEdgeStyle.a;if(clipDistance>0.0&&clipDistance<clippingPlanesEdgeWidth){color=clippingPlanesEdgeColor;}}',
      fn_rayEllipsoidIntersectionInterval:
        '#define GLSLIFY 1\n#ifndef _RAY_ELLIPSOID_INTERSECTION_INTERVAL_\n#define _RAY_ELLIPSOID_INTERSECTION_INTERVAL_\nconst float xVal=1.0/6378137.0;const float zVal=1.0/6356752.3142451793;const vec3 ellipsoid_inverseRadii=vec3(xVal,xVal,zVal);\n#include <infinity>\nvec2 rayEllipsoidIntersectionInterval(vec3 rayOrigin,vec3 rayDir){vec3 q=ellipsoid_inverseRadii*rayOrigin;vec3 w=ellipsoid_inverseRadii*rayDir;q=q;float q2=dot(q,q);float qw=dot(q,w);if(q2>1.0){if(qw>=0.0){return vec2(-infinity);}else{float qw2=qw*qw;float difference=q2-1.0;float w2=dot(w,w);float product=w2*difference;if(qw2<product){return vec2(-infinity);}else if(qw2>product){float discriminant=qw*qw-product;float temp=-qw+sqrt(discriminant);float root0=temp/w2;float root1=difference/temp;if(root0<root1){vec2 i=vec2(root0,root1);return i;}else{vec2 i=vec2(root1,root0);return i;}}else{float root=sqrt(difference/w2);vec2 i=vec2(root,root);return i;}}}else if(q2<1.0){float difference=q2-1.0;float w2=dot(w,w);float product=w2*difference;float discriminant=qw*qw-product;float temp=-qw+sqrt(discriminant);vec2 i=vec2(0.0,temp/w2);return i;}else{if(qw<0.0){float w2=dot(w,w);vec2 i=vec2(0.0,-qw/w2);return i;}else{return vec2(-infinity);}}}\n#endif\n',
      fn_readDepth:
        '#define GLSLIFY 1\n#include <fn_reverseLogDepth>\n#include <fn_unpackDepth>\n#ifndef _READ_DEPTH_\n#define _READ_DEPTH_\nfloat readDepth(sampler2D depthTexture,vec2 texCoords,bool isColorTexture){if(isColorTexture){\n#ifdef M_UNSUPPORTED_COLOR_BUFFER_FLOAT\nreturn reverseLogDepth(unpackDepth(texture2D(depthTexture,texCoords)));\n#else\nreturn reverseLogDepth(texture2D(depthTexture,texCoords).r);\n#endif\n}else{return reverseLogDepth(texture2D(depthTexture,texCoords).r);}}\n#endif\n',
      fn_getExponentialInterpColor:
        '#define GLSLIFY 1\nvec4 getExponentialInterpColor(const float inputValue,const float base,const float lowerValue,const float upperValue,const vec4 lowerColor,const vec4 upperColor){float difference=upperValue-lowerValue;float progress=inputValue-lowerValue;float percent;if(difference==0.0){percent=0.0;}else if(base==1.0){percent=progress/difference;}else{percent=(pow(base,progress)-1.0)/(pow(base,difference)-1.0);}return mix(lowerColor,upperColor,percent);}',
      fn_writeDepth:
        '#define GLSLIFY 1\n#include <fn_reverseLogDepth>\n#include <fn_unpackDepth>\n#include <fn_encodeFloat>\n#ifndef _WRITE_DEPTH_\n#define _WRITE_DEPTH_\nvec4 writeDepth(float depth){\n#ifdef M_UNSUPPORTED_COLOR_BUFFER_FLOAT\nreturn encodeFloat(depth);\n#else\nreturn vec4(depth,depth,depth,1.0);\n#endif\n}\n#endif\n',
      fn_XYZToRGB:
        '#define GLSLIFY 1\nvec3 XYZToRGB(vec3 Yxy){const mat3 XYZ2RGB=mat3(3.2405,-0.9693,0.0556,-1.5371,1.8760,-0.2040,-0.4985,0.0416,1.0572);vec3 xyz;xyz.r=Yxy.r*Yxy.g/Yxy.b;xyz.g=Yxy.r;xyz.b=Yxy.r*(1.0-Yxy.g-Yxy.b)/Yxy.b;return XYZ2RGB*xyz;}',
      fn_polylineVertexPosition:
        '#define GLSLIFY 1\nconst float czm_epsilon6=0.000001;const float czm_epsilon1=0.1;const float czm_piOverFour=0.7853981633974483;bool equalsEpsilon(vec3 left,vec3 right,float epsilon){return all(lessThanEqual(abs(left-right),vec3(epsilon)));}vec4 eyeToWindowCoordinates(vec4 positionEC){vec4 q=u_ProjectionMatrix*positionEC;q.xyz/=q.w;q.xyz=(u_ViewportTransformation*vec4(q.xyz,1.0)).xyz;return q;}void clipLineSegmentToNearPlane(vec3 p0,vec3 p1,out vec4 positionWC,out bool clipped,out bool culledByNearPlane,out vec4 clippedPositionEC){culledByNearPlane=false;clipped=false;vec3 p0ToP1=p1-p0;float magnitude=length(p0ToP1);vec3 direction=normalize(p0ToP1);float endPoint0Distance=u_CurrentFrustum.x+p0.z;float denominator=-direction.z;if(endPoint0Distance>0.0&&abs(denominator)<czm_epsilon7){culledByNearPlane=true;}else if(endPoint0Distance>0.0){float t=endPoint0Distance/denominator;if(t<0.0||t>magnitude){culledByNearPlane=true;}else{p0=p0+t*direction;p0.z=min(p0.z,-u_CurrentFrustum.x);clipped=true;}}clippedPositionEC=vec4(p0,1.0);positionWC=eyeToWindowCoordinates(clippedPositionEC);}vec4 getPolylineWindowCoordinates(vec4 positionEC,vec4 prevEC,vec4 nextEC,float expandDirection,float width,bool usePrevious,out float angle){\n#ifdef M_POLYLINE_DASH\nvec4 positionWindow=eyeToWindowCoordinates(positionEC);vec4 previousWindow=eyeToWindowCoordinates(prevEC);vec4 nextWindow=eyeToWindowCoordinates(nextEC);vec2 lineDir;if(usePrevious){lineDir=normalize(positionWindow.xy-previousWindow.xy);}else{lineDir=normalize(nextWindow.xy-positionWindow.xy);}angle=atan(lineDir.x,lineDir.y)-1.570796327;angle=floor(angle/czm_piOverFour+0.5)*czm_piOverFour;\n#endif\nvec4 clippedPrevWC,clippedPrevEC;bool prevSegmentClipped,prevSegmentCulled;clipLineSegmentToNearPlane(prevEC.xyz,positionEC.xyz,clippedPrevWC,prevSegmentClipped,prevSegmentCulled,clippedPrevEC);vec4 clippedNextWC,clippedNextEC;bool nextSegmentClipped,nextSegmentCulled;clipLineSegmentToNearPlane(nextEC.xyz,positionEC.xyz,clippedNextWC,nextSegmentClipped,nextSegmentCulled,clippedNextEC);bool segmentClipped,segmentCulled;vec4 clippedPositionWC,clippedPositionEC;clipLineSegmentToNearPlane(positionEC.xyz,usePrevious ? prevEC.xyz : nextEC.xyz,clippedPositionWC,segmentClipped,segmentCulled,clippedPositionEC);if(segmentCulled){return vec4(0.0,0.0,0.0,1.0);}vec2 directionToPrevWC=normalize(clippedPrevWC.xy-clippedPositionWC.xy);vec2 directionToNextWC=normalize(clippedNextWC.xy-clippedPositionWC.xy);if(prevSegmentCulled){directionToPrevWC=-directionToNextWC;}else if(nextSegmentCulled){directionToNextWC=-directionToPrevWC;}vec2 thisSegmentForwardWC,otherSegmentForwardWC;if(usePrevious){thisSegmentForwardWC=-directionToPrevWC;otherSegmentForwardWC=directionToNextWC;}else{thisSegmentForwardWC=directionToNextWC;otherSegmentForwardWC=-directionToPrevWC;}vec2 thisSegmentLeftWC=vec2(-thisSegmentForwardWC.y,thisSegmentForwardWC.x);vec2 leftWC=thisSegmentLeftWC;float expandWidth=width*0.5;if(!equalsEpsilon(prevEC.xyz-positionEC.xyz,vec3(0.0),czm_epsilon1)&&!equalsEpsilon(nextEC.xyz-positionEC.xyz,vec3(0.0),czm_epsilon1)){vec2 otherSegmentLeftWC=vec2(-otherSegmentForwardWC.y,otherSegmentForwardWC.x);vec2 leftSumWC=thisSegmentLeftWC+otherSegmentLeftWC;float leftSumLength=length(leftSumWC);leftWC=leftSumLength<czm_epsilon6 ? thisSegmentLeftWC :(leftSumWC/leftSumLength);vec2 u=-thisSegmentForwardWC;vec2 v=leftWC;float sinAngle=abs(u.x*v.y-u.y*v.x);expandWidth=clamp(expandWidth/sinAngle,0.0,width*1.0);}vec2 offset=leftWC*expandDirection*expandWidth*u_PixelRatio;\n#if !defined(M_PIXEL_WIDTH)\noffset/=metersPerPixel(positionEC);\n#endif\nreturn vec4(clippedPositionWC.xy+offset,-clippedPositionWC.z,1.0)*(u_ProjectionMatrix*clippedPositionEC).w;}vec4 computePositionEC(in vec3 high,in vec3 low){vec4 p=u_modelViewRelativeToEye*translateRelativeToEye(high,low);return p;}vec4 polylineVertexPosition(out float angle){float expandDir=a_ExpandAndWidth.x;float width=abs(a_ExpandAndWidth.y)+0.5;bool usePrev=a_ExpandAndWidth.y<0.0;vec4 currentEC=computePositionEC(a_PositionHigh,a_PositionLow);vec4 prevEC=computePositionEC(a_PrevPositionHigh,a_PrevPositionLow);vec4 nextEC=computePositionEC(a_NextPositionHigh,a_NextPositionLow);return getPolylineWindowCoordinates(currentEC,prevEC,nextEC,expandDir,width,usePrev,angle);}vec4 polylineVertexPosition(){float angle;float expandDir=a_ExpandAndWidth.x;float width=abs(a_ExpandAndWidth.y)+0.5;bool usePrev=a_ExpandAndWidth.y<0.0;vec4 currentEC=computePositionEC(a_PositionHigh,a_PositionLow);vec4 prevEC=computePositionEC(a_PrevPositionHigh,a_PrevPositionLow);vec4 nextEC=computePositionEC(a_NextPositionHigh,a_NextPositionLow);return getPolylineWindowCoordinates(currentEC,prevEC,nextEC,expandDir,width,usePrev,angle);}',
      fn_polylineVolumePosition:
        '#define GLSLIFY 1\nconst float czm_piOverFour=0.7853981633974483;vec4 eyeToWindowCoordinates(vec4 positionEC){vec4 q=u_ProjectionMatrix*positionEC;q.xyz/=q.w;q.xyz=(u_ViewportTransformation*vec4(q.xyz,1.0)).xyz;return q;}vec4 polylineVolumePosition(out float angle){float width=a_Width;vec3 ecStart=(u_modelViewRelativeToEye*translateRelativeToEye(a_StartHigh,a_StartLow)).xyz;vec3 offset=u_Normal*a_ForwardOffset;vec3 ecEnd=ecStart+offset;vec3 forwardDirectionEC=normalize(offset);\n#ifdef M_POLYLINE_DASH\nvec4 forwardDirectionWC=eyeToWindowCoordinates(vec4(forwardDirectionEC,1.0));vec2 lineDir=forwardDirectionWC.xy;angle=atan(lineDir.x,lineDir.y)-1.570796327;angle=floor(angle/czm_piOverFour+0.5)*czm_piOverFour;\n#endif\nvec4 startPlaneEC;startPlaneEC.xyz=u_Normal*a_StartNormal;startPlaneEC.w=-dot(startPlaneEC.xyz,ecStart);vec4 endPlaneEC;endPlaneEC.xyz=u_Normal*a_EndNormal;endPlaneEC.w=-dot(endPlaneEC.xyz,ecEnd);v_rightPlaneEC.xyz=u_Normal*a_RightNormal.xyz;v_rightPlaneEC.w=-dot(v_rightPlaneEC.xyz,ecStart);v_texcoordNormalizationAndStartEcYZ.x=abs(a_TexCoord.x);v_texcoordNormalizationAndStartEcYZ.y=a_TexCoord.y;v_texcoordNormalizationAndStartEcYZ.zw=ecStart.yz;v_endEcAndStartEcX.xyz=ecEnd;v_endEcAndStartEcX.w=ecStart.x;vec3 positionRelativeToEye=translateRelativeToEye(a_PositionHigh,a_PositionLow).xyz;vec4 positionEC=u_modelViewRelativeToEye*vec4(positionRelativeToEye,1.0);float absStartPlaneDistance=abs(planeDistance(startPlaneEC,positionEC.xyz));float absEndPlaneDistance=abs(planeDistance(endPlaneEC,positionEC.xyz));vec3 planeDirection=branchFreeTernary(absStartPlaneDistance<absEndPlaneDistance,startPlaneEC.xyz,endPlaneEC.xyz);vec3 upOrDown=normalize(cross(v_rightPlaneEC.xyz,planeDirection));vec3 normalEC=normalize(cross(planeDirection,upOrDown));upOrDown=cross(forwardDirectionEC,normalEC);upOrDown=min(u_GlobeMinimumAltitude,u_GeometricToleranceOverMeter*length(positionRelativeToEye.xyz))*upOrDown;positionEC.xyz+=upOrDown;v_texcoordNormalizationAndStartEcYZ.y=branchFreeTernary(v_texcoordNormalizationAndStartEcYZ.y>1.0,0.0,abs(v_texcoordNormalizationAndStartEcYZ.y));v_startPlaneNormalEcAndHalfWidth.xyz=startPlaneEC.xyz;v_startPlaneNormalEcAndHalfWidth.w=width*0.5;v_endPlaneNormalEcAndBatchId.xyz=endPlaneEC.xyz;\n#ifdef M_PIXEL_WIDTH\nwidth=width*max(0.0,metersPerPixel(positionEC));\n#endif\nwidth=width/dot(normalEC,v_rightPlaneEC.xyz);normalEC*=sign(a_TexCoord.x);positionEC.xyz+=width*normalEC;return u_ProjectionMatrix*positionEC;}',
      fn_planeDistance:
        '#define GLSLIFY 1\nfloat planeDistance(vec4 plane,vec3 point){return(dot(plane.xyz,point)+plane.w);}float planeDistance(vec3 planeNormal,float planeDistance,vec3 point){return(dot(planeNormal,point)+planeDistance);}',
      fn_billboardVertexPosition:
        '#define GLSLIFY 1\nvec4 billboardVertexPosition(){mat4 newModelMatrix;vec4 mvPosition;\n#ifdef M_FIXED_PIXEL_SIZE\nvec2 offset=vec2(0.0);offset=a_POSITION.xy*u_PixelResolution;vec4 center=u_ProjectionMatrix*u_MvMatrix*vec4(0.0,0.0,0.0,1.0);center=center/center.w;vec2 screenLocation=(u_ViewportTransformation*center).xy+offset;vec4 ndc=vec4(0.0);ndc.x=((screenLocation.x-u_Viewport[0])/u_Viewport[2])*2.0-1.0;ndc.y=((screenLocation.y-u_Viewport[1])/u_Viewport[3])*2.0-1.0;ndc.z=center.z;ndc.w=1.0;return ndc;\n#else\n#ifdef M_INSTANCE_MATRIX\nnewModelMatrix=u_InvertViewMatrix*a_InstanceMatrix4*u_ScaleMatrix;mvPosition=a_InstanceMatrix4*u_ScaleMatrix*vec4(0.0,0.0,0.0,1.0);\n#ifdef M_PARTICLSYSTEM\nv_Color=a_Color;\n#endif\n#else\nnewModelMatrix=u_InvertViewMatrix*u_MvMatrix*u_ScaleMatrix;mvPosition=u_MvMatrix*vec4(0.0,0.0,0.0,1.0);\n#endif\nvec2 scale;scale.x=length(vec3(newModelMatrix[0].x,newModelMatrix[0].y,newModelMatrix[0].z));scale.y=length(vec3(newModelMatrix[1].x,newModelMatrix[1].y,newModelMatrix[1].z));\n#if defined(M_SIZEATTENUATION)\n#ifdef M_PARTICLSYSTEM\nscale*=-mvPosition.z*a_Scale;\n#else\nscale*=-mvPosition.z;\n#endif\n#endif\nvec2 alignedPosition=(a_POSITION.xy-(u_center-vec2(0.5)))*scale;vec2 rotatedPosition;rotatedPosition.x=cos(u_rotation)*alignedPosition.x-sin(u_rotation)*alignedPosition.y;rotatedPosition.y=sin(u_rotation)*alignedPosition.x+cos(u_rotation)*alignedPosition.y;mvPosition.xy+=rotatedPosition;return u_ProjectionMatrix*mvPosition;\n#endif\n}',
      s_HighlightColorInfo: '#define GLSLIFY 1\nstruct HighlightColorInfo{vec4 color;};',
      s_JointMatrix: '#define GLSLIFY 1\nstruct JointMatrix{mat4 m;};',
      s_LightMaterial:
        '#define GLSLIFY 1\nstruct LightMaterial{vec3 Ambient;vec3 Diffuse;float Shininess;vec3 SpecularColor;};',
      s_PBRInfo:
        '#define GLSLIFY 1\nstruct PBRInfo{float NdotL;float NdotV;float NdotH;float LdotH;float VdotH;float perceptualRoughness;float metalness;vec3 reflectance0;vec3 reflectance90;float alphaRoughness;vec3 diffuseColor;vec3 specularColor;};',
      infinity:
        '#define GLSLIFY 1\n#ifndef _MINEMAP_INFINITY_\n#define _MINEMAP_INFINITY_\nconst float infinity=5906376272000.0;\n#endif\n',
    };
    var Mp =
      '#define GLSLIFY 1\n#include <fn_vertexLogDepth>\n#include <a_DOUBLE_PRECISION_POSITION>\n#include <a_POSITION3>\n#include <u_ModelViewProjectionMatrix>\n#include <u_ModelMatrix>\n#include <a_BATCHID>\n#include <c_computeSTParsVert>\n#include <u_ModelViewProjectionRelativeToEye>\n#include <u_EncodedCameraPosition>\n#include <fn_translateRelativeToEye>\n#if defined(M_POLYLINE) || defined(M_LOG_DEPTH)\n#include <u_CurrentFrustum>\n#endif\n#ifdef M_JOINT_MATRIX_CNT\nattribute vec4 a_JOINTS_0;attribute vec4 a_WEIGHTS_0;\n#endif\n#ifdef M_INSTANCE_MATRIX\nattribute mat4 a_InstanceMatrix4;uniform mat4 vpmatrix;\n#endif\n#include <u_HasSkinning>\n#include <s_JointMatrix>\n#ifdef M_JOINT_MATRIX_CNT\nuniform highp mat4 u_jointMatrix[M_JOINT_MATRIX_CNT];\n#endif\n#ifdef M_USE_MORPHTARGETS\n#include <a_POSITION3_1>\n#include <a_POSITION3_2>\nuniform vec2 u_morphTargetInfluences;\n#include <a_normal3_1>\n#include <a_NORMAL3_2>\n#include <a_TANGENT_1>\n#include <a_TANGENT_2>\n#endif\n#include <fn_getAnimatedGLPosition>\n#ifdef M_POLYLINE\n#include <u_FrustumPlanes>\n#include <u_ProjectionMatrix>\n#include <u_PixelRatio>\n#include <u_Viewport>\nuniform mat4 u_ViewportTransformation;uniform mat4 u_ViewportOrthographic;uniform mat4 u_modelViewRelativeToEye;uniform mat3 u_Normal;uniform float u_GlobeMinimumAltitude;uniform float u_GeometricToleranceOverMeter;\n#ifdef M_SHADOW_VOLUME\nattribute vec3 a_StartHigh;attribute vec3 a_StartLow;attribute vec3 a_StartNormal;attribute vec3 a_EndNormal;attribute vec3 a_RightNormal;attribute vec3 a_ForwardOffset;attribute vec2 a_TexCoord;attribute float a_Width;varying vec4 v_startPlaneNormalEcAndHalfWidth;varying vec4 v_endPlaneNormalEcAndBatchId;varying vec4 v_rightPlaneEC;varying vec4 v_endEcAndStartEcX;varying vec4 v_texcoordNormalizationAndStartEcYZ;\n#include <fn_metersPerPixel>\n#include <fn_planeDistance>\n#include <fn_branchFreeTernary>\n#include <fn_polylineVolumePosition>\n#else\nattribute vec3 a_PrevPositionHigh;attribute vec3 a_PrevPositionLow;attribute vec3 a_NextPositionHigh;attribute vec3 a_NextPositionLow;attribute vec2 a_ExpandAndWidth;\n#include <fn_polylineVertexPosition>\n#endif\nvarying float v_polylineAngle;\n#endif\n#ifdef M_BILLBOARD\n#include <u_ProjectionMatrix>\nuniform float u_rotation;uniform vec2 u_center;uniform vec2 u_UVScale;uniform mat4 u_ScaleMatrix;uniform mat4 u_MvMatrix;uniform mat4 u_InvertViewMatrix;\n#ifdef M_FIXED_PIXEL_SIZE\nuniform vec2 u_PixelResolution;uniform mat4 u_ViewportTransformation;uniform vec4 u_Viewport;\n#endif\n#include <fn_billboardVertexPosition>\n#endif\nvarying float v_depthFromNearPlusOne;\n#ifdef M_DEPTH_DISTANCE\nvarying vec4 v_Position;\n#endif\nvoid main(){\n#ifdef M_POLYLINE\n#ifdef M_SHADOW_VOLUME\nfloat angle;gl_Position=polylineVolumePosition(angle);v_polylineAngle=angle;gl_Position.z=min(gl_Position.z,gl_Position.w);\n#else\nfloat angle;vec4 positionWC=polylineVertexPosition(angle);v_polylineAngle=angle;getAnimatedGLPosition(positionWC,u_ViewportOrthographic);\n#endif\n#else\n#ifdef M_BILLBOARD\ngl_Position=billboardVertexPosition();\n#else\ngetAnimatedGLPosition();\n#endif\n#endif\n#include <c_computeSTMainVert>\n#ifdef M_LOG_DEPTH\nv_depthFromNearPlusOne=vertexLogDepth(u_CurrentFrustum);\n#endif\n#ifdef M_DEPTH_DISTANCE\n#ifdef M_DOUBLEPRECISION\nv_Position=u_ModelMatrix*vec4(a_PositionHigh+a_PositionLow,1);\n#else\nv_Position=u_ModelMatrix*vec4(a_POSITION,1.0);\n#endif\n#endif\n}';
    function Ip(e) {
      return Op(e);
    }
    const Lp = /^[ \t]*#include +<([\w\d./]+)>/gm,
      Rp = {
        prelude: {
          fragmentSource: Ip(
            '\n#ifdef M_TEXTURE_LOD_SUPPORTED\n#extension GL_EXT_shader_texture_lod:enable\n#endif\n#ifdef M_STANDARD_DERIVATIVES_SUPPORTED\n#extension GL_OES_standard_derivatives:enable\n#endif\n#ifdef M_DEPTH_EXT\n#extension GL_EXT_frag_depth:enable\n#endif\n#ifdef GL_ES\nprecision highp float;\n#define GLSLIFY 1\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\n#if !defined(M_HIGHLIGHT_COLOR_MAX)\n#define M_HIGHLIGHT_COLOR_MAX 4\n#endif\n#define PI 3.141592653589793\nconst float czm_epsilon7=0.0000001;const float czm_twoPi=6.283185307179586;const float czm_pixelRatio=1.0;uniform vec3 u_SunLightDirectionLocal;uniform vec3 u_SunLightDirectionGlobal;uniform vec3 u_SunLightColor;uniform float u_SunLightIntensity;uniform vec3 u_CameraPosition;uniform vec3 u_CameraDirection;',
          ),
          vertexSource: Ip(
            '#ifdef GL_ES\nprecision highp float;\n#define GLSLIFY 1\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\n#if !defined(M_HIGHLIGHT_COLOR_MAX)\n#define M_HIGHLIGHT_COLOR_MAX 4\n#endif\n#define PI 3.141592653589793\nconst float czm_epsilon7=0.0000001;const float czm_twoPi=6.283185307179586;const float czm_pixelRatio=1.0;uniform vec3 u_SunLightDirectionLocal;uniform vec3 u_SunLightDirectionGlobal;uniform vec3 u_SunLightColor;uniform float u_SunLightIntensity;uniform vec3 u_CameraPosition;uniform vec3 u_CameraDirection;',
          ),
        },
        unpackAll: { fragmentSource: Ip(xp), vertexSource: Ip(xp) },
        sphereClipping: {
          fragmentSource: Ip('#define GLSLIFY 1\nvoid main(){gl_FragColor=vec4(1.0);}'),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <a_POSITION3>\n#include <u_ModelViewProjectionMatrix>\nvoid main(){gl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION,1);}',
          ),
        },
        sphereBackground: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\n#include <u_Color4>\n#include <u_Opacity>\n#include <c_define>\nvoid showLogDepth(float depth,vec2 currentFrustum){float farDepthFromNearPlusOne=currentFrustum.y-currentFrustum.x+1.0;float log2FarDepthFromNearPlusOne=log2(farDepthFromNearPlusOne);float oneOverLog2FarDepthFromNearPlusOne=1.0/log2FarDepthFromNearPlusOne;if(depth<=0.9999999||depth>farDepthFromNearPlusOne){discard;}float logDepth=log2(depth)*oneOverLog2FarDepthFromNearPlusOne;gl_FragColor=vec4(logDepth,logDepth,logDepth,1.0);}void main(){gl_FragColor=vec4(u_Color.rgb,u_Color.a*u_Opacity);\n#ifdef M_OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n#ifdef M_SHOW_DEPTH\n#ifdef M_LOG_DEPTH\nshowLogDepth(v_depthFromNearPlusOne,u_CurrentFrustum);\n#else\ngl_FragColor=vec4(gl_FragCoord.z,gl_FragCoord.z,gl_FragCoord.z,1.0);\n#endif\n#endif\n}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <fn_vertexLogDepth>\n#include <c_define>\n#include <a_POSITION3>\n#include <u_ModelViewProjectionMatrix>\nvoid main(){gl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION,1.);\n#ifdef M_SHOW_DEPTH\n#ifdef M_LOG_DEPTH\nv_depthFromNearPlusOne=vertexLogDepth(u_CurrentFrustum);\n#endif\n#endif\n}',
          ),
        },
        sphereBackgroundPattern: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\n#include <u_BaseColorSampler>\nuniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;\n#include <u_Opacity>\nvarying vec2 v_pos_a;varying vec2 v_pos_b;void main(){vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_BaseColorSampler,pos);gl_FragColor=vec4(color1.rgb,color1.a*u_Opacity);\n#ifdef M_OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <a_POSITION3>\n#include <u_ModelViewProjectionMatrix>\n#include <u_Zoom>\nvarying vec2 v_pos_a;varying vec2 v_pos_b;attribute vec2 a_TEXCOORD_0;void main(){gl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION,1.0);v_pos_a=a_TEXCOORD_0*70.0*u_Zoom;v_pos_b=a_TEXCOORD_0*70.0*u_Zoom;}',
          ),
        },
        collisionBox: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nvarying float v_placed;varying float v_notUsed;void main(){float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,alpha);if(v_placed>0.5){gl_FragColor=vec4(0.0,0.0,1.0,0.5*alpha);}if(v_notUsed>0.5){gl_FragColor.a*=.1;}}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <a_POSITION2>\nattribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;\n#include <u_ModelViewProjectionMatrix>\nuniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main(){vec4 projectedPoint=u_ModelViewProjectionMatrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION,0.0,1.0);gl_Position.xy+=a_extrude*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}',
          ),
        },
        collisionCircle: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nuniform float u_overscale_factor;varying float v_radius;varying vec2 v_extrude;varying vec2 v_extrude_scale;varying float v_placed;varying float v_notUsed;void main(){float alpha=0.5;vec4 color=vec4(1.0,0.0,0.0,1.0)*alpha;if(v_placed>0.5){color=vec4(0.0,0.0,1.0,0.5)*alpha;}if(v_notUsed>0.5){color*=.2;}float extrude_scale_length=length(v_extrude_scale);float extrude_length=length(v_extrude)*extrude_scale_length;float stroke_width=15.0*extrude_scale_length/u_overscale_factor;float radius=v_radius*extrude_scale_length;float distance_to_edge=abs(extrude_length-radius);float opacity_t=smoothstep(-stroke_width,0.0,-distance_to_edge);gl_FragColor=vec4(color.rgb,color.a*opacity_t);}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <a_POSITION2>\nattribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;\n#include <u_ModelViewProjectionMatrix>\nuniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;varying float v_radius;varying vec2 v_extrude;varying vec2 v_extrude_scale;void main(){vec4 projectedPoint=u_ModelViewProjectionMatrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION,0.0,1.0);highp float padding_factor=1.2;gl_Position.xy+=a_extrude*u_extrude_scale*padding_factor*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;v_radius=abs(a_extrude.y);v_extrude=a_extrude*padding_factor;v_extrude_scale=u_extrude_scale*u_camera_to_center_distance*collision_perspective_ratio;}',
          ),
        },
        debug: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\n#include <u_Color4>\nvoid main(){gl_FragColor=u_Color;}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <u_ModelViewProjectionMatrix>\n#include <a_POSITION3>\nvoid main(){gl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION,1);}',
          ),
        },
        sphere: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\n#include <c_define>\n#include <fn_writeLogDepth>\n#include <fn_getBlinnPhongColor>\nuniform sampler2D u_earthMap;uniform sampler2D u_earthCloudMap;uniform sampler2D u_earthNightMap;\n#include <v_TexCoord2>\n#include <v_Normal3>\nvarying vec3 v_world_pos;uniform float u_earthTime;uniform bool u_NightVisible;uniform highp float u_DayTexPercent;uniform vec4 u_GlobalInnerColor;uniform vec4 u_LightPer;uniform vec2 u_NightGlobalPer;void main(){vec4 globalColor=vec4(0.0);\n#ifdef M_HAS_BASE_MAP\nglobalColor+=texture2D(u_earthMap,v_TexCoord);\n#endif\nglobalColor.xyz=u_LightPer.w*pow(globalColor.xyz,vec3(2.2));vec4 cloudColor=vec4(0.0);\n#ifdef M_HAS_CLOUD_MAP\ncloudColor=texture2D(u_earthCloudMap,vec2(v_TexCoord.x+u_earthTime*u_LightPer.y,v_TexCoord.y));cloudColor.rgb=pow(cloudColor.rgb,vec3(2.2));\n#endif\nvec4 nightLightColor=vec4(0.0);\n#ifdef M_HAS_NIGHT_MAP\nnightLightColor=u_LightPer.z*texture2D(u_earthNightMap,v_TexCoord);\n#endif\nvec3 N=normalize(v_Normal);vec3 LightDir=u_SunLightDirectionGlobal;vec3 V=normalize(u_CameraPosition-v_world_pos);vec3 H=normalize(LightDir+V);float specularPer=pow(max(dot(H,N),0.0),32.0);vec3 specularLight=specularPer*0.0*vec3(1.0,1.0,1.0);float rimPower=u_GlobalInnerColor.w;float ndv=dot(N,V);vec3 innerRing=(u_GlobalInnerColor.xyz*pow(1.0-ndv,rimPower));float NL=dot(LightDir,N);vec3 FinalColor=globalColor.xyz;\n#ifdef M_HAS_NIGHT_MAP\nconst float threshold=0.2;float y=0.5*NL/threshold+0.5;if(NL>threshold){FinalColor=globalColor.xyz*NL+u_NightGlobalPer.x*globalColor.xyz+specularLight+innerRing+cloudColor.xyz;}else if(NL>-threshold){float z=(1.0-y);FinalColor=y*NL*globalColor.xyz+z*nightLightColor.xyz+u_NightGlobalPer.x*globalColor.xyz+innerRing+max(u_NightGlobalPer.y,y)*cloudColor.xyz;}else{FinalColor=nightLightColor.xyz+u_NightGlobalPer.x*globalColor.xyz+innerRing+max(u_NightGlobalPer.y,y)*cloudColor.xyz;}\n#else\nFinalColor=globalColor.xyz+innerRing+cloudColor.xyz;\n#endif\nif(u_NightVisible==false)FinalColor=globalColor.xyz+innerRing+cloudColor.xyz;FinalColor=mix(FinalColor,globalColor.xyz,u_DayTexPercent);gl_FragColor=vec4(pow(FinalColor,vec3(1.0/2.2)),1.0);\n#ifdef M_LOG_DEPTH\nwriteLogDepth(v_depthFromNearPlusOne,u_CurrentFrustum);\n#endif\n}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <c_define>\n#ifdef M_DOUBLEPRECISION\n#include <a_DOUBLE_PRECISION_POSITION>\n#else\n#include <a_POSITION3>\n#endif\n#include <a_TEXCOORD_0>\n#include <u_ModelViewProjectionMatrix>\n#include <v_Normal3>\n#include <v_TexCoord2>\nvarying vec3 v_world_pos;\n#include <fn_vertexLogDepth>\n#include <u_ModelViewProjectionRelativeToEye>\n#include <u_EncodedCameraPosition>\n#include <fn_translateRelativeToEye>\nvoid main(){\n#ifdef M_DOUBLEPRECISION\ngl_Position=u_ModelViewProjectionRelativeToEye*translateRelativeToEye(a_PositionHigh,a_PositionLow);v_world_pos=a_PositionHigh+a_PositionLow;\n#else\ngl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION,1);v_world_pos=a_POSITION;\n#endif\nv_TexCoord=a_TEXCOORD_0;v_Normal=v_world_pos;\n#ifdef M_LOG_DEPTH\nv_depthFromNearPlusOne=vertexLogDepth(u_CurrentFrustum);\n#endif\n}',
          ),
        },
        sphereAtmosphere: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\n#include <fn_writeLogDepth>\n#include <c_define>\nuniform vec4 u_GlobalOuterColor;uniform vec4 u_GlobalOuterPara;\n#include <v_Normal3>\nvarying vec3 v_world_pos;varying vec3 v_worldAtmos_pos;uniform highp float u_DayTexPercent;void main(){float _OutLightPow=u_GlobalOuterPara.y;float _OutLightStrength=u_GlobalOuterPara.z;vec3 N=normalize(v_Normal);vec3 V=normalize(u_CameraPosition-v_world_pos);float ndv=dot(N,V);float Alpha=pow(clamp(ndv,0.0,1.0),_OutLightPow);Alpha*=_OutLightStrength*ndv;gl_FragColor=vec4(u_GlobalOuterColor.xyz,Alpha*(1.0-u_DayTexPercent));\n#ifdef M_LOG_DEPTH\nwriteLogDepth(v_depthFromNearPlusOne,u_CurrentFrustum);\n#endif\n}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <fn_vertexLogDepth>\n#include <c_define>\n#include <a_POSITION3>\n#include <u_ModelViewProjectionMatrix>\nvarying vec3 v_Normal;varying vec3 v_world_pos;varying vec3 v_worldAtmos_pos;uniform vec4 u_GlobalOuterPara;void main(){v_Normal=a_POSITION;v_world_pos=a_POSITION;v_Normal=normalize(v_Normal);float _Size=u_GlobalOuterPara.x;gl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION+v_Normal*_Size,1.0);v_worldAtmos_pos=a_POSITION+v_Normal*_Size;\n#ifdef M_LOG_DEPTH\nv_depthFromNearPlusOne=vertexLogDepth(u_CurrentFrustum);\n#endif\n}',
          ),
        },
        sphereRaster: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nuniform float u_fade_t;\n#include <u_Opacity>\nuniform sampler2D u_Texture[M_TEXTURE_UNITS];uniform vec4 u_TextureTexCoordsRectangle[M_TEXTURE_UNITS];uniform vec4 u_TextureTranslationAndScale[M_TEXTURE_UNITS];uniform float u_TextureAlpha[M_TEXTURE_UNITS];uniform float u_TextureBrightnessMin[M_TEXTURE_UNITS];uniform float u_TextureBrightnessMax[M_TEXTURE_UNITS];uniform float u_TextureSaturationFactor[M_TEXTURE_UNITS];uniform float u_TextureContrastFactor[M_TEXTURE_UNITS];uniform vec3 u_TextureSpinWeight[M_TEXTURE_UNITS];varying vec2 v_pos0;varying vec2 v_pos1;varying vec3 v_world_pos;varying vec4 v_Color;vec3 Ka=vec3(0.25);vec3 Kd=vec3(0.4);vec3 Ks=vec3(0.774597);vec3 Ke=vec3(0.1,0.1,0.1);float shininess=0.4;\n#include <u_ModelMatrix>\n#include <fn_pixelInVideo>\n#include <fn_writeLogDepth>\n#include <fn_encodeFloat>\n#include <fn_decodeFloat>\n#include <fn_getBlinnPhongColor>\n#include <v_LocalPosition>\n#include <v_Normal3>\n#include <s_LightMaterial>\n#include <fn_phong>\n#include <c_define>\nuniform sampler2D u_MaskSample;\n#include <u_ClipMatrix>\nuniform vec2 u_TextureSize;uniform bool u_ClipVideo;\n#if (defined M_NUM_VIDEOS) && (M_NUM_VIDEOS>0)\nuniform highp mat4 u_VIDEOMATCH_MVPMATRIX[M_NUM_VIDEOS];uniform highp vec3 u_VIDEOMATCH_RTP[M_NUM_VIDEOS];uniform bool u_HAS_VIDEOMATCHMAP[M_NUM_VIDEOS];uniform float u_Alpha[M_NUM_VIDEOS];uniform highp sampler2D u_VideoSampler[M_NUM_VIDEOS];uniform bool u_ActiveClipVideoTexture[M_NUM_VIDEOS];uniform vec3 u_ClipColors[M_NUM_VIDEOS];\n#endif\nvec4 blendColor(in vec4 prevColor,in vec4 currentColor){vec4 colorB=prevColor;vec4 colorT=currentColor;float alphaB=prevColor.a;float alphaT=currentColor.a;float alphaF=alphaT+alphaB*(1.0-alphaT);vec4 colorF=(colorT*alphaT+colorB*alphaB*(1.0-alphaT))/alphaF;vec4 blendT=alphaB*colorF+(1.0-alphaB)*colorT;vec4 outColor=(blendT*alphaT+colorB*alphaB*(1.0-alphaT))/alphaF;return outColor;}vec4 computeProperty(vec4 previousColor,vec3 textureSpinWeight,float textureSaturationFactor,float textureContrastFactor,float textureBrightnessMin,float textureBrightnessMax){vec3 inColor=previousColor.rgb;float inAlpha=previousColor.a;vec3 rgb=vec3(dot(inColor,textureSpinWeight.xyz),dot(inColor,textureSpinWeight.zxy),dot(inColor,textureSpinWeight.yzx));float average=(inColor.r+inColor.g+inColor.b)/3.0;rgb+=(average-rgb)*textureSaturationFactor;rgb=(rgb-0.5)*textureContrastFactor+0.5;vec3 u_high_vec=vec3(textureBrightnessMin,textureBrightnessMin,textureBrightnessMin);vec3 u_low_vec=vec3(textureBrightnessMax,textureBrightnessMax,textureBrightnessMax);return vec4(mix(u_high_vec,u_low_vec,rgb)*inAlpha,inAlpha);}vec4 sampleColor(vec4 previousColor,sampler2D textureToSample,vec2 tileTextureCoordinates,vec4 textureCoordinateRectangle,vec4 textureCoordinateTranslationAndScale,float textureAlpha){vec2 alphaMultiplier=step(textureCoordinateRectangle.st,tileTextureCoordinates);textureAlpha=textureAlpha*alphaMultiplier.x*alphaMultiplier.y;alphaMultiplier=step(vec2(0.0),textureCoordinateRectangle.pq-tileTextureCoordinates);textureAlpha=textureAlpha*alphaMultiplier.x*alphaMultiplier.y;vec2 translation=textureCoordinateTranslationAndScale.xy;vec2 scaleValue=textureCoordinateTranslationAndScale.zw;vec2 textureCoordinates=tileTextureCoordinates*scaleValue+translation;vec4 value=texture2D(textureToSample,textureCoordinates);vec3 color=value.rgb;float alpha=value.a;return vec4(color,alpha*textureAlpha);}vec4 computeDayColor(vec2 textureCoordinates){vec4 colors[M_TEXTURE_UNITS];vec4 outColor;for(int i=0;i<M_TEXTURE_UNITS;i++){vec4 color;color=sampleColor(color,u_Texture[i],textureCoordinates.xy,u_TextureTexCoordsRectangle[i],u_TextureTranslationAndScale[i],u_TextureAlpha[i]);color=computeProperty(color,u_TextureSpinWeight[i],u_TextureSaturationFactor[i],u_TextureContrastFactor[i],u_TextureBrightnessMin[i],u_TextureBrightnessMax[i]);colors[i]=color;}for(int i=0;i<M_TEXTURE_UNITS;i++){outColor=i>0 ? blendColor(outColor,colors[i]): colors[i];}return outColor;}void main(){vec4 color=computeDayColor(clamp(v_pos0,0.0,1.0));if(color.a>0.0){color.rgb=color.rgb/color.a;}else{discard;}\n#ifdef M_PHONG_LIGHT\ngl_FragColor=vec4(ambient(),1.0)*color;\n#else\ngl_FragColor=color;\n#endif\n#ifdef M_OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n#if (defined M_NUM_VIDEOS) && (M_NUM_VIDEOS>0)\nfor(int i=0;i<M_NUM_VIDEOS;i++){if(u_HAS_VIDEOMATCHMAP[i]){if(u_ClipVideo){if(pixelInVideo(u_VIDEOMATCH_MVPMATRIX[i],u_VIDEOMATCH_RTP[i],u_ModelMatrix,v_LocalPosition,u_VideoSampler[i],u_Alpha[i],u_ClipMatrix,u_MaskSample,u_TextureSize,u_ActiveClipVideoTexture[i],u_ClipColors[i])){continue;}}else{if(pixelInVideo(u_VIDEOMATCH_MVPMATRIX[i],u_VIDEOMATCH_RTP[i],u_ModelMatrix,v_LocalPosition,u_VideoSampler[i],u_Alpha[i],u_ClipMatrix,u_MaskSample,u_TextureSize,false,u_ClipColors[i])){continue;}}}}\n#endif\n#ifdef M_LOG_DEPTH\nwriteLogDepth(v_depthFromNearPlusOne,u_CurrentFrustum);\n#endif\n}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <a_POSITION3>\nattribute vec2 a_texture_pos;\n#include <u_ModelViewProjectionMatrix>\n#include <u_ModelMatrix>\nuniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;\n#include <c_define>\n#include <v_LocalPosition>\n#include <v_Normal3>\nvarying vec2 v_pos0;varying vec2 v_pos1;varying vec3 v_world_pos;varying vec4 v_Color;\n#include <fn_vertexLogDepth>\n#include <v_LIGHT>\nvoid main(){gl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION,1);v_LocalPosition=vec4(a_POSITION,1);vec4 geographic=u_ModelMatrix*vec4(a_POSITION,1.);v_world_pos=geographic.xyz;vec4 color=vec4(1.0,1.0,1.0,1.0);v_Color=color;v_pos0=a_texture_pos/32767.0;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;vec4 sunlight_position=u_ModelMatrix*vec4(a_POSITION,1.);v_Normal=sunlight_position.xyz;\n#ifdef M_LOG_DEPTH\nv_depthFromNearPlusOne=vertexLogDepth(u_CurrentFrustum);\n#endif\n}',
          ),
        },
        sphereImage: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\n#include <u_Opacity>\nuniform sampler2D u_BaseColorSampler;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;varying vec2 v_pos0;\n#include <u_ModelMatrix>\n#include <fn_pixelInVideo>\n#include <fn_writeLogDepth>\n#include <fn_encodeFloat>\n#include <fn_decodeFloat>\n#include <fn_getBlinnPhongColor>\n#include <v_LocalPosition>\n#include <v_Normal3>\n#include <c_define>\n#include <u_ClipMatrix>\nvoid main(){vec4 color=texture2D(u_BaseColorSampler,v_pos0);if(color.a>0.0){color.rgb=color.rgb/color.a;}else{discard;}color.a*=u_Opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec4 out_color=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);gl_FragColor=vec4(out_color.xyz,out_color.w*u_Opacity);\n#ifdef M_OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n#ifdef M_LOG_DEPTH\nwriteLogDepth(v_depthFromNearPlusOne,u_CurrentFrustum);\n#endif\n}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <a_POSITION3>\nattribute vec2 a_texture_pos;\n#include <u_ModelViewProjectionMatrix>\n#include <u_ModelMatrix>\nuniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;\n#include <c_define>\n#include <v_LocalPosition>\n#include <v_Normal3>\nvarying vec2 v_pos0;varying vec2 v_pos1;varying vec3 v_world_pos;varying vec4 v_Color;\n#include <fn_vertexLogDepth>\nvoid main(){gl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION,1);v_LocalPosition=vec4(a_POSITION,1);vec4 geographic=u_ModelMatrix*vec4(a_POSITION,1.);v_world_pos=geographic.xyz;vec4 color=vec4(1.0,1.0,1.0,1.0);v_Color=color;v_pos0=a_texture_pos/32767.0;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;vec4 sunlight_position=u_ModelMatrix*vec4(a_POSITION,1.);v_Normal=sunlight_position.xyz;\n#ifdef M_LOG_DEPTH\nv_depthFromNearPlusOne=vertexLogDepth(u_CurrentFrustum);\n#endif\n}',
          ),
        },
        sphereSymbolIcon: { fragmentSource: Ip(vp), vertexSource: Ip(wp) },
        sphereSymbolSDF: { fragmentSource: Ip(Tp), vertexSource: Ip(bp) },
        sphereFill: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\n#include <pragma_base_define>\n#include <pragma_fill_define>\n#include <c_define>\n#include <c_fillF>\n#include <fn_writeLogDepth>\n#include <fn_encodeFloat>\nvoid main(){\n#include <pragma_base_initialize>\n#include <pragma_fill_initialize>\ngl_FragColor=vec4(color.rgb,color.a*opacity);\n#ifdef M_OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n#ifdef M_LOG_DEPTH\nwriteLogDepth(v_depthFromNearPlusOne,u_CurrentFrustum);\n#endif\n}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <a_POSITION3>\n#include <u_ModelViewProjectionMatrix>\n#include <u_ModelMatrix>\n#include <u_Resolution>\n#include <u_Bearing>\n#include <pragma_base_define>\n#include <pragma_fill_define>\n#include <c_fillV>\n#include <c_define>\n#include <fn_vertexLogDepth>\nvoid main(){\n#include <pragma_base_initialize>\n#include <pragma_fill_initialize>\nvec4 spacePos=u_ModelMatrix*vec4(a_POSITION,1.0);gl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION,1);vec2 translate=u_translate;float translate_anchor=u_translate_anchor;if(translate_anchor==0.0){float sinA=sin(-u_Bearing);float cosA=cos(-u_Bearing);translate=vec2(translate[0]*cosA-translate[1]*sinA,translate[0]*sinA+translate[1]*cosA);}gl_Position.xy+=translate/vec2(u_Resolution.x/2.0,-u_Resolution.y/2.0)*gl_Position.w;\n#ifdef M_LOG_DEPTH\nv_depthFromNearPlusOne=vertexLogDepth(u_CurrentFrustum);\n#endif\n}',
          ),
        },
        sphereFillPattern: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\n#include <u_BaseColorSampler>\n#include <pragma_base_define>\n#include <pragma_fill_define>\n#include <c_fillF>\nvoid main(){\n#include <pragma_base_initialize>\n#include <pragma_fill_initialize>\nvec2 imagecoord=mod(abs(v_pos_a),1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_BaseColorSampler,pos);vec2 imagecoord_b=mod(abs(v_pos_b),1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_BaseColorSampler,pos2);vec4 mixedColor=mix(color1,color2,u_mix);gl_FragColor=vec4(mixedColor.rgb,mixedColor.a*opacity);\n#ifdef M_OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <a_POSITION3>\nattribute vec2 a_ST;\n#include <u_ModelViewProjectionMatrix>\n#include <u_ModelMatrix>\n#include <u_Resolution>\n#include <u_Bearing>\n#include <pragma_base_define>\n#include <pragma_fill_define>\n#include <c_fillV>\nuniform float u_zoom_factor;float rad=PI*26.5/180.0;mat3 Z=mat3(cos(rad),-sin(rad),0.0,sin(rad),cos(rad),0.0,0.0,0.0,1.0);void main(){\n#include <pragma_base_initialize>\n#include <pragma_fill_initialize>\nvec4 spacePos=u_ModelMatrix*vec4(a_POSITION,1.0);gl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION,1);vec2 translate=u_translate;float translate_anchor=u_translate_anchor;if(translate_anchor==0.0){float sinA=sin(-u_Bearing);float cosA=cos(-u_Bearing);translate=vec2(translate[0]*cosA-translate[1]*sinA,translate[0]*sinA+translate[1]*cosA);}gl_Position.xy+=translate/vec2(u_Resolution.x/2.0,-u_Resolution.y/2.0)*gl_Position.w;v_pos_a=a_ST;v_pos_b=a_ST;}',
          ),
        },
        sphereFillOutline: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\n#include <pragma_base_define>\n#include <pragma_fill_define>\n#include <c_fillF>\nvoid main(){\n#include <pragma_base_initialize>\n#include <pragma_fill_initialize>\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=vec4(outline_color.rgb,outline_color.a*opacity);\n#ifdef M_OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <a_POSITION3>\n#include <u_ModelViewProjectionMatrix>\n#include <u_Resolution>\n#include <u_Bearing>\n#include <u_World>\n#include <pragma_base_define>\n#include <pragma_fill_define>\n#include <c_fillV>\nvoid main(){\n#include <pragma_base_initialize>\n#include <pragma_fill_initialize>\ngl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION,1);vec2 translate=u_translate;float translate_anchor=u_translate_anchor;if(translate_anchor==0.0){float sinA=sin(-u_Bearing);float cosA=cos(-u_Bearing);translate=vec2(translate[0]*cosA-translate[1]*sinA,translate[0]*sinA+translate[1]*cosA);}gl_Position.xy+=translate/vec2(u_Resolution.x/2.0,-u_Resolution.y/2.0)*gl_Position.w;v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_World;}',
          ),
        },
        sphereFillOutlinePattern: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\n#include <u_BaseColorSampler>\n#include <pragma_base_define>\n#include <pragma_fill_define>\n#include <c_fillF>\nvoid main(){\n#include <pragma_base_initialize>\n#include <pragma_fill_initialize>\nvec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_BaseColorSampler,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_BaseColorSampler,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 mixedColor=mix(color1,color2,u_mix);gl_FragColor=vec4(mixedColor.rgb,mixedColor.a*alpha*opacity);\n#ifdef M_OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <a_POSITION3>\n#include <u_ModelViewProjectionMatrix>\n#include <u_Resolution>\n#include <u_Bearing>\n#include <u_World>\n#include <pragma_base_define>\n#include <pragma_fill_define>\n#include <c_fillV>\nvoid main(){\n#include <pragma_base_initialize>\n#include <pragma_fill_initialize>\ngl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION,1.0);vec2 translate=u_translate;float translate_anchor=u_translate_anchor;if(translate_anchor==0.0){float sinA=sin(-u_Bearing);float cosA=cos(-u_Bearing);translate=vec2(translate[0]*cosA-translate[1]*sinA,translate[0]*sinA+translate[1]*cosA);}gl_Position.xy+=translate/vec2(u_Resolution.x/2.0,-u_Resolution.y/2.0)*gl_Position.w;v_pos_a=a_ST;v_pos_b=a_ST;v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_World;}',
          ),
        },
        sphereLine: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\n#include <pragma_line_define>\n#include <pragma_border_define>\n#include <c_define>\n#include <c_lineF>\nvoid main(){\n#include <pragma_line_initialize>\n#include <pragma_border_initialize>\nfloat dist=length(v_Normal)*v_width2.s;float blur2=(blur+1.0/M_DEVICE_PIXEL_RATIO)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef M_SHADOW_VOLUME\ngl_FragColor=u_HasBorder==1.0 ? vec4(bordercolor.rgb,bordercolor.a*(alpha*borderopacity)): vec4(color.rgb,color.a*(alpha*opacity));\n#else\ngl_FragColor=u_HasBorder==1.0 ? vec4(bordercolor.rgb,bordercolor.a*(alpha*borderopacity)): vec4(color.rgb,color.a*(alpha*opacity));\n#endif\n#ifdef M_OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n#ifdef M_LOG_DEPTH\nwriteLogDepth(v_depthFromNearPlusOne,u_CurrentFrustum);\n#endif\n}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <a_POSITION3>\n#include <u_ModelViewProjectionMatrix>\n#include <u_Bearing>\n#include <pragma_line_define>\n#include <pragma_border_define>\n#include <c_define>\n#include <c_lineV>\nattribute vec2 a_extra_extrude;void main(){\n#include <pragma_line_initialize>\n#include <pragma_border_initialize>\nvec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;mediump vec2 normal=vec2(a_NORMAL/2.0>=1.0 ? 1.0 : 0.0,mod(a_NORMAL,2.0)==1.0 ? 1.0 :-1.0);v_Normal=normal;float constant=width==0.0 ? 0.0 : ANTIALIASING;float inset=0.0;float outset=0.0;float halfwidth=0.0;if(u_HasBorder==1.0){gapwidth=width/2.0;halfwidth=borderwidth;inset=gapwidth+constant;outset=gapwidth+halfwidth+constant;}else{halfwidth=width/2.0;gapwidth=gapwidth/2.0;inset=gapwidth+(gapwidth>0.0 ? constant : 0.0);outset=gapwidth+halfwidth*(gapwidth>0.0 ? 2.0 : 1.0)+constant;}offset=-1.0*offset;if(u_HalfRender==1.){if(normal_direction==1.){outset=2.0*(gapwidth+(normal.y>0. ? halfwidth : 0.))*(gapwidth>0.0 ? 2.0 : 1.0)+constant;}else{outset=2.0*(gapwidth+(normal.y<0. ? halfwidth : 0.))*(gapwidth>0.0 ? 2.0 : 1.0)+constant;}}mediump vec2 origin_dist=outset*a_extrude*scale;mediump vec2 dist=u_PixelMatrix*outset*a_extrude*scale;vec2 extra_extrude=a_extra_extrude.xy-128.0;mediump vec2 extra_dist=u_PixelMatrix*outset*extra_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);gl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION.xyz,1.0);if(u_HasBorder==1.0){gl_Position.xy+=dist/u_GlUnitsToPixels*gl_Position.w;}else{gl_Position.xy+=(dist+extra_dist)/u_GlUnitsToPixels*gl_Position.w;}vec2 translate=u_translate;float translate_anchor=u_translate_anchor;if(translate_anchor==0.0){float sinA=sin(-u_Bearing);float cosA=cos(-u_Bearing);translate=vec2(translate[0]*cosA-translate[1]*sinA,translate[0]*sinA+translate[1]*cosA);}gl_Position.xy+=(offset2+translate)/u_GlUnitsToPixels*gl_Position.w;float extrude_length_without_perspective=length(origin_dist);float extrude_length_with_perspective=length(dist);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);\n#ifdef M_LOG_DEPTH\nv_depthFromNearPlusOne=vertexLogDepth(u_CurrentFrustum);\n#endif\n}',
          ),
        },
        sphereLineSDF: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\n#include <u_BaseColorSampler>\n#include <pragma_line_define>\n#include <pragma_border_define>\n#include <c_define>\n#include <c_lineF>\nuniform float u_sdfgamma;uniform float u_mix;varying vec2 v_tex_a;varying vec2 v_tex_b;void main(){\n#include <pragma_line_initialize>\n#include <pragma_border_initialize>\nfloat dist=length(v_Normal)*v_width2.s;float blur2=(blur+1.0/M_DEVICE_PIXEL_RATIO)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_BaseColorSampler,v_tex_a).a;float sdfdist_b=texture2D(u_BaseColorSampler,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);\n#ifdef M_SHADOW_VOLUME\ngl_FragColor=vec4(color.rgb,color.a*alpha*opacity);\n#else\ngl_FragColor=u_HasBorder==1.0 ? vec4(bordercolor.rgb,bordercolor.a*(alpha*borderopacity)): vec4(color.rgb,color.a*(alpha*opacity));\n#endif\n#ifdef M_OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n#ifdef M_LOG_DEPTH\nwriteLogDepth(v_depthFromNearPlusOne,u_CurrentFrustum);\n#endif\n}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <a_POSITION3>\n#include <u_ModelViewProjectionMatrix>\n#include <u_Bearing>\n#include <pragma_line_define>\n#include <pragma_border_define>\n#include <c_define>\n#include <c_lineV>\nuniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;varying vec2 v_tex_a;varying vec2 v_tex_b;void main(){\n#include <pragma_line_initialize>\n#include <pragma_border_initialize>\nvec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;mediump vec2 normal=vec2(a_NORMAL/2.0>=1.0 ? 1.0 : 0.0,mod(a_NORMAL,2.0)==1.0 ? 1.0 :-1.0);v_Normal=normal;if(u_HasBorder==1.0){gapwidth=width/2.0;width=borderwidth/2.0;}else{gapwidth=gapwidth/2.0;}float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth>0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth>0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 origin_dist=outset*a_extrude*scale;mediump vec2 dist=u_PixelMatrix*outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);gl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION,1.0);gl_Position.xy+=dist/u_GlUnitsToPixels*gl_Position.w;vec2 translate=u_translate;float translate_anchor=u_translate_anchor;if(translate_anchor==0.0){float sinA=sin(-u_Bearing);float cosA=cos(-u_Bearing);translate=vec2(translate[0]*cosA-translate[1]*sinA,translate[0]*sinA+translate[1]*cosA);}gl_Position.xy+=(offset2+translate)/u_GlUnitsToPixels*gl_Position.w;float extrude_length_without_perspective=length(origin_dist);float extrude_length_with_perspective=length(dist);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);\n#ifdef M_LOG_DEPTH\nv_depthFromNearPlusOne=vertexLogDepth(u_CurrentFrustum);\n#endif\n}',
          ),
        },
        sphereLinePattern: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\n#include <u_BaseColorSampler>\n#include <pragma_line_define>\n#include <pragma_border_define>\n#include <c_define>\n#include <c_lineF>\nuniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_fade;varying float v_linesofar;void main(){\n#include <pragma_line_initialize>\n#include <pragma_border_initialize>\nfloat dist=length(v_Normal)*v_width2.s;float blur2=(blur+1.0/M_DEVICE_PIXEL_RATIO)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/u_pattern_size_a.x,1.0);float x_b=mod(v_linesofar/u_pattern_size_b.x,1.0);float y_a=0.5+(v_Normal.y*clamp(v_width2.s,0.0,(u_pattern_size_a.y+2.0)/2.0)/u_pattern_size_a.y);float y_b=0.5+(v_Normal.y*clamp(v_width2.s,0.0,(u_pattern_size_b.y+2.0)/2.0)/u_pattern_size_b.y);vec2 pos_a=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,vec2(x_a,y_a));vec2 pos_b=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,vec2(x_b,y_b));color=mix(texture2D(u_BaseColorSampler,pos_a),texture2D(u_BaseColorSampler,pos_b),u_fade);\n#ifdef M_SHADOW_VOLUME\ngl_FragColor=vec4(color.rgb,color.a*alpha*opacity);\n#else\ngl_FragColor=u_HasBorder==1.0 ? vec4(bordercolor.rgb,bordercolor.a*(alpha*borderopacity)): vec4(color.rgb,color.a*(alpha*opacity));\n#endif\n#ifdef M_OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n#ifdef M_LOG_DEPTH\nwriteLogDepth(v_depthFromNearPlusOne,u_CurrentFrustum);\n#endif\n}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <a_POSITION3>\n#include <u_ModelViewProjectionMatrix>\n#include <u_Bearing>\n#include <pragma_line_define>\n#include <pragma_border_define>\n#include <c_define>\n#include <c_lineV>\nvarying float v_linesofar;void main(){\n#include <pragma_line_initialize>\n#include <pragma_border_initialize>\nvec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;mediump vec2 normal=vec2(a_NORMAL/2.0>=1.0 ? 1.0 : 0.0,mod(a_NORMAL,2.0)==1.0 ? 1.0 :-1.0);v_Normal=normal;if(u_HasBorder==1.0){gapwidth=width/2.0;width=borderwidth/2.0;}else{gapwidth=gapwidth/2.0;}float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth>0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth>0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 origin_dist=outset*a_extrude*scale;mediump vec2 dist=u_PixelMatrix*outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);gl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION,1.0);gl_Position.xy+=dist/u_GlUnitsToPixels*gl_Position.w;vec2 translate=u_translate;float translate_anchor=u_translate_anchor;if(translate_anchor==0.0){float sinA=sin(-u_Bearing);float cosA=cos(-u_Bearing);translate=vec2(translate[0]*cosA-translate[1]*sinA,translate[0]*sinA+translate[1]*cosA);}gl_Position.xy+=(offset2+translate)/u_GlUnitsToPixels*gl_Position.w;float extrude_length_without_perspective=length(origin_dist);float extrude_length_with_perspective=length(dist);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_linesofar=a_linesofar;v_width2=vec2(outset,inset);\n#ifdef M_LOG_DEPTH\nv_depthFromNearPlusOne=vertexLogDepth(u_CurrentFrustum);\n#endif\n}',
          ),
        },
        sphereLineGradient: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\n#include <u_BaseColorSampler>\n#include <pragma_line_define>\n#include <pragma_border_define>\n#include <c_define>\n#include <c_lineF>\n#include <v_TexCoord2>\nvoid main(){\n#include <pragma_line_initialize>\n#include <pragma_border_initialize>\nfloat dist=length(v_Normal)*v_width2.s;float blur2=(blur+1.0/M_DEVICE_PIXEL_RATIO)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);color=texture2D(u_BaseColorSampler,v_TexCoord);\n#ifdef M_SHADOW_VOLUME\ngl_FragColor=vec4(color.rgb,color.a*alpha*opacity);\n#else\ngl_FragColor=u_HasBorder==1.0 ? vec4(bordercolor.rgb,bordercolor.a*(alpha*borderopacity)): vec4(color.rgb,color.a*(alpha*opacity));\n#endif\n#ifdef M_OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n#ifdef M_LOG_DEPTH\nwriteLogDepth(v_depthFromNearPlusOne,u_CurrentFrustum);\n#endif\n}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <a_POSITION3>\n#include <u_ModelViewProjectionMatrix>\n#include <u_Bearing>\n#include <pragma_line_define>\n#include <pragma_border_define>\n#include <c_define>\n#include <c_lineV>\nattribute float a_uv_x;attribute float a_split_index;uniform float u_image_height;\n#include <v_TexCoord2>\nvoid main(){\n#include <pragma_line_initialize>\n#include <pragma_border_initialize>\nvec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_TexCoord=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);mediump vec2 normal=vec2(a_NORMAL/2.0>=1.0 ? 1.0 : 0.0,mod(a_NORMAL,2.0)==1.0 ? 1.0 :-1.0);v_Normal=normal;if(u_HasBorder==1.0){gapwidth=width/2.0;width=borderwidth/2.0;}else{gapwidth=gapwidth/2.0;}float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth>0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth>0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 origin_dist=outset*a_extrude*scale;mediump vec2 dist=u_PixelMatrix*outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);gl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION,1.0);gl_Position.xy+=dist/u_GlUnitsToPixels*gl_Position.w;vec2 translate=u_translate;float translate_anchor=u_translate_anchor;if(translate_anchor==0.0){float sinA=sin(-u_Bearing);float cosA=cos(-u_Bearing);translate=vec2(translate[0]*cosA-translate[1]*sinA,translate[0]*sinA+translate[1]*cosA);}gl_Position.xy+=(offset2+translate)/u_GlUnitsToPixels*gl_Position.w;float extrude_length_without_perspective=length(origin_dist);float extrude_length_with_perspective=length(dist);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);\n#ifdef M_LOG_DEPTH\nv_depthFromNearPlusOne=vertexLogDepth(u_CurrentFrustum);\n#endif\n}',
          ),
        },
        sphereHeatmap: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\n#include <pragma_heatmap_define>\n#include <c_define>\nuniform highp float u_Intensity;uniform sampler2D u_color_ramp;\n#include <u_Opacity>\nvarying vec2 v_extrude;void main(){\n#include <pragma_heatmap_initialize>\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_Intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,0.0,1.0);\n#ifdef M_OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <pragma_heatmap_define>\n#include <c_define>\nattribute vec3 a_pos_vec3;attribute vec2 a_extrude;\n#include <u_ModelViewProjectionMatrix>\nuniform float u_extrude_scale;\n#include <u_Opacity>\nuniform float u_Intensity;\n#include <u_Resolution>\n#include <u_PixelMatrix>\nvarying float v_value;varying vec2 v_extrude;void main(void){\n#include <pragma_heatmap_initialize>\nfloat S=sqrt(-2.0*log(ZERO/weight/u_Intensity/GAUSS_COEF))/3.0;v_extrude=S*a_extrude;vec2 scaled_extrude=u_PixelMatrix*S*a_extrude;vec4 temppos=vec4(a_pos_vec3,1);vec4 trans_pos=u_ModelViewProjectionMatrix*temppos;vec2 screen_pos=vec2(trans_pos.x/trans_pos.w*u_Resolution.y/2.0+scaled_extrude.x*radius*u_Resolution.y/u_Resolution.x,trans_pos.y/trans_pos.w*u_Resolution.y/2.0+scaled_extrude.y*radius);gl_Position=vec4(screen_pos*trans_pos.w*2.0/u_Resolution.y,trans_pos.z,trans_pos.w);}',
          ),
        },
        heatmapTexture: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\n#include <u_BaseColorSampler>\n#include <v_TexCoord2>\n#include <c_define>\nuniform highp float u_Intensity;uniform sampler2D u_color_ramp;\n#include <u_Opacity>\nvarying vec2 v_extrude;void main(){float t=texture2D(u_BaseColorSampler,v_TexCoord).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=vec4(color.rgb,color.a*u_Opacity);\n#ifdef M_OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <a_POSITION2>\n#include <u_ModelViewProjectionMatrix>\n#include <v_TexCoord2>\n#include <c_define>\nuniform float u_extrude_scale;\n#include <u_Opacity>\nuniform float u_Intensity;\n#include <u_World>\nvarying vec2 v_extrude;void main(){gl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION*u_World,0,1);v_TexCoord.x=a_POSITION.x;v_TexCoord.y=1.0-a_POSITION.y;}',
          ),
        },
        heatmap3DTexture: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\n#include <u_BaseColorSampler>\n#include <u_Opacity>\nuniform sampler2D u_color_ramp;\n#include <v_TexCoord2>\nvarying float v_Alpha;void main(){if(v_Alpha==-1.0){discard;}vec4 color=texture2D(u_color_ramp,vec2(v_Alpha,0.5));gl_FragColor=vec4(color.rgb,color.a*u_Opacity);\n#ifdef M_OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}',
          ),
          vertexSource: Ip(
            'precision highp float;\n#define GLSLIFY 1\n#include <u_ModelViewProjectionMatrix>\n#include <u_BaseColorSampler>\nuniform float u_HeightFactor;uniform float u_Intensity;uniform vec4 u_Bezier;uniform mat4 u_InverseViewProjectionMatrix;\n#include <a_POSITION3>\n#include <a_TEXCOORD_0>\nattribute vec3 a_NORMAL;\n#include <v_TexCoord2>\nvarying float v_Alpha;varying vec3 v_Normal;\n#include <fn_rayEllipsoidIntersectionInterval>\n#include <fn_getEllipsoidNormal>\nvec2 toBezierInner(float t,vec2 P0,vec2 P1,vec2 P2,vec2 P3){float t2=t*t;float one_minus_t=1.0-t;float one_minus_t2=one_minus_t*one_minus_t;return(P0*one_minus_t2*one_minus_t+P1*3.0*t*one_minus_t2+P2*3.0*t2*one_minus_t+P3*t2*t);}vec2 toBezier(float t,vec4 p){return toBezierInner(t,vec2(0.0,0.0),vec2(p.x,p.y),vec2(p.z,p.w),vec2(1.0,1.0));}float interpolate(float a,float b,float t){return(a*(1.0-t))+(b*t);}\n#ifdef M_LARGE_SCALE\nvoid main(){v_TexCoord=a_TEXCOORD_0;v_Alpha=texture2D(u_BaseColorSampler,v_TexCoord).r;vec4 spacePos=u_InverseViewProjectionMatrix*vec4(a_POSITION,1.0);spacePos=spacePos/spacePos.w;vec3 rayDir=spacePos.xyz-u_CameraPosition;vec3 normalizedRayDir=normalize(rayDir);vec2 interval=rayEllipsoidIntersectionInterval(u_CameraPosition,normalizedRayDir);if(interval.x==-infinity){v_Alpha=-1.0;gl_Position=vec4(a_POSITION,1);return;}float height1=toBezier(v_Alpha,u_Bezier).y;float height0=toBezier(0.0,u_Bezier).y;float height=(height1-height0);if(height<0.0){height=0.0;}height*=u_HeightFactor;vec3 cartesian=u_CameraPosition+normalizedRayDir*interval.x;vec3 normal=getEllipsoidNormal(cartesian);vec3 position=normal*height+cartesian;gl_Position=u_ModelViewProjectionMatrix*vec4(position,1);}\n#else\nvoid main(){v_TexCoord=a_TEXCOORD_0;v_Alpha=texture2D(u_BaseColorSampler,v_TexCoord).r;float height1=toBezier(v_Alpha,u_Bezier).y;float height0=toBezier(0.0,u_Bezier).y;float height=(height1-height0);if(height<0.0){height=0.0;}height*=u_HeightFactor;if(v_TexCoord.x==-infinity){v_Alpha=-1.0;gl_Position=vec4(a_POSITION,1);}else{v_Normal=getEllipsoidNormal(a_POSITION);vec3 position=v_Normal*height+a_POSITION;gl_Position=u_ModelViewProjectionMatrix*vec4(position,1);}}\n#endif\n',
          ),
        },
        sphereCircle: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\n#include <pragma_circle_define>\nvarying vec3 v_data;void main(){\n#include <pragma_circle_initialize>\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width<0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));vec4 tempColor=mix(vec4(color.rgb,color.a*opacity),vec4(stroke_color.rgb,stroke_color.a*stroke_opacity),color_t);tempColor.a*=opacity_t;gl_FragColor=tempColor;\n#ifdef M_OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <a_POSITION3>\nattribute vec2 a_extra;\n#include <u_ModelViewProjectionMatrix>\n#include <u_ModelMatrix>\n#include <u_PixelMatrix>\nuniform vec2 u_GlUnitsToPixels;varying vec3 v_data;\n#include <pragma_circle_define>\n#include <c_define>\nvoid main(void){\n#include <pragma_circle_initialize>\nvec4 spacePos=u_ModelMatrix*vec4(a_POSITION,1.0);vec2 extrude=a_extra;mediump vec2 dist=u_PixelMatrix*(radius+stroke_width)*extrude;gl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION.xyz,1.0);gl_Position.xy+=dist/u_GlUnitsToPixels*gl_Position.w;lowp float antialiasblur=1.0/M_DEVICE_PIXEL_RATIO/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}',
          ),
        },
        sphereExtrusion: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\n#include <c_extrusionF>\n#include <c_define>\n#include <pragma_extrusion_define>\n#include <s_LightMaterial>\n#include <fn_phong>\nuniform sampler2D u_model_clippingPlanes;uniform vec4 u_model_clippingPlanesEdgeStyle;uniform mat4 u_model_clippingPlanesMatrix;\n#include <u_Viewport>\nuniform mat4 u_ViewportTransformation;uniform mat4 u_InverseProjection;\n#include <u_PixelRatio>\n#include <u_CurrentFrustum>\n#include <u_FrustumPlanes>\n#include <fn_primitiveClippingPlanes>\nuniform bool u_SelfBloom;uniform float u_Time;uniform float u_BloomHeight;uniform float u_PureColorHeight;uniform float u_BloomSpeed;uniform float u_GlowWidth;varying vec4 v_ModelPos;varying vec4 v_RelativePos;\n#include <u_LightMaterial>\nuniform float u_Shininess;uniform float u_Reflectivity;uniform vec3 u_sunLightGlobal;uniform float u_Roughness;varying vec3 v_LocalPosition;bool oppositeSigns(float x,float y){return(x<=0.&&y>=0.)||(x>=0.&&y<=0.);}\n#include <fn_writeLogDepth>\nvoid main(){\n#include <pragma_extrusion_initialize>\nif(color.a==0.||opacity==0.){discard;}vec4 finalColor=v_color;\n#ifdef M_OVERDRAW_INSPECTOR\nfinalColor=vec4(1.0);\n#endif\n#ifdef M_LOG_DEPTH\nwriteLogDepth(v_depthFromNearPlusOne,u_CurrentFrustum);\n#endif\n#ifdef M_HAS_CLIPPING_PLANES\nmodelClippingPlanesStage(finalColor);\n#endif\n#ifdef M_PHONG_LIGHT\nfinalColor=finalColor*vec4(phong(u_Reflectivity,v_Normal,u_sunLightGlobal,v_LocalPosition,u_Shininess,u_Roughness),1.0);\n#endif\nif(u_SelfBloom){float earthR=sqrt(v_RelativePos.x*v_RelativePos.x+v_RelativePos.y*v_RelativePos.y+v_RelativePos.z*v_RelativePos.z);float v_R_h=sqrt(v_ModelPos.x*v_ModelPos.x+v_ModelPos.y*v_ModelPos.y+v_ModelPos.z*v_ModelPos.z);float real_h=v_R_h-earthR;float dt_a12=clamp((real_h/u_PureColorHeight),0.0,1.0);finalColor*=vec4(dt_a12,dt_a12,dt_a12,1.0);float dt_a13=fract(u_Time/u_BloomSpeed);float dt_h=clamp((real_h/u_BloomHeight),0.0,1.0);dt_a13=abs(dt_a13-0.5)*2.0;float dt_diff=step(u_GlowWidth,abs(dt_h-dt_a13));finalColor.rgb+=finalColor.rgb*(1.0-dt_diff);}gl_FragColor=finalColor;}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <a_POSITION3>\n#include <u_ModelViewProjectionMatrix>\n#include <u_ViewProjectionMatrix>\n#include <u_ModelMatrix>\n#include <u_NormalMatrix>\n#include <u_Resolution>\n#include <u_Bearing>\n#include <c_define>\n#include <c_extrusionV>\n#include <pragma_extrusion_define>\n#ifdef M_ANS_ENABLED\nattribute vec3 a_ANS_POSITION_TOP_0;attribute vec3 a_ANS_POSITION_TOP_1;attribute float a_ANS_POS_TIME_0;attribute float a_ANS_POS_TIME_1;uniform float u_ANS_CurrentTime;\n#endif\nvarying vec4 v_ModelPos;varying vec4 v_RelativePos;varying vec3 v_LocalPosition;\n#include <fn_vertexLogDepth>\nuniform vec3 u_lightPos;varying vec4 v_color;void main(){\n#include <pragma_extrusion_initialize>\nvec4 pos=u_ModelMatrix*vec4(a_POSITION,1.0);v_LocalPosition=vec3(pos.xyz)/pos.w;v_Normal=normalize(vec3(u_NormalMatrix*vec4(a_NORMAL_ED)));\n#ifdef M_LOG_DEPTH\nv_depthFromNearPlusOne=vertexLogDepth(u_CurrentFrustum);\n#endif\n#ifdef M_ANS_ENABLED\nvec4 ansModelPos0=u_ModelMatrix*vec4(a_ANS_POSITION_TOP_0,1.0);vec4 ansModelPos1=u_ModelMatrix*vec4(a_ANS_POSITION_TOP_1,1.0);ansModelPos0=ansModelPos0/ansModelPos0.w;ansModelPos1=ansModelPos1/ansModelPos1.w;float weight0=(u_ANS_CurrentTime-a_ANS_POS_TIME_0)/(a_ANS_POS_TIME_1-a_ANS_POS_TIME_0);weight0=weight0>1.0 ? 1.0 : weight0;vec3 difPos=ansModelPos1.xyz-ansModelPos0.xyz;vec3 deltaPos=difPos*weight0;vec3 ansPosition=ansModelPos0.xyz+deltaPos;gl_Position=u_ViewProjectionMatrix*vec4(ansPosition,1.0);\n#else\ngl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION,1);\n#endif\nvec2 translate=u_translate;float translate_anchor=u_translate_anchor;if(translate_anchor==0.0){float sinA=sin(-u_Bearing);float cosA=cos(-u_Bearing);translate=vec2(translate[0]*cosA-translate[1]*sinA,translate[0]*sinA+translate[1]*cosA);}gl_Position.xy+=translate/vec2(u_Resolution.x/2.0,-u_Resolution.y/2.0)*gl_Position.w;vec3 normal=a_NORMAL_ED.xyz;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);float u_lightintensity=0.5;float u_vertical_gradient=1.0;vec3 u_lightcolor=vec3(1.0);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);vec4 ambientColor=color+ambientlight;float directional=clamp(dot(normal/16384.0,u_lightPos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if(normal.y!=0.0){directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(ambientColor.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(ambientColor.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(ambientColor.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color.a=opacity;v_ModelPos=u_ModelMatrix*vec4(a_POSITION,1.0);v_RelativePos=u_ModelMatrix*vec4(0.0,0.0,0.0,1.0);v_RelativePos=v_RelativePos/v_RelativePos.w;v_ModelPos=v_ModelPos/v_ModelPos.w;}',
          ),
        },
        sphereExtrusionPattern: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\n#include <u_BaseColorSampler>\n#include <v_TexCoord2>\n#include <c_extrusionF>\n#include <pragma_extrusion_define>\n#include <s_LightMaterial>\n#include <fn_phong>\n#include <u_LightMaterial>\nvarying vec4 modelPos;bool oppositeSigns(float x,float y){return(x<=0.&&y>=0.)||(x>=0.&&y<=0.);}void main(){\n#include <pragma_extrusion_initialize>\nvec4 finalFragColor=vec4(1.0);if(v_is_top!=0.){if(u_top_tex_rend){vec2 imagecoord=mod(v_TexCoord,1.0);vec2 pos=mix(u_top_pattern_tl_a/u_texsize,u_top_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_BaseColorSampler,pos);vec2 imagecoord_b=mod(v_TexCoord,1.0);vec2 pos2=mix(u_top_pattern_tl_b/u_texsize,u_top_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_BaseColorSampler,pos2);vec4 mixedColor=mix(color1,color2,u_mix);finalFragColor=mixedColor;}else{finalFragColor=color;}}else{if(u_body_tex_rend){vec2 imagecoord=mod(v_TexCoord,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_BaseColorSampler,pos);vec2 imagecoord_b=mod(v_TexCoord,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_BaseColorSampler,pos2);vec4 mixedColor=mix(color1,color2,u_mix);finalFragColor=mixedColor;}else{finalFragColor=color;}}\n#ifdef M_PHONG_LIGHT\nvec3 normal=normalize(v_Normal);vec4 phongColor=vec4(phong(modelPos.xyz,normal,u_LightMaterial,u_SunLightDirectionLocal,u_CameraPosition),1.0);vec4 baseColor=vec4(finalFragColor.rgb,opacity*finalFragColor.a);finalFragColor=baseColor*phongColor;\n#else\nfinalFragColor=vec4(finalFragColor.rgb,opacity*finalFragColor.a);\n#endif\ngl_FragColor=finalFragColor;\n#ifdef M_OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <a_POSITION3>\n#include <u_ModelViewProjectionMatrix>\n#include <u_ModelMatrix>\n#include <u_NormalMatrix>\n#include <u_Resolution>\n#include <u_Bearing>\n#include <pragma_extrusion_define>\n#include <v_TexCoord2>\n#include <c_extrusionV>\nvoid main(){\n#include <pragma_extrusion_initialize>\ngl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION,1);vec2 translate=u_translate;float translate_anchor=u_translate_anchor;if(translate_anchor==0.0){float sinA=sin(-u_Bearing);float cosA=cos(-u_Bearing);translate=vec2(translate[0]*cosA-translate[1]*sinA,translate[0]*sinA+translate[1]*cosA);}gl_Position.xy+=translate/vec2(u_Resolution.x/2.0,-u_Resolution.y/2.0)*gl_Position.w;v_Normal=vec3(u_NormalMatrix*vec4(a_NORMAL_ED));v_TexCoord=a_ST.xy;v_is_top=a_ST.z;}',
          ),
        },
        sphereTracking: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\n#include <pragma_line_define>\n#include <c_define>\n#include <c_lineF>\nuniform float u_start;uniform float u_end;uniform float u_segments;uniform bool u_reverse;uniform bool u_reserve;varying float v_seq;\n#ifdef M_ANS_ENABLED\nuniform float u_ANS_CurrentTime;varying float v_ANS_tripLength;varying float v_ANS_time;varying float v_ANS_trip_total_time;\n#endif\nvoid main(){\n#include <pragma_line_initialize>\nmediump float drive_opacity=1.0;float dist=length(v_Normal)*v_width2.s;float blur2=(blur+1.0/M_DEVICE_PIXEL_RATIO)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 tmpColor=vec4(color.xyz,1.0);\n#ifdef M_ANS_ENABLED\nfloat loopDelta=floor(u_ANS_CurrentTime/v_ANS_trip_total_time);float independentCurrentTime=u_ANS_CurrentTime-v_ANS_trip_total_time*loopDelta;if(v_ANS_time>independentCurrentTime||(v_ANS_time<independentCurrentTime-v_ANS_tripLength)){discard;}float ansOpacity=1.0-(independentCurrentTime-v_ANS_time)/v_ANS_tripLength;gl_FragColor=vec4(tmpColor.rgb,tmpColor.a*(alpha*opacity)*ansOpacity);\n#else\nif(u_reserve){if(v_seq>u_end){discard;}}else{if(v_seq<u_start||v_seq>u_end){discard;}drive_opacity=(v_seq-u_start)/u_segments;if(u_reverse){drive_opacity=1.0-drive_opacity;}}gl_FragColor=vec4(tmpColor.rgb,tmpColor.a*(alpha*opacity)*drive_opacity);\n#endif\n#ifdef M_OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <a_POSITION3>\n#include <u_ModelViewProjectionMatrix>\n#include <pragma_line_define>\n#include <c_define>\n#include <c_lineV>\nattribute vec2 a_normal_vec2;attribute float a_seq;varying float v_seq;\n#ifdef M_ANS_ENABLED\nattribute float a_ANS_POS_TIME;attribute float a_ANS_TRIP_TOTAL_TIME;attribute float a_ANS_TRIP_LENGTH;varying float v_ANS_tripLength;varying float v_ANS_time;varying float v_ANS_trip_total_time;\n#endif\nvoid main(){\n#include <pragma_line_initialize>\n#ifdef M_ANS_ENABLED\nv_ANS_tripLength=a_ANS_TRIP_LENGTH;v_ANS_time=a_ANS_POS_TIME;v_ANS_trip_total_time=a_ANS_TRIP_TOTAL_TIME;\n#endif\nv_seq=a_seq;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;mediump vec2 normal=a_normal_vec2;v_Normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth>0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth>0.0 ? 2.0 : 1.0)+ANTIALIASING;mediump vec2 origin_dist=outset*a_extrude*scale;mediump vec2 dist=u_PixelMatrix*outset*a_extrude*scale;gl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION,1.0);gl_Position.xy+=dist/u_GlUnitsToPixels*gl_Position.w;float extrude_length_without_perspective=length(origin_dist);float extrude_length_with_perspective=length(dist);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}',
          ),
        },
        sphereSprite: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\n#include <pragma_base_define>\n#include <c_define>\n#include <c_lineF>\nvarying float v_opacity;varying float v_discard;void main(){\n#include <pragma_base_initialize>\nif(v_discard<0.0){discard;}float opacity_m=v_opacity;float dist=length(v_Normal)*v_width2.s;float blur2=(blur+1.0/M_DEVICE_PIXEL_RATIO)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=vec4(color.rgb,color.a*(alpha*opacity)*opacity_m);\n#ifdef M_OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <a_POSITION3>\n#include <u_ModelViewProjectionMatrix>\n#include <pragma_line_define>\n#include <c_define>\n#include <c_lineV>\nattribute vec2 a_normal_vec2;attribute vec3 a_extra_m;uniform float u_count;varying float v_opacity;varying float v_discard;void main(){\n#include <pragma_line_initialize>\nvec3 f_extra_m=vec3(a_extra_m[0]*3.0/255.0,a_extra_m[1],a_extra_m[2]);float status=f_extra_m[2];float link_seq=f_extra_m[1];v_opacity=f_extra_m[0];int speed1;int speed2;int speed3;int speed4;if(speed_factor==1.0){speed1=int(u_count)-(int(u_count)/20)*20;}else if(speed_factor==2.0){speed2=int(u_count)-(int(u_count)/80)*80;}else if(speed_factor==3.0){speed3=int(u_count)-(int(u_count)/150)*150;}else{speed4=int(u_count)-(int(u_count)/240)*240;}speed1=speed1/2;speed2=speed2/8;speed3=speed3/15;speed4=speed4/24;if(status==1.0){if(link_seq!=float(speed1)){v_discard=-100.0;}else{v_discard=100.0;}}else if(status==2.0){if(link_seq!=float(speed2)){v_discard=-100.0;}else{v_discard=100.0;}}else if(status==3.0){if(link_seq!=float(speed3)){v_discard=-100.0;}else{v_discard=100.0;}}else if(status==4.0){if(link_seq!=float(speed4)){v_discard=-100.0;}else{v_discard=100.0;}}vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;mediump vec2 normal=a_normal_vec2;v_Normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth>0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth>0.0 ? 2.0 : 1.0)+ANTIALIASING;mediump vec2 origin_dist=outset*a_extrude*scale;mediump vec2 dist=u_PixelMatrix*outset*a_extrude*scale;gl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION,1.0);gl_Position.xy+=dist/u_GlUnitsToPixels*gl_Position.w;float extrude_length_without_perspective=length(origin_dist);float extrude_length_with_perspective=length(dist);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}',
          ),
        },
        sphereSpritePattern: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\n#include <u_BaseColorSampler>\n#include <u_PixelRatio>\n#pragma minemap: define lowp vec4 pattern_from\n#pragma minemap: define lowp vec4 pattern_to\n#pragma minemap: define lowp float pixel_ratio_from\n#pragma minemap: define lowp float pixel_ratio_to\n#pragma minemap: define lowp float speed\n#pragma minemap: define lowp float move_direction\n#include <pragma_line_define>\n#include <pragma_border_define>\n#include <c_define>\n#include <c_lineF>\nuniform vec2 u_texsize;uniform float u_count;uniform mediump vec3 u_scale;varying float v_linesofar;varying float v_width;void main(){\n#pragma minemap: initialize mediump vec4 pattern_from\n#pragma minemap: initialize mediump vec4 pattern_to\n#pragma minemap: initialize lowp float pixel_ratio_from\n#pragma minemap: initialize lowp float pixel_ratio_to\n#pragma minemap: initialize lowp float speed\n#pragma minemap: initialize lowp float move_direction\n#include <pragma_line_initialize>\n#include <pragma_border_initialize>\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_Normal)*v_width2.s;float blur2=(blur+1.0/u_PixelRatio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_Normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));float dir=move_direction-2.0<0.01 ?-1.0 : move_direction-3.0<0.01 ? 1.0 :-1.0;float count=u_count*speed*dir;color=texture2D(u_BaseColorSampler,vec2(mod(pos_a.x+count,1.0),pos_a.y+0.1));\n#ifdef M_SHADOW_VOLUME\ngl_FragColor=color;\n#else\ngl_FragColor=color;\n#endif\n#ifdef M_OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n#ifdef M_LOG_DEPTH\nwriteLogDepth(v_depthFromNearPlusOne,u_CurrentFrustum);\n#endif\n}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <a_POSITION3>\n#include <u_ModelViewProjectionMatrix>\n#pragma minemap: define lowp vec4 pattern_from\n#pragma minemap: define lowp vec4 pattern_to\n#pragma minemap: define lowp float pixel_ratio_from\n#pragma minemap: define lowp float pixel_ratio_to\n#pragma minemap: define lowp float speed\n#pragma minemap: define lowp float move_direction\n#include <pragma_line_define>\n#include <pragma_border_define>\n#include <c_define>\n#include <c_lineV>\nvarying float v_linesofar;varying float v_width;void main(){\n#pragma minemap: initialize mediump vec4 pattern_from\n#pragma minemap: initialize mediump vec4 pattern_to\n#pragma minemap: initialize lowp float pixel_ratio_from\n#pragma minemap: initialize lowp float pixel_ratio_to\n#pragma minemap: initialize lowp float speed\n#pragma minemap: initialize lowp float move_direction\n#include <pragma_line_initialize>\n#include <pragma_border_initialize>\nvec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;mediump vec2 normal=vec2(a_NORMAL/2.0>=1.0 ? 1.0 : 0.0,mod(a_NORMAL,2.0)==1.0 ? 1.0 :-1.0);v_Normal=normal;if(u_HasBorder==1.0){gapwidth=width/2.0;width=borderwidth/2.0;}else{gapwidth=gapwidth/2.0;}float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth>0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth>0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 origin_dist=outset*a_extrude*scale;mediump vec2 dist=u_PixelMatrix*outset*a_extrude*scale;gl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION,1.0);gl_Position.xy+=dist/u_GlUnitsToPixels*gl_Position.w;float extrude_length_without_perspective=length(origin_dist);float extrude_length_with_perspective=length(dist);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;\n#ifdef M_LOG_DEPTH\nv_depthFromNearPlusOne=vertexLogDepth(u_CurrentFrustum);\n#endif\n}',
          ),
        },
        gltfPBR: { fragmentSource: Ip(Sp), vertexSource: Ip(Ap) },
        gltfPBRI3DM: { fragmentSource: Ip(Sp), vertexSource: Ip(Ap) },
        StandardMaterial: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\n#include <c_define>\n#include <fn_getBlinnPhongColor>\n#include <fn_writeLogDepth>\n#include <s_LightMaterial>\n#include <fn_phong>\n#include <u_LightMaterial>\n#include <fn_encodeFloat>\n#include <u_ModelMatrix>\n#include <v_LocalPosition>\n#include <fn_pixelInVideo>\n#include <u_Color4>\n#include <u_Opacity>\n#include <v_TexCoord2>\n#include <v_Normal3>\nvarying vec4 v_ModelPos;\n#ifdef M_HAS_BASECOLORMAP\n#include <u_BaseColorSampler>\n#endif\nuniform sampler2D u_MaskSample;\n#include <u_ClipMatrix>\nuniform vec2 u_TextureSize;uniform bool u_ClipVideo;\n#if (defined M_NUM_VIDEOS) && (M_NUM_VIDEOS>0)\nuniform highp mat4 u_VIDEOMATCH_MVPMATRIX[M_NUM_VIDEOS];uniform highp vec3 u_VIDEOMATCH_RTP[M_NUM_VIDEOS];uniform bool u_HAS_VIDEOMATCHMAP[M_NUM_VIDEOS];uniform float u_Alpha[M_NUM_VIDEOS];uniform highp sampler2D u_VideoSampler[M_NUM_VIDEOS];uniform bool u_ActiveClipVideoTexture[M_NUM_VIDEOS];uniform vec3 u_ClipColors[M_NUM_VIDEOS];\n#endif\n#ifdef M_VERTEX_COLOR\nvarying vec3 v_Color;\n#endif\nuniform vec4 u_TexOffsetScale;uniform vec3 u_TexRotate;void main(){vec4 color=vec4(0.0);\n#ifdef M_HAS_BASECOLORMAP\nvec2 finalTexCoord=u_TexOffsetScale.zw*v_TexCoord;finalTexCoord=finalTexCoord-u_TexRotate.xy;finalTexCoord=vec2(finalTexCoord.x*cos(u_TexRotate.z)-finalTexCoord.y*sin(u_TexRotate.z),finalTexCoord.x*sin(u_TexRotate.z)+finalTexCoord.y*cos(u_TexRotate.z));finalTexCoord=finalTexCoord+u_TexRotate.xy;finalTexCoord+=u_TexOffsetScale.xy;color=texture2D(u_BaseColorSampler,finalTexCoord);\n#else\ncolor=u_Color;\n#endif\nvec4 finalFragColor=vec4(color.rgb,u_Opacity*color.a);gl_FragColor=finalFragColor;\n#if (defined M_NUM_VIDEOS) && (M_NUM_VIDEOS>0)\nfor(int i=0;i<M_NUM_VIDEOS;i++){if(u_HAS_VIDEOMATCHMAP[i]){if(u_ClipVideo){if(pixelInVideo(u_VIDEOMATCH_MVPMATRIX[i],u_VIDEOMATCH_RTP[i],u_ModelMatrix,v_LocalPosition,u_VideoSampler[i],u_Alpha[i],u_ClipMatrix,u_MaskSample,u_TextureSize,u_ActiveClipVideoTexture[i],u_ClipColors[i])){continue;}}else{if(pixelInVideo(u_VIDEOMATCH_MVPMATRIX[i],u_VIDEOMATCH_RTP[i],u_ModelMatrix,v_LocalPosition,u_VideoSampler[i],u_Alpha[i],u_ClipMatrix,u_MaskSample,u_TextureSize,false,u_ClipColors[i])){continue;}}}}\n#endif\n#ifdef M_VERTEX_COLOR\ngl_FragColor=vec4(v_Color,1.0);\n#endif\n#ifdef M_LOG_DEPTH\nwriteLogDepth(v_depthFromNearPlusOne,u_CurrentFrustum);\n#endif\n}',
          ),
          vertexSource: Ip(
            'precision highp float;\n#define GLSLIFY 1\n#include <c_define>\n#include <fn_vertexLogDepth>\n#include <a_POSITION3>\n#include <a_DOUBLE_PRECISION_POSITION>\n#include <u_ModelViewProjectionMatrix>\n#include <u_ModelMatrix>\n#include <u_NormalMatrix>\n#include <v_LocalPosition>\nattribute vec2 a_TEXCOORD_0;\n#include <a_NORMAL3>\n#include <v_TexCoord2>\n#include <v_Normal3>\nvarying vec4 v_ModelPos;\n#include <u_ModelViewProjectionRelativeToEye>\n#include <u_EncodedCameraPosition>\n#include <fn_translateRelativeToEye>\n#include <v_LIGHT>\n#ifdef M_INSTANCE_MATRIX\nattribute mat4 a_InstanceMatrix4;\n#endif\n#ifdef M_VERTEX_COLOR\nattribute vec3 a_Color;varying vec3 v_Color;\n#endif\nvoid main(){\n#ifdef M_DOUBLEPRECISION\n#ifdef M_INSTANCE_MATRIX\ngl_Position=u_ModelViewProjectionMatrix*a_InstanceMatrix4*u_ModelMatrix*vec4(a_PositionHigh+a_PositionLow,1.0);\n#else\ngl_Position=u_ModelViewProjectionRelativeToEye*translateRelativeToEye(a_PositionHigh,a_PositionLow);\n#endif\nv_LocalPosition=vec4(a_PositionHigh+a_PositionLow,1);v_ModelPos=u_ModelMatrix*v_LocalPosition;\n#else\nmat4 instanceMatrix4=mat4(1.0);\n#ifdef M_INSTANCE_MATRIX\ninstanceMatrix4=a_InstanceMatrix4*u_ModelMatrix;\n#endif\ngl_Position=u_ModelViewProjectionMatrix*instanceMatrix4*vec4(a_POSITION,1.0);v_LocalPosition=vec4(a_POSITION,1);v_ModelPos=u_ModelMatrix*vec4(a_POSITION,1.0);\n#endif\nv_TexCoord=a_TEXCOORD_0;\n#ifdef M_LOG_DEPTH\nv_depthFromNearPlusOne=vertexLogDepth(u_CurrentFrustum);\n#endif\nv_ModelPos=v_ModelPos/v_ModelPos.w;v_Normal=(u_NormalMatrix*vec4(a_NORMAL,0.0)).xyz;\n#ifdef M_VERTEX_COLOR\nv_Color=a_Color;\n#endif\n}',
          ),
        },
        WaterMaterial: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nuniform sampler2D u_MirrorSampler;\n#ifdef M_EnableSSR\nuniform sampler2D u_ColorSampler;uniform sampler2D u_NormalSampler;uniform sampler2D u_DepthSampler;varying vec2 uv;\n#include <u_ProjectionMatrix>\n#include <u_ModelViewProjectionMatrix>\nuniform float u_Width;uniform float u_Height;\n#endif\n#include <fn_readDepth>\n#include <u_CurrentFrustum>\n#include <u_Opacity>\nuniform float u_Time;uniform float u_DistortionScale;uniform sampler2D u_BaseColorSampler;\n#include <u_Color3>\nuniform vec3 u_SunDirection;uniform vec3 u_SunColor;uniform vec3 u_SkyColor;uniform float u_WaveSize;varying vec4 v_MirrorCoord;varying vec4 v_WorldPosition;varying vec4 v_reallyPosition;varying vec4 v_camera;varying mat3 v_RotateMatrixInverse;vec4 getNoise(vec2 uv){vec2 uv0=(uv/103.0)+vec2(u_Time/17.0,u_Time/29.0);vec2 uv1=uv/107.0-vec2(u_Time/-19.0,u_Time/31.0);vec2 uv2=uv/vec2(8907.0,9803.0)+vec2(u_Time/101.0,u_Time/97.0);vec2 uv3=uv/vec2(1091.0,1027.0)-vec2(u_Time/109.0,u_Time/-113.0);vec4 noise=texture2D(u_BaseColorSampler,uv0)+texture2D(u_BaseColorSampler,uv1)+texture2D(u_BaseColorSampler,uv2)+texture2D(u_BaseColorSampler,uv3);return noise*0.5-1.0;}float getShadowMask(){float shadow=1.0;\n#ifdef USE_SHADOWMAP\n#if NUM_DIR_LIGHT_SHADOWS > 0\nDirectionalLightShadow directionalLight;\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_DIR_LIGHT_SHADOWS;i++){directionalLight=directionalLightShadows[i];shadow*=receiveShadow ? getShadow(directionalShadowMap[i],directionalLight.shadowMapSize,directionalLight.shadowBias,directionalLight.shadowRadius,vDirectionalShadowCoord[i]): 1.0;}\n#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHT_SHADOWS > 0\nSpotLightShadow spotLight;\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_SPOT_LIGHT_SHADOWS;i++){spotLight=spotLightShadows[i];shadow*=receiveShadow ? getShadow(spotShadowMap[i],spotLight.shadowMapSize,spotLight.shadowBias,spotLight.shadowRadius,vSpotShadowCoord[i]): 1.0;}\n#pragma unroll_loop_end\n#endif\n#if NUM_POINT_LIGHT_SHADOWS > 0\nPointLightShadow pointLight;\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_POINT_LIGHT_SHADOWS;i++){pointLight=pointLightShadows[i];shadow*=receiveShadow ? getPointShadow(pointShadowMap[i],pointLight.shadowMapSize,pointLight.shadowBias,pointLight.shadowRadius,vPointShadowCoord[i],pointLight.shadowCameraNear,pointLight.shadowCameraFar): 1.0;}\n#pragma unroll_loop_end\n#endif\n#endif\nreturn shadow;}void sunLight(const vec3 sunDirection,const vec3 surfaceNormal,const vec3 eyeDirection,float shiny,float spec,float diffuse,inout vec3 diffuseColor,inout vec3 specularColor){vec3 reflection=normalize(reflect(-sunDirection,surfaceNormal));float direction=max(0.0,dot(eyeDirection,reflection));specularColor+=pow(direction,shiny)*u_SunColor*spec;diffuseColor+=max(dot(sunDirection,surfaceNormal),0.0)*u_SunColor*diffuse;}float getDepth(float z){float near=u_CurrentFrustum.x;float far=u_CurrentFrustum.y;float a=far/(far-near);float b=near/(near-far);return(a*z+b)/z;}bool checkDepthCollision(vec3 viewPos,mat4 mvp,sampler2D texture,out vec2 texPos){vec4 clipPos=mvp*vec4(viewPos,1.0);clipPos=clipPos/clipPos.w;texPos=vec2(clipPos.x,clipPos.y)*0.5+0.5;float depth=readDepth(texture,texPos,true);return texPos.x>0.0&&texPos.y>0.0&&texPos.x<1.0&&texPos.y<1.0&&depth<(clipPos.z*0.5)+0.5;}bool viewSpaceRayMarching(vec3 rayOrigin,vec3 rayDir,mat4 mvp,sampler2D texture,out vec2 hitScreenPos){const int maxStep=500;for(int i=10;i<maxStep;i++){vec3 currentPos=rayOrigin+rayDir*2.0*float(i);if(checkDepthCollision(currentPos,mvp,texture,hitScreenPos)){return true;}}return false;}void main(){vec3 sunDirection;if(u_SunDirection==vec3(0,0,0)){sunDirection=vec3(-u_SunLightDirectionLocal.x,u_SunLightDirectionLocal.y,-u_SunLightDirectionLocal.z);}else{sunDirection=u_SunDirection;}vec4 noise=getNoise(v_WorldPosition.xz*u_WaveSize);vec3 surfaceNormal=normalize(noise.xzy*vec3(1.5,1.0,1.5));vec3 diffuseLight=vec3(0.0);vec3 specularLight=vec3(0.0);vec3 worldToEye=v_RotateMatrixInverse*(u_CameraPosition-v_reallyPosition.xyz);worldToEye=vec3(-worldToEye.x,worldToEye.z,worldToEye.y);vec3 eyeDirection=normalize(worldToEye);sunLight(sunDirection,surfaceNormal,eyeDirection,100.0,2.0,0.5,diffuseLight,specularLight);float distance=length(worldToEye);vec2 distortion=surfaceNormal.xz*(0.001+1.0/distance)*u_DistortionScale;vec3 reflectionSample=u_SkyColor;float theta=max(dot(eyeDirection,surfaceNormal),0.0);float rf0=0.3;float reflectance=rf0+(1.0-rf0)*pow((1.0-theta),5.0);vec3 scatter=max(0.0,dot(surfaceNormal,eyeDirection))*u_Color;vec3 albedo=mix((u_SunColor*diffuseLight*0.3+scatter)*getShadowMask(),(vec3(0.1)+reflectionSample*0.9+reflectionSample*specularLight),reflectance);vec3 outgoingLight=albedo;\n#ifdef M_EnableSSR\nvec3 localNormalDirection=vec3(texture2D(u_NormalSampler,vec2(gl_FragCoord.x/u_Width,gl_FragCoord.y/u_Height)))*2.0-1.0;vec3 lightDirection=normalize(u_CameraPosition-v_reallyPosition.xyz);vec3 reflection=normalize(reflect(-lightDirection,localNormalDirection));vec2 hitScreenPos=vec2(0.0,0.0);if(viewSpaceRayMarching(v_reallyPosition.xyz,reflection,u_ModelViewProjectionMatrix,u_DepthSampler,hitScreenPos)){vec3 reflectTexture=vec3(texture2D(u_ColorSampler,hitScreenPos));gl_FragColor=vec4(albedo*u_Opacity*0.5+reflectTexture*0.5,u_Opacity);}else{gl_FragColor=vec4(albedo,u_Opacity);}\n#else\ngl_FragColor=vec4(albedo,u_Opacity);\n#endif\n}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#ifdef M_DOUBLEPRECISION\n#include <a_DOUBLE_PRECISION_POSITION>\n#else\n#include <a_POSITION3>\n#endif\n#include <u_ModelMatrix>\n#include <u_ModelViewProjectionMatrix>\n#include <u_ProjectionMatrix>\n#include <u_RotateMatrixInverse>\nvarying mat3 v_RotateMatrixInverse;varying vec4 v_MirrorCoord;varying vec4 v_WorldPosition;varying vec4 v_reallyPosition;\n#include <u_ModelViewProjectionRelativeToEye>\n#include <u_EncodedCameraPosition>\n#include <fn_translateRelativeToEye>\nvoid main(){\n#ifdef M_DOUBLEPRECISION\ngl_Position=u_ModelViewProjectionRelativeToEye*translateRelativeToEye(a_PositionHigh,a_PositionLow);v_reallyPosition=u_ModelMatrix*vec4(a_PositionHigh+a_PositionLow,1);\n#else\ngl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION,1.0);v_reallyPosition=u_ModelMatrix*vec4(a_POSITION,1.0);\n#endif\nv_MirrorCoord=u_RotateMatrixInverse*v_reallyPosition;v_RotateMatrixInverse=mat3(u_RotateMatrixInverse);v_MirrorCoord=v_MirrorCoord.xzyw;v_WorldPosition=v_MirrorCoord.xyzw;}',
          ),
        },
        mirrorMaterial: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nuniform lowp samplerCube u_EnvMap;varying vec3 v_Normal;uniform mat4 u_ModelMatrixInverse;varying vec3 v_Position;void main(){vec3 cameraPosition=(u_ModelMatrixInverse*vec4(u_CameraPosition,1.0)).xyz;vec3 eyeToSurfaceDir=normalize(v_Position-cameraPosition);vec3 direction=reflect(eyeToSurfaceDir,v_Normal);gl_FragColor=vec4(textureCube(u_EnvMap,direction).rgb,1.0);}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#ifdef M_DOUBLEPRECISION\n#include <a_DOUBLE_PRECISION_POSITION>\n#else\n#include <a_POSITION3>\n#endif\n#include <u_ModelMatrix>\n#include <u_ModelViewProjectionMatrix>\n#include <u_ProjectionMatrix>\n#include <u_RotateMatrixInverse>\nvarying vec3 v_Position;\n#include <u_ModelViewProjectionRelativeToEye>\n#include <u_EncodedCameraPosition>\n#include <fn_translateRelativeToEye>\nattribute vec3 a_NORMAL;varying vec3 v_Normal;void main(){\n#ifdef M_DOUBLEPRECISION\ngl_Position=u_ModelViewProjectionRelativeToEye*translateRelativeToEye(a_PositionHigh,a_PositionLow);v_Position=vec3(a_PositionHigh+a_PositionLow);\n#else\ngl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION,1.0);v_Position=vec3(a_POSITION);\n#endif\nv_Normal=normalize(a_NORMAL);}',
          ),
        },
        PhongMaterial: {
          fragmentSource: Ip(
            'precision highp float;\n#define GLSLIFY 1\n#include <s_LightMaterial>\n#include <fn_phong>\nuniform vec3 u_Color;uniform float u_Shininess;uniform float u_Reflectivity;uniform float u_Opacity;varying vec3 v_Normal;varying vec3 v_worldPosition;void main(){\n#ifdef M_enableLight\ngl_FragColor=vec4(u_Color*phong(u_Reflectivity,v_Normal,u_SunLightDirectionGlobal,v_worldPosition,u_Shininess),u_Opacity);\n#else\ngl_FragColor=vec4(u_Color,u_Opacity);\n#endif\n}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <basicVertex>\n#include <fn_basic>\nattribute vec3 a_NORMAL;varying vec3 v_Normal;varying vec3 v_worldPosition;\n#include <v_LIGHT>\nvoid main(){gl_Position=getGLPosition();v_worldPosition=getWorldPosition().xyz;vec4 delt=u_ModelMatrix*vec4(a_NORMAL,1.0)-u_ModelMatrix*vec4(0.0,0.0,0.0,1.0);v_Normal=normalize(delt.xyz);}',
          ),
        },
        LambertMaterial: {
          fragmentSource: Ip(
            'precision highp float;\n#define GLSLIFY 1\n#ifdef M_enableLight\n#ifdef M_AmbientLight\nuniform float u_AmbientLightsColor[M_AmbientLightCount*3];uniform float u_AmbientLightsIntensity[M_AmbientLightCount];\n#endif\n#ifdef M_DirectionalLight\nuniform float u_DirectionalLightColor[M_DirectionalLightCount*3];uniform float u_DirectionalLightIntensity[M_DirectionalLightCount];uniform float u_DirectionalLightDir[M_DirectionalLightCount*3];\n#endif\n#endif\nuniform vec3 u_Color;uniform vec3 u_Emissive;uniform float u_Reflectivity;uniform float u_Opacity;varying vec3 v_Normal;varying vec3 v_worldPosition;void main(){\n#ifdef M_enableLight\nvec3 ambient=vec3(0.0,0.0,0.0);\n#ifdef M_AmbientLight\nfor(int i=0;i<int(M_AmbientLightCount);++i){vec3 ambientColor=vec3(u_AmbientLightsColor[i*3],u_AmbientLightsColor[i*3+1],u_AmbientLightsColor[i*3+2]);float ambientIntensity=u_AmbientLightsIntensity[i];ambient=ambient+ambientIntensity*u_Reflectivity*ambientColor;}\n#endif\nvec3 diffuse=vec3(0.0,0.0,0.0);\n#ifdef M_SunLight\nif(u_SunLightDirectionLocal.z>0.0){diffuse=diffuse+u_Reflectivity*max(dot(v_Normal,u_SunLightDirectionGlobal),0.)*u_SunLightColor*u_SunLightIntensity;}\n#endif\n#ifdef M_DirectionalLight\nfor(int i=0;i<int(M_DirectionalLightCount);++i){vec3 directLightColor=vec3(u_DirectionalLightColor[i*3],u_DirectionalLightColor[i*3+1],u_DirectionalLightColor[i*3+2]);float directLightIntensity=u_DirectionalLightIntensity[i];vec3 directLightDir=vec3(u_DirectionalLightDir[i*3],u_DirectionalLightDir[i*3+1],u_DirectionalLightDir[i*3+2]);diffuse=diffuse+u_Reflectivity*max(dot(v_Normal,directLightDir),0.)*directLightColor*directLightIntensity;}\n#endif\ngl_FragColor=vec4(u_Color*(ambient+diffuse),u_Opacity);\n#else\ngl_FragColor=vec4(u_Color,u_Opacity);\n#endif\n}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <basicVertex>\n#include <fn_basic>\nattribute vec3 a_NORMAL;varying vec3 v_Normal;varying vec3 v_worldPosition;void main(){gl_Position=getGLPosition();v_worldPosition=getWorldPosition().xyz;vec4 delt=u_ModelMatrix*vec4(a_NORMAL,1.0)-u_ModelMatrix*vec4(0.0,0.0,0.0,1.0);v_Normal=normalize(delt.xyz);}',
          ),
        },
        SimplePolyline: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\n#include <u_Color4>\nvoid main(){gl_FragColor=u_Color;}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#ifdef M_DOUBLEPRECISION\n#include <a_DOUBLE_PRECISION_POSITION>\n#else\n#include <a_POSITION3>\n#endif\n#include <u_ModelViewProjectionMatrix>\n#include <u_ModelViewProjectionRelativeToEye>\n#include <u_EncodedCameraPosition>\n#include <fn_translateRelativeToEye>\nvoid main(){\n#ifdef M_DOUBLEPRECISION\ngl_Position=u_ModelViewProjectionRelativeToEye*translateRelativeToEye(a_PositionHigh,a_PositionLow);\n#else\ngl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION,1.0);\n#endif\n}',
          ),
        },
        screen: {
          fragmentSource: Ip(
            'precision highp float;\n#define GLSLIFY 1\n#include <u_BaseColorSampler>\nvarying highp vec2 v_TexCoord;uniform vec2 u_Resolution;void main(){if(M_SSAASamples==1){gl_FragColor=texture2D(u_BaseColorSampler,v_TexCoord);}else{float widthResolution=1.0/(u_Resolution.x*float(M_SSAASamples));float heightResolution=1.0/(u_Resolution.y*float(M_SSAASamples));vec4 color;float number;vec2 startCoord=v_TexCoord-vec2(widthResolution*((float(M_SSAASamples))/2.0-1.0)+0.5*widthResolution,heightResolution*((float(M_SSAASamples))/2.0-1.0)-0.5*widthResolution);for(int i=0;i<M_SSAASamples;i++){for(int j=0;j<M_SSAASamples;j++){color=color+texture2D(u_BaseColorSampler,startCoord+vec2(widthResolution*float(i),heightResolution*float(j)));number=number+1.0;}}gl_FragColor=color/number;}}',
          ),
          vertexSource: Ip(Pp),
        },
        panorama: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nuniform sampler2D u_std_resolution_img;uniform sampler2D u_low_resolution;\n#include <v_TexCoord2>\nvoid main(){vec4 calColor=texture2D(u_std_resolution_img,v_TexCoord);gl_FragColor=calColor;\n#ifdef M_OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <a_POSITION3>\nattribute vec2 a_texture_pos;\n#include <u_ModelViewProjectionMatrix>\n#include <v_TexCoord2>\nvoid main(){gl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION,1);v_TexCoord=a_texture_pos;}',
          ),
        },
        sphereHistogram: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\n#include <c_define>\n#include <fn_writeLogDepth>\n#include <c_extrusionF>\n#include <pragma_extrusion_define>\n#include <s_LightMaterial>\n#include <fn_phong>\n#include <u_LightMaterial>\nvarying vec4 modelPos;\n#include <u_Opacity>\nvoid main(){\n#include <pragma_extrusion_initialize>\nvec3 normal=normalize(v_Normal);\n#ifdef M_PHONG_LIGHT\nvec3 phongColor=phong(modelPos.xyz,normal,u_LightMaterial,u_SunLightDirectionLocal,u_CameraPosition);gl_FragColor=vec4(phongColor*color.rgb,color.a*v_opacity*u_Opacity);\n#else\ngl_FragColor=vec4(color.rgb,color.a*v_opacity*u_Opacity);\n#endif\n#ifdef M_LOG_DEPTH\nwriteLogDepth(v_depthFromNearPlusOne,u_CurrentFrustum);\n#endif\n}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <fn_vertexLogDepth>\n#include <c_define>\n#include <a_POSITION3>\n#include <u_ModelViewProjectionMatrix>\n#include <u_ModelMatrix>\n#include <u_NormalMatrix>\n#include <pragma_extrusion_define>\n#include <v_TexCoord2>\n#include <c_extrusionV>\nvarying float v_opacity;varying vec4 modelPos;void main(){\n#include <pragma_extrusion_initialize>\ngl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION,1);v_Normal=vec3(u_NormalMatrix*vec4(a_NORMAL_ED));v_Normal=a_NORMAL_ED.xyz;v_TexCoord=a_ST.xy;v_is_top=a_ST.z;float t=mod(a_NORMAL_ED.y,2.0);if(a_NORMAL_ED.y>0.0){v_opacity=1.2;}else{v_opacity=0.1;}modelPos=u_ModelMatrix*vec4(a_POSITION,1.0);modelPos=modelPos/modelPos.w;\n#ifdef M_LOG_DEPTH\nv_depthFromNearPlusOne=vertexLogDepth(u_CurrentFrustum);\n#endif\n}',
          ),
        },
        sphereHistogramColor: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\n#include <pragma_extrusion_define>\n#include <c_extrusionF>\n#include <u_Opacity>\nvoid main(){vec3 normal=normalize(v_Normal);vec3 lightDirection=normalize(u_SunLightDirectionLocal);float nDotL=max(dot(lightDirection,normal),0.0);vec3 diffuse_a=u_SunLightColor*u_color_a.rgb*nDotL;vec3 ambient_a=vec3(M_AMBIENT_STRENGTH,M_AMBIENT_STRENGTH,M_AMBIENT_STRENGTH)*u_color_a.rgb;vec3 diffuse_b=u_SunLightColor*u_color_b.rgb*nDotL;vec3 ambient_b=vec3(M_AMBIENT_STRENGTH,M_AMBIENT_STRENGTH,M_AMBIENT_STRENGTH)*u_color_b.rgb;vec3 diffuse_c=u_SunLightColor*u_color_c.rgb*nDotL;vec3 ambient_c=vec3(M_AMBIENT_STRENGTH,M_AMBIENT_STRENGTH,M_AMBIENT_STRENGTH)*u_color_c.rgb;vec3 diffuse_d=u_SunLightColor*u_color_d.rgb*nDotL;vec3 ambient_d=vec3(M_AMBIENT_STRENGTH,M_AMBIENT_STRENGTH,M_AMBIENT_STRENGTH)*u_color_d.rgb;vec3 diffuse_e=u_SunLightColor*u_color_e.rgb*nDotL;vec3 ambient_e=vec3(M_AMBIENT_STRENGTH,M_AMBIENT_STRENGTH,M_AMBIENT_STRENGTH)*u_color_e.rgb;vec3 tmp=vec3(0.0);vec3 real=vec3(0.0);if(v_height<0.25*u_max_height){tmp=(diffuse_b+ambient_b)-(diffuse_a+ambient_a);real=tmp*((v_height)/0.25/u_max_height)+(diffuse_a+ambient_a);}else if(v_height<0.5*u_max_height){tmp=(diffuse_c+ambient_c)-(diffuse_b+ambient_b);real=tmp*((v_height-0.25*u_max_height)/0.25/u_max_height)+(diffuse_b+ambient_b);}else if(v_height<0.75*u_max_height){tmp=(diffuse_d+ambient_d)-(diffuse_c+ambient_c);real=tmp*((v_height-0.5*u_max_height)/0.25/u_max_height)+(diffuse_c+ambient_c);}else if(v_height<0.8*u_max_height){tmp=(diffuse_e+ambient_e)-(diffuse_d+ambient_d);real=tmp*((v_height-0.75*u_max_height)/0.25/u_max_height)+(diffuse_d+ambient_d);}else{real=(diffuse_e+ambient_e);}if(u_depth_render==1.0){gl_FragColor=vec4(real.rgb,real.a*u_Opacity);}else{gl_FragColor=vec4(real.rgb,real.a*v_opacity*u_Opacity);}\n#ifdef M_OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);;\n#endif\n}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <a_POSITION3>\n#include <u_ModelViewProjectionMatrix>\n#include <u_NormalMatrix>\n#include <c_extrusionV>\nvarying float v_height;varying float v_opacity;\n#pragma minemap: define highp float base\n#pragma minemap: define highp float height\n#pragma minemap: define highp vec4 color\nvoid main(){\n#pragma minemap: initialize highp float base\n#pragma minemap: initialize highp float height\n#pragma minemap: initialize highp vec4 color\ngl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION,1);v_Normal=vec3(u_NormalMatrix*vec4(a_normal_ed));vec3 normal=a_normal_ed.xyz;float t=mod(normal.x,2.0);if(t>0.0){v_opacity=1.2;v_height=height*3.0;}else{v_opacity=0.1;v_height=0.0;}}',
          ),
        },
        sphereHistogramDynamic: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\n#include <pragma_extrusion_define>\n#include <c_extrusionF>\nvoid main(){\n#include <pragma_extrusion_initialize>\nif(v_height<0.2*u_max_height){vec4 tmp=u_color_b-u_color_a;vec4 real=tmp*((v_height)/0.2/u_max_height)+u_color_a;gl_FragColor=vec4(real.rgb*v_directional,1.0);}else if(v_height<0.4*u_max_height){vec4 tmp=u_color_c-u_color_b;vec4 real=tmp*((v_height-0.2*u_max_height)/0.2/u_max_height)+u_color_b;gl_FragColor=vec4(real.rgb*v_directional,1.0);}else if(v_height<0.6*u_max_height){vec4 tmp=u_color_d-u_color_c;vec4 real=tmp*((v_height-0.4*u_max_height)/0.2/u_max_height)+u_color_c;gl_FragColor=vec4(real.rgb*v_directional,1.0);}else if(v_height<0.8*u_max_height){vec4 tmp=u_color_e-u_color_d;vec4 real=tmp*((v_height-0.6*u_max_height)/0.2/u_max_height)+u_color_d;gl_FragColor=vec4(real.rgb*v_directional,1.0);}else{gl_FragColor=vec4(u_color_e.rgb*v_directional,1.0);}\n#ifdef M_OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <a_POSITION2>\n#include <u_ModelViewProjectionMatrix>\n#include <pragma_extrusion_define>\n#include <c_extrusionV>\nuniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform lowp float u_dyn_count;uniform float u_fluorescent;varying vec4 v_color;varying float v_opacity;varying float v_height;varying float v_directional;\n#pragma minemap: define lowp vec4 heightArr1\n#pragma minemap: define lowp vec4 heightArr2\n#pragma minemap: define lowp vec4 heightArr3\nvoid main(){\n#include <pragma_extrusion_initialize>\n#pragma minemap: initialize lowp vec4 heightArr1\n#pragma minemap: initialize lowp vec4 heightArr2\n#pragma minemap: initialize lowp vec4 heightArr3\nfloat _height=0.0;float _num=0.0;float _height1=0.0;float _height2=0.0;_num=abs(u_dyn_count)/500.0;if(_num<1.0){_height1=abs(height);_height2=abs(heightArr1[0]/255.0);}else if(_num<2.0){_height1=abs(heightArr1[0]/255.0);_height2=abs(heightArr1[1]/255.0);}else if(_num<3.0){_height1=abs(heightArr1[1]/255.0);_height2=abs(heightArr1[2]/255.0);}else if(_num<4.0){_height1=abs(heightArr1[2]/255.0);_height2=abs(heightArr1[3]/255.0);}else if(_num<5.0){_height1=abs(heightArr1[3]/255.0);_height2=abs(heightArr2[0]/255.0);}else if(_num<6.0){_height1=abs(heightArr2[0]/255.0);_height2=abs(heightArr2[1]/255.0);}else if(_num<7.0){_height1=abs(heightArr2[1]/255.0);_height2=abs(heightArr2[2]/255.0);}else if(_num<8.0){_height1=abs(heightArr2[2]/255.0);_height2=abs(heightArr2[3]/255.0);}else if(_num<9.0){_height1=abs(heightArr2[3]/255.0);_height2=abs(heightArr3[0]/255.0);}else if(_num<10.0){_height1=abs(heightArr3[0]/255.0);_height2=abs(heightArr3[1]/255.0);}else if(_num<11.0){_height1=abs(heightArr3[1]/255.0);_height2=abs(heightArr3[2]/255.0);}else if(_num<12.0){_height1=abs(heightArr3[2]/255.0);_height2=abs(heightArr3[3]/255.0);}_height=20.0+(_height1+(_height2-_height1)/500.0*mod(abs(u_dyn_count),500.0))*1.0;vec3 normal=a_normal_ed.xyz;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);gl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION.xy,t>0.0 ? _height : base,1);if(t>0.0){v_opacity=1.2;v_height=_height*3.0;}else{v_opacity=0.1;v_height=0.0;}float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if(normal.y!=0.0){directional*=clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0);}v_color.r+=clamp(color.r*directional*u_SunLightColor.r,mix(0.0,0.3,1.0-u_SunLightColor.r),1.0);v_color.g+=clamp(color.g*directional*u_SunLightColor.g,mix(0.0,0.3,1.0-u_SunLightColor.g),1.0);v_color.b+=clamp(color.b*directional*u_SunLightColor.b,mix(0.0,0.3,1.0-u_SunLightColor.b),1.0);v_directional=directional;}',
          ),
        },
        sphereSymtrackingIcon: { fragmentSource: Ip(vp), vertexSource: Ip(wp) },
        sphereSymtrackingSDF: { fragmentSource: Ip(Tp), vertexSource: Ip(bp) },
        sphereDynamicLine: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\n#include <pragma_line_define>\n#include <c_define>\n#include <c_lineF>\nuniform float u_count;uniform float u_segments;varying float v_seq;varying vec2 v_info;void main(){\n#include <pragma_line_initialize>\nfloat total_count=v_info[0];float offset_count=v_info[1];float actualSeq=v_seq-2.0;float actualCount=u_count+offset_count;float quotient=floor(actualCount/(total_count+u_segments));float mod1=mod(quotient,2.0);float count=mod(actualCount,total_count+u_segments);if(mod1!=0.0){count=total_count+u_segments-count;}float start=count-u_segments;float end=count;if(actualSeq<start||actualSeq>end){discard;}mediump float drive_opacity=(actualSeq-start)/u_segments;if(mod1!=0.0){drive_opacity=1.0-drive_opacity;}float dist=length(v_Normal)*v_width2.s;float blur2=(blur+1.0/M_DEVICE_PIXEL_RATIO)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=vec4(color.rgb,color.a*(alpha*opacity)*drive_opacity);\n#ifdef M_OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <a_POSITION3>\n#include <u_ModelViewProjectionMatrix>\n#include <pragma_line_define>\n#include <pragma_border_define>\n#include <c_define>\n#include <c_lineV>\nattribute float a_seq;attribute vec2 a_info;varying float v_seq;varying vec2 v_info;void main(){\n#include <pragma_line_initialize>\n#include <pragma_border_initialize>\nvec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_seq=a_seq;v_info=a_info;mediump vec2 normal=vec2(a_NORMAL/2.0>=1.0 ? 1.0 : 0.0,mod(a_NORMAL,2.0)==1.0 ? 1.0 :-1.0);v_Normal=normal;gapwidth=gapwidth/2.0;float halfwidth=(u_HasBorder==1.0)?(borderwidth*2.0+width)/2.0 : width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth>0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth>0.0 ? 2.0 : 1.0)+ANTIALIASING;if(u_HalfRender==1.){if(normaldirection==1.){outset=gapwidth+(normal.y>0. ? halfwidth : 0.)*(gapwidth>0.0 ? 2.0 : 1.0)+ANTIALIASING;}else{outset=gapwidth+(normal.y<0. ? halfwidth : 0.)*(gapwidth>0.0 ? 2.0 : 1.0)+ANTIALIASING;}}mediump vec2 origin_dist=outset*a_extrude*scale;mediump vec2 dist=u_PixelMatrix*outset*a_extrude*scale;gl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION.xyz,1.0);gl_Position.xy+=dist/u_GlUnitsToPixels*gl_Position.w;float extrude_length_without_perspective=length(origin_dist);float extrude_length_with_perspective=length(dist);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}',
          ),
        },
        debugViewPort: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nuniform sampler2D colorTexture;varying vec2 vUv;void main(){vec4 color=texture2D(colorTexture,vUv);gl_FragColor=vec4(color.r,color.g,color.r,1.0);}',
          ),
          vertexSource: Ip(Ep),
        },
        debugDepthTexture: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nuniform sampler2D colorTexture;varying vec2 vUv;\n#include <fn_unpackDepth>\nvoid main(){float z_window=unpackDepth(texture2D(colorTexture,vUv));float n_range=u_CurrentFrustum.x;float f_range=u_CurrentFrustum.y;float z_ndc=(2.0*z_window-n_range-f_range)/(f_range-n_range);float scale=pow(z_ndc*0.5+0.5,1.0);gl_FragColor=vec4(mix(vec3(0.0),vec3(1.0),scale),1.0);}',
          ),
          vertexSource: Ip(Ep),
        },
        skyboxCapture: {
          fragmentSource: Ip(
            'varying highp vec3 v_position;uniform highp float u_luminance;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;\n#ifdef GL_ES\nprecision highp float;\n#define GLSLIFY 1\n#endif\n#define BETA_R vec3(5.5e-6, 13.0e-6, 22.4e-6)\n#define BETA_M vec3(21e-6, 21e-6, 21e-6)\n#define MIE_G 0.76\n#define DENSITY_HEIGHT_SCALE_R 8000.0\n#define DENSITY_HEIGHT_SCALE_M 1200.0\n#define PLANET_RADIUS 6360e3\n#define ATMOSPHERE_RADIUS 6420e3\n#define SAMPLE_STEPS 10\n#define DENSITY_STEPS 4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius){float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return(-b+d)/(2.0*a);}vec3 extinction(vec2 density){return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point){float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle){return(3.0/(16.0*radians(180.0)))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle){return(3.0/(8.0*radians(180.0)))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir){float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for(int i=0;i<DENSITY_STEPS;++i){vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity){vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for(int i=0;i<SAMPLE_STEPS;++i){vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return(scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x){return((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main(){vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_SunLightDirectionLocal,u_SunLightIntensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;gl_FragColor=vec4(color,1.0);}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <a_POSITION3>\nuniform mat3 u_matrix_3f;varying highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end){return((value-start)*(new_end-new_start))/(end-start)+new_start;}void main(){vec4 pos=vec4(u_matrix_3f*a_POSITION,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_POSITION.xy,0.0,1.0);}',
          ),
        },
        skybox: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\n#include <v_TexCoord3>\nuniform lowp samplerCube u_cubemap;\n#ifdef M_HAS_STARRY_SKY_MAP\nuniform lowp samplerCube u_starrySkyTextureMap;\n#endif\n#ifdef M_HAS_DAY_MAP\nuniform lowp samplerCube u_dayTextureMap;\n#endif\n#include <u_Opacity>\nfloat sun_disk(highp vec3 ray_direction,highp vec3 sun_direction){highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(cos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end){return((value-start)*(new_end-new_start))/(end-start)+new_start;}highp vec3 hash(highp vec2 p){highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed){vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}void main(){vec3 uv=v_TexCoord;\n#ifdef M_HAS_DAY_MAP\nvec3 sky_color=textureCube(u_dayTextureMap,uv).rgb;\n#else\nvec3 sky_color=textureCube(u_cubemap,uv).rgb;\n#endif\n#ifdef M_HAS_STARRY_SKY_MAP\nsky_color=sky_color*u_Opacity+textureCube(u_starrySkyTextureMap,uv).rgb*(1.0-u_Opacity);\n#else\nsky_color=sky_color*u_Opacity+vec3(0.)*(1.0-u_Opacity);\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+0.44999999);sky_color+=0.1*sun_disk(v_TexCoord,u_SunLightDirectionLocal)*u_Opacity;gl_FragColor=vec4(sky_color,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <a_POSITION3>\nuniform lowp mat4 u_matrixSkyBox;\n#include <v_TexCoord3>\nvoid main(){const mat3 half_neg_pi_around_x=mat3(1.0,0.0,0.0,0.0,0.0,-1.0,0.0,1.0,0.0);v_TexCoord=half_neg_pi_around_x*a_POSITION;vec4 pos=u_matrixSkyBox*vec4(a_POSITION,1.0);gl_Position=pos.xyww;}',
          ),
        },
        distanceMaterial: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nvarying vec4 v_Position;\n#include <fn_encodeFloat>\nvoid main(){float distance=max(dot((u_CameraPosition-v_Position.xyz),u_CameraDirection),0.0);if(distance>65535.0){gl_FragColor=vec4(0.);}else{gl_FragColor=encodeFloat(distance/65535.0);}}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <fn_vertexLogDepth>\n#include <a_DOUBLE_PRECISION_POSITION>\n#include <a_POSITION3>\n#include <u_ModelViewProjectionMatrix>\n#include <a_BATCHID>\n#include <c_computeSTParsVert>\n#include <u_ModelViewProjectionRelativeToEye>\n#include <u_EncodedCameraPosition>\n#include <fn_translateRelativeToEye>\n#ifdef M_JOINT_MATRIX_CNT\nattribute vec4 a_JOINTS_0;attribute vec4 a_WEIGHTS_0;\n#endif\n#ifdef M_INSTANCE_MATRIX\nattribute mat4 a_InstanceMatrix4;uniform mat4 vpmatrix;\n#endif\n#include <u_HasSkinning>\n#ifdef M_JOINT_MATRIX_CNT\nuniform highp mat4 u_jointMatrix[M_JOINT_MATRIX_CNT];\n#endif\n#ifdef M_USE_MORPHTARGETS\n#include <a_POSITION3_1>\n#include <a_POSITION3_2>\nuniform vec2 u_morphTargetInfluences;\n#include <a_normal3_1>\n#include <a_NORMAL3_2>\n#include <a_TANGENT_1>\n#include <a_TANGENT_2>\n#endif\n#include <u_ModelMatrix>\nvarying vec4 v_Position;\n#include <fn_getAnimatedGLPosition>\nvoid main(){\n#ifdef M_DOUBLEPRECISION\nv_Position=u_ModelMatrix*vec4(a_PositionHigh+a_PositionLow,1);\n#else\nv_Position=u_ModelMatrix*vec4(a_POSITION,1.0);\n#endif\ngetAnimatedGLPosition();\n#include <c_computeSTMainVert>\n}',
          ),
        },
        depthMaterial: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\n#ifdef M_LOG_DEPTH\n#include <fn_writeLogDepth>\nvarying float v_depthFromNearPlusOne;\n#include <u_CurrentFrustum>\n#endif\n#ifdef M_DEPTH_DISTANCE\nvarying vec4 v_Position;\n#include <u_CurrentFrustum>\n#endif\n#include <fn_encodeFloat>\nvoid main(){gl_FragColor=vec4(encodeFloat(gl_FragCoord.z));\n#ifdef M_LOG_DEPTH\nwriteLogDepth(v_depthFromNearPlusOne,u_CurrentFrustum);\n#endif\n#ifdef M_DEPTH_DISTANCE\nfloat distance=length(u_CameraPosition-v_Position.xyz);float depth=distance/u_CurrentFrustum.y;gl_FragColor=vec4(depth,depth,depth,1.0);\n#endif\n}',
          ),
          vertexSource: Ip(Mp),
        },
        normalMaterial: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nvarying vec3 v_Normal;void main(){gl_FragColor=vec4((v_Normal+1.0)/2.0,1.0);}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\nattribute vec3 a_NORMAL;varying vec3 v_Normal;varying vec4 v_reallyPosition;\n#include <a_POSITION3>\n#include <u_ModelMatrix>\n#include <u_ModelViewProjectionMatrix>\n#include <a_DOUBLE_PRECISION_POSITION>\n#include <u_ModelViewProjectionRelativeToEye>\n#include <u_EncodedCameraPosition>\n#include <fn_translateRelativeToEye>\nvec3 cross2(vec3 a,vec3 b){float ax=a[0];float ay=a[1];float az=a[2];float bx=b[0];float by=b[1];float bz=b[2];vec3 result;result[0]=ay*bz-az*by;result[1]=az*bx-ax*bz;result[2]=ax*by-ay*bx;return-result;}mat4 localFrameToFixedFrame(vec3 cartesianOrigin){vec3 origin=cartesianOrigin;vec3 oneOverRadiiSquared=vec3(2.458172257647332e-14,2.458172257647332e-14,2.4747391015697002e-14);vec3 east=normalize(vec3(-origin.y,origin.x,0.0));vec3 up=normalize(vec3(origin.x*oneOverRadiiSquared.x,origin.y*oneOverRadiiSquared.y,origin.z*oneOverRadiiSquared.z));vec3 north=cross2(up,east);vec3 firstAxisVector=east;vec3 secondAxisVector=north;vec3 thirdAxisVector=up;mat4 result=mat4(firstAxisVector.x,firstAxisVector.y,firstAxisVector.z,0.0,secondAxisVector.x,secondAxisVector.y,secondAxisVector.z,0.0,thirdAxisVector.x,thirdAxisVector.y,thirdAxisVector.z,0.0,origin.x,origin.y,origin.z,1.0);return result;}void main(){\n#ifdef M_DOUBLEPRECISION\ngl_Position=u_ModelViewProjectionRelativeToEye*translateRelativeToEye(a_PositionHigh,a_PositionLow);v_reallyPosition=u_ModelMatrix*vec4(a_PositionHigh+a_PositionLow,1);\n#else\ngl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION,1.0);v_reallyPosition=u_ModelMatrix*vec4(a_POSITION,1.0);\n#endif\nvec4 delt=u_ModelMatrix*vec4(a_NORMAL,1.0)-u_ModelMatrix*vec4(0.0,0.0,0.0,1.0);v_Normal=normalize(delt.xyz);}',
          ),
        },
        pickColorMaterial: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\n#if defined(M_USE_PICKINGTEXTURES)\nuniform sampler2D pickColorTexture;varying vec2 batch_featureSt;\n#else\nuniform vec4 u_pickIdColor;\n#endif\n#ifdef M_MODEL_INSTANCE_BATCH_TEXTURE\nvarying vec4 v_pickColor;\n#endif\n#if defined(M_POLYLINE) && defined(M_SHADOW_VOLUME)\n#include <u_PixelRatio>\n#include <u_Viewport>\n#include <u_CurrentFrustum>\n#include <u_FrustumPlanes>\nuniform mat4 u_ViewportTransformation;uniform mat4 u_InverseProjection;uniform sampler2D u_DepthTexture;\n#include <fn_readDepth>\n#include <fn_windowToEyeCoordinates>\n#include <fn_metersPerPixel>\n#include <fn_planeDistance>\nvarying vec4 v_startPlaneNormalEcAndHalfWidth;varying vec4 v_endPlaneNormalEcAndBatchId;varying vec4 v_rightPlaneEC;varying vec4 v_endEcAndStartEcX;varying vec4 v_texcoordNormalizationAndStartEcYZ;\n#endif\n#ifdef M_USE_PICKINGTEXTURES\nvoid main(){gl_FragColor=texture2D(pickColorTexture,batch_featureSt);}\n#else\nvoid main(){\n#if defined(M_POLYLINE) && defined(M_SHADOW_VOLUME)\nfloat logDepthOrDepth=readDepth(u_DepthTexture,gl_FragCoord.xy/u_Viewport.zw,false);if(logDepthOrDepth==0.0){discard;}vec3 ecStart=vec3(v_endEcAndStartEcX.w,v_texcoordNormalizationAndStartEcYZ.zw);vec4 eyeCoordinate=windowToEyeCoordinates(gl_FragCoord.xy,logDepthOrDepth);eyeCoordinate/=eyeCoordinate.w;float halfMaxWidth=v_startPlaneNormalEcAndHalfWidth.w*metersPerPixel(eyeCoordinate);;float widthwiseDistance=planeDistance(v_rightPlaneEC,eyeCoordinate.xyz);float distanceFromStart=planeDistance(v_startPlaneNormalEcAndHalfWidth.xyz,-dot(ecStart,v_startPlaneNormalEcAndHalfWidth.xyz),eyeCoordinate.xyz);float distanceFromEnd=planeDistance(v_endPlaneNormalEcAndBatchId.xyz,-dot(v_endEcAndStartEcX.xyz,v_endPlaneNormalEcAndBatchId.xyz),eyeCoordinate.xyz);if(abs(widthwiseDistance)>halfMaxWidth||distanceFromStart<0.0||distanceFromEnd<0.0){discard;}\n#endif\ngl_FragColor=u_pickIdColor;\n#ifdef M_MODEL_INSTANCE_BATCH_TEXTURE\ngl_FragColor=v_pickColor;\n#endif\n}\n#endif\n',
          ),
          vertexSource: Ip(Mp),
        },
        BillboardMaterial: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nuniform sampler2D u_BaseColorSampler;\n#include <u_Color4>\nvarying vec2 v_TexCoord;\n#ifdef M_PARTICLSYSTEM\nvarying vec4 v_Color;\n#endif\nvoid main(){\n#if defined(M_USE_BILLBOARDTEXTURE)\n#if defined(M_INSTANCE_MATRIX) && defined(M_PARTICLSYSTEM)\nvec4 texture=texture2D(u_BaseColorSampler,vec2(v_TexCoord.x,v_TexCoord.y));gl_FragColor=vec4(texture.rgb,texture.a*v_Color.a);\n#else\ngl_FragColor=texture2D(u_BaseColorSampler,vec2(v_TexCoord.x,v_TexCoord.y));\n#endif\n#else\ngl_FragColor=u_Color;\n#endif\n}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\nattribute vec3 a_POSITION;attribute vec2 a_TEXCOORD_0;attribute vec2 a_UVOffset;uniform float u_rotation;uniform vec2 u_center;uniform vec2 u_UVScale;uniform mat4 u_ScaleMatrix;uniform mat4 u_MvMatrix;uniform mat4 u_InvertViewMatrix;uniform mat4 u_ProjectionMatrix;varying vec2 v_TexCoord;\n#ifdef M_INSTANCE_MATRIX\nattribute mat4 a_InstanceMatrix4;\n#endif\n#ifdef M_PARTICLSYSTEM\nattribute vec4 a_Color;attribute float a_Scale;varying vec4 v_Color;\n#endif\n#ifdef M_FIXED_PIXEL_SIZE\nuniform vec2 u_PixelResolution;uniform mat4 u_ViewportTransformation;uniform vec4 u_Viewport;\n#endif\n#include <fn_billboardVertexPosition>\nvoid main(){v_TexCoord.x=a_TEXCOORD_0.x;v_TexCoord.y=1.0-a_TEXCOORD_0.y;gl_Position=billboardVertexPosition();}',
          ),
        },
        viewDomeAnalysis: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nuniform sampler2D u_DepthMap0;uniform sampler2D u_DepthMap1;uniform sampler2D u_DepthMap2;uniform sampler2D u_DepthMap3;uniform sampler2D u_DepthMap4;uniform int u_DomeType;uniform vec4 u_VisibleAreaColor;uniform vec4 u_HiddenAreaColor;varying vec4 v_renderTextureCoord0;varying vec4 v_renderTextureCoord1;varying vec4 v_renderTextureCoord2;varying vec4 v_renderTextureCoord3;varying vec4 v_renderTextureCoord4;\n#include <fn_unpackDepth>\nbool IsValidUV(vec4 texCoord){if((texCoord.x<=1.0)&&(texCoord.x>=-1.0)&&(texCoord.y<=1.0)&&(texCoord.y>=-1.0)&&(texCoord.z<=1.0)&&(texCoord.z>=-1.0)){return true;}else{return false;}}bool IsVisible(sampler2D shadowMap,vec4 uv){bool isVisible=true;float depth=unpackDepth(texture2D(shadowMap,uv.xy));if(depth<0.00001){return isVisible;}if(uv.z>(depth+0.00001)){isVisible=false;}return isVisible;}bool GetVisibleFlag(){bool isVisible=true;if(IsValidUV(v_renderTextureCoord0)){isVisible=IsVisible(u_DepthMap0,v_renderTextureCoord0);}else if(IsValidUV(v_renderTextureCoord1)){isVisible=IsVisible(u_DepthMap1,v_renderTextureCoord1);}else if(IsValidUV(v_renderTextureCoord2)){isVisible=IsVisible(u_DepthMap2,v_renderTextureCoord2);}else if(IsValidUV(v_renderTextureCoord3)){isVisible=IsVisible(u_DepthMap3,v_renderTextureCoord3);}else if(IsValidUV(v_renderTextureCoord4)){isVisible=IsVisible(u_DepthMap4,v_renderTextureCoord4);}return isVisible;}void main(){bool isVisible=GetVisibleFlag();if(u_DomeType==0){if(!isVisible){discard;}else{gl_FragColor=u_VisibleAreaColor;}}else if(u_DomeType==1){if(!isVisible){gl_FragColor=u_HiddenAreaColor;}else{discard;}}else{if(!isVisible){gl_FragColor=u_HiddenAreaColor;}else{gl_FragColor=u_VisibleAreaColor;}}}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\nuniform mat4 u_TexWorldViewProjMatrix0;uniform mat4 u_TexWorldViewProjMatrix1;uniform mat4 u_TexWorldViewProjMatrix2;uniform mat4 u_TexWorldViewProjMatrix3;uniform mat4 u_TexWorldViewProjMatrix4;varying vec4 v_renderTextureCoord0;varying vec4 v_renderTextureCoord1;varying vec4 v_renderTextureCoord2;varying vec4 v_renderTextureCoord3;varying vec4 v_renderTextureCoord4;vec4 vexPos;uniform float u_Radius;\n#include <a_POSITION3>\n#include <u_ModelViewProjectionMatrix>\nvec4 GetUV(const mat4 renderTextureMatrix){vec4 texCoord=renderTextureMatrix*vec4(vexPos.xyz,1.0);texCoord=texCoord/texCoord.w;texCoord.xyz=texCoord.xyz*0.5+0.5;return texCoord;}void main(){vexPos=vec4(a_POSITION*u_Radius,1.0);v_renderTextureCoord0=GetUV(u_TexWorldViewProjMatrix0);v_renderTextureCoord1=GetUV(u_TexWorldViewProjMatrix1);v_renderTextureCoord2=GetUV(u_TexWorldViewProjMatrix2);v_renderTextureCoord3=GetUV(u_TexWorldViewProjMatrix3);v_renderTextureCoord4=GetUV(u_TexWorldViewProjMatrix4);gl_Position=u_ModelViewProjectionMatrix*vexPos;}',
          ),
        },
        viewDomeCalculateAnalysis: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nuniform sampler2D u_DepthMap;varying vec4 v_renderTextureCoord;\n#include <fn_unpackDepth>\nbool IsValidUV(vec4 texCoord){if((texCoord.x<=1.0)&&(texCoord.x>=-1.0)&&(texCoord.y<=1.0)&&(texCoord.y>=-1.0)&&(texCoord.z<=1.0)&&(texCoord.z>=-1.0)){return true;}else{return false;}}void main(){bool isVisible=false;if(IsValidUV(v_renderTextureCoord)){float depth=unpackDepth(texture2D(u_DepthMap,v_renderTextureCoord.xy));if(depth>1.0-0.00001){isVisible=true;}}if(!isVisible){gl_FragColor=vec4(1.0,0.0,0.0,1.0);}else{gl_FragColor=vec4(0.0,1.0,0.0,1.0);}}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <a_POSITION3>\n#include <u_ModelViewProjectionMatrix>\nvarying vec4 v_renderTextureCoord;vec4 GetUV(vec4 vexPos){vec4 texCoord=vec4(vexPos.xyz,1.0);texCoord.xyz=texCoord.xyz*0.5+0.5;return texCoord;}void main(){vec4 vexPos=u_ModelViewProjectionMatrix*vec4(a_POSITION,1.0);v_renderTextureCoord=GetUV(vexPos);gl_Position=vexPos;}',
          ),
        },
        viewshedAnalysis: {
          fragmentSource: Ip(
            'precision highp float;\n#define GLSLIFY 1\nuniform sampler2D u_DepthTexture;uniform sampler2D u_ViewshedDepthTexture;uniform mat4 u_textureViewMatrix;uniform mat4 u_textureProjMatrix;uniform float u_farDist;varying vec2 v_TexCoord;\n#include <fn_readDepth>\nvoid main(){vec4 result=vec4(0.,0.,0.,1.);if(result.x!=1.0){float sceneDepth=readDepth(u_DepthTexture,v_TexCoord,true);vec4 projPos=vec4(v_TexCoord*2.0-1.0,sceneDepth*2.0-1.0,1.0);vec4 texViewPos=u_textureViewMatrix*projPos;vec4 texProjPos=u_textureProjMatrix*texViewPos;texProjPos/=texProjPos.w;texProjPos.xyz=texProjPos.xyz*0.5+0.5;texViewPos/=texViewPos.w;texViewPos.xyz*=u_farDist/length(texViewPos.xyz);vec4 farPos=u_textureProjMatrix*texViewPos;float farDepth=farPos.z/farPos.w;farDepth=farDepth*0.5+0.5;farDepth=min(farDepth,1.0);if(texProjPos.x>0.0&&texProjPos.x<1.0&&texProjPos.y>0.0&&texProjPos.y<1.0&&texProjPos.z>0.5&&texProjPos.z<farDepth){float texelSize=1.0/2048.0;float depth0=readDepth(u_ViewshedDepthTexture,texProjPos.xy,false);float depth1=readDepth(u_ViewshedDepthTexture,texProjPos.xy+vec2(-texelSize,0.0),false);float depth2=readDepth(u_ViewshedDepthTexture,texProjPos.xy+vec2(texelSize,0.0),false);float depth3=readDepth(u_ViewshedDepthTexture,texProjPos.xy+vec2(0.0,-texelSize),false);float depth4=readDepth(u_ViewshedDepthTexture,texProjPos.xy+vec2(0.0,texelSize),false);float depth=max(max(max(max(depth0,depth1),depth2),depth3),depth4);if(depth<1.0&&depth-texProjPos.z<-1.0e-5){result.x=0.5;}else{result.x=1.0;}}}gl_FragColor=result;}',
          ),
          vertexSource: Ip(Pp),
        },
        viewshedMix: {
          fragmentSource: Ip(
            'precision highp float;\n#define GLSLIFY 1\nuniform sampler2D u_resultTexture;uniform vec4 u_visibleAreaColor;uniform vec4 u_hiddenAreaColor;varying vec2 v_TexCoord;void main(){vec4 color=vec4(0.0);vec4 result=texture2D(u_resultTexture,v_TexCoord);if(result.x>0.9){color=u_visibleAreaColor;}else if(result.x>0.4){color=u_hiddenAreaColor;}gl_FragColor=color;}',
          ),
          vertexSource: Ip(Pp),
        },
        sightlineAnalysis: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nuniform vec4 u_VisibleColor;uniform vec4 u_HiddenColor;uniform sampler2D u_DepthTexture;uniform sampler2D u_ViewshedDepthTexture;uniform bool u_MainCameraDetection;\n#include <fn_readDepth>\nvarying vec4 v_ViewshedTexCoord;varying vec4 v_TexCoord;void main(){vec4 resultColor=u_VisibleColor;vec4 texCoord=v_ViewshedTexCoord/v_ViewshedTexCoord.w;float depth=texCoord.z*0.5+0.5;texCoord.xy=texCoord.xy*0.5+0.5;float viewshedDepth=readDepth(u_ViewshedDepthTexture,texCoord.xy,false);if(viewshedDepth<depth&&viewshedDepth>0.0&&viewshedDepth<1.0){resultColor=u_HiddenColor;}if(u_MainCameraDetection){vec4 sceneTexCoord=v_TexCoord/v_TexCoord.w;float linePixelDepth=sceneTexCoord.z*0.5+0.5;sceneTexCoord.xy=sceneTexCoord.xy*0.5+0.5;float sceneDepth=readDepth(u_DepthTexture,sceneTexCoord.xy,true);if(sceneDepth<linePixelDepth){resultColor=vec4(0.4,0.4,0.4,1.0);}}gl_FragColor=resultColor;}',
          ),
          vertexSource: Ip(
            'precision highp float;\n#define GLSLIFY 1\n#include <a_POSITION3>\n#include <u_ModelViewProjectionMatrix>\nuniform mat4 u_ModelViewProjectionMatrixOnViewshed;varying vec4 v_ViewshedTexCoord;varying vec4 v_TexCoord;void main(){gl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION,1.0);v_ViewshedTexCoord=u_ModelViewProjectionMatrixOnViewshed*vec4(a_POSITION,1.0);v_TexCoord=gl_Position;}',
          ),
        },
        sightlineMix: {
          fragmentSource: Ip(
            'precision highp float;\n#define GLSLIFY 1\nuniform sampler2D u_resultTexture;uniform vec4 u_visibleAreaColor;uniform vec4 u_hiddenAreaColor;varying vec2 v_TexCoord;void main(){vec4 result=texture2D(u_resultTexture,v_TexCoord);gl_FragColor=result;}',
          ),
          vertexSource: Ip(Pp),
        },
        PolylineMaterial: {
          fragmentSource: Ip(
            '#include <u_Opacity>\n#include <u_PixelRatio>\n#include <u_BaseColorSampler>\n#extension GL_EXT_frag_depth : enable\n#define GLSLIFY 1\nuniform float u_OneOverLog2FarDepthFromNearPlusOne;uniform float u_FarDepthFromNearPlusOne;uniform vec4 u_Color;uniform float u_DashLength;uniform float u_DashPattern;uniform vec4 u_GapColor;uniform vec4 u_TexOffsetScale;uniform vec3 u_TexRotate;varying float v_polylineAngle;\n#ifdef M_SHADOW_VOLUME\n#include <u_Viewport>\n#include <u_CurrentFrustum>\n#include <u_FrustumPlanes>\nuniform mat4 u_ViewportTransformation;uniform mat4 u_InverseProjection;uniform sampler2D u_DepthTexture;\n#include <fn_readDepth>\n#include <fn_windowToEyeCoordinates>\n#include <fn_metersPerPixel>\n#include <fn_planeDistance>\nvarying vec4 v_startPlaneNormalEcAndHalfWidth;varying vec4 v_endPlaneNormalEcAndBatchId;varying vec4 v_rightPlaneEC;varying vec4 v_endEcAndStartEcX;varying vec4 v_texcoordNormalizationAndStartEcYZ;\n#else\n#include <v_TexCoord2>\n#endif\n#ifdef M_LOG_DEPTH\nvarying float v_depthFromNearPlusOne;\n#endif\n#ifdef M_VERTEX_COLOR\nvarying vec3 v_Color;\n#endif\nvoid czm_writeLogDepth(float depth){\n#if defined(GL_EXT_frag_depth) && defined(M_LOG_DEPTH)\nif(depth<=0.9999999||depth>u_FarDepthFromNearPlusOne){discard;}gl_FragDepthEXT=log2(depth)*u_OneOverLog2FarDepthFromNearPlusOne;\n#endif\n}void czm_writeLogDepth(){\n#ifdef M_LOG_DEPTH\nczm_writeLogDepth(v_depthFromNearPlusOne);\n#endif\n}mat2 rotate(float rad){float c=cos(rad);float s=sin(rad);return mat2(c,s,-s,c);}void main(){vec2 texCoord=vec2(0.0);\n#ifdef M_SHADOW_VOLUME\nfloat logDepthOrDepth=readDepth(u_DepthTexture,gl_FragCoord.xy/u_Viewport.zw,false);if(logDepthOrDepth==0.0){discard;}vec3 ecStart=vec3(v_endEcAndStartEcX.w,v_texcoordNormalizationAndStartEcYZ.zw);vec4 eyeCoordinate=windowToEyeCoordinates(gl_FragCoord.xy,logDepthOrDepth);eyeCoordinate/=eyeCoordinate.w;float halfMaxWidth=v_startPlaneNormalEcAndHalfWidth.w;\n#ifdef M_PIXEL_WIDTH\nhalfMaxWidth*=metersPerPixel(eyeCoordinate);\n#endif\nfloat widthwiseDistance=planeDistance(v_rightPlaneEC,eyeCoordinate.xyz);float distanceFromStart=planeDistance(v_startPlaneNormalEcAndHalfWidth.xyz,-dot(ecStart,v_startPlaneNormalEcAndHalfWidth.xyz),eyeCoordinate.xyz);float distanceFromEnd=planeDistance(v_endPlaneNormalEcAndBatchId.xyz,-dot(v_endEcAndStartEcX.xyz,v_endPlaneNormalEcAndBatchId.xyz),eyeCoordinate.xyz);if(abs(widthwiseDistance)>halfMaxWidth||distanceFromStart<0.0||distanceFromEnd<0.0){discard;}vec3 alignedPlaneNormal;alignedPlaneNormal=cross(v_rightPlaneEC.xyz,v_startPlaneNormalEcAndHalfWidth.xyz);alignedPlaneNormal=normalize(cross(alignedPlaneNormal,v_rightPlaneEC.xyz));distanceFromStart=planeDistance(alignedPlaneNormal,-dot(alignedPlaneNormal,ecStart),eyeCoordinate.xyz);alignedPlaneNormal=cross(v_rightPlaneEC.xyz,v_endPlaneNormalEcAndBatchId.xyz);alignedPlaneNormal=normalize(cross(alignedPlaneNormal,v_rightPlaneEC.xyz));distanceFromEnd=planeDistance(alignedPlaneNormal,-dot(alignedPlaneNormal,v_endEcAndStartEcX.xyz),eyeCoordinate.xyz);float s=clamp(distanceFromStart/(distanceFromStart+distanceFromEnd),0.0,1.0);s=(s*v_texcoordNormalizationAndStartEcYZ.x)+v_texcoordNormalizationAndStartEcYZ.y;float t=(widthwiseDistance+halfMaxWidth)/(2.0*halfMaxWidth);texCoord=vec2(s,t);\n#else\ntexCoord=v_TexCoord;\n#endif\nvec4 color=vec4(0.0);\n#ifdef M_HAS_BASECOLORMAP\nvec2 finalTexCoord=u_TexOffsetScale.zw*texCoord;finalTexCoord=finalTexCoord-u_TexRotate.xy;finalTexCoord=vec2(finalTexCoord.x*cos(u_TexRotate.z)-finalTexCoord.y*sin(u_TexRotate.z),finalTexCoord.x*sin(u_TexRotate.z)+finalTexCoord.y*cos(u_TexRotate.z));finalTexCoord=finalTexCoord+u_TexRotate.xy;finalTexCoord+=u_TexOffsetScale.xy;color=texture2D(u_BaseColorSampler,finalTexCoord);\n#else\ncolor=u_Color;\n#endif\n#ifdef M_POLYLINE_DASH\nvec2 pos=rotate(v_polylineAngle)*gl_FragCoord.xy;float dashPosition=fract(pos.x/(u_DashLength*u_PixelRatio));float maskIndex=floor(dashPosition*16.0);float maskTest=floor(u_DashPattern/pow(2.0,maskIndex));vec4 fragColor=(mod(maskTest,2.0)<1.0)? u_GapColor : color;if(fragColor.a<0.005){discard;}gl_FragColor=vec4(fragColor.rgb,fragColor.a*u_Opacity);\n#else\ngl_FragColor=vec4(color.rgb,color.a*u_Opacity);\n#endif\n#ifdef M_VERTEX_COLOR\ngl_FragColor=vec4(v_Color,u_Opacity);\n#endif\nczm_writeLogDepth();}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <u_CurrentFrustum>\n#include <u_FrustumPlanes>\n#include <u_EncodedCameraPosition>\n#include <u_ProjectionMatrix>\n#include <u_PixelRatio>\n#include <u_Viewport>\n#include <fn_metersPerPixel>\nuniform mat4 u_ViewportTransformation;uniform mat4 u_ViewportOrthographic;uniform mat4 u_modelViewRelativeToEye;uniform mat3 u_Normal;uniform float u_GlobeMinimumAltitude;uniform float u_GeometricToleranceOverMeter;\n#include <fn_translateRelativeToEye>\n#ifdef M_SHADOW_VOLUME\nattribute vec3 a_PositionHigh;attribute vec3 a_PositionLow;attribute vec3 a_StartHigh;attribute vec3 a_StartLow;attribute vec3 a_StartNormal;attribute vec3 a_EndNormal;attribute vec3 a_RightNormal;attribute vec3 a_ForwardOffset;attribute vec2 a_TexCoord;attribute float a_Width;varying vec4 v_startPlaneNormalEcAndHalfWidth;varying vec4 v_endPlaneNormalEcAndBatchId;varying vec4 v_rightPlaneEC;varying vec4 v_endEcAndStartEcX;varying vec4 v_texcoordNormalizationAndStartEcYZ;\n#include <fn_planeDistance>\n#include <fn_branchFreeTernary>\n#include <fn_polylineVolumePosition>\n#else\nattribute vec3 a_PositionHigh;attribute vec3 a_PositionLow;attribute vec3 a_PrevPositionHigh;attribute vec3 a_PrevPositionLow;attribute vec3 a_NextPositionHigh;attribute vec3 a_NextPositionLow;attribute vec2 a_ExpandAndWidth;attribute vec2 a_TEXCOORD_0;\n#include <fn_polylineVertexPosition>\n#include <v_TexCoord2>\n#endif\nvarying float v_polylineAngle;\n#ifdef M_LOG_DEPTH\nvarying float v_depthFromNearPlusOne;\n#include <fn_vertexLogDepth>\n#endif\n#ifdef M_VERTEX_COLOR\nattribute vec3 a_Color;varying vec3 v_Color;\n#endif\nvoid main(){\n#ifdef M_SHADOW_VOLUME\nfloat angle;gl_Position=polylineVolumePosition(angle);v_polylineAngle=angle;gl_Position.z=min(gl_Position.z,gl_Position.w);\n#else\nfloat angle;vec4 positionWC=polylineVertexPosition(angle);v_polylineAngle=angle;gl_Position=u_ViewportOrthographic*positionWC;v_TexCoord=a_TEXCOORD_0;\n#endif\n#ifdef M_LOG_DEPTH\nv_depthFromNearPlusOne=vertexLogDepth(u_CurrentFrustum);\n#endif\n#ifdef M_VERTEX_COLOR\nv_Color=a_Color;\n#endif\n}',
          ),
        },
        point: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nvarying vec4 v_color;varying vec4 v_outlineColor;varying float v_innerPercent;varying float v_pixelDistance;\n#include <u_CurrentFrustum>\n#include <fn_writeLogDepth>\n#ifdef M_LOG_DEPTH\nvarying float v_depthFromNearPlusOne;\n#endif\nvoid main(){float distanceToCenter=length(gl_PointCoord-vec2(0.5));float maxDistance=max(0.0,0.5-v_pixelDistance);float wholeAlpha=1.0-smoothstep(maxDistance,0.5,distanceToCenter);float innerAlpha=1.0-smoothstep(maxDistance*v_innerPercent,0.5*v_innerPercent,distanceToCenter);vec4 color=mix(v_outlineColor,v_color,innerAlpha);color.a*=wholeAlpha;\n#if !defined(M_OPAQUE) && !defined(M_TRANSLUCENT)\nif(color.a<0.005){discard;}\n#else\n#ifdef M_OPAQUE\nif(color.a<0.995){discard;}\n#else\nif(color.a>=0.995){discard;}\n#endif\n#endif\ngl_FragColor=color;\n#ifdef M_LOG_DEPTH\nwriteLogDepth(v_depthFromNearPlusOne,u_CurrentFrustum);\n#endif\n}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\nuniform float u_maxTotalPointSize;\n#include <u_PixelRatio>\nuniform mat4 u_modelViewRelativeToEye;\n#include <u_ProjectionMatrix>\nuniform vec2 u_CurrentFrustum;attribute vec4 a_PositionHighAndSize;attribute vec4 a_PositionLowAndOutline;attribute vec3 a_CompressedAttribute0;attribute vec4 a_CompressedAttribute1;attribute vec4 a_ScaleByDistance;attribute vec2 a_DistanceDisplayCondition;varying vec4 v_color;varying vec4 v_outlineColor;varying float v_innerPercent;varying float v_pixelDistance;const float SHIFT_LEFT8=256.0;const float SHIFT_RIGHT8=1.0/256.0;\n#include <u_EncodedCameraPosition>\n#include <fn_translateRelativeToEye>\n#include <fn_nearFarScalar>\n#include <fn_vertexLogDepth>\nvoid main(){vec3 positionHigh=a_PositionHighAndSize.xyz;vec3 positionLow=a_PositionLowAndOutline.xyz;float outlineWidthBothSides=2.0*a_PositionLowAndOutline.w;float totalSize=a_PositionHighAndSize.w+outlineWidthBothSides;float outlinePercent=outlineWidthBothSides/totalSize;totalSize*=u_PixelRatio;totalSize+=3.0;float temp=a_CompressedAttribute1.x*SHIFT_RIGHT8;float show=floor(temp);\n#ifdef M_EYE_DISTANCE_TRANSLUCENCY\nvec4 translucencyByDistance;translucencyByDistance.x=a_CompressedAttribute1.z;translucencyByDistance.z=a_CompressedAttribute1.w;translucencyByDistance.y=((temp-floor(temp))*SHIFT_LEFT8)/255.0;temp=a_CompressedAttribute1.y*SHIFT_RIGHT8;translucencyByDistance.w=((temp-floor(temp))*SHIFT_LEFT8)/255.0;\n#endif\nvec4 color;vec4 outlineColor;temp=a_CompressedAttribute0.x*SHIFT_RIGHT8;color.b=(temp-floor(temp))*SHIFT_LEFT8;temp=floor(temp)*SHIFT_RIGHT8;color.g=(temp-floor(temp))*SHIFT_LEFT8;color.r=floor(temp);temp=a_CompressedAttribute0.y*SHIFT_RIGHT8;outlineColor.b=(temp-floor(temp))*SHIFT_LEFT8;temp=floor(temp)*SHIFT_RIGHT8;outlineColor.g=(temp-floor(temp))*SHIFT_LEFT8;outlineColor.r=floor(temp);temp=a_CompressedAttribute0.z*SHIFT_RIGHT8;temp=floor(temp)*SHIFT_RIGHT8;outlineColor.a=(temp-floor(temp))*SHIFT_LEFT8;outlineColor/=255.0;color.a=floor(temp);color/=255.0;vec4 p=translateRelativeToEye(positionHigh,positionLow);vec4 positionEC=u_modelViewRelativeToEye*p;float lengthSq;\n#if defined(M_EYE_DISTANCE_SCALING) || defined(M_EYE_DISTANCE_TRANSLUCENCY) || defined(M_DISTANCE_DISPLAY_CONDITION)\nlengthSq=dot(positionEC.xyz,positionEC.xyz);\n#endif\n#ifdef M_EYE_DISTANCE_SCALING\ntotalSize*=nearFarScalar(a_ScaleByDistance,lengthSq);\n#endif\ntotalSize=min(totalSize,u_maxTotalPointSize);if(totalSize<1.0){positionEC.xyz=vec3(0.0);totalSize=1.0;}float translucency=1.0;\n#ifdef M_EYE_DISTANCE_TRANSLUCENCY\ntranslucency=nearFarScalar(translucencyByDistance,lengthSq);if(translucency<0.004){positionEC.xyz=vec3(0.0);}\n#endif\n#ifdef M_DISTANCE_DISPLAY_CONDITION\nfloat nearSq=a_DistanceDisplayCondition.x;float farSq=a_DistanceDisplayCondition.y;if(lengthSq<nearSq||lengthSq>farSq){positionEC.xyz=vec3(0.0,0.0,1.0);}\n#endif\ngl_Position=u_ProjectionMatrix*positionEC;\n#ifdef M_LOG_DEPTH\nv_depthFromNearPlusOne=vertexLogDepth(u_CurrentFrustum);\n#endif\nv_color=color;v_color.a*=translucency*show;v_outlineColor=outlineColor;v_outlineColor.a*=translucency*show;v_innerPercent=1.0-outlinePercent;v_pixelDistance=2.0/totalSize;gl_PointSize=totalSize*show;gl_Position*=show;}',
          ),
        },
        AcesTonemappingStage: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nuniform sampler2D colorTexture;\n#include <u_Gamma>\n#include <fn_acesTonemapping>\n#include <fn_inverseGamma>\nvarying vec2 v_TexCoord;\n#ifdef AUTO_EXPOSURE\nuniform sampler2D autoExposure;\n#endif\nvoid main(){vec4 fragmentColor=texture2D(colorTexture,v_TexCoord);vec3 color=fragmentColor.rgb;\n#ifdef AUTO_EXPOSURE\ncolor/=texture2D(autoExposure,vec2(0.5)).r;\n#endif\ncolor=acesTonemapping(color);color=inverseGamma(color,u_Gamma);gl_FragColor=vec4(color,fragmentColor.a);}',
          ),
        },
        AdditiveBlend: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nuniform sampler2D colorTexture;uniform sampler2D colorTexture2;uniform vec2 center;uniform float radius;varying vec2 v_TexCoord;void main(){vec4 color0=texture2D(colorTexture,v_TexCoord);vec4 color1=texture2D(colorTexture2,v_TexCoord);float x=length(gl_FragCoord.xy-center)/radius;float t=smoothstep(0.5,0.8,x);gl_FragColor=mix(color0+color1,color1,t);}',
          ),
        },
        AmbientOcclusionGenerate: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nuniform sampler2D randomTexture;uniform sampler2D u_depthTexture;uniform float intensity;uniform float bias;uniform float lengthCap;uniform float stepSize;uniform float frustumLength;\n#include <u_Viewport>\n#include <u_PixelRatio>\n#include <fn_readDepth>\nvarying vec2 v_TexCoord;vec4 clipToEye(vec2 uv,float depth){vec2 xy=vec2((uv.x*2.0-1.0),((1.0-uv.y)*2.0-1.0));vec4 posEC=czm_inverseProjection*vec4(xy,depth,1.0);posEC=posEC/posEC.w;return posEC;}vec3 getNormalXEdge(vec3 posInCamera,float depthU,float depthD,float depthL,float depthR,vec2 pixelSize){vec4 posInCameraUp=clipToEye(v_TexCoord-vec2(0.0,pixelSize.y),depthU);vec4 posInCameraDown=clipToEye(v_TexCoord+vec2(0.0,pixelSize.y),depthD);vec4 posInCameraLeft=clipToEye(v_TexCoord-vec2(pixelSize.x,0.0),depthL);vec4 posInCameraRight=clipToEye(v_TexCoord+vec2(pixelSize.x,0.0),depthR);vec3 up=posInCamera.xyz-posInCameraUp.xyz;vec3 down=posInCameraDown.xyz-posInCamera.xyz;vec3 left=posInCamera.xyz-posInCameraLeft.xyz;vec3 right=posInCameraRight.xyz-posInCamera.xyz;vec3 DX=length(left)<length(right)? left : right;vec3 DY=length(up)<length(down)? up : down;return normalize(cross(DY,DX));}void main(void){float depth=readDepth(u_depthTexture,v_TexCoord,true);vec4 posInCamera=clipToEye(v_TexCoord,depth);if(posInCamera.z>frustumLength){gl_FragColor=vec4(1.0);return;}vec2 pixelSize=u_PixelRatio/u_Viewport.zw;float depthU=readDepth(u_depthTexture,v_TexCoord-vec2(0.0,pixelSize.y),true);float depthD=readDepth(u_depthTexture,v_TexCoord+vec2(0.0,pixelSize.y),true);float depthL=readDepth(u_depthTexture,v_TexCoord-vec2(pixelSize.x,0.0),true);float depthR=readDepth(u_depthTexture,v_TexCoord+vec2(pixelSize.x,0.0),true);vec3 normalInCamera=getNormalXEdge(posInCamera.xyz,depthU,depthD,depthL,depthR,pixelSize);float ao=0.0;vec2 sampleDirection=vec2(1.0,0.0);float gapAngle=90.0*czm_radiansPerDegree;float randomVal=texture2D(randomTexture,v_TexCoord).x;for(int i=0;i<4;i++){float newGapAngle=gapAngle*(float(i)+randomVal);float cosVal=cos(newGapAngle);float sinVal=sin(newGapAngle);vec2 rotatedSampleDirection=vec2(cosVal*sampleDirection.x-sinVal*sampleDirection.y,sinVal*sampleDirection.x+cosVal*sampleDirection.y);float localAO=0.0;float localStepSize=stepSize;for(int j=0;j<6;j++){vec2 newCoords=v_TexCoord+rotatedSampleDirection*localStepSize*pixelSize;if(newCoords.x>1.0||newCoords.y>1.0||newCoords.x<0.0||newCoords.y<0.0){break;}float stepDepthInfo=readDepth(u_depthTexture,newCoords,true);vec4 stepPosInCamera=clipToEye(newCoords,stepDepthInfo);vec3 diffVec=stepPosInCamera.xyz-posInCamera.xyz;float len=length(diffVec);if(len>lengthCap){break;}float dotVal=clamp(dot(normalInCamera,normalize(diffVec)),0.0,1.0);float weight=len/lengthCap;weight=1.0-weight*weight;if(dotVal<bias){dotVal=0.0;}localAO=max(localAO,dotVal*weight);localStepSize+=stepSize;}ao+=localAO;}ao/=4.0;ao=1.0-clamp(ao,0.0,1.0);ao=pow(ao,intensity);gl_FragColor=vec4(vec3(ao),1.0);}',
          ),
        },
        AmbientOcclusionModulate: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nuniform sampler2D colorTexture;uniform sampler2D ambientOcclusionTexture;uniform bool ambientOcclusionOnly;varying vec2 v_TexCoord;void main(void){vec3 color=texture2D(colorTexture,v_TexCoord).rgb;vec3 ao=texture2D(ambientOcclusionTexture,v_TexCoord).rgb;gl_FragColor.rgb=ambientOcclusionOnly ? ao : ao*color;}',
          ),
        },
        BlackAndWhite: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nuniform sampler2D colorTexture;uniform float gradations;\n#include <fn_luminance>\nvarying vec2 v_TexCoord;void main(void){vec3 rgb=texture2D(colorTexture,v_TexCoord).rgb;\n#ifdef CZM_SELECTED_FEATURE\nif(czm_selected()){gl_FragColor=vec4(rgb,1.0);return;}\n#endif\nfloat luminance=luminance(rgb);float darkness=luminance*gradations;darkness=(darkness-fract(darkness))/gradations;gl_FragColor=vec4(vec3(darkness),1.0);}',
          ),
        },
        BloomComposite: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nuniform sampler2D colorTexture;uniform sampler2D bloomTexture;uniform bool glowOnly;varying vec2 v_TexCoord;void main(void){vec4 color=texture2D(colorTexture,v_TexCoord);\n#ifdef CZM_SELECTED_FEATURE\nif(czm_selected()){gl_FragColor=color;return;}\n#endif\nvec4 bloom=texture2D(bloomTexture,v_TexCoord);gl_FragColor=glowOnly ? bloom : bloom+color;}',
          ),
        },
        Brightness: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nuniform sampler2D colorTexture;uniform float brightness;varying vec2 v_TexCoord;void main(void){vec3 rgb=texture2D(colorTexture,v_TexCoord).rgb;vec3 target=vec3(0.0);gl_FragColor=vec4(mix(target,rgb,brightness),1.0);}',
          ),
        },
        BrightPass: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nuniform sampler2D colorTexture;uniform float avgLuminance;uniform float threshold;uniform float offset;\n#include <fn_RGBToXYZ>\n#include <fn_XYZToRGB>\nvarying vec2 v_TexCoord;float key(float avg){float guess=1.5-(1.5/(avg*0.1+1.0));return max(0.0,guess)+0.1;}void main(){vec4 color=texture2D(colorTexture,v_TexCoord);vec3 xyz=RGBToXYZ(color.rgb);float luminance=xyz.r;float scaledLum=key(avgLuminance)*luminance/avgLuminance;float brightLum=max(scaledLum-threshold,0.0);float brightness=brightLum/(offset+brightLum);xyz.r=brightness;gl_FragColor=vec4(XYZToRGB(xyz),1.0);}',
          ),
        },
        CompositeTranslucentClassification: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nuniform sampler2D colorTexture;\n#ifdef DEBUG_SHOW_DEPTH\nuniform sampler2D u_packedTranslucentDepth;\n#endif\n#include <fn_unpackDepth>\nvarying vec2 v_TexCoord;void main(){\n#ifdef DEBUG_SHOW_DEPTH\nif(v_TexCoord.x<0.5){gl_FragColor.rgb=vec3(unpackDepth(texture2D(u_packedTranslucentDepth,v_TexCoord)));gl_FragColor.a=1.0;}\n#else\nvec4 color=texture2D(colorTexture,v_TexCoord);\n#ifdef PICK\nif(color==vec4(0.0)){discard;}\n#else\ncolor.rgb/=color.a;\n#endif\ngl_FragColor=color;\n#endif\n}',
          ),
        },
        ContrastBias: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nuniform sampler2D colorTexture;uniform float contrast;uniform float brightness;\n#include <fn_HSBToRGB>\n#include <fn_RGBToHSB>\nvarying vec2 v_TexCoord;void main(void){vec3 sceneColor=texture2D(colorTexture,v_TexCoord).xyz;sceneColor=RGBToHSB(sceneColor);sceneColor.z+=brightness;sceneColor=HSBToRGB(sceneColor);float factor=(259.0*(contrast+255.0))/(255.0*(259.0-contrast));sceneColor=factor*(sceneColor-vec3(0.5))+vec3(0.5);gl_FragColor=vec4(sceneColor,1.0);}',
          ),
        },
        DepthOfField: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nuniform sampler2D colorTexture;uniform sampler2D blurTexture;uniform sampler2D u_depthTexture;uniform float focalDistance;\n#include <fn_readDepth>\nvarying vec2 v_TexCoord;vec4 toEye(vec2 uv,float depth){vec2 xy=vec2((uv.x*2.0-1.0),((1.0-uv.y)*2.0-1.0));vec4 posInCamera=czm_inverseProjection*vec4(xy,depth,1.0);posInCamera=posInCamera/posInCamera.w;return posInCamera;}float computeDepthBlur(float depth){float f;if(depth<focalDistance){f=(focalDistance-depth)/(focalDistance-czm_currentFrustum.x);}else{f=(depth-focalDistance)/(czm_currentFrustum.y-focalDistance);f=pow(f,0.1);}f*=f;f=clamp(f,0.0,1.0);return pow(f,0.5);}void main(void){float depth=readDepth(u_depthTexture,v_TexCoord,true);vec4 posInCamera=toEye(v_TexCoord,depth);float d=computeDepthBlur(-posInCamera.z);gl_FragColor=mix(texture2D(colorTexture,v_TexCoord),texture2D(blurTexture,v_TexCoord),d);}',
          ),
        },
        DepthView: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nuniform sampler2D u_depthTexture;\n#include <fn_readDepth>\nvarying vec2 v_TexCoord;void main(void){float depth=readDepth(u_depthTexture,v_TexCoord,true);gl_FragColor=vec4(vec3(depth),1.0);}',
          ),
        },
        DepthViewPacked: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nuniform sampler2D u_depthTexture;\n#include <fn_unpackDepth>\n#include <fn_reverseLogDepth>\nvarying vec2 v_TexCoord;void main(){float z_window=unpackDepth(texture2D(u_depthTexture,v_TexCoord));z_window=reverseLogDepth(z_window);float n_range=czm_depthRange.near;float f_range=czm_depthRange.far;float z_ndc=(2.0*z_window-n_range-f_range)/(f_range-n_range);float scale=pow(z_ndc*0.5+0.5,8.0);gl_FragColor=vec4(mix(vec3(0.0),vec3(1.0),scale),1.0);}',
          ),
        },
        EdgeDetection: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nuniform sampler2D depthTexture;uniform float length;uniform vec4 color;\n#include <u_PixelRatio>\n#include <u_Viewport>\n#include <fn_readDepth>\nvarying vec2 v_TexCoord;void main(void){float directions[3];directions[0]=-1.0;directions[1]=0.0;directions[2]=1.0;float scalars[3];scalars[0]=3.0;scalars[1]=10.0;scalars[2]=3.0;float padx=u_PixelRatio/u_Viewport.z;float pady=u_PixelRatio/u_Viewport.w;\n#ifdef CZM_SELECTED_FEATURE\nbool selected=false;for(int i=0;i<3;++i){float dir=directions[i];selected=selected||czm_selected(vec2(-padx,dir*pady));selected=selected||czm_selected(vec2(padx,dir*pady));selected=selected||czm_selected(vec2(dir*padx,-pady));selected=selected||czm_selected(vec2(dir*padx,pady));if(selected){break;}}if(!selected){gl_FragColor=vec4(color.rgb,0.0);return;}\n#endif\nfloat horizEdge=0.0;float vertEdge=0.0;for(int i=0;i<3;++i){float dir=directions[i];float scale=scalars[i];horizEdge-=readDepth(depthTexture,v_TexCoord+vec2(-padx,dir*pady),true)*scale;horizEdge+=readDepth(depthTexture,v_TexCoord+vec2(padx,dir*pady),true)*scale;vertEdge-=readDepth(depthTexture,v_TexCoord+vec2(dir*padx,-pady),true)*scale;vertEdge+=readDepth(depthTexture,v_TexCoord+vec2(dir*padx,pady),true)*scale;}float len=sqrt(horizEdge*horizEdge+vertEdge*vertEdge);gl_FragColor=vec4(color.rgb,len>length ? color.a : 0.0);}',
          ),
        },
        FilmicTonemapping: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nuniform sampler2D colorTexture;\n#include <u_Gamma>\n#include <fn_inverseGamma>\nvarying vec2 v_TexCoord;\n#ifdef AUTO_EXPOSURE\nuniform sampler2D autoExposure;\n#endif\nvoid main(){vec4 fragmentColor=texture2D(colorTexture,v_TexCoord);vec3 color=fragmentColor.rgb;\n#ifdef AUTO_EXPOSURE\nfloat exposure=texture2D(autoExposure,vec2(0.5)).r;color/=exposure;\n#endif\nconst float A=0.22;const float B=0.30;const float C=0.10;const float D=0.20;const float E=0.01;const float F=0.30;const float white=11.2;vec3 c=((color*(A*color+C*B)+D*E)/(color*(A*color+B)+D*F))-E/F;float w=((white*(A*white+C*B)+D*E)/(white*(A*white+B)+D*F))-E/F;c=inverseGamma(c/w,u_Gamma);gl_FragColor=vec4(c,fragmentColor.a);}',
          ),
        },
        FXAA: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nuniform sampler2D colorTexture;\n#include <u_Resolution>\nconst float fxaaQualitySubpix=0.5;const float fxaaQualityEdgeThreshold=0.125;const float fxaaQualityEdgeThresholdMin=0.0833;varying vec2 v_TexCoord;\n#include <fn_nvidia_fxaa>\nvoid main(){vec2 fxaaQualityRcpFrame=vec2(1.0)/u_Resolution;vec4 color=FxaaPixelShader(v_TexCoord,colorTexture,fxaaQualityRcpFrame,fxaaQualitySubpix,fxaaQualityEdgeThreshold,fxaaQualityEdgeThresholdMin);float alpha=texture2D(colorTexture,v_TexCoord).a;gl_FragColor=vec4(color.rgb,alpha);}',
          ),
        },
        GaussianBlur1D: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\n#define SAMPLES 8\nuniform float delta;uniform float sigma;uniform float direction;\n#include <u_Viewport>\n#include <u_PixelRatio>\nuniform sampler2D colorTexture;\n#ifdef USE_STEP_SIZE\nuniform float stepSize;\n#else\nuniform vec2 step;\n#endif\nvarying vec2 v_TexCoord;void main(){vec2 st=v_TexCoord;vec2 dir=vec2(1.0-direction,direction);\n#ifdef USE_STEP_SIZE\nvec2 step=vec2(stepSize*(u_PixelRatio/u_Viewport.zw));\n#else\nvec2 step=step;\n#endif\nvec3 g;g.x=1.0/(sqrt(czm_twoPi)*sigma);g.y=exp((-0.5*delta*delta)/(sigma*sigma));g.z=g.y*g.y;vec4 result=texture2D(colorTexture,st)*g.x;for(int i=1;i<SAMPLES;++i){g.xy*=g.yz;vec2 offset=float(i)*dir*step;result+=texture2D(colorTexture,st-offset)*g.x;result+=texture2D(colorTexture,st+offset)*g.x;}gl_FragColor=result;}',
          ),
        },
        LensFlare: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nuniform sampler2D colorTexture;uniform sampler2D dirtTexture;uniform sampler2D starTexture;uniform vec2 dirtTextureDimensions;uniform float distortion;uniform float ghostDispersal;uniform float haloWidth;uniform float dirtAmount;uniform float earthRadius;uniform float intensity;\n#include <u_Viewport>\n#include <u_PixelRatio>\nvarying vec2 v_TexCoord;\n#define DISTANCE_TO_SPACE 6500000.0\nvec4 getNDCFromWC(vec3 WC,float earthRadius){vec4 positionEC=czm_view*vec4(WC,1.0);positionEC=vec4(positionEC.x+earthRadius,positionEC.y,positionEC.z,1.0);vec4 positionWC=czm_eyeToWindowCoordinates(positionEC);return czm_viewportOrthographic*vec4(positionWC.xy,-positionWC.z,1.0);}float isInEarth(vec2 texcoord,vec2 sceneSize){vec2 NDC=texcoord*2.0-1.0;vec4 earthPosSC=getNDCFromWC(vec3(0.0),0.0);vec4 earthPosSCEdge=getNDCFromWC(vec3(0.0),earthRadius*1.5);NDC.xy-=earthPosSC.xy;float X=abs(NDC.x)*sceneSize.x;float Y=abs(NDC.y)*sceneSize.y;return clamp(0.0,1.0,max(sqrt(X*X+Y*Y)/max(abs(earthPosSCEdge.x*sceneSize.x),1.0)-0.8,0.0));}vec4 textureDistorted(sampler2D tex,vec2 texcoord,vec2 direction,vec3 distortion,bool isSpace){vec2 sceneSize=u_Viewport.zw;vec3 color;if(isSpace){color.r=isInEarth(texcoord+direction*distortion.r,sceneSize)*texture2D(tex,texcoord+direction*distortion.r).r;color.g=isInEarth(texcoord+direction*distortion.g,sceneSize)*texture2D(tex,texcoord+direction*distortion.g).g;color.b=isInEarth(texcoord+direction*distortion.b,sceneSize)*texture2D(tex,texcoord+direction*distortion.b).b;}else{color.r=texture2D(tex,texcoord+direction*distortion.r).r;color.g=texture2D(tex,texcoord+direction*distortion.g).g;color.b=texture2D(tex,texcoord+direction*distortion.b).b;}return vec4(clamp(color,0.0,1.0),0.0);}void main(void){vec4 originalColor=texture2D(colorTexture,v_TexCoord);vec3 rgb=originalColor.rgb;bool isSpace=length(czm_viewerPositionWC.xyz)>DISTANCE_TO_SPACE;vec4 sunPos=czm_morphTime==1.0 ? vec4(czm_sunPositionWC,1.0): vec4(czm_sunPositionColumbusView.zxy,1.0);vec4 sunPositionEC=czm_view*sunPos;vec4 sunPositionWC=czm_eyeToWindowCoordinates(sunPositionEC);sunPos=czm_viewportOrthographic*vec4(sunPositionWC.xy,-sunPositionWC.z,1.0);if(!isSpace||!((sunPos.x>=-1.1&&sunPos.x<=1.1)&&(sunPos.y>=-1.1&&sunPos.y<=1.1))){gl_FragColor=originalColor;return;}vec2 texcoord=vec2(1.0)-v_TexCoord;vec2 pixelSize=u_PixelRatio/u_Viewport.zw;vec2 invPixelSize=1.0/pixelSize;vec3 distortionVec=pixelSize.x*vec3(-distortion,0.0,distortion);vec2 ghostVec=(vec2(0.5)-texcoord)*ghostDispersal;vec3 direction=normalize(vec3(ghostVec,0.0));vec4 result=vec4(0.0);vec4 ghost=vec4(0.0);for(int i=0;i<4;++i){vec2 offset=fract(texcoord+ghostVec*float(i));ghost+=textureDistorted(colorTexture,offset,direction.xy,distortionVec,isSpace);}result+=ghost;vec2 haloVec=normalize(ghostVec)*haloWidth;float weightForHalo=length(vec2(0.5)-fract(texcoord+haloVec))/length(vec2(0.5));weightForHalo=pow(1.0-weightForHalo,5.0);result+=textureDistorted(colorTexture,texcoord+haloVec,direction.xy,distortionVec,isSpace)*weightForHalo*1.5;vec2 dirtTexCoords=(v_TexCoord*invPixelSize)/dirtTextureDimensions;if(dirtTexCoords.x>1.0){dirtTexCoords.x=mod(floor(dirtTexCoords.x),2.0)==1.0 ? 1.0-fract(dirtTexCoords.x): fract(dirtTexCoords.x);}if(dirtTexCoords.y>1.0){dirtTexCoords.y=mod(floor(dirtTexCoords.y),2.0)==1.0 ? 1.0-fract(dirtTexCoords.y): fract(dirtTexCoords.y);}result+=dirtAmount*texture2D(dirtTexture,dirtTexCoords);float camrot=czm_view[0].z+czm_view[1].y;float cosValue=cos(camrot);float sinValue=sin(camrot);mat3 rotation=mat3(cosValue,-sinValue,0.0,sinValue,cosValue,0.0,0.0,0.0,1.0);vec3 st1=vec3(v_TexCoord*2.0-vec2(1.0),1.0);vec3 st2=vec3((rotation*st1).xy,1.0);vec3 st3=st2*0.5+vec3(0.5);vec2 lensStarTexcoord=st3.xy;float weightForLensFlare=length(vec3(sunPos.xy,0.0));float oneMinusWeightForLensFlare=max(1.0-weightForLensFlare,0.0);if(!isSpace){result*=oneMinusWeightForLensFlare*intensity*0.2;}else{result*=oneMinusWeightForLensFlare*intensity;result*=texture2D(starTexture,lensStarTexcoord)*pow(weightForLensFlare,1.0)*max((1.0-length(vec3(st1.xy,0.0))),0.0)*2.0;}result+=texture2D(colorTexture,v_TexCoord);gl_FragColor=result;}',
          ),
        },
        ModifiedReinhardTonemapping: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nuniform sampler2D colorTexture;uniform vec3 white;\n#include <u_Gamma>\n#include <fn_inverseGamma>\nvarying vec2 v_TexCoord;\n#ifdef AUTO_EXPOSURE\nuniform sampler2D autoExposure;\n#endif\nvoid main(){vec4 fragmentColor=texture2D(colorTexture,v_TexCoord);vec3 color=fragmentColor.rgb;\n#ifdef AUTO_EXPOSURE\nfloat exposure=texture2D(autoExposure,vec2(0.5)).r;color/=exposure;\n#endif\ncolor=(color*(1.0+color/white))/(1.0+color);color=inverseGamma(color,u_Gamma);gl_FragColor=vec4(color,fragmentColor.a);}',
          ),
        },
        NightVision: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nuniform sampler2D colorTexture;\n#include <u_FrameNumber>\nvarying vec2 v_TexCoord;float rand(vec2 co){return fract(sin(dot(co.xy,vec2(12.9898,78.233)))*43758.5453);}void main(void){float noiseValue=rand(v_TexCoord+sin(u_FrameNumber))*0.1;vec3 rgb=texture2D(colorTexture,v_TexCoord).rgb;vec3 green=vec3(0.0,1.0,0.0);gl_FragColor=vec4((noiseValue+rgb)*green,1.0);}',
          ),
        },
        PassThrough: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nuniform sampler2D colorTexture;varying vec2 v_TexCoord;void main(){gl_FragColor=texture2D(colorTexture,v_TexCoord);}',
          ),
        },
        PassThroughDepth: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nuniform highp sampler2D u_depthTexture;\n#include <fn_writeDepth>\n#include <fn_readDepth>\nvarying vec2 v_TexCoord;void main(){gl_FragColor=writeDepth(readDepth(u_depthTexture,v_TexCoord,true));}',
          ),
        },
        PointCloudEyeDomeLighting: {
          fragmentSource: Ip(
            '#extension GL_EXT_frag_depth : enable\n#define GLSLIFY 1\nuniform sampler2D u_pointCloud_colorGBuffer;uniform sampler2D u_pointCloud_depthGBuffer;uniform vec2 u_distanceAndEdlStrength;\n#include <u_Viewport>\n#include <fn_windowToEyeCoordinates>\n#include <fn_unpackDepth>\nvarying vec2 v_TexCoord;vec2 neighborContribution(float log2Depth,vec2 offset){float dist=u_distanceAndEdlStrength.x;vec2 texCoordOrig=v_TexCoord+offset*dist;vec2 texCoord0=v_TexCoord+offset*floor(dist);vec2 texCoord1=v_TexCoord+offset*ceil(dist);float depthOrLogDepth0=unpackDepth(texture2D(u_pointCloud_depthGBuffer,texCoord0));float depthOrLogDepth1=unpackDepth(texture2D(u_pointCloud_depthGBuffer,texCoord1));if(depthOrLogDepth0==0.0||depthOrLogDepth1==0.0){return vec2(0.0);}float depthMix=mix(depthOrLogDepth0,depthOrLogDepth1,fract(dist));vec4 eyeCoordinate=fn_windowToEyeCoordinates(texCoordOrig,depthMix);return vec2(max(0.0,log2Depth-log2(-eyeCoordinate.z/eyeCoordinate.w)),1.0);}void main(){float depthOrLogDepth=unpackDepth(texture2D(u_pointCloud_depthGBuffer,v_TexCoord));vec4 eyeCoordinate=fn_windowToEyeCoordinates(gl_FragCoord.xy,depthOrLogDepth);eyeCoordinate/=eyeCoordinate.w;float log2Depth=log2(-eyeCoordinate.z);if(depthOrLogDepth==0.0){discard;}vec4 color=texture2D(u_pointCloud_colorGBuffer,v_TexCoord);vec2 texelSize=1.0/u_Viewport.zw;vec2 responseAndCount=vec2(0.0);responseAndCount+=neighborContribution(log2Depth,vec2(-texelSize.x,0.0));responseAndCount+=neighborContribution(log2Depth,vec2(+texelSize.x,0.0));responseAndCount+=neighborContribution(log2Depth,vec2(0.0,-texelSize.y));responseAndCount+=neighborContribution(log2Depth,vec2(0.0,+texelSize.y));float response=responseAndCount.x/responseAndCount.y;float strength=u_distanceAndEdlStrength.y;float shade=exp(-response*300.0*strength);color.rgb*=shade;gl_FragColor=vec4(color);gl_FragDepthEXT=depthOrLogDepth;}',
          ),
        },
        ReinhardTonemapping: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nuniform sampler2D colorTexture;\n#include <u_Gamma>\n#include <fn_inverseGamma>\nvarying vec2 v_TexCoord;\n#ifdef AUTO_EXPOSURE\nuniform sampler2D autoExposure;\n#endif\nvoid main(){vec4 fragmentColor=texture2D(colorTexture,v_TexCoord);vec3 color=fragmentColor.rgb;\n#ifdef AUTO_EXPOSURE\nfloat exposure=texture2D(autoExposure,vec2(0.5)).r;color/=exposure;\n#endif\ncolor=color/(1.0+color);color=inverseGamma(color,u_Gamma);gl_FragColor=vec4(color,fragmentColor.a);}',
          ),
        },
        Silhouette: {
          fragmentSource: Ip(
            '#define GLSLIFY 1\nuniform sampler2D colorTexture;uniform sampler2D silhouetteTexture;varying vec2 v_TexCoord;void main(void){vec4 silhouetteColor=texture2D(silhouetteTexture,v_TexCoord);vec4 color=texture2D(colorTexture,v_TexCoord);gl_FragColor=mix(color,silhouetteColor,silhouetteColor.a);}',
          ),
        },
        showDepth: {
          fragmentSource: Ip(
            'precision highp float;\n#define GLSLIFY 1\n#include <u_BaseColorSampler>\nuniform sampler2D u_BackgroundSampler;\n#include <fn_readDepth>\n#include <fn_writeDepth>\nvarying vec2 v_TexCoord;void main(){float r=readDepth(u_BaseColorSampler,v_TexCoord,false);float r1=readDepth(u_BackgroundSampler,v_TexCoord,false);if(r<r1){r1=r;}gl_FragColor=writeDepth(r1);}',
          ),
          vertexSource: Ip(
            '#define GLSLIFY 1\n#include <a_POSITION2>\n#include <u_ModelViewProjectionMatrix>\n#include <u_World>\n#include <v_TexCoord2>\nvoid main(){gl_Position=u_ModelViewProjectionMatrix*vec4(a_POSITION*u_World,0,1);v_TexCoord.x=a_POSITION.x;v_TexCoord.y=1.0-a_POSITION.y;}',
          ),
        },
      },
      Np = /#pragma minemap: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g;
    for (const e in Rp) {
      const t = Rp[e],
        i = {};
      (t.fragmentSource = t.fragmentSource?.replace(
        Np,
        (e, t, n, r, o) => (
          (i[o] = !0),
          'define' === t
            ? `\n#ifndef HAS_UNIFORM_u_${o}\nvarying ${n} ${r} ${o};\n#else\nuniform ${n} ${r} u_${o};\n#endif\n`
            : `\n#ifdef HAS_UNIFORM_u_${o}\n    ${n} ${r} ${o} = u_${o};\n#endif\n`
        ),
      )),
        (t.vertexSource = t.vertexSource?.replace(Np, (e, t, n, r, o) => {
          const a = 'float' === r ? 'vec2' : 'vec4',
            s = -1 != o.indexOf('pattern_from') || -1 != o.indexOf('pattern_to');
          return i[o]
            ? 'define' === t
              ? `\n#ifndef HAS_UNIFORM_u_${o}\nuniform lowp float a_${o}_t;\nattribute ${n} ${a} a_${o};\nvarying ${n} ${r} ${o};\n#else\nuniform ${n} ${r} u_${o};\n#endif\n`
              : s
              ? `\n#ifndef HAS_UNIFORM_u_${o}\n    ${o} = a_${o};\n#else\n    ${n} ${r} ${o} = u_${o};\n#endif\n`
              : `\n#ifndef HAS_UNIFORM_u_${o}\n    ${o} = unpack_mix_${a}(a_${o}, a_${o}_t);\n#else\n    ${n} ${r} ${o} = u_${o};\n#endif\n`
            : 'define' === t
            ? `\n#ifndef HAS_UNIFORM_u_${o}\nuniform lowp float a_${o}_t;\nattribute ${n} ${a} a_${o};\n#else\nuniform ${n} ${r} u_${o};\n#endif\n`
            : `\n#ifndef HAS_UNIFORM_u_${o}\n    ${n} ${r} ${o} = unpack_mix_${a}(a_${o}, a_${o}_t);\n#else\n    ${n} ${r} ${o} = u_${o};\n#endif\n`;
        }));
    }
    function Op(e) {
      return e.replace(Lp, Dp);
    }
    function Dp(e, t) {
      const i = Cp[t];
      if (void 0 === i) throw new Error(`Can not resolve #include <${t}>`);
      return Op(i);
    }
    class Fp {
      constructor(e) {
        (this._type = e.type),
          (this._defines = t(e.defines) ? e.defines : {}),
          e.noCache
            ? ((this.fragmentSource = e.fragmentSource), (this.vertexSource = e.vertexSource))
            : (e.type &&
                !Rp[e.type] &&
                e.fragmentSource &&
                e.vertexSource &&
                (Rp[e.type] = { fragmentSource: e.fragmentSource, vertexSource: e.vertexSource }),
              (this.fragmentSource = e.type ? Rp[e.type].fragmentSource : e.fragmentSource),
              (this.vertexSource = e.type ? Rp[e.type].vertexSource : e.vertexSource));
      }
      set defines(e) {
        this._defines = dp(e, this._defines);
      }
      get defines() {
        return this._defines;
      }
      get type() {
        return this._type;
      }
      set type(e) {
        e &&
          ((this.fragmentSource = Rp[e].fragmentSource),
          (this.vertexSource = Rp[e].vertexSource),
          (this._type = e));
      }
      destroy() {
        (this._type = ''),
          (this._defines = {}),
          (this.fragmentSource = void 0),
          (this.vertexSource = void 0);
      }
      static replaceMain(e, t) {
        return e.replace(/void\s+main\s*\(\s*(?:void)?\s*\)/g, (t = `void ${t}()`));
      }
    }
    class zp {
      constructor(e) {
        const { json: t, joints: i } = e;
        this.options = e;
        const n = [];
        for (let e = 0; e < i.length; e++) n.push(t.nodes[i[e]]);
        (this._jointNode = n), (this._jointMatrix = []);
      }
      get jointMatrix() {
        return this._jointMatrix;
      }
      findRootMatrix(e) {
        let t = e;
        for (; t.parent; ) t = t.parent;
        return t.matrix.clone();
      }
      findGltfRootMatrix(e) {
        let t = e;
        for (; t.parent && 'gltfNode' === t.parent.type; ) t = t.parent;
        return t.matrix.clone();
      }
      update() {
        this._jointMatrix.length = 0;
        for (let e = 0; e < this._jointNode.length; e++) {
          const t = this._jointNode[e],
            i = this.findRootMatrix(t).invert(),
            n = this.findGltfRootMatrix(t)
              .invert()
              .multiplyRight(t.matrixWorld.clone().multiplyLeft(i))
              .multiplyRight(this.options.inverseBindMatrices[e]);
          this._jointMatrix.push(n);
        }
      }
    }
    class Bp extends Ta {
      constructor(e, i = !0) {
        if (
          (super(),
          (this._id = e.id),
          (this.isGLTFTreeNode = !0),
          (this.originMatrix = void 0),
          (this._skinsIndex = void 0),
          (this._skeleton = void 0),
          (this.type = 'gltfNode'),
          e.matrix && i)
        )
          this.applyMatrix(new Je(e.matrix));
        else {
          let t, i, n;
          e.translation && (t = new Ge(e.translation)),
            e.scale && (n = new Pt(e.scale)),
            e.rotation &&
              (3 === e.rotation.length
                ? (i = new Et().fromHeadingPitchRoll(
                    new Le(e.rotation[0], e.rotation[1], e.rotation[2]),
                  ))
                : 4 === e.rotation.length && (i = new Et(e.rotation))),
            this.applyMatrix(Je.fromTranslationQuaternionRotationScale(t, i, n));
        }
        (this.mesh = e.mesh),
          (this.properties = { name: e.name, id: e.mesh }),
          (this.meshes = e.meshes),
          t(e.skin) && ((this.skin = e.skin), (this._skinsIndex = ye(e.skin))),
          e.children && (this.childIdxes = e.children),
          (this._play = !0);
      }
      get id() {
        return this._id;
      }
      set id(e) {
        this._id = e;
      }
      get skeleton() {
        return this._skeleton;
      }
      get play() {
        return this._play;
      }
      set play(e) {
        Pe(e) && (this._play = e);
      }
      createSkeleton(e) {
        t(this.skin) &&
          (this._skeleton = new zp({
            json: e,
            id: this.skin.id,
            inverseBindMatrices: this.skin.inverseBindMatrices,
            joints: this.skin.joints,
            name: this.skin.name,
            skeleton: this.skin.skeleton,
            parent: this,
          }));
      }
      update() {
        t(this._skeleton) && this._skeleton.update();
      }
    }
    function Vp(e) {
      let i = [];
      return (
        t(e.scene)
          ? e.scene.nodes.forEach((e) => {
              i = i.concat(Up(e));
            })
          : t(e.scenes) &&
            e.scenes.forEach((e) => {
              e.nodes.forEach((e) => {
                i = i.concat(Up(e));
              });
            }),
        i
      );
    }
    function Up(e) {
      let i = [];
      return (
        t(e.children) &&
          e.children.forEach((e) => {
            i = i.concat(Up(e));
          }),
        t(e.mesh) && (i = i.concat(e.mesh.primitives)),
        i
      );
    }
    class kp {
      constructor(e) {
        const {
          tileID: t,
          modelFolder: i,
          modelType: n,
          noHighlighting: r,
          boundingVolume: o,
          minemap3DType: a,
          instances: s,
          normalRight: l,
          normalUp: c,
          relativeCenter: u,
        } = e;
        (this.tileID = t),
          (this.uid = he()),
          (this.expirationTime = null),
          (this.queryPadding = 0),
          (this.boundingVolume = o),
          (this.state = 'loading'),
          (this.primitives = []),
          (this.modelFolder = i),
          (this.modelType = n || Me.MODEL_TYPE.OSGB),
          (this.noHighlighting = r || !1),
          (this.cartographicOrigin = []),
          (this.childTiles = []),
          (this.minemap3DType = a),
          (this.instances = s),
          (this.normalRight = l),
          (this.normalUp = c),
          (this.relativeCenter = u);
      }
      unloadVectorData() {
        for (let e = 0; e < this.primitives.length; e++) this.primitives[e].destroy();
        (this.uploaded = !1),
          this.primitives.forEach((e) => {
            e.destroy();
          }),
          (this.primitives = []),
          (this.content = void 0),
          (this.extra = void 0),
          (this.state = 'unloaded'),
          (this.boundingVolume = null);
      }
      upload(e, t, i) {
        let n;
        (this.source = i),
          (this.rootNode = new Bp({ id: this.id })),
          (n =
            '3d-model' === i.type
              ? (function (e, t, i) {
                  let n = t.translation || [0, 0, 0];
                  n = [n[0], n[1], n[2]];
                  let r = [];
                  if (t.location) r = t.location;
                  else if (t._eventedParent) {
                    const e = t._eventedParent.tileset3d.root.transform.slice(12, 15);
                    (r = Il.DefaultEllipsoid.cartesianToCartographic(e)), (t.location = r);
                  } else r = t.location;
                  if (!r) return i;
                  const o = Il.cartographicToFixedFrame(new Pt(r[0], r[1], r[2] || 0));
                  return (
                    o.multiplyRight(new Je().rotateX(Math.PI / 2)),
                    (function (e, t, i, n) {
                      let r = !1;
                      if (
                        (!e ||
                          (0 === e[0] && 0 === e[1] && 0 === e[2]) ||
                          (n.translate(e), (r = !0)),
                        t)
                      )
                        if (4 === t.length) n.multiplyRight(new Je().fromQuaternion(t)), (r = !0);
                        else if (t[0] || t[1] || t[1]) {
                          const e = new It(
                            t[0] * Me.TRANSFORM.DEG_TO_RAD,
                            t[1] * Me.TRANSFORM.DEG_TO_RAD,
                            t[2] * Me.TRANSFORM.DEG_TO_RAD,
                            It.XYZ,
                          ).getQuaternion();
                          n.multiplyRight(new Je().fromQuaternion(e)), (r = !0);
                        }
                      !i || (1 === i[0] && 1 === i[1] && 1 === i[2]) || (n.scale(i), (r = !0));
                    })(n, t.rotation, t.scale, i),
                    i.multiplyLeft(o)
                  );
                })(0, i, new Je())
              : e.childModelMatrix
              ? e.childModelMatrix
              : e.cartesianModelMatrix),
          this.rootNode.applyMatrix(n),
          this.rootNode.addObject3DsWithoutParent(...e.gltf.nodes),
          this.rootNode.updateMatrixWorld(!0),
          (this.animations = e.gltf.animations),
          (this.primitives = []),
          (this.extra = e.extra),
          Vp(e.gltf).forEach((e) => {
            (e.owner = this), this.primitives.push(e);
          }),
          (this.state = 'loaded');
      }
      fire(e) {
        this.source.fire(e);
      }
    }
    function Gp(e = new Map(), t = new Map()) {
      if (!e || !t) return e || t;
      try {
        return new Map([...t, ...e]);
      } catch (e) {
        console.error('请检查object1 或 object2 是否未object对象而不是 Map对象');
      }
    }
    var Hp = Object.freeze({ ShadowMapping: 0, SHADOW_MAPPING: 0, PCF: 1, NONE: -1 });
    const Yp = new $e(),
      qp = new Ge(),
      Xp = new Je(),
      jp = new Je();
    class Wp {
      constructor(e) {
        (this.isTranslucent = 'OPAQUE' != e.alphaMode),
          (this._lights = e.lights),
          (this._type = e.type),
          (this._renderState = Z(e.renderState, Wp.getDefaultRenderState())),
          (this._depthTest = void 0),
          (this._translucent = void 0),
          (this._uniforms = new Map()),
          (this.minimumUniformMap = new Map()),
          (this._programConfiguration = void 0),
          (this._shaderSource =
            e.shaderSource ||
            new Fp({
              type: e.type,
              defines: e.defines,
              fragmentSource: e.fragmentSource,
              vertexSource: e.vertexSource,
              noCache: e.noCache,
            })),
          (this.layer = e.layer),
          (this._picking = !1),
          (this._pickColor = void 0),
          (this._usePickColorTexture = void 0),
          (this._isOneDimensionBatchTexture = void 0),
          (this._isModelInstanceTexture = !1),
          (this._pickTextureUniformsCallBack = void 0),
          (this.state = th.PROCESSINGFISH),
          (this._baseColorTexture = Z(e.baseColorTexture, void 0)),
          (this._color = Z(e.color, void 0)),
          (this._doubleSided = Z(e.doubleSided, !1)),
          (this._opacity = Z(e.opacity, void 0)),
          (this._lightingModel = Z(e.lightingModel, void 0));
      }
      get type() {
        return this._type;
      }
      set type(e) {
        (this._shaderSource.type = e), (this._type = e);
      }
      set defines(e) {
        this._shaderSource.defines = dp(e, this._defines);
      }
      get defines() {
        return this._shaderSource.defines;
      }
      set uniforms(e) {
        this._uniforms = Gp(e, this._uniforms);
      }
      get picking() {
        return this._picking;
      }
      set picking(e) {
        e != this._picking && ((this._shaderSource.defines.USE_PICKING = !!e), (this._picking = e));
      }
      get pickColor() {
        return this._pickColor;
      }
      set pickColor(e) {
        this._pickColor = new Ge(e.r, e.g, e.b, e.a);
      }
      get depthTest() {
        return this._depthTest;
      }
      set depthTest(e) {
        (this._depthTest = e),
          null != e &&
            (!1 ===
              Object.getOwnPropertyDescriptor(this._renderState.depthTest, 'enabled').writable &&
              (this._renderState = ye(this._renderState)),
            (this._renderState.depthTest.enabled = this._depthTest));
      }
      get renderState() {
        return this.overrideRenderState || this._renderState;
      }
      set renderState(e) {
        (this._renderState = dp(e, this._renderState)),
          t(this._depthTest) && (this._renderState.depthTest.enabled = this._depthTest);
      }
      get translucent() {
        return this._translucent;
      }
      set translucent(e) {
        (this._translucent = e),
          (this.renderState = {
            blending: {
              enabled: this.translucent,
              color: { red: 0, green: 0, blue: 0, alpha: 0 },
              equationRgb: Ll.FUNC_ADD,
              equationAlpha: Ll.FUNC_ADD,
              functionSourceRgb: Ll.SRC_ALPHA,
              functionSourceAlpha: Ll.ONE,
              functionDestinationRgb: Ll.ONE_MINUS_SRC_ALPHA,
              functionDestinationAlpha: Ll.ONE_MINUS_SRC_ALPHA,
            },
          });
      }
      update(e, i, n = {}) {
        this.#y(e, i, e.transform.position[0], e.transform.position[1]);
        const r = this.getCamera(i);
        this.#x(r),
          this.#v(e, i, n),
          this.#w(e, i, n),
          this.#T(e, i, n),
          t(n.primitive) && n.primitive.allowPick && this.#b(n.primitive);
      }
      updateProperty() {}
      beforeCompile() {}
      #x(e) {
        (this._cameraPosition = e.position),
          (this._cameraDir = e.direction),
          this._uniforms.has('u_CameraPosition') ||
            this._uniforms.set('u_CameraPosition', () => this._cameraPosition),
          this.pushMinimumUniform('u_CameraPosition'),
          this._uniforms.has('u_CameraDirection') ||
            this._uniforms.set('u_CameraDirection', () => this._cameraDir),
          this.pushMinimumUniform('u_CameraDirection');
      }
      #y(e, t, i, n) {
        if (t._enableLight) {
          if (((this.defines.enableLight = !0), t.sunLight)) {
            this.defines.SunLight = !0;
            try {
              this._uniforms.set('u_SunLightDirectionLocal', () => {
                if (t.sunLight) return t.sunLight.getSunDirectionWithCache(n, i);
              });
            } catch (e) {
              throw new Error(e);
            }
            this._uniforms.set('u_SunLightColor', () => {
              if (t.sunLight) return t.sunLight.color;
            }),
              this._uniforms.set('u_SunLightIntensity', () => {
                if (t.sunLight) return t.sunLight.intensity;
              }),
              this._uniforms.set('u_SunLightDirectionGlobal', () => {
                if (t.sunLight) return t.sunLight.getSunDirectionGlobalWithCache().normalize();
              });
          } else this.defines.SunLight = !1;
          if (
            ((this.defines.AmbientLight = !1),
            (this.defines.DirectionalLight = !1),
            (this.defines.PointLight = !1),
            t._lights.length > 0)
          ) {
            const i = [],
              n = [],
              r = [],
              o = [],
              a = [],
              s = [],
              l = [],
              c = [],
              u = [],
              h = [],
              d = [],
              p = [],
              f = [];
            let m = null,
              _ = null,
              g = null,
              y = null,
              x = null,
              v = null,
              w = 0;
            t._lights.forEach((T) => {
              if (
                ('AmbientLight' == T.type &&
                  ((this.defines.AmbientLight = !0),
                  i.push(T.color[0], T.color[1], T.color[1]),
                  n.push(T.intensity)),
                'DirectionalLight' == T.type &&
                  ((this.defines.DirectionalLight = !0),
                  r.push(T.color[0], T.color[1], T.color[2]),
                  o.push(T.intensity),
                  a.push(T.lightDirection[0], T.lightDirection[1], T.lightDirection[2])),
                'PointLight' == T.type &&
                  ((this.defines.PointLight = !0),
                  s.push(T.color[0], T.color[1], T.color[2]),
                  l.push(T.position[0], T.position[1], T.position[2]),
                  c.push(T.intensity),
                  t._shadows))
              ) {
                const t = Je.inverse(
                  Il.localFrameToFixedFrame(new Pt(T.position[0], T.position[1], T.position[2])),
                  new Je(),
                );
                u.push(t),
                  null != e.cubeMapCollection[T.id] && h.push(e.cubeMapCollection[T.id].cubeMap),
                  0 == w
                    ? null != e.cubeMapCollection[T.id] && (m = e.cubeMapCollection[T.id].cubeMap)
                    : 1 == w
                    ? null != e.cubeMapCollection[T.id] && (_ = e.cubeMapCollection[T.id].cubeMap)
                    : 2 == w
                    ? null != e.cubeMapCollection[T.id] && (g = e.cubeMapCollection[T.id].cubeMap)
                    : 3 == w
                    ? null != e.cubeMapCollection[T.id] && (y = e.cubeMapCollection[T.id].cubeMap)
                    : 4 == w
                    ? null != e.cubeMapCollection[T.id] && (x = e.cubeMapCollection[T.id].cubeMap)
                    : 5 == w &&
                      null != e.cubeMapCollection[T.id] &&
                      (v = e.cubeMapCollection[T.id].cubeMap),
                  (w += 1),
                  d.push(T.shadowFar),
                  p.push(T.epsilon),
                  f.push(T.mapSizeScale / T.textureSize);
              }
            }),
              n.length > 0 && (this.defines.AmbientLightCount = n.length),
              this._uniforms.set('u_AmbientLightsColor', () => i),
              this._uniforms.set('u_AmbientLightsIntensity', () => n),
              o.length > 0 && (this.defines.DirectionalLightCount = o.length),
              this._uniforms.set('u_DirectionalLightColor', () => r),
              this._uniforms.set('u_DirectionalLightIntensity', () => o),
              this._uniforms.set('u_DirectionalLightDir', () => a),
              c.length > 0 && (this.defines.PointLightCount = c.length),
              this._uniforms.set('u_PointLightColor', () => s),
              this._uniforms.set('u_PointLightIntensity', () => c),
              this._uniforms.set('u_PointLightPosition', () => l),
              this._uniforms.set('u_PointLightModelMatrixInverse', () => u),
              this._uniforms.set('u_PointLightDepthCubeTexture', () => {
                if (c.length > 0 && t._shadows && h.length == c.length) return h[0];
              }),
              this._uniforms.set('u_PointLightDepthCubeTexture0', () => {
                if (c.length > 0 && t._shadows) return m;
              }),
              this._uniforms.set('u_PointLightDepthCubeTexture1', () => {
                if (c.length > 1 && t._shadows) return _;
              }),
              this._uniforms.set('u_PointLightDepthCubeTexture2', () => {
                if (c.length > 2 && t._shadows) return g;
              }),
              this._uniforms.set('u_PointLightDepthCubeTexture3', () => {
                if (c.length > 3 && t._shadows) return y;
              }),
              this._uniforms.set('u_PointLightDepthCubeTexture4', () => {
                if (c.length > 4 && t._shadows) return x;
              }),
              this._uniforms.set('u_PointLightDepthCubeTexture5', () => {
                if (c.length > 5 && t._shadows) return v;
              }),
              this._uniforms.set('u_PointLightFar', () => {
                if (c.length > 0 && t._shadows) return d;
              }),
              this._uniforms.set('u_PointLightEpsilon', () => {
                if (c.length > 0 && t._shadows) return p;
              }),
              this._uniforms.set('u_DiskRadius', () => {
                if (c.length > 0 && t._shadows) return f;
              });
          }
        } else this.defines.enableLight = !1;
      }
      #v(e, i, n = {}) {
        const { primitive: r } = n,
          o = this.getCamera(i);
        this._uniforms.set('u_ModelMatrix', () =>
          t(r)
            ? (t(r.modelInstanceType) && '3d-model-instance' !== r.modelInstanceType) ||
              r.animationModelInstanceCollection
              ? Je.IDENTITY
              : r.matrixWorld
            : Je.IDENTITY,
        ),
          this.pushMinimumUniform('u_ModelMatrix'),
          this._uniforms.set('u_ModelMatrixInverse', () => {
            const e = t(r) && t(r.modelInstanceType) && '3d-model-instance' !== r.modelInstanceType,
              i = new Je(t(r) ? (e ? Je.IDENTITY : r.matrixWorld) : Je.IDENTITY);
            return Je.inverse(i, jp);
          }),
          this.pushMinimumUniform('u_ModelMatrixInverse'),
          this.updateMVPMatrix(e, i, r),
          this._uniforms.set('u_RotateMatrixInverse', () =>
            Je.inverse(
              Il.localFrameToFixedFrame(
                Il.cartographicToCartesian3([116.39178335666656, 39.93314961417835, 20]),
              ),
              Xp,
            ),
          ),
          this._uniforms.set('u_ViewMatrix', () => o.matrixWorldInverse),
          this._uniforms.set('u_ModelViewMatrix', () =>
            o.matrixWorldInverse.clone().multiplyRight(r.matrixWorld),
          ),
          this.pushMinimumUniform('u_ModelViewMatrix'),
          this._uniforms.set('u_ProjectionMatrix', () => o.projectionMatrix),
          this.pushMinimumUniform('u_ProjectionMatrix'),
          this._uniforms.set('u_ViewProjectionMatrix', () => o.getVPMatrix()),
          this.pushMinimumUniform('u_ViewProjectionMatrix'),
          this._uniforms.set('u_InverseViewProjectionMatrix', () => o.getVPMatrix().invert()),
          this.pushMinimumUniform('u_InverseViewProjectionMatrix'),
          this._uniforms.set('u_Resolution', () => (Yp.set(e.width, e.height), Yp)),
          this.pushMinimumUniform('u_Resolution'),
          this._uniforms.set('u_NormalMatrix', () => {
            return (e = t(r) ? r.matrixWorld : Je.IDENTITY), new Je(e).invert().transpose();
            var e;
          }),
          this.pushMinimumUniform('u_NormalMatrix'),
          this._uniforms.set('u_InverseProjection', () => o.projectionMatrixInverse),
          this.pushMinimumUniform('u_InverseProjection'),
          this._uniforms.set('u_EncodedCameraPositionMCLow', () => ih.fromVector3(o.position).low),
          this._uniforms.set(
            'u_EncodedCameraPositionMCHigh',
            () => ih.fromVector3(o.position).high,
          ),
          this._uniforms.set('u_modelViewRelativeToEye', () => {
            const e = o.getViewMatrix();
            return (e[12] = 0), (e[13] = 0), (e[14] = 0), e;
          }),
          this._uniforms.set('u_ModelViewProjectionRelativeToEye', () => {
            const e = o.getViewMatrix();
            (e[12] = 0), (e[13] = 0), (e[14] = 0);
            const t = new Je();
            return Je.multiply(t, o.projectionMatrix, e), t;
          }),
          this._uniforms.set(
            'u_FrustumPlanes',
            () => (
              qp.set(
                o.frustumCrate.frustum._offCenterFrustum.top,
                o.frustumCrate.frustum._offCenterFrustum.bottom,
                o.frustumCrate.frustum._offCenterFrustum.left,
                o.frustumCrate.frustum._offCenterFrustum.right,
              ),
              qp
            ),
          ),
          this._uniforms.set(
            'u_Bearing',
            () => e.transform.getMapViewParams().bearing * Me.TRANSFORM.DEG_TO_RAD,
          ),
          this.pushMinimumUniform('u_Bearing');
      }
      getCamera(e) {
        return this._extraCamera ? this._extraCamera : e.camera;
      }
      updateMVPMatrix(e, i, n) {
        const r = this.getCamera(i);
        this._uniforms.set('u_ModelViewProjectionMatrix', () => {
          let e;
          return (
            (e = t(n.modelInstanceCollection)
              ? r.getVPMatrix().multiplyRight(n.modelInstanceCollection._rtcTransform)
              : r.getVPMatrix().multiplyRight(t(n) ? n.matrixWorld : Je.IDENTITY)),
            e
          );
        }),
          this.pushMinimumUniform('u_ModelViewProjectionMatrix'),
          this._uniforms.set('u_ModelInstanceRTCTransformMatrix', () => {
            if (t(n.modelInstanceCollection)) return n.modelInstanceCollection._rtcTransform;
          }),
          this.pushMinimumUniform('u_ModelInstanceRTCTransformMatrix');
      }
      pushMinimumUniform(e) {
        this.isVectorMaterial && this.minimumUniformMap.set(e, this._uniforms.get(e));
      }
      getMinimumUniforms(e) {
        return this.isVectorMaterial
          ? e.sameLayerFrame
            ? this.minimumUniformMap
            : ((e.sameLayerFrame = !0), this._uniforms)
          : this._uniforms;
      }
      #w(e, i, n = {}) {
        const { primitive: r } = n;
        i._shadowModel == Hp.NONE
          ? (this.defines = { ShadowEnable: !1 })
          : i._shadowModel == Hp.ShadowMapping
          ? (this.defines = { ShadowEnable: !0, ShadowMapping: !0 })
          : i._shadowModel == Hp.PCF &&
            (this.defines = { ShadowEnable: !0, ShadowMapping: !1, PCF: !0 }),
          e._shadows &&
            (this._uniforms.set('u_ShadowModelViewProjectionMatrix', () =>
              e.frameState.shadowVPMatrix.clone().multiplyRight(t(r) ? r.matrixWorld : Je.IDENTITY),
            ),
            this._uniforms.set('u_ShadowDepthSampler', () => {
              const t = e.shadowPass.framebuffer.depthStencilTexture;
              return (
                (t.sampler = {
                  minificationFilter: Ll.LINEAR_MIPMAP_LINEAR,
                  magnificationFilter: Ll.LINEAR,
                  wrapS: Ll.REPEAT,
                  wrapT: Ll.REPEAT,
                }),
                t
              );
            }),
            this._uniforms.set('u_EPSILON', () => {
              if (e.frameState._sunLight) return e.frameState._sunLight.epsilon;
            }),
            this._uniforms.set('u_MapSizeScale', () => {
              if (e.frameState._sunLight) return e.frameState._sunLight.mapSizeScale;
            }));
      }
      #T(e) {
        if (this._updatedUniformFlag) return;
        this._uniforms.set('u_PixelRatio', () => J.devicePixelRatio);
        const t = new $e();
        this._uniforms.set(
          'u_CurrentFrustum',
          () => ((t.x = e.frameState._camera.near), (t.y = e.frameState._camera.far), t),
        );
        let i = {
          x: e.context.viewport.current.x,
          y: e.context.viewport.current.y,
          width: e.context.viewport.current.width,
          height: e.context.viewport.current.height,
        };
        this._uniforms.set('u_Viewport', () => new Ge(i.x, i.y, i.width, i.height));
        let n = new Je();
        Je.computeViewportTransformation(i, 0, 1, n),
          this._uniforms.set(
            'u_ViewportTransformation',
            () => (
              (i.x == e.context.viewport.current.x &&
                i.y == e.context.viewport.current.y &&
                i.width == e.context.viewport.current.width &&
                i.height == e.context.viewport.current.height) ||
                ((i = {
                  x: e.context.viewport.current.x,
                  y: e.context.viewport.current.y,
                  width: e.context.viewport.current.width,
                  height: e.context.viewport.current.height,
                }),
                (n = new Je()),
                Je.computeViewportTransformation(i, 0, 1, n)),
              n
            ),
          ),
          (this._updatedUniformFlag = !0);
      }
      #b(e) {
        const i = e.owner;
        if (e.allowPick && t(i) && e.pickId)
          if (
            ((this.pickColor = e.pickId.color),
            (this._isModelInstanceTexture = !1),
            i instanceof kp && void 0 === this._usePickColorTexture)
          ) {
            const e = i?.extra?.batchTable;
            e &&
              e.featureCount > 0 &&
              ((this._usePickColorTexture = !0),
              (this._isOneDimensionBatchTexture = !(e._batchTexture._textureDimensions.y > 1)),
              (this._pickTextureUniformsCallBack = e._batchTexture.getUniformMapCallback()),
              (this._uniforms = this._pickTextureUniformsCallBack(this._uniforms)));
          } else
            t(e.modelInstanceCollection) &&
              t(e.modelInstanceCollection._batchTable) &&
              ((this._isModelInstanceTexture = !0),
              (this.uniforms = e.modelInstanceCollection._batchTable.getUniformMapCallback()));
      }
      static getDefaultRenderState() {
        const e = {};
        return (
          (e.blending = yp.enableBlending),
          (e.depthRange = yp.depthRange),
          (e.depthTest = yp.enableDepthTest),
          (e.depthMask = yp.enableDepthMask),
          (e.cull = ye(yp.enableCull)),
          (e.frontFace = Ll.CCW),
          (e.stencilTest = yp.disableStencilTest),
          (e.stencilMask = yp.disableStencilMask),
          e
        );
      }
      setValues(e) {
        if (null != e)
          for (const t in e) {
            const i = e[t];
            null != i
              ? void 0 !== this[t]
                ? (this[t] =
                    'string' == typeof i && i.startsWith('#') ? ai.parse(i).toVector3() : i)
                : console.warn(
                    `MineMap.Material: '${t}' is not a property of MineMap.${this.type}.`,
                  )
              : console.warn(`MineMap.Material: parameter '${t}' has value of undefined.`);
          }
      }
      destroy() {
        (this._renderState = void 0),
          (this._uniforms = void 0),
          (this._programConfiguration = void 0),
          this._shaderSource.destroy(),
          (this._shaderSource = void 0),
          (this.layer = void 0),
          (this._pickColor = void 0),
          (this._usePickColorTexture = void 0),
          (this._isOneDimensionBatchTexture = void 0),
          (this._pickTextureUniformsCallBack = void 0),
          (this.isTranslucent = void 0),
          (this.state = void 0),
          (this._cameraPosition = void 0),
          (this._type = void 0);
      }
    }
    const $p = {
      RGBA4: Ll.RGBA4,
      RGBA8: Ll.RGBA8,
      RGBA16F: Ll.RGBA16F,
      RGBA32F: Ll.RGBA32F,
      RGB5_A1: Ll.RGB5_A1,
      RGB565: Ll.RGB565,
      DEPTH_COMPONENT16: Ll.DEPTH_COMPONENT16,
      STENCIL_INDEX8: Ll.STENCIL_INDEX8,
      DEPTH_STENCIL: Ll.DEPTH_STENCIL,
      DEPTH24_STENCIL8: Ll.DEPTH24_STENCIL8,
      validate: (e) =>
        e === $p.RGBA4 ||
        e === $p.RGBA8 ||
        e === $p.RGBA16F ||
        e === $p.RGBA32F ||
        e === $p.RGB5_A1 ||
        e === $p.RGB565 ||
        e === $p.DEPTH_COMPONENT16 ||
        e === $p.STENCIL_INDEX8 ||
        e === $p.DEPTH_STENCIL ||
        e === $p.DEPTH24_STENCIL8,
      getColorFormat: (e) =>
        e === Ll.FLOAT ? $p.RGBA32F : e === Ll.HALF_FLOAT_OES ? $p.RGBA16F : $p.RGBA8,
    };
    var Zp = Object.freeze($p);
    function Kp(e, t, i) {
      e.framebufferTexture2D(Ll.FRAMEBUFFER, t, i._target, i.texture, 0);
    }
    function Qp(e, t, i) {
      e.framebufferRenderbuffer(e.FRAMEBUFFER, t, e.RENDERBUFFER, i._getRenderbuffer());
    }
    class Jp {
      constructor(e) {
        const { context: i, width: n, height: r } = e;
        (this.context = i), (this.width = n), (this.height = r);
        const o = i.gl;
        (this.framebuffer = o.createFramebuffer()),
          (this._colorTextures = []),
          (this._colorRenderbuffers = []),
          (this._activeColorAttachments = []);
        const a = Uc._maximumColorAttachments;
        if (((this.destroyAttachments = !0), t(e.colorTextures) && t(e.colorRenderbuffers)))
          throw new Error('color texture 和 color renderbuffer attachments 不能同时存在。');
        if (t(e.depthTexture) && t(e.depthRenderbuffer))
          throw new Error('depth texture he depth renderbuffer attachment 不能同时存在。');
        if (t(e.depthStencilTexture) && t(e.depthStencilRenderbuffer))
          throw new Error(
            'depth-stencil texture 和 depth-stencil renderbuffer attachment 不能同时存在。',
          );
        const s = t(e.depthTexture) || t(e.depthRenderbuffer),
          l = t(e.depthStencilTexture) || t(e.depthStencilRenderbuffer);
        if (s && l) throw new Error('depth 和 depth-stencil attachment 不能同时存在。');
        if (t(e.stencilRenderbuffer) && l)
          throw new Error('stencil 和 depth-stencil attachment 不能同时存在。');
        if (s && t(e.stencilRenderbuffer))
          throw new Error('depth 和 stencil attachment 不能同时存在。');
        let c, u, h, d;
        if ((this._bind(), t(e.colorTextures))) {
          const t = e.colorTextures;
          if (
            ((h = this._colorTextures.length = this._activeColorAttachments.length = t.length),
            h > a)
          )
            throw new Error('color attachments 越界！');
          for (let e = 0; e < h; ++e) {
            if (((c = t[e]), !Qc.isColorFormat(c.pixelFormat)))
              throw new Error('color-texture 像素格式必须是颜色格式');
            if (c.pixelDatatype === Ll.FLOAT && !i.extColorBufferFloat)
              throw new Error(
                'The color texture pixel datatype is FLOAT and the WebGL implementation does not support the EXT_color_buffer_float or WEBGL_color_buffer_float extensions. See Context.colorBufferFloat.',
              );
            if (c.pixelDatatype === Ll.HALF_FLOAT && !i.extColorBufferHalfFloat)
              throw new Error(
                'The color texture pixel datatype is HALF_FLOAT and the WebGL implementation does not support the EXT_color_buffer_half_float extension. See Context.colorBufferHalfFloat.',
              );
            (d = Ll.COLOR_ATTACHMENT0 + e),
              Kp(o, d, c),
              (this._activeColorAttachments[e] = d),
              (this._colorTextures[e] = c);
          }
        }
        if (t(e.colorRenderbuffers)) {
          const t = e.colorRenderbuffers;
          if (
            ((h = this._colorRenderbuffers.length = this._activeColorAttachments.length = t.length),
            h > a)
          )
            throw new Error('color attachments 超过显卡数量限制');
          for (let e = 0; e < h; ++e)
            (u = t[e]),
              (d = Ll.COLOR_ATTACHMENT0 + e),
              Qp(o, d, u),
              (this._activeColorAttachments[e] = d),
              (this._colorRenderbuffers[e] = u);
        }
        if (t(e.depthTexture)) {
          if (((c = e.depthTexture), c.pixelFormat !== Ll.DEPTH_COMPONENT))
            throw new Error('depth-texture 像素格式必须是 DEPTH_COMPONENT.');
          Kp(o, Ll.DEPTH_ATTACHMENT, c), (this._depthTexture = c);
        }
        if (
          (t(e.depthRenderbuffer) &&
            ((u = e.depthRenderbuffer),
            Qp(o, Ll.DEPTH_ATTACHMENT, u),
            (this._depthRenderbuffer = u)),
          t(e.stencilRenderbuffer) &&
            ((u = e.stencilRenderbuffer),
            Qp(o, Ll.STENCIL_ATTACHMENT, u),
            (this._stencilRenderbuffer = u)),
          t(e.depthStencilTexture))
        ) {
          if (((c = e.depthStencilTexture), c.pixelFormat !== Ll.DEPTH_STENCIL))
            throw new Error('depth-stencil 的像素格式 必须是 DEPTH_STENCIL.');
          Kp(o, Ll.DEPTH_STENCIL_ATTACHMENT, c), (this._depthStencilTexture = c);
        }
        t(e.depthStencilRenderbuffer) &&
          ((u = e.depthStencilRenderbuffer),
          Qp(o, Ll.DEPTH_STENCIL_ATTACHMENT, u),
          (this._depthStencilRenderbuffer = u)),
          this._unBind();
      }
      get status() {
        this._bind();
        const e = this._gl.checkFramebufferStatus(this._gl.FRAMEBUFFER);
        return this._unBind(), e;
      }
      get numberOfColorAttachments() {
        return this._activeColorAttachments.length;
      }
      get depthTexture() {
        return this._depthTexture;
      }
      get depthRenderbuffer() {
        return this._depthRenderbuffer;
      }
      get stencilRenderbuffer() {
        return this._stencilRenderbuffer;
      }
      get depthStencilTexture() {
        return this._depthStencilTexture;
      }
      get depthStencilRenderbuffer() {
        return this._depthStencilRenderbuffer;
      }
      get hasDepthAttachment() {
        return !!(
          this.depthTexture ||
          this.depthRenderbuffer ||
          this.depthStencilTexture ||
          this.depthStencilRenderbuffer
        );
      }
      _bind() {
        this.context.gl.bindFramebuffer(Ll.FRAMEBUFFER, this.framebuffer);
      }
      _unBind() {
        this.context.gl.bindFramebuffer(Ll.FRAMEBUFFER, null);
      }
      bindDraw() {
        this.context.gl.bindFramebuffer(Ll.DRAW_FRAMEBUFFER, this._framebuffer);
      }
      bindRead() {
        this.context.gl.bindFramebuffer(Ll.READ_FRAMEBUFFER, this._framebuffer);
      }
      _getActiveColorAttachments() {
        return this._activeColorAttachments;
      }
      getColorTexture(e) {
        if (!t(e) || e < 0 || e >= this._colorTextures.length)
          throw new Error('color的索引值必须输入，并且是≥0切小于color attachments的数量');
        return this._colorTextures[e];
      }
      getColorRenderbuffer(e) {
        if (!t(e) || e < 0 || e >= this._colorRenderbuffers.length)
          throw new Error('color的索引值必须输入，并且是≥0切小于color attachments的数量');
        return this._colorRenderbuffers[e];
      }
      destroy(e) {
        const i = this.context.gl;
        if (this.destroyAttachments) {
          let i = 0;
          const n = this._colorTextures;
          let r = n.length;
          if (!e)
            for (; i < r; ++i) {
              const e = n[i];
              t(e) && e.destroy();
            }
          const o = this._colorRenderbuffers;
          for (r = o.length, i = 0; i < r; ++i) {
            const e = o[i];
            t(e) && e.destroy();
          }
          (this._depthTexture = this._depthTexture && this._depthTexture.destroy()),
            (this._depthRenderbuffer =
              this._depthRenderbuffer && this._depthRenderbuffer.destroy()),
            (this._stencilRenderbuffer =
              this._stencilRenderbuffer && this._stencilRenderbuffer.destroy()),
            (this._depthStencilTexture =
              this._depthStencilTexture && this._depthStencilTexture.destroy()),
            (this._depthStencilRenderbuffer =
              this._depthStencilRenderbuffer && this._depthStencilRenderbuffer.destroy());
        }
        return i.deleteFramebuffer(this.framebuffer), Vc(this);
      }
    }
    class ef {
      constructor(e) {
        (this.pos = e.pos), (this.up = e.up), (this.forward = e.forward);
      }
      equals(e) {
        for (let t = 0; t < 3; t++)
          if (
            this.pos[t] !== e.pos[t] ||
            this.up[t] !== e.up[t] ||
            this.forward[t] !== e.forward[t]
          )
            return !1;
        return !0;
      }
      equalsAndSet(e) {
        return (
          !!this.equals(e) ||
          ((this.pos = e.pos.slice(0)),
          (this.up = e.up.slice(0)),
          (this.forward = e.forward.slice(0)),
          !1)
        );
      }
    }
    function tf(e, t, i, n, r, o = 4, a = 1) {
      let s = new Uint8Array(o);
      r === Ll.FLOAT && (s = new Float32Array(o));
      const l = t.bindFramebuffer.get();
      return (
        t.bindFramebuffer.set(i?.framebuffer),
        t.gl.readPixels(
          e.x * J.devicePixelRatio * a,
          (n - e.y * J.devicePixelRatio) * a,
          e.width || 1,
          e.height || 1,
          Ll.RGBA,
          r || Ll.UNSIGNED_BYTE,
          s,
        ),
        t.bindFramebuffer.set(l),
        s
      );
    }
    class nf {
      constructor(e) {
        const { passType: t } = e;
        (this.passType = t),
          (this.replaceMaterial = void 0),
          (this._SSAASamples = 1),
          (this._SSAASamplesDirty = !0);
      }
      set SSAASamples(e) {
        e != this._SSAASamples && ((this._SSAASamples = e), (this._SSAASamplesDirty = !0));
      }
      get SSAASamples() {
        return this._SSAASamples;
      }
      checkDirty(e) {
        return (
          !e ||
          (this.cameraStatusStore
            ? !this.cameraStatusStore.equalsAndSet({
                pos: e.activeCamera.position,
                up: e.activeCamera.matrixWorld.getColumn(0),
                forward: e.activeCamera.matrixWorld.getColumn(1),
              })
            : ((this.cameraStatusStore = new ef({
                pos: e.activeCamera.position,
                up: e.activeCamera.matrixWorld.getColumn(0),
                forward: e.activeCamera.matrixWorld.getColumn(1),
              })),
              !0))
        );
      }
      middleRender(e, t, i, n) {
        _p.applyRenderState(
          t,
          _p.fromCache({
            viewport: {
              x: 0,
              y: 0,
              width: this.width * this._SSAASamples,
              height: this.height * this._SSAASamples,
            },
          }),
        ),
          t.clear({
            color: e._map._canvasTransparent ? ai.transparent : ai.black,
            depth: 1,
            stencil: 0,
          }),
          e.renderGroup.update({
            layers: e.style._layers,
            orders: e.style._order,
            frameState: i,
            ignoreNonePickPrimitive: n,
          }),
          e.renderGroup.render({ layers: e.style._layers, frameState: i }),
          1 != this.SSAASamples &&
            _p.applyRenderState(
              t,
              _p.fromCache({ viewport: { x: 0, y: 0, width: this.width, height: this.height } }),
            );
      }
      createFramebuffer({ width: e, height: t, context: i }) {
        const n = new jc({ minificationFilter: Yc.NEAREST, magnificationFilter: Gc.NEAREST }),
          r = e * this._SSAASamples,
          o = t * this._SSAASamples;
        return new Jp({
          context: i,
          width: r,
          height: o,
          colorTextures: [new Pu({ width: r, height: o, context: i, pixelFormat: Ll.RGBA })],
          depthStencilTexture: new Pu({
            context: i,
            width: r,
            height: o,
            minFilter: Ll.LINEAR,
            magFilter: Ll.LINEAR,
            pixelFormat: Qc.DEPTH_STENCIL,
            pixelDatatype: Zc.UNSIGNED_INT_24_8,
            sampler: n,
            anisotropy: 1,
          }),
        });
      }
      update(e, i, n) {
        const { context: r } = e;
        if (!t(i) || !t(n)) throw new Error('pass 必须手动设定宽高');
        (this.width === i && this.height === n && this.framebuffer && !this._SSAASamplesDirty) ||
          (this.framebuffer && this.framebuffer.destroy(),
          (this.framebuffer = this.createFramebuffer({ width: i, height: n, context: r })),
          (this._SSAASamplesDirty = !1)),
          e.frameState.update({ framebuffer: this.framebuffer }),
          e.frameState.bindFramebuffer(r),
          (this.width = i),
          (this.height = n);
      }
      destroy(e) {
        return (
          (this.camera = void 0),
          this.framebuffer.destroy(e),
          (this.framebuffer = void 0),
          (this.width = void 0),
          (this.height = void 0),
          this.frameState && ((this.frameState.framebuffer = void 0), this.frameState.destroy()),
          (this.frameState = void 0),
          (this.passType = void 0),
          this.replaceMaterial.destroy(),
          (this.replaceMaterial = void 0),
          Vc(this)
        );
      }
    }
    class rf extends Wp {
      constructor(e) {
        super(e),
          (this.type = 'depthMaterial'),
          (this.renderState = this.#S()),
          (this.dirty = !1),
          (this.bUniformCreated = !1);
      }
      update(e, t, i = {}) {
        super.update(e, t, i), this.#A(i.primitive, e), this.bUniformCreated || this.#P();
      }
      #A(e, t) {
        this.defines = {
          JOINT_MATRIX_CNT: Z(e?._material?.defines?.JOINT_MATRIX_CNT, !1),
          INSTANCE_MATRIX: Z(e?._material?.defines?.INSTANCE_MATRIX, !1),
          USE_MORPHTARGETS: Z(e?._material?.defines?.USE_MORPHTARGETS, !1),
          LOG_DEPTH: Z(t._logDepth, !1),
        };
      }
      #S() {
        return {
          cull: { enabled: !1 },
          depthTest: { enabled: !0, func: Ll.LESS },
          blending: {
            color: { red: 0, green: 0, blue: 0, alpha: 0 },
            enabled: !1,
            equationRgb: Ll.FUNC_ADD,
            equationAlpha: Ll.FUNC_ADD,
            functionSourceRgb: Ll.SRC_ALPHA,
            functionSourceAlpha: Ll.ONE,
            functionDestinationRgb: Ll.ONE_MINUS_SRC_ALPHA,
            functionDestinationAlpha: Ll.ONE_MINUS_SRC_ALPHA,
          },
          stencilTest: {
            enabled: !1,
            frontFunction: Ll.ALWAYS,
            backFunction: Ll.ALWAYS,
            reference: 0,
            mask: 0,
            frontOperation: { fail: Ll.KEEP, zFail: Ll.KEEP, zPass: Ll.REPLACE },
            backOperation: { fail: Ll.KEEP, zFail: Ll.KEEP, zPass: Ll.REPLACE },
          },
        };
      }
      #P() {
        this.bUniformCreated = !0;
      }
      destroy() {
        return (
          (this.type = void 0),
          (this._renderState = void 0),
          (this.dirty = void 0),
          (this.bUniformCreated = void 0),
          (this._uniforms = void 0),
          (this._programConfiguration = void 0),
          this._shaderSource.destroy(),
          (this._shaderSource = void 0),
          (this.layer = void 0),
          (this._pickColor = void 0),
          (this._usePickColorTexture = void 0),
          (this._isOneDimensionBatchTexture = void 0),
          (this._pickTextureUniformsCallBack = void 0),
          Vc(this)
        );
      }
    }
    var of = Gt([{ name: 'a_POSITION', type: 'Int16', components: 2 }]);
    class af {
      constructor(e) {
        (this.type = 'ViewportQuadGeometry'),
          (this.primitiveType = Ll.TRIANGLE_STRIP),
          (this._segmentVector = Yh.simpleSegment(0, 0, 4));
        const t = new xo();
        t.emplaceBack(0, 0),
          t.emplaceBack(1, 0),
          t.emplaceBack(0, 1),
          t.emplaceBack(1, 1),
          (this.state = th.PROCESSINGFISH),
          (this._vertBuffer = e.context.createVertexBuffer(t, of.members));
      }
      update() {}
      destroy() {
        return (
          (this.type = void 0),
          (this.primitiveType = void 0),
          this._vertBuffer.destroy(),
          (this._vertBuffer = void 0),
          Vc(this)
        );
      }
    }
    function sf(e) {
      return (e[0] + e[1] / 255 + e[2] / 65025 + e[3] / 16581375) / 255;
    }
    class lf extends nf {
      constructor(e) {
        super(e), (this.replaceMaterial = new rf({}));
      }
      update(e, t, i) {
        e.frameState.overrideMaterial = this.replaceMaterial;
        const { context: n } = e;
        (this.width === t && this.height === i && this.framebuffer) ||
          (this.framebuffer && this.framebuffer.destroy(),
          (this.framebuffer = this.createFramebuffer({ width: t, height: i, context: n }))),
          e.frameState.update({ framebuffer: this.framebuffer }),
          e.frameState.bindFramebuffer(n),
          (this.width = t),
          (this.height = i),
          (this.cameraStatusStore = null);
      }
      createFramebuffer({ width: e, height: t, context: i }) {
        const n = {
          width: e,
          height: t,
          context: i,
          pixelFormat: Ll.RGBA,
          pixelDatatype: Ll.FLOAT,
        };
        return (
          i.extColorBufferFloat || delete n.pixelDatatype,
          new Jp({ context: i, width: e, height: t, colorTextures: [new Pu(n)] })
        );
      }
      render(e) {
        const { painter: t } = e,
          { context: i, mainPass: n, backgroundPass: r } = t,
          o = t.frameState.framebuffer,
          a = t.frameState.passType,
          { width: s, height: l } = t.getMaxFramebufferSize();
        this.update(t, s, l),
          i.clear({ color: ai.white, depth: 1, stencil: 0 }),
          this._uniforms ||
            (this._uniforms = new Map([
              [
                'u_ModelViewProjectionMatrix',
                () =>
                  new Je().ortho({
                    left: 0,
                    right: i.drawingBufferWidth,
                    bottom: i.drawingBufferHeight,
                    top: 0,
                    near: 0,
                    far: 1,
                  }),
              ],
              ['u_BaseColorSampler', () => n.framebuffer.depthStencilTexture],
              ['u_BackgroundSampler', () => r.framebuffer.depthStencilTexture],
              ['u_World', () => new $e(i.drawingBufferWidth, i.drawingBufferHeight)],
            ])),
          i.draw({
            painter: t,
            framebuffer: this.framebuffer.framebuffer,
            layer: { id: 'depth' },
            geometry: new af(t),
            material: {
              renderState: _p.fromCache({
                depthTest: { enabled: !1 },
                depthMask: !1,
                blending: yp.disableBlending,
              }),
              _uniforms: this._uniforms,
              _shaderSource: new Fp({ type: 'showDepth' }),
            },
          }),
          (t.frameState.overrideMaterial = void 0),
          (t.frameState.passType = a),
          t.frameState.update({ framebuffer: o }),
          t.frameState.bindFramebuffer(i);
      }
      readPixel(e, t) {
        const i = tf(
          e,
          t,
          this.framebuffer,
          this.height,
          t.extColorBufferFloat ? Ll.FLOAT : Ll.UNSIGNED_BYTE,
        );
        return t.extColorBufferFloat ? i[0] : sf(i);
      }
    }
    class cf extends Wp {
      constructor(e) {
        super(e),
          (this._renderState = {
            cull: { enabled: !1 },
            blending: {
              enabled: !0,
              color: { red: 0, green: 0, blue: 0, alpha: 0 },
              equationRgb: Ll.FUNC_ADD,
              equationAlpha: Ll.FUNC_ADD,
              functionSourceRgb: Ll.SRC_ALPHA,
              functionSourceAlpha: Ll.ONE,
              functionDestinationRgb: Ll.ONE_MINUS_SRC_ALPHA,
              functionDestinationAlpha: Ll.ONE_MINUS_SRC_ALPHA,
            },
            polygonOffset: { enabled: !0, factor: 1, units: 1 },
            depthTest: { enabled: !0, func: Ll.LESS },
          }),
          (this._color = ai.parse(Z(e.color, new ai(1, 0, 0, 1)))),
          (this.type = 'PolylineMaterial'),
          (this._viewportOrthographicMatrix = new Je()),
          (this._currentFrustum = new $e()),
          (this._interval = new yc()),
          (this._cameraViewMatrix = void 0),
          (this._opacity = Z(e.opacity, 1)),
          (this._dashLength = Z(e.dashLength, 16)),
          (this._dashPattern = Z(e.dashPattern, 255)),
          (this._gapColor = Z(e.gapColor, new ai(0, 0, 0, 0))),
          (this._dashed = Z(e.dashed, !1)),
          (this._pixelWidth = Z(e.pixelWidth, !0)),
          (this.defines = {
            POLYLINE: !0,
            POLYLINE_DASH: this._dashed,
            HAS_BASECOLORMAP: !!this._baseColorTexture,
            PIXEL_WIDTH: this._pixelWidth,
          }),
          (this._flowOptions = void 0),
          (this._depthTexture = void 0),
          this.#E(null);
      }
      update(e, t, i = {}) {
        super.update(e, t, i), this.updateUniforms(e, t, i);
      }
      updateTexture(e) {
        const t = Z(e.color, this._color),
          i = Z(e.opacity, this._opacity),
          n = Z(e.dashed, this._dashed),
          r = Z(e.dashLength, this._dashLength),
          o = Z(e.baseColorTexture, this._baseColorTexture),
          a = Z(e.pixelWidth, this._pixelWidth);
        (this._color = ai.parse(t)),
          (this._opacity = i),
          (this._dashed = n),
          (this._dashLength = r),
          (this._baseColorTexture = o),
          (this._pixelWidth = a),
          this.#E(e);
      }
      static bindTextureSampler(e) {
        return (
          (e.sampler = {
            minificationFilter: e.minFilter || Ll.LINEAR_MIPMAP_NEAREST,
            magnificationFilter: e.magFilter || Ll.LINEAR,
            wrapS: e.wrapS || Ll.REPEAT,
            wrapT: e.wrapT || Ll.REPEAT,
          }),
          e
        );
      }
      updateUniforms(e, i, n = {}) {
        const { primitive: r } = n;
        if (
          ((this.defines = {
            POLYLINE_DASH: this._dashed,
            HAS_BASECOLORMAP: !!this._baseColorTexture,
            PIXEL_WIDTH: this._pixelWidth,
          }),
          this._baseColorTexture
            ? this._uniforms.set('u_BaseColorSampler', () =>
                cf.bindTextureSampler(this._baseColorTexture),
              )
            : this._uniforms.set('u_Color', () => Ge.fromColor(this._color, !1)),
          this._uniforms.set(
            'u_FarDepthFromNearPlusOne',
            () => (
              (this._farDepthFromNearPlusOne = i.camera.far - i.camera.near + 1),
              this._farDepthFromNearPlusOne
            ),
          ),
          this._uniforms.set(
            'u_OneOverLog2FarDepthFromNearPlusOne',
            () => (
              (this._oneOverLog2FarDepthFromNearPlusOne =
                1 / Me.CesiumMath.log2(this._farDepthFromNearPlusOne)),
              this._oneOverLog2FarDepthFromNearPlusOne
            ),
          ),
          this._uniforms.set('u_ViewportOrthographic', () => {
            const t = e.context.viewport.current;
            return (
              Je.computeOrthographicOffCenter(
                t.x,
                t.x + t.width,
                t.y,
                t.y + t.height,
                0,
                1,
                this._viewportOrthographicMatrix,
              ),
              this._viewportOrthographicMatrix
            );
          }),
          this._uniforms.set('u_Opacity', () => this._opacity),
          this._uniforms.set('u_GeometricToleranceOverMeter', () => {
            let n;
            const r = i.camera.frustumCrate.fov,
              o = e.context.viewport.current;
            return (
              (n = t(r)
                ? o.height > o.width
                  ? (2 * Math.tan(0.5 * r)) / o.height
                  : (2 * Math.tan(0.5 * r)) / o.width
                : 1 / Math.max(o.width, o.height)),
              (this._geometricToleranceOverMeter = 2 * n),
              this._geometricToleranceOverMeter
            );
          }),
          this._uniforms.set('u_Normal', () => {
            const e = r ? r.matrixWorld : new Je(),
              t = i.camera.getViewMatrix();
            t.multiplyRight(e), t.invert();
            const n = new je();
            return t.getRotationMatrix3(n), je.transpose(n, n), (this._normal = n), this._normal;
          }),
          this._uniforms.set(
            'u_GlobeMinimumAltitude',
            () => (
              (this._globeMinimumAltitude = wt.WGS84.minimumRadius.toFixed(1)),
              this._globeMinimumAltitude
            ),
          ),
          this._uniforms.set('u_DashLength', () => this._dashLength),
          this._uniforms.set('u_DashPattern', () => this._dashPattern),
          this._uniforms.set('u_GapColor', () => this._gapColor),
          this.defines.SHADOW_VOLUME)
        ) {
          const t = new lf({ context: e.context, passType: pp.PICK_PASS });
          t.render({ painter: e }),
            this._depthTexture && this._depthTexture.destroy(),
            (this._depthTexture = t.framebuffer
              .getColorTexture(0)
              .bind(Ll.LINEAR, Ll.CLAMP_TO_EDGE)),
            t.destroy(!0),
            this._uniforms.set('u_DepthTexture', () => this._depthTexture);
        }
      }
      flowTexture(e) {
        e.speed || (e.speed = 1),
          e.rotation || (e.rotation = 0),
          e.direction || (e.direction = 'right'),
          e.texRepeat || (e.repeat = [0, 0]),
          e.speed > 10 && (e.speed = 10),
          e.speed < 1 && (e.speed = 1);
        const t = 50 / e.speed,
          i = new Ge(0, 0, 1, 1),
          n = Date.now(),
          r = this;
        (r._flowOptions = e),
          (function o() {
            if (Date.now() - n >= t) {
              switch ((i.x > 1 && (i.x = i.x - 1), i.y > 1 && (i.y = i.y - 1), e.direction)) {
                case 'right':
                  i.x = i.x - 1 / 60 + 1;
                  break;
                case 'left':
                default:
                  i.x += 1 / 60;
                  break;
                case 'up':
                  i.y = i.y - 1 / 60 + 1;
                  break;
                case 'down':
                  i.y += 1 / 60;
              }
              r.#E({
                texCoordCenter: [0.5, 0.5],
                texCoordRotation: e.rotation,
                texCoordOffset: [i.x, i.y],
                texCoordRepeat: e.texRepeat,
              });
            }
            r.frame && J.cancelAnimationFrame(r.frame), (r.frame = J.requestAnimationFrame(o));
          })();
      }
      #E(e) {
        this._uniforms.set('u_TexOffsetScale', () => {
          const t = new Ge(0, 0, 1, 1);
          return (
            e && e.texCoordOffset && e.texCoordOffset[0] && (t.x = e.texCoordOffset[0]),
            e && e.texCoordOffset && e.texCoordOffset[1] && (t.y = e.texCoordOffset[1]),
            e && e.texCoordRepeat && e.texCoordRepeat[0] && (t.z = e.texCoordRepeat[0]),
            e && e.texCoordRepeat && e.texCoordRepeat[1] && (t.w = e.texCoordRepeat[1]),
            t
          );
        }),
          this._uniforms.set('u_TexRotate', () => {
            const t = new Pt(0.5, 0.5, 0);
            return (
              e && e.texCoordCenter && e.texCoordCenter[0] && (t.x = e.texCoordCenter[0]),
              e && e.texCoordCenter && e.texCoordCenter[1] && (t.y = e.texCoordCenter[1]),
              e && e.texCoordRotation && (t.z = e.texCoordRotation * Me.TRANSFORM.DEG_TO_RAD),
              t
            );
          });
      }
      serialize() {
        return {
          type: this.type,
          color: ai.pack(this._color, new Array(4)),
          opacity: this._opacity,
          dashLength: this._dashLength,
          dashPattern: this._dashPattern,
          gapColor: this._gapColor,
          dashed: this._dashed,
          pixelWidth: this._pixelWidth,
        };
      }
      destroy() {
        return (
          (this._renderState = void 0),
          (this._color = void 0),
          (this._uColor = void 0),
          (this.type = void 0),
          (this._viewportOrthographicMatrix = void 0),
          (this._currentFrustum = void 0),
          (this._cameraPositionEncode = void 0),
          (this._interval = void 0),
          (this._cameraViewMatrix = void 0),
          (this._dashLength = void 0),
          (this._dashPattern = void 0),
          (this._gapColor = void 0),
          (this._dashed = void 0),
          (this._pixelWidth = void 0),
          this._depthTexture && (this._depthTexture.destroy(), (this._depthTexture = void 0)),
          Vc(this)
        );
      }
    }
    class uf extends Wp {
      constructor(e) {
        super(e),
          (this.type = 'pickColorMaterial'),
          (this.renderState = this.#S()),
          (this.dirty = !1),
          (this.bUniformCreated = !1),
          (this._usePickColorTexture = void 0),
          (this._isOneDimensionBatchTexture = void 0),
          (this._pickTextureUniformsCallBack = void 0);
      }
      update(e, t, i = {}) {
        this.#C(), super.update(e, t, i), this.#M(i, t), this.#A(i.primitive);
      }
      #M(e = {}, t) {
        const { primitive: i } = e;
        if (i.allowPick) {
          if (
            (i.allowPick && (this._renderState.cull = yp.disableCull),
            null != this._usePickColorTexture)
          ) {
            const e = i?.owner?.extra?.batchTable?._batchTexture.getUniformMapCallback();
            e && (this._uniforms = e(this._uniforms));
          } else this._uniforms.set('u_pickIdColor', () => i._material.pickColor);
          i._material instanceof cf &&
            (this._uniforms.set(
              'u_ViewportOrthographic',
              () => i._material._viewportOrthographicMatrix,
            ),
            this._uniforms.set(
              'u_GeometricToleranceOverMeter',
              () => i._material._geometricToleranceOverMeter,
            ),
            this._uniforms.set('u_Normal', () => i._material._normal),
            this._uniforms.set('u_GlobeMinimumAltitude', () => i._material._globeMinimumAltitude),
            i._material.defines.SHADOW_VOLUME &&
              this._uniforms.set('u_DepthTexture', () => i._material._depthTexture)),
            'BillboardMaterial' === i._material.type &&
              (i._material._pixelResolution &&
                ((this.defines = { FIXED_PIXEL_SIZE: !0 }),
                this._uniforms.set(
                  'u_PixelResolution',
                  () => new $e(i._material._pixelResolution),
                )),
              this._uniforms.set('u_MvMatrix', () =>
                i._material._modelMatrix
                  ? t.camera.getViewMatrix().multiplyRight(i._material._modelMatrix)
                  : void 0,
              ),
              this._uniforms.set('u_center', () => i._material._center),
              this._uniforms.set('u_rotation', () => i._material.u_rotation),
              this._uniforms.set('u_ProjectionMatrix', () => t.camera.getProjectionMatrix()),
              this._uniforms.set('u_InvertViewMatrix', () => t.camera.getViewMatrix().invert()),
              this._uniforms.set('u_ScaleMatrix', () => i._material._scaleMatrix));
        }
      }
      #A(e) {
        this.defines = {
          JOINT_MATRIX_CNT: Z(e?._material?.defines?.JOINT_MATRIX_CNT, !1),
          INSTANCE_MATRIX: Z(e?._material?.isInstance, !1),
          USE_MORPHTARGETS: Z(e?._material?.defines?.USE_MORPHTARGETS, !1),
          LOG_DEPTH: !1,
          USE_PICKINGTEXTURES: Z(this._usePickColorTexture, !1),
          ONE_DIMENSION_BATCH_TEXTURE: Z(this._isOneDimensionBatchTexture, !1),
          TWO_DIMENSION_BATCH_TEXTURE: !1,
          MODEL_INSTANCE_BATCH_TEXTURE: this._isModelInstanceTexture,
          POLYLINE: Z(e?._material?.defines?.POLYLINE, !1),
          BILLBOARD: Z(e?._material?.defines?.BILLBOARD, !1),
          SHADOW_VOLUME: Z(e.adaptTerrain, !1),
        };
      }
      #C() {
        (this._usePickColorTexture = void 0), (this._isOneDimensionBatchTexture = void 0);
      }
      #S() {
        return {
          depthTest: { enabled: !0, func: Ll.LEQUAL },
          blending: {
            color: { red: 0, green: 0, blue: 0, alpha: 0 },
            enabled: !1,
            equationRgb: Ll.FUNC_ADD,
            equationAlpha: Ll.FUNC_ADD,
            functionSourceRgb: Ll.SRC_ALPHA,
            functionSourceAlpha: Ll.ONE,
            functionDestinationRgb: Ll.ONE_MINUS_SRC_ALPHA,
            functionDestinationAlpha: Ll.ONE_MINUS_SRC_ALPHA,
          },
          stencilTest: {
            enabled: !1,
            frontFunction: Ll.ALWAYS,
            backFunction: Ll.ALWAYS,
            reference: 0,
            mask: 0,
            frontOperation: { fail: Ll.KEEP, zFail: Ll.KEEP, zPass: Ll.REPLACE },
            backOperation: { fail: Ll.KEEP, zFail: Ll.KEEP, zPass: Ll.REPLACE },
          },
        };
      }
    }
    class hf extends Wp {
      constructor(e) {
        super(e),
          (this.type = 'normalMaterial'),
          (this.renderState = this.#S()),
          (this.dirty = !1),
          (this.bUniformCreated = !1);
      }
      update(e, t, i = {}) {
        super.update(e, t, i), this.bUniformCreated || this.#P();
      }
      #S() {
        return {
          depthTest: { enabled: !0, func: Ll.LESS },
          blending: {
            color: { red: 0, green: 0, blue: 0, alpha: 0 },
            enabled: !1,
            equationRgb: Ll.FUNC_ADD,
            equationAlpha: Ll.FUNC_ADD,
            functionSourceRgb: Ll.SRC_ALPHA,
            functionSourceAlpha: Ll.ONE,
            functionDestinationRgb: Ll.ONE_MINUS_SRC_ALPHA,
            functionDestinationAlpha: Ll.ONE_MINUS_SRC_ALPHA,
          },
          stencilTest: {
            enabled: !1,
            frontFunction: Ll.ALWAYS,
            backFunction: Ll.ALWAYS,
            reference: 0,
            mask: 0,
            frontOperation: { fail: Ll.KEEP, zFail: Ll.KEEP, zPass: Ll.REPLACE },
            backOperation: { fail: Ll.KEEP, zFail: Ll.KEEP, zPass: Ll.REPLACE },
          },
        };
      }
      #P() {
        this.bUniformCreated = !0;
      }
      destroy() {
        return (
          (this.type = void 0),
          (this._renderState = void 0),
          (this.dirty = void 0),
          (this.bUniformCreated = void 0),
          (this._uniforms = void 0),
          (this._programConfiguration = void 0),
          this._shaderSource.destroy(),
          (this._shaderSource = void 0),
          (this.layer = void 0),
          (this._pickColor = void 0),
          (this._usePickColorTexture = void 0),
          (this._isOneDimensionBatchTexture = void 0),
          (this._pickTextureUniformsCallBack = void 0),
          Vc(this)
        );
      }
    }
    class df {
      constructor() {
        (this._insatnceBuffer = void 0),
          (this._attributes = []),
          (this._attributesbuffviewObject = {}),
          this.#o(),
          this.#a(),
          (this._particleNum = 0),
          (this.dirty = !1),
          (this.colorArr = null),
          (this.modelPositonArr = null),
          (this.scaleArr = null);
      }
      get instanceBuffer() {
        return this._insatnceBuffer;
      }
      createBuffer(e) {
        this._insatnceBuffer = new Ru({
          context: e,
          attributesbuffviewObject: this._attributesbuffviewObject,
          attributes: this._attributes,
          dynamicDraw: !1,
          buffers: void 0,
        });
      }
      #o() {
        for (let e = 0; e < 4; ++e)
          this._attributes.push({
            name: 'a_InstanceMatrix4',
            type: 5126,
            components: 4,
            instance: !0,
            byteStride: 64,
            offset: 16 * e,
            attribIndex: e,
            divisor: 1,
          });
        this._attributes.push({
          name: 'a_Color',
          type: 5126,
          components: 4,
          instance: !0,
          byteStride: 0,
          offset: 0,
          attribIndex: 0,
          divisor: 1,
        }),
          this._attributes.push({
            name: 'a_Scale',
            type: 5126,
            components: 1,
            instance: !0,
            byteStride: 0,
            offset: 0,
            attribIndex: 0,
            divisor: 1,
          });
      }
      #a() {
        this.#l();
      }
      #l() {
        (this._attributesbuffviewObject.InstanceMatrix4 = { value: new Float32Array(128e4) }),
          (this._attributesbuffviewObject.Color = { value: new Float32Array(32e4) }),
          (this._attributesbuffviewObject.Scale = { value: new Float32Array(8e4) });
      }
      update(e) {
        e && e.context && !this._insatnceBuffer && this.createBuffer(e.context),
          this.dirty &&
            (this._insatnceBuffer.updateDataTest(
              new Float32Array(this.modelPositonArr),
              'a_InstanceMatrix4',
            ),
            this._insatnceBuffer.updateDataTest(new Float32Array(this.colorArr), 'a_Color'),
            this._insatnceBuffer.updateDataTest(new Float32Array(this.scaleArr), 'a_Scale'));
      }
      updateData(e) {
        if (e.positions.length) {
          const t = e.positions,
            i = e.frameState.camera.getViewMatrix().clone(),
            n = [];
          for (let e = 0; e < t.length; e++) {
            const r = Il.eastNorthUpToFixedFrame(t[e]),
              o = i.multiplyRight(r, new Je());
            n.push(
              o[0],
              o[1],
              o[2],
              o[3],
              o[4],
              o[5],
              o[6],
              o[7],
              o[8],
              o[9],
              o[10],
              o[11],
              o[12],
              o[13],
              o[14],
              o[15],
            );
          }
          (this._particleNum = t.length),
            (this.colorArr = e.colorArr),
            (this.scaleArr = e.scaleArr),
            (this.modelPositonArr = n),
            (this.dirty = !0);
        }
      }
      static generateInstanceModelMatrix(e) {
        const t = [];
        return (
          e.forEach((e, i) => {
            const n = Il.cartographicToFixedFrame(e);
            t.push({ modelMatrix: n, batchId: i });
          }),
          t
        );
      }
      destroy() {
        this._insatnceBuffer && this._insatnceBuffer.destroy(),
          (this._attributes = []),
          (this._attributesbuffviewObject = null),
          (this._particleNum = 0),
          (this.dirty = !1),
          (this.colorArr = null),
          (this.modelPositonArr = null),
          (this.scaleArr = null);
      }
    }
    class pf {
      constructor(e, t, i) {
        const n = Z(i, wt.WGS84);
        (this._ellipsoid = n),
          (this._start = new Pt()),
          (this._end = new Pt()),
          (this._constants = {}),
          (this._startHeading = void 0),
          (this._endHeading = void 0),
          (this._distance = void 0),
          (this._uSquared = void 0);
      }
      get ellipsoid() {
        return this._ellipsoid;
      }
      get surfaceDistance() {
        return this._distance;
      }
      get start() {
        return this._start;
      }
      get end() {
        return this._end;
      }
      get startHeading() {
        return this._startHeading;
      }
      get endHeading() {
        return this._endHeading;
      }
      setConstants(e) {
        const t = e._uSquared,
          i = e._ellipsoid.maximumRadius,
          n = e._ellipsoid.minimumRadius,
          r = (i - n) / i,
          o = Math.cos(e._startHeading),
          a = Math.sin(e._startHeading),
          s = (1 - r) * Math.tan(e._start.y),
          l = 1 / Math.sqrt(1 + s * s),
          c = l * s,
          u = Math.atan2(s, o),
          h = l * a,
          d = h * h,
          p = 1 - d,
          f = Math.sqrt(p),
          m = t / 4,
          _ = m * m,
          g = _ * m,
          y = _ * _,
          x = 1 + m - (3 * _) / 4 + (5 * g) / 4 - (175 * y) / 64,
          v = 1 - m + (15 * _) / 8 - (35 * g) / 8,
          w = 1 - 3 * m + (35 * _) / 4,
          T = 1 - 5 * m,
          b =
            x * u -
            (v * Math.sin(2 * u) * m) / 2 -
            (w * Math.sin(4 * u) * _) / 16 -
            (T * Math.sin(6 * u) * g) / 48 -
            (5 * Math.sin(8 * u) * y) / 512,
          S = e._constants;
        (S.a = i),
          (S.b = n),
          (S.f = r),
          (S.cosineHeading = o),
          (S.sineHeading = a),
          (S.tanU = s),
          (S.cosineU = l),
          (S.sineU = c),
          (S.sigma = u),
          (S.sineAlpha = h),
          (S.sineSquaredAlpha = d),
          (S.cosineSquaredAlpha = p),
          (S.cosineAlpha = f),
          (S.u2Over4 = m),
          (S.u4Over16 = _),
          (S.u6Over64 = g),
          (S.u8Over256 = y),
          (S.a0 = x),
          (S.a1 = v),
          (S.a2 = w),
          (S.a3 = T),
          (S.distanceRatio = b);
      }
      computeC(e, t) {
        return (e * t * (4 + e * (4 - 3 * t))) / 16;
      }
      computeDeltaLambda(e, t, i, n, r, o, a) {
        const s = this.computeC(e, i);
        return (1 - s) * e * t * (n + s * r * (a + s * o * (2 * a * a - 1)));
      }
      vincentyInverseFormula(e, t, i, n, r, o, a) {
        const s = (t - i) / t,
          l = o - n,
          c = Math.atan((1 - s) * Math.tan(r)),
          u = Math.atan((1 - s) * Math.tan(a)),
          h = Math.cos(c),
          d = Math.sin(c),
          p = Math.cos(u),
          f = Math.sin(u),
          m = h * p,
          _ = h * f,
          g = d * f,
          y = d * p;
        let x,
          v,
          w,
          T,
          b,
          S = l,
          A = Me.TRANSFORM.TWO_PI,
          P = Math.cos(S),
          E = Math.sin(S);
        do {
          (P = Math.cos(S)), (E = Math.sin(S));
          const e = _ - y * P;
          let t;
          (w = Math.sqrt(p * p * E * E + e * e)),
            (v = g + m * P),
            (x = Math.atan2(w, v)),
            0 === w ? ((t = 0), (T = 1)) : ((t = (m * E) / w), (T = 1 - t * t)),
            (A = S),
            (b = v - (2 * g) / T),
            isFinite(b) || (b = 0),
            (S = l + this.computeDeltaLambda(s, t, T, x, w, v, b));
        } while (Math.abs(S - A) > Me.TRANSFORM.EPSILON12);
        const C = (T * (t * t - i * i)) / (i * i),
          M = (C * (256 + C * (C * (74 - 47 * C) - 128))) / 1024,
          I = b * b,
          L =
            i *
            (1 + (C * (4096 + C * (C * (320 - 175 * C) - 768))) / 16384) *
            (x -
              M *
                w *
                (b + (M * (v * (2 * I - 1) - (M * b * (4 * w * w - 3) * (4 * I - 3)) / 6)) / 4)),
          R = Math.atan2(p * E, _ - y * P),
          N = Math.atan2(h * E, _ * P - y);
        (e._distance = L), (e._startHeading = R), (e._endHeading = N), (e._uSquared = C);
      }
      computeProperties(e, t, i, n) {
        this.vincentyInverseFormula(e, n.maximumRadius, n.minimumRadius, t.x, t.y, i.x, i.y),
          (e._start = Pt.clone(t, e._start)),
          (e._end = Pt.clone(i, e._end)),
          (e._start.z = 0),
          (e._end.z = 0),
          this.setConstants(e);
      }
      setEndPoints(e, t, i) {
        this.computeProperties(this, e, t, this._ellipsoid, i);
      }
      interpolateUsingFraction(e, t) {
        return this.interpolateUsingSurfaceDistance(this._distance * e, t);
      }
      interpolateUsingSurfaceDistance(e, i) {
        const n = this._constants,
          r = n.distanceRatio + e / n.b,
          o = Math.cos(2 * r),
          a = Math.cos(4 * r),
          s = Math.cos(6 * r),
          l = Math.sin(2 * r),
          c = Math.sin(4 * r),
          u = Math.sin(6 * r),
          h = Math.sin(8 * r),
          d = r * r,
          p = n.u8Over256,
          f = n.u2Over4,
          m = n.u6Over64,
          _ = n.u4Over16;
        let g =
          (r * d * 2 * p * o) / 3 +
          r *
            (1 -
              f +
              (7 * _) / 4 -
              (15 * m) / 4 +
              (579 * p) / 64 -
              (_ - (15 * m) / 4 + (187 * p) / 16) * o -
              ((5 * m) / 4 - (115 * p) / 16) * a -
              (29 * p * s) / 16) +
          (f / 2 - _ + (71 * m) / 32 - (85 * p) / 16) * l +
          ((5 * _) / 16 - (5 * m) / 4 + (383 * p) / 96) * c -
          d * ((m - (11 * p) / 2) * l + (5 * p * c) / 2) +
          ((29 * m) / 96 - (29 * p) / 16) * u +
          (539 * p * h) / 1536;
        const y = Math.asin(Math.sin(g) * n.cosineAlpha),
          x = Math.atan((n.a / n.b) * Math.tan(y));
        g -= n.sigma;
        const v = Math.cos(2 * n.sigma + g),
          w = Math.sin(g),
          T = Math.cos(g),
          b =
            Math.atan2(w * n.sineHeading, n.cosineU * T - n.sineU * w * n.cosineHeading) -
            this.computeDeltaLambda(n.f, n.sineAlpha, n.cosineSquaredAlpha, g, w, T, v);
        return t(i)
          ? ((i.x = this._start.x + b), (i.y = x), (i.z = 0), i)
          : new Pt(this._start.x + b, x, 0);
      }
    }
    const ff = {};
    function mf(e, t, i) {
      const n = [];
      let r;
      if (((n.length = e), t === i)) {
        for (r = 0; r < e; r++) n[r] = t;
        return n;
      }
      const o = (i - t) / e;
      for (r = 0; r < e; r++) n[r] = t + r * o;
      return n;
    }
    function _f(e, t, i, n, r, o, a, s) {
      const l = new as(),
        c = new as(),
        u = new Pt(),
        h = new Pt(),
        d = new Pt(),
        p = n.scaleToGeodeticSurface(e, h),
        f = n.scaleToGeodeticSurface(t, d),
        m = new pf(),
        _ = ff.numberOfPoints(e, t, i),
        g = n.cartesianToCartographic(p, l);
      ct(g, g);
      const y = n.cartesianToCartographic(f, c);
      ct(y, y);
      const x = mf(_, r, o);
      m.setEndPoints(g, y, !0);
      const v = m.surfaceDistance / _;
      let w = s;
      g.height = r;
      let T = n.cartographicToCartesian(g, u, !0);
      Pt.pack(T, a, w), (w += 3);
      for (let e = 1; e < _; e++) {
        const t = m.interpolateUsingSurfaceDistance(e * v, c);
        (t.height = x[e]), (T = n.cartographicToCartesian(t, u, !0)), Pt.pack(T, a, w), (w += 3);
      }
      return w;
    }
    function gf(e, t, i, n, r, o, a, s) {
      const l = new as(),
        c = new as(),
        u = new Pt(),
        h = n.cartesianToCartographic(e, l);
      ct(h, h);
      const d = n.cartesianToCartographic(t, c);
      ct(d, d);
      let p = new hh();
      const f = ff.numberOfPointsRhumbLine(h, d, i);
      (h.height = 0), (d.height = 0);
      const m = mf(f, r, o);
      p.ellipsoid.equals(n) || (p = new hh(void 0, void 0, n)), p.setEndPoints(h, d);
      const _ = p.surfaceDistance / f;
      let g = s;
      h.height = r;
      let y = n.cartographicToCartesian(h, u, !0);
      Pt.pack(y, a, g), (g += 3);
      for (let e = 1; e < f; e++) {
        const t = p.interpolateUsingSurfaceDistance(e * _, c);
        (t.height = m[e]), (y = n.cartographicToCartesian(t, u, !0)), Pt.pack(y, a, g), (g += 3);
      }
      return g;
    }
    (ff.numberOfPoints = function (e, t, i) {
      const n = Pt.distance(e, t);
      return Math.ceil(n / i);
    }),
      (ff.numberOfPointsRhumbLine = function (e, t, i) {
        const n = Math.pow(e.longitude - t.longitude, 2) + Math.pow(e.latitude - t.latitude, 2);
        return Math.max(1, Math.ceil(Math.sqrt(n / (i * i))));
      }),
      (ff.extractHeights = function (e, t) {
        const i = new as(),
          n = e.length,
          r = new Array(n);
        for (let o = 0; o < n; o++) r[o] = t.cartesianToCartographic(e[o], i).height;
        return r;
      }),
      (ff.wrapLongitude = function (e, i) {
        const n = [],
          r = [],
          o = new Je(),
          a = new Pt(),
          s = new Pt(),
          l = new Ca(Pt.UNIT_X, 0),
          c = new Pt(),
          u = new Ca(Pt.UNIT_X, 0),
          h = new Pt(),
          d = new Pt();
        if (t(e) && e.length > 0) {
          i = Z(i, Je.IDENTITY);
          const p = Je.inverseTransformation(i, o),
            f = Je.multiplyByPoint(p, Pt.ZERO, a),
            m = Pt.normalize(Je.multiplyByPointAsVector(p, Pt.UNIT_Y, s), s),
            _ = Ca.fromPointNormal(f, m, l),
            g = Pt.normalize(Je.multiplyByPointAsVector(p, Pt.UNIT_X, c), c),
            y = Ca.fromPointNormal(f, g, u);
          let x = 1;
          n.push(Pt.clone(e[0]));
          let v = n[0];
          const w = e.length;
          for (let i = 1; i < w; ++i) {
            const o = e[i];
            if (Ca.getPointDistance(y, v) < 0 || Ca.getPointDistance(y, o) < 0) {
              const e = ds.lineSegmentPlane(v, o, _, h);
              if (t(e)) {
                const t = Pt.multiplyByScalar(m, 5e-9, d);
                Ca.getPointDistance(_, v) < 0 && Pt.negate(t, t),
                  n.push(Pt.add(e, t, new Pt())),
                  r.push(x + 1),
                  Pt.negate(t, t),
                  n.push(Pt.add(e, t, new Pt())),
                  (x = 1);
              }
            }
            n.push(Pt.clone(e[i])), x++, (v = o);
          }
          r.push(x);
        }
        return { positions: n, lengths: r };
      }),
      (ff.generateArc = function (e) {
        t(e) || (e = {});
        const i = e.positions;
        if (!t(i)) throw new Error('options.positions is required.');
        const n = new Pt(),
          r = new Pt(),
          o = i.length,
          a = Z(e.ellipsoid, wt.WGS84);
        let s = Z(e.height, 0);
        const l = Array.isArray(s);
        if (o < 1) return [];
        if (1 === o) {
          const e = a.scaleToGeodeticSurface(i[0], r);
          if (((s = l ? s[0] : s), 0 !== s)) {
            const t = a.geodeticSurfaceNormal(e, n);
            Pt.multiplyByScalar(t, s, t), Pt.add(e, t, e);
          }
          return [e.x, e.y, e.z];
        }
        let c = e.minDistance;
        if (!t(c)) {
          const t = Z(e.granularity, Me.CesiumMath.RADIANS_PER_DEGREE);
          c = Me.CesiumMath.chordLength(t, a.maximumRadius);
        }
        let u,
          h = 0;
        for (u = 0; u < o - 1; u++) h += ff.numberOfPoints(i[u], i[u + 1], c);
        const d = 3 * (h + 1),
          p = new Array(d);
        let f = 0;
        for (u = 0; u < o - 1; u++)
          f = _f(i[u], i[u + 1], c, a, l ? s[u] : s, l ? s[u + 1] : s, p, f);
        const m = i[o - 1],
          _ = new as(),
          g = a.cartesianToCartographic(m, _);
        ct(g, g), (g.height = l ? s[o - 1] : s);
        const y = a.cartographicToCartesian(g, n, !0);
        return Pt.pack(y, p, d - 3), p;
      });
    const yf = new as(),
      xf = new as();
    (ff.generateRhumbArc = function (e) {
      t(e) || (e = {});
      const i = e.positions;
      if (!t(i)) throw new Error('options.positions is required.');
      const n = new Pt(),
        r = new Pt(),
        o = i.length,
        a = Z(e.ellipsoid, wt.WGS84);
      let s = Z(e.height, 0);
      const l = Array.isArray(s);
      if (o < 1) return [];
      if (1 === o) {
        const e = a.scaleToGeodeticSurface(i[0], r);
        if (((s = l ? s[0] : s), 0 !== s)) {
          const t = a.geodeticSurfaceNormal(e, n);
          Pt.multiplyByScalar(t, s, t), Pt.add(e, t, e);
        }
        return [e.x, e.y, e.z];
      }
      const c = Z(e.granularity, Me.CesiumMath.RADIANS_PER_DEGREE);
      let u,
        h,
        d = 0,
        p = a.cartesianToCartographic(i[0], yf);
      for (ct(p, p), u = 0; u < o - 1; u++)
        (h = a.cartesianToCartographic(i[u + 1], xf)),
          ct(h, h),
          (d += ff.numberOfPointsRhumbLine(p, h, c)),
          (p = as.clone(h, yf));
      const f = 3 * (d + 1),
        m = new Array(f);
      let _ = 0;
      for (u = 0; u < o - 1; u++)
        _ = gf(i[u], i[u + 1], c, a, l ? s[u] : s, l ? s[u + 1] : s, m, _);
      const g = i[o - 1],
        y = new as(),
        x = a.cartesianToCartographic(g, y);
      ct(x, x), (x.height = l ? s[o - 1] : s);
      const v = a.cartographicToCartesian(x, n, !0);
      return Pt.pack(v, m, f - 3), m;
    }),
      (ff.generateCartesianArc = function (e) {
        const t = ff.generateArc(e),
          i = t.length / 3,
          n = new Array(i);
        for (let e = 0; e < i; e++) n[e] = Pt.unpack(t, 3 * e);
        return n;
      }),
      (ff.generateCartesianRhumbArc = function (e) {
        const t = ff.generateRhumbArc(e),
          i = t.length / 3,
          n = new Array(i);
        for (let e = 0; e < i; e++) n[e] = Pt.unpack(t, 3 * e);
        return n;
      });
    const vf = Gt([
        { name: 'a_PositionHigh', type: 'Float32', components: 3 },
        { name: 'a_PositionLow', type: 'Float32', components: 3 },
        { name: 'a_PrevPositionHigh', type: 'Float32', components: 3 },
        { name: 'a_PrevPositionLow', type: 'Float32', components: 3 },
        { name: 'a_NextPositionHigh', type: 'Float32', components: 3 },
        { name: 'a_NextPositionLow', type: 'Float32', components: 3 },
        { name: 'a_ExpandAndWidth', type: 'Float32', components: 2 },
        { name: 'a_TEXCOORD_0', type: 'Float32', components: 2 },
      ]),
      wf = Gt([
        { name: 'a_PositionHigh', type: 'Float32', components: 3 },
        { name: 'a_PositionLow', type: 'Float32', components: 3 },
        { name: 'a_StartHigh', type: 'Float32', components: 3 },
        { name: 'a_StartLow', type: 'Float32', components: 3 },
        { name: 'a_StartNormal', type: 'Float32', components: 3 },
        { name: 'a_EndNormal', type: 'Float32', components: 3 },
        { name: 'a_RightNormal', type: 'Float32', components: 3 },
        { name: 'a_ForwardOffset', type: 'Float32', components: 3 },
        { name: 'a_TexCoord', type: 'Float32', components: 2 },
        { name: 'a_Width', type: 'Float32', components: 1 },
      ]),
      Tf = [
        0, 2, 1, 0, 3, 2, 0, 7, 3, 0, 4, 7, 0, 5, 4, 0, 1, 5, 5, 7, 4, 5, 6, 7, 5, 2, 6, 5, 1, 2, 3,
        6, 2, 3, 7, 6,
      ],
      bf = Tf.length;
    class Sf {
      constructor() {}
      static createVolumeGeometry(e, t) {
        if (e.length < 2) return;
        let i = e.map((e) => {
          const i = Pt.fromArray(t.cartesianToCartographic(e));
          return (i.z = 0), i;
        });
        i = Wh(i, Pt.equalsEpsilon, !1);
        const n = i.length,
          r = -100,
          o = 3e3;
        let a, s;
        const l = [],
          c = [],
          u = [];
        let h = new Pt(),
          d = new Pt(),
          p = new Pt(),
          f = new Pt(),
          m = new Pt();
        const _ = i[0],
          g = i[1];
        for (
          h = this.getPosition(t, i[n - 1], r, h),
            f = this.getPosition(t, g, r, f),
            d = this.getPosition(t, _, r, d),
            p = this.getPosition(t, _, o, p),
            m = this.computeRightNormal(_, g, o, t, m),
            Pt.pack(m, l, 0),
            Pt.pack(d, c, 0),
            Pt.pack(p, u, 0),
            s = 1;
          s < n - 1;
          ++s
        )
          (h = Pt.clone(d, h)),
            (d = Pt.clone(f, d)),
            this.getPosition(t, i[s], o, p),
            this.getPosition(t, i[s + 1], r, f),
            this.computeVertexMiterNormal(h, d, p, f, m),
            (a = l.length),
            Pt.pack(m, l, a),
            Pt.pack(d, c, a),
            Pt.pack(p, u, a);
        const y = i[n - 1],
          x = i[n - 2];
        return (
          (d = this.getPosition(t, y, r, d)),
          (p = this.getPosition(t, y, o, p)),
          (m = this.computeRightNormal(x, y, o, t, m)),
          (a = l.length),
          Pt.pack(m, l, a),
          Pt.pack(d, c, a),
          Pt.pack(p, u, a),
          this.createGeometryArray(c, u, l)
        );
      }
      static createGeometryArray(e, t, i) {
        let n, r;
        const o = e.length / 3 - 1,
          a = 8 * o,
          s = 4 * a,
          l = 36 * o,
          c = a > 65535 ? new Uint32Array(l) : new Uint16Array(l),
          u = new Float64Array(3 * a),
          h = new Float32Array(s),
          d = new Float32Array(s),
          p = new Float32Array(s),
          f = new Float32Array(s),
          m = new Float32Array(s);
        let _ = new Pt(),
          g = new Pt();
        const y = t.length / 3;
        g = Pt.unpack(t, 0, g);
        let x,
          v = 0;
        for (r = 3, n = 1; n < y; n++)
          (_ = Pt.clone(g, _)), (g = Pt.unpack(t, r, g)), (v += Pt.distance(_, g)), (r += 3);
        r = 3;
        let w = 0,
          T = 0,
          b = !1,
          S = Pt.unpack(e, 0),
          A = Pt.unpack(t, 0),
          P = Pt.unpack(i, 0),
          E = 0;
        for (n = 0; n < o; n++) {
          const n = Pt.clone(S),
            o = Pt.clone(A);
          let a = Pt.clone(P);
          b && (a = Pt.negate(a, a)),
            (S = Pt.unpack(e, r)),
            (A = Pt.unpack(t, r)),
            (P = Pt.unpack(i, r)),
            (b = this.breakMiter(P, n, S, A));
          const s = Pt.distance(o, A),
            l = ih.fromVector3(n),
            c = Pt.subtract(S, n),
            _ = Pt.normalize(c, new Pt());
          let g = Pt.subtract(o, n);
          g = Pt.normalize(g, g);
          let y = Pt.cross(_, g);
          y = Pt.normalize(y, y);
          let C = Pt.cross(g, a);
          C = Pt.normalize(C, C);
          let M = Pt.subtract(A, S);
          M = Pt.normalize(M, M);
          let I = Pt.cross(P, M);
          I = Pt.normalize(I, I);
          const L = s / v,
            R = E / v;
          for (x = 0; x < 8; x++) {
            const e = T + 4 * x,
              t = e + 3,
              i = x < 4 ? 1 : -1,
              n = 2 === x || 3 === x || 6 === x || 7 === x ? 1 : -1;
            Pt.pack(l.high, h, e),
              (h[t] = c.x),
              Pt.pack(l.low, d, e),
              (d[t] = c.y),
              Pt.pack(C, p, e),
              (p[t] = c.z),
              Pt.pack(I, f, e),
              (f[t] = L * i),
              Pt.pack(y, m, e);
            let r = R * n;
            0 === r && n < 0 && (r = 9), (m[t] = r);
          }
          const N = Pt.clone(n),
            O = Pt.clone(S),
            D = Pt.clone(o),
            F = Pt.clone(A);
          let z = Pt.multiplyByScalar(y, Me.CesiumMath.EPSILON5);
          Pt.add(N, z, N),
            Pt.add(O, z, O),
            Pt.add(D, z, D),
            Pt.add(F, z, F),
            this.nudgeXZ(N, O),
            this.nudgeXZ(D, F),
            Pt.pack(N, u, w),
            Pt.pack(O, u, w + 3),
            Pt.pack(F, u, w + 6),
            Pt.pack(D, u, w + 9),
            (z = Pt.multiplyByScalar(y, -2 * Me.CesiumMath.EPSILON5, z)),
            Pt.add(N, z, N),
            Pt.add(O, z, O),
            Pt.add(D, z, D),
            Pt.add(F, z, F),
            this.nudgeXZ(N, O),
            this.nudgeXZ(D, F),
            Pt.pack(N, u, w + 12),
            Pt.pack(O, u, w + 15),
            Pt.pack(F, u, w + 18),
            Pt.pack(D, u, w + 21),
            (r += 3),
            (w += 24),
            (T += 32),
            (E += s);
        }
        r = 0;
        let C = 0;
        for (n = 0; n < o; n++) {
          for (x = 0; x < bf; x++) c[r + x] = Tf[x] + C;
          (C += 8), (r += bf);
        }
        return {
          attributes: {
            position: u,
            startHiAndForwardOffsetX: h,
            startLoAndForwardOffsetY: d,
            startNormalAndForwardOffsetZ: p,
            endNormalAndTextureCoordinateNormalizationX: f,
            rightNormalAndTextureCoordinateNormalizationY: m,
          },
          indices: c,
        };
      }
      static getPosition(e, t, i, n) {
        const r = new Pt();
        return Pt.clone(t, r), (r.z = i), e.cartographicToCartesian(r, n);
      }
      static computeRightNormal(e, t, i, n, r) {
        const o = new Pt(),
          a = new Pt(),
          s = new Pt(),
          l = this.getPosition(n, e, 0, o),
          c = this.getPosition(n, e, i, a),
          u = this.getPosition(n, t, 0, s),
          h = this.direction(c, l, a),
          d = this.direction(u, l, s);
        return Pt.cross(d, h, r), Pt.normalize(r, r);
      }
      static computeVertexMiterNormal(e, t, i, n, r) {
        const o = new Pt(),
          a = new Pt(),
          s = new Pt(),
          l = new Pt(),
          c = this.direction(i, t, o),
          u = this.tangentDirection(e, t, c, a),
          h = this.tangentDirection(n, t, c, s);
        if (Me.CesiumMath.equalsEpsilon(Pt.dot(u, h), -1, Me.CesiumMath.EPSILON5))
          return (r = Pt.cross(c, u, r)), Pt.normalize(r, r);
        (r = Pt.add(h, u, r)), (r = Pt.normalize(r, r));
        const d = Pt.cross(c, r, l);
        return Pt.dot(h, d) < 0 && (r = Pt.negate(r, r)), r;
      }
      static direction(e, t, i) {
        return Pt.subtract(e, t, i), Pt.normalize(i, i), i;
      }
      static tangentDirection(e, t, i, n) {
        return (
          (n = this.direction(e, t, n)),
          (n = Pt.cross(n, i, n)),
          (n = Pt.normalize(n, n)),
          Pt.cross(i, n, n)
        );
      }
      static breakMiter(e, t, i, n) {
        const r = Math.cos(Me.CesiumMath.toRadians(30)),
          o = Math.cos(Me.CesiumMath.toRadians(150)),
          a = new Pt(),
          s = new Pt(),
          l = new je(),
          c = new Et(),
          u = this.direction(i, t, s),
          h = Pt.dot(u, e);
        if (h > r || h < o) {
          const t = this.direction(n, i, a),
            r = Et.fromAxisAngle(
              t,
              h < o ? Me.CesiumMath.PI_OVER_TWO : -Me.CesiumMath.PI_OVER_TWO,
              c,
            ),
            s = je.fromQuaternion(r, l);
          return je.multiplyByVector(s, e, e), !0;
        }
        return !1;
      }
      static nudgeXZ(e, t) {
        const i = Ca.fromPointNormal(Pt.ZERO, Pt.UNIT_Y),
          n = Ca.getPointDistance(i, e),
          r = Ca.getPointDistance(i, t);
        let o = new Pt();
        Me.CesiumMath.equalsEpsilon(n, 0, Me.CesiumMath.EPSILON2)
          ? ((o = this.direction(t, e, o)),
            Pt.multiplyByScalar(o, Me.CesiumMath.EPSILON2, o),
            Pt.add(e, o, e))
          : Me.CesiumMath.equalsEpsilon(r, 0, Me.CesiumMath.EPSILON2) &&
            ((o = this.direction(e, t, o)),
            Pt.multiplyByScalar(o, Me.CesiumMath.EPSILON2, o),
            Pt.add(t, o, t));
      }
    }
    const Af = Gt([
        { name: 'a_PositionHigh', type: 'Float32', components: 3 },
        { name: 'a_PositionLow', type: 'Float32', components: 3 },
        { name: 'a_PrevPositionHigh', type: 'Float32', components: 3 },
        { name: 'a_PrevPositionLow', type: 'Float32', components: 3 },
        { name: 'a_NextPositionHigh', type: 'Float32', components: 3 },
        { name: 'a_NextPositionLow', type: 'Float32', components: 3 },
        { name: 'a_ExpandAndWidth', type: 'Float32', components: 2 },
        { name: 'a_TEXCOORD_0', type: 'Float32', components: 2 },
        { name: 'a_Color', type: 'Float32', components: 3 },
      ]),
      Pf = new Pt(),
      Ef = new Pt(),
      Cf = new Pt(),
      Mf = new Pt();
    class If extends ah {
      constructor(e) {
        super(e), this.setData(e);
      }
      #g(e, t = [], i = []) {
        let n, r, o, a;
        if (
          (this._positionsCallBack
            ? ((n = this._positionsCallBack()), this._vertexArray.clear(), this._indices.clear())
            : 0 != t.length
            ? ((n = t), (r = i[0][0]), (o = i[0][1]), (a = i[0][2]))
            : (n = this._positions),
          e &&
            this.incrementalData &&
            ((n = this._positions.slice(this.incrementalData.originPositionCount)),
            (n = this.incrementalData.lastTwoPosition.concat(n))),
          n.length < 2)
        )
          return;
        const s = this._width,
          l = this._arcType,
          c = this._granularity,
          u = this._ellipsoid;
        let h, d, p;
        n = Wh(n, Pt.equalsEpsilon, !1, []);
        let f = n.length;
        if (f < 2 || s <= 0) return;
        if (l === Kh.GEODESIC || l === Kh.RHUMB) {
          let e;
          e = l === Kh.GEODESIC ? Me.CesiumMath.chordLength(c, u.maximumRadius) : c;
          const t = ff.extractHeights(n, u);
          n =
            l === Kh.GEODESIC
              ? ff.generateCartesianArc({ positions: n, minDistance: e, ellipsoid: u, height: t })
              : ff.generateCartesianRhumbArc({
                  positions: n,
                  granularity: e,
                  ellipsoid: u,
                  height: t,
                });
        }
        f = n.length;
        const m = 4 * f - 4,
          _ = new Float64Array(3 * m),
          g = new Float64Array(3 * m),
          y = new Float64Array(3 * m),
          x = new Float32Array(2 * m),
          v = new Float32Array(2 * m);
        let w,
          T,
          b,
          S,
          A,
          P,
          E,
          C,
          M,
          I,
          L = 0,
          R = 0,
          N = 0;
        for (d = 0; d < f; ++d) {
          0 === d ? ((w = Pf), Pt.subtract(n[0], n[1], w), Pt.add(n[0], w, w)) : (w = n[d - 1]),
            Pt.clone(w, Cf),
            Pt.clone(n[d], Ef),
            d === f - 1
              ? ((w = Pf), Pt.subtract(n[f - 1], n[f - 2], w), Pt.add(n[f - 1], w, w))
              : (w = n[d + 1]),
            Pt.clone(w, Mf);
          const e = d === f - 1 ? 2 : 4;
          for (p = 0 === d ? 2 : 0; p < e; ++p) {
            Pt.pack(Ef, _, L), Pt.pack(Cf, g, L), Pt.pack(Mf, y, L), (L += 3);
            const e = p - 2 < 0 ? -1 : 1;
            (x[R++] = (p % 2) * 2 - 1),
              (x[R++] = e * s),
              (v[N++] = d / (f - 1)),
              (v[N++] = Math.max(x[R - 2], 0));
          }
        }
        for (this.finalPositions = _, h = 0; h < _.length; h += 3)
          (T = ih.encode(_[h])),
            (b = ih.encode(_[h + 1])),
            (S = ih.encode(_[h + 2])),
            (A = ih.encode(g[h])),
            (P = ih.encode(g[h + 1])),
            (E = ih.encode(g[h + 2])),
            (C = ih.encode(y[h])),
            (M = ih.encode(y[h + 1])),
            (I = ih.encode(y[h + 2])),
            i.length > 1
              ? this._vertexArray.emplaceBack(
                  T.high,
                  b.high,
                  S.high,
                  T.low,
                  b.low,
                  S.low,
                  A.high,
                  P.high,
                  E.high,
                  A.low,
                  P.low,
                  E.low,
                  C.high,
                  M.high,
                  I.high,
                  C.low,
                  M.low,
                  I.low,
                  x[(h / 3) * 2],
                  x[(h / 3) * 2 + 1],
                  v[(h / 3) * 2],
                  v[(h / 3) * 2 + 1],
                  r,
                  o,
                  a,
                )
              : this._vertexArray.emplaceBack(
                  T.high,
                  b.high,
                  S.high,
                  T.low,
                  b.low,
                  S.low,
                  A.high,
                  P.high,
                  E.high,
                  A.low,
                  P.low,
                  E.low,
                  C.high,
                  M.high,
                  I.high,
                  C.low,
                  M.low,
                  I.low,
                  x[(h / 3) * 2],
                  x[(h / 3) * 2 + 1],
                  v[(h / 3) * 2],
                  v[(h / 3) * 2 + 1],
                );
        const O = f - 1;
        if (t.length > 0)
          for (d = 0; d < O; ++d)
            this._indices.emplaceBack(this.index, this.index + 2, this.index + 1),
              this._indices.emplaceBack(this.index + 1, this.index + 2, this.index + 3),
              (this.index += 4);
        else {
          let t = e ? this.incrementalData.lastIndex : 0;
          for (d = 0; d < O; ++d)
            this._indices.emplaceBack(t, t + 2, t + 1),
              this._indices.emplaceBack(t + 1, t + 2, t + 3),
              (t += 4);
          this.incrementalData = {
            originPositionCount: this._positionsCallBack
              ? this._positionsCallBack().length
              : this._positions.length,
            lastIndex: t,
            lastTwoPosition: n.slice(n.length - 2),
          };
        }
      }
      #_() {
        const e = this._positions;
        if (e.length < 2) return;
        const t = this._ellipsoid,
          i = this._granularity,
          n = this._arcType,
          { attributes: r, indices: o } = Sf.createVolumeGeometry(e, t, i, n),
          {
            position: a,
            startHiAndForwardOffsetX: s,
            startLoAndForwardOffsetY: l,
            startNormalAndForwardOffsetZ: c,
            endNormalAndTextureCoordinateNormalizationX: u,
            rightNormalAndTextureCoordinateNormalizationY: h,
          } = r;
        this.finalPositions = a;
        for (let e = 0, t = o.length; e < t; e += 3)
          this._indices.emplaceBack(o[e], o[e + 1], o[e + 2]);
        let d,
          p,
          f,
          m = 0;
        for (let e = 0, t = s.length; e < t; e += 4)
          (d = ih.encode(a[m])),
            (p = ih.encode(a[m + 1])),
            (f = ih.encode(a[m + 2])),
            this._vertexArray.emplaceBack(
              d.high,
              p.high,
              f.high,
              d.low,
              p.low,
              f.low,
              s[e],
              s[e + 1],
              s[e + 2],
              l[e],
              l[e + 1],
              l[e + 2],
              c[e],
              c[e + 1],
              c[e + 2],
              u[e],
              u[e + 1],
              u[e + 2],
              h[e],
              h[e + 1],
              h[e + 2],
              s[e + 3],
              l[e + 3],
              c[e + 3],
              u[e + 3],
              h[e + 3],
              this._width,
            ),
            (m += 3);
        this.computeBoundingSphere(this.finalPositions),
          this.computeBoundingBox(this.finalPositions),
          (this._ready = !0),
          (this._needUpdate = !0);
      }
      updateProperty(e) {
        this.setData(e);
      }
      setData(e) {
        if (
          ((this._width = Z(Z(e.width, this._width), 1)),
          (this.colorArray = Z(e.colorArray, void 0)),
          (this.lineSegmentation = Z(e.lineSegmentation, void 0)),
          (this.speed = Z(e.speed, 60)),
          (this.segGroup = Z(e.segGroup, 5)),
          (this.dynamicAirLine = Z(e.dynamicAirLine, !1)),
          e.positions && 'function' == typeof e.positions)
        )
          this._positionsCallBack = e.positions;
        else {
          if (!e.positions || e.positions.length < 2)
            return void console.error('至少添加两个点位！');
          this._positions = e.positions;
        }
        if (
          (this._vertexArray || this._indices
            ? e.incrementalUpdate || (this._vertexArray.clear(), this._indices.clear())
            : ((this._arcType = Z(e.arcType, Kh.GEODESIC)),
              (this._granularity = Z(e.granularity, Me.CesiumMath.RADIANS_PER_DEGREE)),
              (this._ellipsoid = wt.clone(Z(e.ellipsoid, wt.WGS84))),
              (this.type = 'PolylineGeometry'),
              (this._vertexArray = null == this.colorArray ? new Ao() : new Eo()),
              (this._indices = new ea()),
              (this.primitiveType = Ll.TRIANGLES),
              (this._usedDoublePrecision = !0),
              (this._ready = !1)),
          e.adaptTerrain)
        )
          (this._vertexArray = new Po()), this.#_();
        else if (((this.index = 0), null != this.lineSegmentation))
          for (let t = 0; t < this.lineSegmentation.length; t++)
            this.#g(
              e.incrementalUpdate,
              this._positions.slice(this.lineSegmentation[t][2], this.lineSegmentation[t][3]),
              this.colorArray.slice(this.lineSegmentation[t][2], this.lineSegmentation[t][3]),
            );
        else this.#g(e.incrementalUpdate);
        this.computeBoundingSphere(this._positions),
          this.computeBoundingBox(this._positions),
          (this._ready = !0),
          (this._needUpdate = !0);
      }
      setAdaptTerrain(e) {
        (this._indices = new ea()),
          e
            ? ((this._vertexArray = new Po()), this.#_())
            : ((this._vertexArray = new Ao()), this.#g());
      }
      update(e) {
        if (
          (this._positionsCallBack && this.#g(),
          this.dynamicAirLine &&
            (null != this.lineSegmentation && this.updateLineSegmentation(e),
            this.setData({
              positions: this._positions,
              width: this.width,
              arcType: Kh.GEODESIC,
              lineSegmentation: this.lineSegmentation,
              colorArray: this.colorArray,
              speed: this.speed,
              segGroup: this.segGroup,
              dynamicAirLine: this.dynamicAirLine,
            }),
            (this._needUpdate = !0)),
          this._needUpdate && e.painter)
        ) {
          const t = e.painter.context;
          this._vertBuffer
            ? (this._vertBuffer.updateData(this._vertexArray),
              this._indexBuffer.updateData(this._indices))
            : ((this._vertBuffer = t.createVertexBuffer(
                this._vertexArray,
                this._vertexArray instanceof Ao
                  ? vf.members
                  : this._vertexArray instanceof Eo
                  ? Af.members
                  : wf.members,
                this.dynamicDraw,
              )),
              (this._indexBuffer = t.createIndexBuffer(this._indices, this.dynamicDraw))),
            (this._segmentVector = Yh.simpleSegment(
              0,
              0,
              this._vertexArray.length,
              this._indices.length,
            )),
            (this._ready = !0),
            (this._needUpdate = !1);
          const { primitive: i } = e;
          i.computeBounding();
        }
      }
      updateLineSegmentation(e) {
        for (let t = 0; t < this.lineSegmentation.length; t++) {
          const i = this.lineSegmentation[t][0],
            n = this.lineSegmentation[t][1],
            r = n - i;
          let o = e.painter._map.timer.counter * this.speed,
            a = o - this.segGroup;
          o % r > a % r
            ? ((o = Math.floor(o % r) + i), (a = o - this.segGroup))
            : ((o = n), (a = Math.floor(a % r) + i)),
            (this.lineSegmentation[t][2] = a),
            (this.lineSegmentation[t][3] = o);
        }
      }
      serialize() {
        const e = [];
        for (let t = 0; t < this._positions.length; t++)
          e.push(Pt.pack(this._positions[t], new Array(3)));
        return { type: this.type, positions: e, width: this._width, arcType: this._arcType };
      }
      destroy() {
        return (
          super.destroy(),
          (this._positions = void 0),
          (this._width = void 0),
          (this._arcType = void 0),
          (this._granularity = void 0),
          (this._ellipsoid = void 0),
          (this.type = void 0),
          (this._vertexArray = void 0),
          (this._indices = void 0),
          (this.primitiveType = void 0),
          (this._ready = void 0),
          (this._segmentVector = void 0),
          (this._polylineUpdated = void 0),
          Vc(this)
        );
      }
    }
    function Lf(e, t, i) {
      return t * (Wu / (e.tileSize * Math.pow(2, i - e.tileID.overscaledZ)));
    }
    function Rf(e, t) {
      const { expression: i } = t;
      if ('constant' === i.kind)
        return { functionType: 'constant', layoutSize: i.evaluate(new fd(e + 1)) };
      if ('source' === i.kind) return { functionType: 'source' };
      {
        const n = i.zoomStops;
        let r = 0;
        for (; r < n.length && n[r] <= e; ) r++;
        r = Math.max(0, r - 1);
        let o = r;
        for (; o < n.length && n[o] < e + 1; ) o++;
        o = Math.min(n.length - 1, o);
        const a = { min: n[r], max: n[o] };
        return 'composite' === i.kind
          ? { functionType: 'composite', zoomRange: a, propertyValue: t.value }
          : {
              functionType: 'camera',
              layoutSize: i.evaluate(new fd(e + 1)),
              zoomRange: a,
              sizeRange: { min: i.evaluate(new fd(a.min)), max: i.evaluate(new fd(a.max)) },
              propertyValue: t.value,
            };
      }
    }
    function Nf(e, t, i) {
      const n = t;
      return 'source' === e.functionType
        ? i.lowerSize / 10
        : 'composite' === e.functionType
        ? zn(i.lowerSize / 10, i.upperSize / 10, n.uSizeT)
        : n.uSize;
    }
    function Of(e, t, i) {
      if ('constant' === e.functionType) return { uSizeT: 0, uSize: e.layoutSize };
      if ('source' === e.functionType) return { uSizeT: 0, uSize: 0 };
      if ('camera' === e.functionType) {
        const { propertyValue: n, zoomRange: r, sizeRange: o } = e,
          a = se(lo(n, i.specification).interpolationFactor(t, r.min, r.max), 0, 1);
        return { uSizeT: 0, uSize: o.min + a * (o.max - o.min) };
      }
      {
        const { propertyValue: n, zoomRange: r } = e;
        return {
          uSizeT: se(lo(n, i.specification).interpolationFactor(t, r.min, r.max), 0, 1),
          uSize: 0,
        };
      }
    }
    const Df = Gt([
        { name: 'a_POSITION', components: 3, type: 'Float32' },
        { name: 'a_offset', components: 2, type: 'Int16' },
        { name: 'a_data', components: 4, type: 'Uint16' },
      ]),
      Ff = Gt(
        [
          { name: 'a_CARTESIAN', components: 3, type: 'Float32' },
          { name: 'a_projected_pos', components: 3, type: 'Float32' },
        ],
        4,
      );
    Gt([{ name: 'a_fade_opacity', components: 1, type: 'Uint32' }], 4);
    const zf = Gt([{ name: 'a_pick_color', components: 4, type: 'Float32' }]),
      Bf = Gt([{ name: 'a_placed', components: 2, type: 'Uint8' }], 4);
    Gt([
      { type: 'Int16', name: 'anchorPointX' },
      { type: 'Int16', name: 'anchorPointY' },
      { type: 'Int16', name: 'x1' },
      { type: 'Int16', name: 'y1' },
      { type: 'Int16', name: 'x2' },
      { type: 'Int16', name: 'y2' },
      { type: 'Uint32', name: 'featureIndex' },
      { type: 'Uint16', name: 'sourceLayerIndex' },
      { type: 'Uint16', name: 'bucketIndex' },
      { type: 'Int16', name: 'radius' },
      { type: 'Int16', name: 'signedDistanceFromAnchor' },
    ]);
    const Vf = Gt(
        [
          { name: 'a_POSITION', components: 3, type: 'Float32' },
          { name: 'a_anchor_pos', components: 2, type: 'Int16' },
          { name: 'a_extrude', components: 2, type: 'Int16' },
        ],
        4,
      ),
      Uf = Gt(
        [
          { name: 'a_POSITION', components: 3, type: 'Float32' },
          { name: 'a_anchor_pos', components: 2, type: 'Int16' },
          { name: 'a_extrude', components: 2, type: 'Int16' },
        ],
        4,
      );
    function kf(e, t, i) {
      const n = t.layout.get('text-transform').evaluate(i, {});
      return (
        'uppercase' === n
          ? (e = e.toLocaleUpperCase())
          : 'lowercase' === n && (e = e.toLocaleLowerCase()),
        pd.applyArabicShaping && (e = pd.applyArabicShaping(e)),
        e
      );
    }
    function Gf(e, t, i) {
      return e instanceof Vi
        ? (e.sections.forEach((e) => {
            e.text = kf(e.text, t, i);
          }),
          e)
        : kf(e, t, i);
    }
    function Hf(e) {
      const t = {},
        i = {},
        n = [];
      let r = 0;
      function o(t) {
        n.push(e[t]), r++;
      }
      function a(e, t, r) {
        const o = i[e];
        return (
          delete i[e],
          (i[t] = o),
          n[o].geometry[0].pop(),
          (n[o].geometry[0] = n[o].geometry[0].concat(r[0])),
          o
        );
      }
      function s(e, i, r) {
        const o = t[i];
        return (
          delete t[i],
          (t[e] = o),
          n[o].geometry[0].shift(),
          (n[o].geometry[0] = r[0].concat(n[o].geometry[0])),
          o
        );
      }
      function l(e, t, i) {
        const n = i ? t[0][t[0].length - 1] : t[0][0];
        return `${e}:${n.x}:${n.y}`;
      }
      for (let c = 0; c < e.length; c++) {
        const u = e[c],
          h = u.geometry,
          d = u.text instanceof Vi ? u.text.toString() : u.text;
        if (!d) {
          o(c);
          continue;
        }
        const p = l(d, h),
          f = l(d, h, !0);
        if (p in i && f in t && i[p] !== t[f]) {
          const e = s(p, f, h),
            r = a(p, f, n[e].geometry);
          delete t[p], delete i[f], (i[l(d, n[r].geometry, !0)] = r), (n[e].geometry = null);
        } else p in i ? a(p, f, h) : f in t ? s(p, f, h) : (o(c), (t[p] = r - 1), (i[f] = r - 1));
      }
      return n.filter((e) => e.geometry);
    }
    Gt([
      { type: 'Int16', name: 'anchorX' },
      { type: 'Int16', name: 'anchorY' },
      { type: 'Uint16', name: 'glyphStartIndex' },
      { type: 'Uint16', name: 'numGlyphs' },
      { type: 'Uint32', name: 'vertexStartIndex' },
      { type: 'Uint32', name: 'lineStartIndex' },
      { type: 'Uint32', name: 'lineLength' },
      { type: 'Uint16', name: 'segment' },
      { type: 'Uint16', name: 'lowerSize' },
      { type: 'Uint16', name: 'upperSize' },
      { type: 'Float32', name: 'lineOffsetX' },
      { type: 'Float32', name: 'lineOffsetY' },
      { type: 'Uint8', name: 'writingMode' },
      { type: 'Uint8', name: 'hidden' },
    ]),
      Gt([{ type: 'Float32', name: 'offsetX' }]),
      Gt([
        { type: 'Int16', name: 'x' },
        { type: 'Int16', name: 'y' },
        { type: 'Int16', name: 'tileUnitDistanceFromAnchor' },
      ]);
    const Yf = { min: -1 * Math.pow(2, 15), max: Math.pow(2, 15) - 1 };
    function qf(e) {
      const t = Wu / e.extent,
        i = e.loadGeometry();
      for (let e = 0; e < i.length; e++) {
        const n = i[e];
        for (let e = 0; e < n.length; e++) {
          const i = n[e];
          (i.x = Math.round(i.x * t)),
            (i.y = Math.round(i.y * t)),
            (i.x < Yf.min || i.x > Yf.max || i.y < Yf.min || i.y > Yf.max) &&
              ve('Geometry exceeds allowed extent, reduce your vector tile buffer size');
        }
      }
      return i;
    }
    function Xf(e, t, i, n, r) {
      (this.properties = {}),
        (this.extent = i),
        (this.type = 0),
        (this._pbf = e),
        (this._geometry = -1),
        (this._keys = n),
        (this._values = r),
        (this._version = arguments[5]),
        (this._projection = e.projection || 'MERCATOR'),
        (this.projObj = zt(this._projection)),
        e.readFields(jf, this, t);
    }
    function jf(e, t, i) {
      1 == e
        ? (t.id = i.readVarint())
        : 2 == e
        ? (function (e, t) {
            const i = e.readVarint() + e.pos;
            for (; e.pos < i; ) {
              const i = t._keys[e.readVarint()],
                n = t._values[e.readVarint()];
              t.properties[i] = n;
            }
          })(i, t)
        : 3 == e
        ? (t.type = i.readVarint())
        : 4 == e && (t._geometry = i.pos);
    }
    function Wf(e) {
      let t = 0;
      for (var i, n, r = 0, o = e.length, a = o - 1; r < o; a = r++)
        t += ((n = e[a]).x - (i = e[r]).x) * (i.y + n.y);
      return t;
    }
    function $f(e, t) {
      (this.version = 1),
        (this.name = null),
        (this.extent = 4096),
        (this.length = 0),
        (this._pbf = e),
        (this._keys = []),
        (this._values = []),
        (this._features = []),
        e.readFields(Zf, this, t),
        (this.length = this._features.length);
    }
    function Zf(e, t, i) {
      15 === e
        ? (t.version = i.readVarint())
        : 1 === e
        ? (t.name = i.readString())
        : 5 === e
        ? (t.extent = i.readVarint())
        : 2 === e
        ? t._features.push(i.pos)
        : 3 === e
        ? t._keys.push(i.readString())
        : 4 === e &&
          t._values.push(
            (function (e) {
              let t = null,
                i = e.readVarint() + e.pos;
              for (; e.pos < i; ) {
                const i = e.readVarint() >> 3;
                t =
                  1 === i
                    ? e.readString()
                    : 2 === i
                    ? e.readFloat()
                    : 3 === i
                    ? e.readDouble()
                    : 4 === i
                    ? e.readVarint64()
                    : 5 === i
                    ? e.readVarint()
                    : 6 === i
                    ? e.readSVarint()
                    : 7 === i
                    ? e.readBoolean()
                    : null;
              }
              return t;
            })(i),
          );
    }
    function Kf(e, t, i) {
      if (3 === e) {
        const e = new $f(i, i.readVarint() + i.pos);
        e.length && (t[e.name] = e);
      }
    }
    (Xf.types = ['Unknown', 'Point', 'LineString', 'Polygon']),
      (Xf.prototype.loadGeometry = function () {
        const e = this._pbf;
        e.pos = this._geometry;
        let t,
          i = e.readVarint() + e.pos,
          n = 1,
          r = 0,
          o = 0,
          a = 0,
          s = 0,
          l = [];
        for (; e.pos < i; ) {
          if (r <= 0) {
            const t = e.readVarint();
            (n = 7 & t), (r = t >> 3);
          }
          if ((r--, 1 === n || 2 === n))
            (o += e.readSVarint()),
              (a += e.readSVarint()),
              this._version > 100 && (s += e.readSVarint()),
              1 === n && (t && l.push(t), (t = [])),
              t.push(new te(o, a, s));
          else {
            if (7 !== n) throw new Error(`unknown command ${n}`);
            t && t.push(t[0].clone());
          }
        }
        return t && l.push(t), l;
      }),
      (Xf.prototype.bbox = function () {
        const e = this._pbf;
        e.pos = this._geometry;
        let t = e.readVarint() + e.pos,
          i = 1,
          n = 0,
          r = 0,
          o = 0,
          a = 1 / 0,
          s = -1 / 0,
          l = 1 / 0,
          c = -1 / 0;
        for (; e.pos < t; ) {
          if (n <= 0) {
            const t = e.readVarint();
            (i = 7 & t), (n = t >> 3);
          }
          if ((n--, 1 === i || 2 === i))
            (r += e.readSVarint()),
              (o += e.readSVarint()),
              r < a && (a = r),
              r > s && (s = r),
              o < l && (l = o),
              o > c && (c = o);
          else if (7 !== i) throw new Error(`unknown command ${i}`);
        }
        return [a, l, s, c];
      }),
      (Xf.prototype.toGeoJSON = function (e, t, i) {
        let n,
          r,
          o = this.extent * Math.pow(2, i),
          a = this.extent * e,
          s = this.extent * t,
          l = this.loadGeometry(),
          c = Xf.types[this.type];
        const u = this;
        function h(e) {
          for (let t = 0; t < e.length; t++) {
            const i = e[t];
            e[t] = [u.projObj.xLng(i.x + a, o), u.projObj.yLat(i.y + s, o)];
          }
        }
        switch (this.type) {
          case 1:
            var d = [];
            for (n = 0; n < l.length; n++) d[n] = l[n][0];
            (l = d), h(l);
            break;
          case 2:
            for (n = 0; n < l.length; n++) h(l[n]);
            break;
          case 3:
            for (
              l = (function (e) {
                const t = e.length;
                if (t <= 1) return [e];
                let i,
                  n,
                  r = [];
                for (let o = 0; o < t; o++) {
                  const t = Wf(e[o]);
                  0 !== t &&
                    (void 0 === n && (n = t < 0),
                    n === t < 0 ? (i && r.push(i), (i = [e[o]])) : i.push(e[o]));
                }
                return i && r.push(i), r;
              })(l),
                n = 0;
              n < l.length;
              n++
            )
              for (r = 0; r < l[n].length; r++) h(l[n][r]);
        }
        1 === l.length ? (l = l[0]) : (c = `Multi${c}`);
        const p = {
          type: 'Feature',
          geometry: { type: c, coordinates: l },
          properties: this.properties,
        };
        return 'id' in this && (p.id = this.id), p;
      }),
      ($f.prototype.feature = function (e) {
        if (e < 0 || e >= this._features.length) throw new Error('feature index out of bounds');
        this._pbf.pos = this._features[e];
        const t = this._pbf.readVarint() + this._pbf.pos;
        return new Xf(this._pbf, t, this.extent, this._keys, this._values, this.version);
      });
    var Qf = {
      VectorTile: function (e, t, i) {
        (e.projection = i), (this.layers = e.readFields(Kf, {}, t));
      },
      VectorTileFeature: Xf,
      VectorTileLayer: $f,
    };
    const Jf = {
      '!': '︕',
      '#': '＃',
      $: '＄',
      '%': '％',
      '&': '＆',
      '(': '︵',
      ')': '︶',
      '*': '＊',
      '+': '＋',
      ',': '︐',
      '-': '︲',
      '.': '・',
      '/': '／',
      ':': '︓',
      ';': '︔',
      '<': '︿',
      '=': '＝',
      '>': '﹀',
      '?': '︖',
      '@': '＠',
      '[': '﹇',
      '\\': '＼',
      ']': '﹈',
      '^': '＾',
      _: '︳',
      '`': '｀',
      '{': '︷',
      '|': '―',
      '}': '︸',
      '~': '～',
      '¢': '￠',
      '£': '￡',
      '¥': '￥',
      '¦': '￤',
      '¬': '￢',
      '¯': '￣',
      '–': '︲',
      '—': '︱',
      '‘': '﹃',
      '’': '﹄',
      '“': '﹁',
      '”': '﹂',
      '…': '︙',
      '‧': '・',
      '₩': '￦',
      '、': '︑',
      '。': '︒',
      '〈': '︿',
      '〉': '﹀',
      '《': '︽',
      '》': '︾',
      '「': '﹁',
      '」': '﹂',
      '『': '﹃',
      '』': '﹄',
      '【': '︻',
      '】': '︼',
      '〔': '︹',
      '〕': '︺',
      '〖': '︗',
      '〗': '︘',
      '！': '︕',
      '（': '︵',
      '）': '︶',
      '，': '︐',
      '－': '︲',
      '．': '・',
      '：': '︓',
      '；': '︔',
      '＜': '︿',
      '＞': '﹀',
      '？': '︖',
      '［': '﹇',
      '］': '﹈',
      '＿': '︳',
      '｛': '︷',
      '｜': '―',
      '｝': '︸',
      '｟': '︵',
      '｠': '︶',
      '｡': '︒',
      '｢': '﹁',
      '｣': '﹂',
    };
    class em extends te {
      constructor(e, t, i, n) {
        super(e, t), (this.angle = i), void 0 !== n && (this.segment = n);
      }
      clone() {
        return new em(this.x, this.y, this.angle, this.segment);
      }
    }
    fo('Anchor', em);
    const tm = {
        AIRLINE: 'airline',
        CIRCLE: 'circle',
        DYNAMIC_LINE: 'dynamic-line',
        EXTRUSION: 'extrusion',
        FILL: 'fill',
        HEATMAP: 'heatmap',
        HISTOGRAM: 'histogram',
        LINE: 'line',
        SPRITE: 'sprite',
        SYMBOL: 'symbol',
        SYMTRACKING: 'symtracking',
        TRACKING: 'tracking',
        RASTER: 'raster',
        IMAGE: 'image',
        BACKGROUND: 'background',
        MODEL: '3d-model',
        TILES: '3d-tiles',
        DEBUG_TILE: 'debug-tile',
      },
      im = Object.freeze([1, 0, 0, 1]),
      nm = Object.freeze([0, 0, 0, 0]),
      rm = {};
    Object.freeze({ COL0ROW0: 0, COL0ROW1: 1, COL1ROW0: 2, COL1ROW1: 3 });
    class om extends Fe {
      static get IDENTITY() {
        return (rm.IDENTITY = rm.IDENTITY || Object.freeze(new om(im))), rm.IDENTITY;
      }
      static get ZERO() {
        return (rm.ZERO = rm.ZERO || Object.freeze(new om(nm))), rm.ZERO;
      }
      constructor(e) {
        super(-0, -0, -0, -0), 1 === arguments.length && a(e) ? this.copy(e) : this.identity();
      }
      get ELEMENTS() {
        return 4;
      }
      get RANK() {
        return 2;
      }
      copy(e) {
        return (this[0] = e[0]), (this[1] = e[1]), (this[2] = e[2]), (this[3] = e[3]), this.check();
      }
      set(e, t, i, n) {
        return (this[0] = e), (this[1] = t), (this[2] = i), (this[3] = n), this.check();
      }
      setRowMajor(e, t, i, n) {
        return (this[0] = e), (this[1] = i), (this[2] = t), (this[3] = n), this.check();
      }
      determinant() {
        return (e = this)[0] * e[3] - e[2] * e[1];
        var e;
      }
      identity() {
        return this.copy(om.IDENTITY);
      }
      transpose(e = this) {
        return (
          (function (e, t) {
            if (e === t) {
              var i = t[1];
              (e[1] = t[2]), (e[2] = i);
            } else (e[0] = t[0]), (e[1] = t[2]), (e[2] = t[1]), (e[3] = t[3]);
          })(e, this),
          e.check()
        );
      }
      invert(e) {
        return (
          (function (e, t) {
            var i = t[0],
              n = t[1],
              r = t[2],
              o = t[3],
              a = i * o - r * n;
            a && ((e[0] = o * (a = 1 / a)), (e[1] = -n * a), (e[2] = -r * a), (e[3] = i * a));
          })(e, this),
          e.check()
        );
      }
      multiplyLeft(e, t = this) {
        return y(t, e, this), t.check();
      }
      multiplyRight(e, t = this) {
        return y(t, this, e), t.check();
      }
      rotate(e, t = this) {
        return (
          (function (e, t, i) {
            var n = t[0],
              r = t[1],
              o = t[2],
              a = t[3],
              s = Math.sin(i),
              l = Math.cos(i);
            (e[0] = n * l + o * s),
              (e[1] = r * l + a * s),
              (e[2] = n * -s + o * l),
              (e[3] = r * -s + a * l);
          })(t, this, e),
          t.check()
        );
      }
      scale(e, t = this) {
        return a(e) ? x(t, this, e) : x(t, this, [e, e]), t.check();
      }
      transform(e, t = new $e()) {
        return f((t = j(t, e, this)), e.length), t;
      }
      transformVector(e, t) {
        return m('Matrix2.transformVector'), this.transform(e, t);
      }
      transformVector2(e, t) {
        return m('Matrix2.transformVector2'), this.transform(e, t);
      }
      static equalsArray(e, t, i = 0) {
        return e[0] === t[0 + i] && e[1] === t[1 + i] && e[2] === t[2 + i] && e[3] === t[3 + i];
      }
      static pack(e, t, i = 0) {
        return (i = i || 0), (t[i++] = e[0]), (t[i++] = e[1]), (t[i++] = e[2]), (t[i++] = e[3]), t;
      }
    }
    const am = Qf.VectorTileFeature.types,
      sm = [{ name: 'a_fade_opacity', components: 1, type: 'Uint8', offset: 0 }];
    function lm(e, t, i, n, r, o, a) {
      e.emplaceBack(
        t.x,
        t.y,
        t.z,
        Math.round(32 * i),
        Math.round(32 * n),
        r,
        o,
        a ? a[0] : 0,
        a ? a[1] : 0,
      );
    }
    function cm(e, t, i, n, r, o, a, s, l, c, u) {
      const h = new om(),
        d = Math.pow(2, o[2] - l),
        p = new $e(t.x - n.x, t.y - n.y);
      p.multiplyScalar(16 * r), h.rotate(i);
      for (let l = 0; l < 4; l++) {
        const f = new $e(a[l][0], a[l][1]);
        f.transformByMatrix2(h).multiplyScalar(r / 4);
        const m = p
            .clone()
            .add(f)
            .add([16 * n.x, 16 * n.y])
            .multiplyScalar(d / 8192),
          _ = Xs(o[0] + m[0], o[1] + m[1], o[2], s, u);
        e.emplaceBack(_[0] - c[0], _[1] - c[1], _[2] - c[2], t.x - n.x, t.y - n.y, i);
      }
    }
    class um {
      constructor(e) {
        (this.layoutVertexArray = new Zo()),
          (this.indexArray = new ea()),
          (this.programConfigurations = e),
          (this.segments = new Yh()),
          (this.dynamicLayoutVertexArray = new Mo()),
          (this.opacityVertexArray = new Yo()),
          (this.placedSymbolArray = new sa());
      }
      upload(e, t, i, n) {
        i &&
          ((this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Df.members)),
          (this.indexBuffer = e.createIndexBuffer(this.indexArray, t)),
          (this.dynamicLayoutVertexBuffer = e.createVertexBuffer(
            this.dynamicLayoutVertexArray,
            Ff.members,
            !0,
          )),
          (this.opacityVertexBuffer = e.createVertexBuffer(this.opacityVertexArray, sm, !0)),
          (this.opacityVertexBuffer.itemSize = 1)),
          (i || n) && this.programConfigurations.upload(e);
      }
      destroy() {
        this.layoutVertexBuffer &&
          (this.layoutVertexBuffer.destroy(),
          this.indexBuffer.destroy(),
          this.programConfigurations.destroy(),
          this.segments.destroy(),
          this.dynamicLayoutVertexBuffer.destroy(),
          this.opacityVertexBuffer.destroy());
      }
    }
    fo('SphereSymbolBuffers', um);
    class hm {
      constructor(e, t, i) {
        (this.layoutVertexArray = new e()),
          (this.layoutAttributes = t),
          (this.indexArray = new i()),
          (this.segments = new Yh()),
          (this.collisionVertexArray = new Xo());
      }
      upload(e) {
        (this.layoutVertexBuffer = e.createVertexBuffer(
          this.layoutVertexArray,
          this.layoutAttributes,
        )),
          (this.indexBuffer = e.createIndexBuffer(this.indexArray)),
          (this.collisionVertexBuffer = e.createVertexBuffer(
            this.collisionVertexArray,
            Bf.members,
            !0,
          ));
      }
      destroy() {
        this.layoutVertexBuffer &&
          (this.layoutVertexBuffer.destroy(),
          this.indexBuffer.destroy(),
          this.segments.destroy(),
          this.collisionVertexBuffer.destroy());
      }
    }
    fo('SphereCollisionBuffers', hm);
    class dm {
      constructor(e) {
        (this.collisionBoxArray = e.collisionBoxArray),
          (this.zoom = e.zoom),
          (this.overscaling = e.overscaling),
          (this.layers = e.layers),
          (this.layerIds = this.layers.map((e) => e.id)),
          (this.index = e.index),
          (this.pixelRatio = e.pixelRatio),
          (this.sourceLayerIndex = e.sourceLayerIndex),
          (this.hasRTLText = !1),
          (this.glyphQuadsArray = []),
          (this.symbolHeightsArray = []),
          (this.type = tm.SYMBOL);
        const t = this.layers[0]._unevaluatedLayout._values;
        (this.textSizeData = Rf(this.zoom, t['text-size'])),
          (this.iconSizeData = Rf(this.zoom, t['icon-size']));
        const i = this.layers[0].layout,
          n = i.get('symbol-sort-key'),
          r = i.get('symbol-z-order');
        (this.sortFeaturesByKey = 'viewport-y' !== r && void 0 !== n.constantOr(1)),
          (this.sortFeaturesByY =
            ('viewport-y' === r || ('auto' === r && !this.sortFeaturesByKey)) &&
            (i.get('text-allow-overlap') ||
              i.get('icon-allow-overlap') ||
              i.get('text-ignore-placement') ||
              i.get('icon-ignore-placement'))),
          (this.sourceID = e.sourceID),
          (this.projection = e.projection || Ot.MERCATOR),
          (this.pickColor = !0);
      }
      createArrays() {
        (this.text = new um(new cp(Df.members, this.layers, this.zoom, (e) => /^text/.test(e)))),
          (this.icon = new um(new cp(Df.members, this.layers, this.zoom, (e) => /^icon/.test(e)))),
          (this.collisionBox = new hm(Ko, Vf.members, ia)),
          (this.collisionCircle = new hm(Ko, Uf.members, ea)),
          (this.glyphOffsetArray = new ca()),
          (this.lineVertexArray = new ha());
      }
      calculateGlyphDependencies(e, t, i, n) {
        for (let r = 0; r < e.length; r++)
          if (((t[e.charCodeAt(r)] = !0), i && n)) {
            const i = Jf[e.charAt(r)];
            i && (t[i.charCodeAt(0)] = !0);
          }
      }
      populate(e, t, i) {
        this.referencePoint ||
          ((this.x = t.x),
          (this.y = t.y),
          (this.z = t.z),
          (this.zPow = Math.pow(2, this.z)),
          (this.referencePoint = Xs(this.x, this.y, this.z, this.projection)),
          (this.matrix = new Je()),
          (this.matrix[12] = this.referencePoint[0]),
          (this.matrix[13] = this.referencePoint[1]),
          (this.matrix[14] = this.referencePoint[2]));
        const n = this.layers[0],
          r = n.layout,
          o = r.get('text-font'),
          a = r.get('text-field'),
          s = r.get('icon-image'),
          l =
            ('constant' !== a.value.kind || a.value.value.toString().length > 0) &&
            ('constant' !== o.value.kind || o.value.value.length > 0),
          c = 'constant' !== s.value.kind || (s.value.value && s.value.value.length > 0),
          u = r.get('symbol-sort-key');
        if (((this.features = []), !l && !c)) return;
        const h = t.iconDependencies,
          d = t.glyphDependencies,
          p = t.availableImages,
          f = new fd(this.zoom);
        for (const { feature: t, index: a, sourceLayerIndex: s } of e) {
          if (!n._featureFilter(f, t, i)) continue;
          let e, m;
          if (l) {
            const r = n.getValueAndResolveTokens('text-field', t, i, p),
              o = Vi.factory(r);
            o.containsRTLText() && (this.hasRTLText = !0),
              (!this.hasRTLText || 'unavailable' === hd() || (this.hasRTLText && pd.isParsed())) &&
                (e = Gf(o, n, t));
          }
          if (c) {
            const e = n.getValueAndResolveTokens('icon-image', t, i, p);
            m = e instanceof Ui ? e : Ui.fromString(e);
          }
          if (!e && !m) continue;
          const _ = this.sortFeaturesByKey ? u.evaluate(t, {}, i) : void 0,
            g = {
              text: e,
              icon: m,
              index: a,
              sourceLayerIndex: s,
              geometry: qf(t),
              properties: t.properties,
              type: am[t.type],
              sortKey: _,
            };
          if (
            (void 0 !== t.id && (g.id = t.id),
            this.features.push(g),
            m && m instanceof Ui && (h[m.name] = !0),
            e)
          ) {
            const i = o.evaluate(t, {}).join(','),
              n = (d[i] = d[i] || {}),
              a =
                'map' === r.get('text-rotation-alignment') && 'point' !== r.get('symbol-placement');
            if (e instanceof Vi)
              for (const t of e.sections) {
                const n = Li(e.toString()),
                  r = t.fontStack || i,
                  o = (d[r] = d[r] || {});
                this.calculateGlyphDependencies(t.text, o, a, n);
              }
            else {
              const t = Li(e);
              this.calculateGlyphDependencies(e, n, a, t);
            }
          }
        }
        'line' === r.get('symbol-placement') && (this.features = Hf(this.features)),
          this.sortFeaturesByKey && this.features.sort((e, t) => e.sortKey - t.sortKey);
      }
      update(e, t) {
        this.stateDependentLayers.length &&
          (this.text.programConfigurations.updatePaintArrays(e, t, this.layers),
          this.icon.programConfigurations.updatePaintArrays(e, t, this.layers));
      }
      isEmpty() {
        return 0 === this.symbolInstances.length && !this.hasRTLText;
      }
      uploadPending() {
        return (
          !this.uploaded ||
          this.text.programConfigurations.needsUpload ||
          this.icon.programConfigurations.needsUpload
        );
      }
      upload(e) {
        this.uploaded || (this.collisionBox.upload(e), this.collisionCircle.upload(e)),
          this.text.upload(
            e,
            this.sortFeaturesByY,
            !this.uploaded,
            this.text.programConfigurations.needsUpload,
          ),
          this.icon.upload(
            e,
            this.sortFeaturesByY,
            !this.uploaded,
            this.icon.programConfigurations.needsUpload,
          ),
          (this.uploaded = !0);
      }
      destroy() {
        this.text.destroy(),
          this.icon.destroy(),
          this.collisionBox.destroy(),
          this.collisionCircle.destroy();
      }
      addToLineVertexArray(e, t) {
        const i = this.lineVertexArray.length;
        if (void 0 !== e.segment) {
          let i = e.dist(t[e.segment + 1]),
            n = e.dist(t[e.segment]);
          const r = {};
          for (let n = e.segment + 1; n < t.length; n++)
            (r[n] = { x: t[n].x, y: t[n].y, tileUnitDistanceFromAnchor: i }),
              n < t.length - 1 && (i += t[n + 1].dist(t[n]));
          for (let i = e.segment || 0; i >= 0; i--)
            (r[i] = { x: t[i].x, y: t[i].y, tileUnitDistanceFromAnchor: n }),
              i > 0 && (n += t[i - 1].dist(t[i]));
          for (let e = 0; e < t.length; e++) {
            const t = r[e];
            this.lineVertexArray.emplaceBack(t.x, t.y, t.tileUnitDistanceFromAnchor);
          }
        }
        return { lineStartIndex: i, lineLength: this.lineVertexArray.length - i };
      }
      addSymbols(e, t, i, n, r, o, a, s, l, c, u) {
        const h = e.indexArray,
          d = e.layoutVertexArray,
          p = e.dynamicLayoutVertexArray,
          f = e.segments.prepareSegment(4 * t.length, e.layoutVertexArray, e.indexArray),
          m = this.glyphOffsetArray.length,
          _ = f.vertexLength;
        for (const e of t) {
          const t = e.tl,
            n = e.tr,
            r = e.bl,
            a = e.br,
            l = e.tex,
            c = f.vertexLength,
            u = e.glyphOffset[1];
          let m = 0;
          const _ = this.layers[0].layout.get('symbol-height-offset')?.value?.value || 0,
            g = this.layers[0].layout.get('symbol-height-key') || 'symbolHeight';
          o.properties && o.properties[g]
            ? (m = parseFloat(o.properties[g]))
            : o.properties && o.properties.height && (m = parseFloat(o.properties.height)),
            (m += parseFloat(_));
          const y = this.calcTDSpacePoint(s.x, s.y, m);
          lm(d, y, t.x, u + t.y, l.x, l.y, i),
            lm(d, y, n.x, u + n.y, l.x + l.w, l.y, i),
            lm(d, y, r.x, u + r.y, l.x, l.y + l.h, i),
            lm(d, y, a.x, u + a.y, l.x + l.w, l.y + l.h, i);
          const x = [
            [32 * t.x, 32 * (u + t.y)],
            [32 * n.x, 32 * (u + n.y)],
            [32 * r.x, 32 * (u + r.y)],
            [32 * a.x, 32 * (u + a.y)],
          ];
          cm(
            p,
            s,
            0,
            s,
            1,
            [this.x, this.y, this.z],
            x,
            this.projection,
            this.z,
            this.referencePoint,
            m,
          ),
            h.emplaceBack(c, c + 1, c + 2),
            h.emplaceBack(c + 1, c + 2, c + 3),
            (f.vertexLength += 4),
            (f.primitiveLength += 2),
            this.glyphOffsetArray.emplaceBack(e.glyphOffset[0]),
            this.glyphQuadsArray.push(x),
            this.symbolHeightsArray.push(m);
        }
        e.placedSymbolArray.emplaceBack(
          s.x,
          s.y,
          m,
          this.glyphOffsetArray.length - m,
          _,
          l,
          c,
          s.segment,
          i ? i[0] : 0,
          i ? i[1] : 0,
          n[0],
          n[1],
          a,
          !1,
        ),
          e.programConfigurations.populatePaintArrays(
            e.layoutVertexArray.length,
            o,
            o.index,
            {},
            u,
          );
      }
      _addCollisionDebugVertex(e, t, i, n, r) {
        return (
          t.emplaceBack(0, 0),
          e.emplaceBack(i.x, i.y, i.z, n.x, n.y, Math.round(r.x), Math.round(r.y))
        );
      }
      addCollisionDebugVertices(e, t, i, n, r, o, a, s) {
        const l = r.segments.prepareSegment(4, r.layoutVertexArray, r.indexArray),
          c = l.vertexLength,
          u = r.layoutVertexArray,
          h = r.collisionVertexArray,
          d = this.calcTDSpacePoint(o.x, o.y);
        if (
          (this._addCollisionDebugVertex(u, h, d, a.anchor, new te(e, t)),
          this._addCollisionDebugVertex(u, h, d, a.anchor, new te(i, t)),
          this._addCollisionDebugVertex(u, h, d, a.anchor, new te(i, n)),
          this._addCollisionDebugVertex(u, h, d, a.anchor, new te(e, n)),
          (l.vertexLength += 4),
          s)
        ) {
          const e = r.indexArray;
          e.emplaceBack(c, c + 1, c + 2), e.emplaceBack(c, c + 2, c + 3), (l.primitiveLength += 2);
        } else {
          const e = r.indexArray;
          e.emplaceBack(c, c + 1),
            e.emplaceBack(c + 1, c + 2),
            e.emplaceBack(c + 2, c + 3),
            e.emplaceBack(c + 3, c),
            (l.primitiveLength += 4);
        }
      }
      generateCollisionDebugBuffers() {
        for (const e of this.symbolInstances) {
          (e.textCollisionFeature = {
            boxStartIndex: e.textBoxStartIndex,
            boxEndIndex: e.textBoxEndIndex,
          }),
            (e.iconCollisionFeature = {
              boxStartIndex: e.iconBoxStartIndex,
              boxEndIndex: e.iconBoxEndIndex,
            });
          for (let t = 0; t < 2; t++) {
            const i = e[0 === t ? 'textCollisionFeature' : 'iconCollisionFeature'];
            if (i)
              for (let t = i.boxStartIndex; t < i.boxEndIndex; t++) {
                const i = this.collisionBoxArray.get(t),
                  n = i.radius > 0;
                this.addCollisionDebugVertices(
                  i.x1,
                  i.y1,
                  i.x2,
                  i.y2,
                  n ? this.collisionCircle : this.collisionBox,
                  i.anchorPoint,
                  e,
                  n,
                );
              }
          }
        }
      }
      deserializeCollisionBoxes(e, t, i, n, r) {
        const o = {};
        for (let n = t; n < i; n++) {
          const t = e.get(n);
          if (0 === t.radius) {
            (o.textBox = {
              x1: t.x1,
              y1: t.y1,
              x2: t.x2,
              y2: t.y2,
              anchorPointX: t.anchorPointX,
              anchorPointY: t.anchorPointY,
            }),
              (o.textFeatureIndex = t.featureIndex);
            break;
          }
          o.textCircles || ((o.textCircles = []), (o.textFeatureIndex = t.featureIndex)),
            o.textCircles.push(
              t.anchorPointX,
              t.anchorPointY,
              t.radius,
              t.signedDistanceFromAnchor,
              1,
            );
        }
        for (let t = n; t < r; t++) {
          const i = e.get(t);
          if (0 === i.radius) {
            (o.iconBox = {
              x1: i.x1,
              y1: i.y1,
              x2: i.x2,
              y2: i.y2,
              anchorPointX: i.anchorPointX,
              anchorPointY: i.anchorPointY,
            }),
              (o.iconFeatureIndex = i.featureIndex);
            break;
          }
        }
        return o;
      }
      hasTextData() {
        return this.text.segments.get().length > 0;
      }
      hasIconData() {
        return this.icon.segments.get().length > 0;
      }
      hasCollisionBoxData() {
        return this.collisionBox.segments.get().length > 0;
      }
      hasCollisionCircleData() {
        return this.collisionCircle.segments.get().length > 0;
      }
      sortFeatures(e) {
        if (!this.sortFeaturesByY) return;
        if (this.sortedAngle === e) return;
        if (
          ((this.sortedAngle = e),
          this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)
        )
          return;
        const t = [];
        for (let e = 0; e < this.symbolInstances.length; e++) t.push(e);
        const i = Math.sin(e),
          n = Math.cos(e);
        t.sort((e, t) => {
          const r = this.symbolInstances[e],
            o = this.symbolInstances[t];
          return (
            (0 | Math.round(i * r.anchor.x + n * r.anchor.y)) -
              (0 | Math.round(i * o.anchor.x + n * o.anchor.y)) || o.featureIndex - r.featureIndex
          );
        }),
          this.text.indexArray.clear(),
          this.icon.indexArray.clear(),
          (this.featureSortOrder = []);
        for (const e of t) {
          const t = this.symbolInstances[e];
          this.featureSortOrder.push(t.featureIndex);
          for (const e of t.placedTextSymbolIndices) {
            const t = this.text.placedSymbolArray.get(e),
              i = t.vertexStartIndex + 4 * t.numGlyphs;
            for (let e = t.vertexStartIndex; e < i; e += 4)
              this.text.indexArray.emplaceBack(e, e + 1, e + 2),
                this.text.indexArray.emplaceBack(e + 1, e + 2, e + 3);
          }
          const i = this.icon.placedSymbolArray.get(e);
          if (i.numGlyphs) {
            const e = i.vertexStartIndex;
            this.icon.indexArray.emplaceBack(e, e + 1, e + 2),
              this.icon.indexArray.emplaceBack(e + 1, e + 2, e + 3);
          }
        }
        this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray),
          this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
      }
      calcTDSpacePoint(e, t, i) {
        const n = qs(this.x + e / 8192, this.y + t / 8192, this.zPow, this.projection),
          r = Il.cartographicToCartesian3(new Pt(n[0], n[1], i));
        return new te(
          r[0] - this.referencePoint[0],
          r[1] - this.referencePoint[1],
          r[2] - this.referencePoint[2],
        );
      }
    }
    fo('SymbolBucket', dm, {
      omit: ['layers', 'collisionBoxArray', 'compareText'],
      shallow: ['symbolInstances', 'features'],
    }),
      (dm.MAX_GLYPHS = 65535),
      (dm.addDynamicAttributes = cm);
    var pm = {
      $version: 8,
      $root: {
        version: {
          required: !0,
          type: 'enum',
          values: [8],
          'doc-en': 'Style specification version number. Must be 8.',
        },
        name: { type: 'string', 'doc-en': 'A human-readable name for the style.' },
        metadata: {
          type: '*',
          'doc-en':
            "Arbitrary properties useful to track with the stylesheet, but do not influence rendering. Properties should be prefixed to avoid collisions, like 'minemap:'.",
        },
        center: {
          type: 'array',
          value: 'number',
          'doc-en':
            'Default map center in longitude and latitude.  The style center will be used only if the map has not been positioned by other means (e.g. map options or user interaction).',
        },
        zoom: {
          type: 'number',
          'doc-en':
            'Default zoom level.  The style zoom will be used only if the map has not been positioned by other means (e.g. map options or user interaction).',
        },
        bearing: {
          type: 'number',
          default: 0,
          period: 360,
          units: 'degrees',
          'doc-en':
            'Default bearing, in degrees. The bearing is the compass direction that is "up"; for example, a bearing of 90° orients the map so that east is up. This value will be used only if the map has not been positioned by other means (e.g. map options or user interaction).',
        },
        pitch: {
          type: 'number',
          default: 0,
          units: 'degrees',
          'doc-en':
            'Default pitch, in degrees. Zero is perpendicular to the surface, for a look straight down at the map, while a greater value like 60 looks ahead towards the horizon. The style pitch will be used only if the map has not been positioned by other means (e.g. map options or user interaction).',
        },
        light: { type: 'light', 'doc-en': 'The global light source.' },
        sources: { required: !0, type: 'sources', 'doc-en': 'Data source specifications.' },
        sprite: {
          type: 'any',
          'doc-en':
            'A base URL for retrieving the sprite image and metadata. The extensions `.png`, `.json` and scale factor `@2x.png` will be automatically appended. This property is required if any layer uses the `background-pattern`, `fill-pattern`, `line-pattern`, `extrusion-pattern`, or `icon-image` properties. The URL must be absolute, containing the [scheme, authority and path components](https://en.wikipedia.org/wiki/URL#Syntax).',
        },
        IBL: {
          type: 'string',
          'doc-en': 'The base request path of the picture used to request the PBR effect',
        },
        glyphs: {
          type: 'string',
          'doc-en':
            'A URL template for loading signed-distance-field glyph sets in PBF format. The URL must include `{fontstack}` and `{range}` tokens. This property is required if any layer uses the `text-field` layout property. The URL must be absolute, containing the [scheme, authority and path components](https://en.wikipedia.org/wiki/URL#Syntax).',
        },
        transition: {
          type: 'transition',
          'doc-en':
            "A global transition definition to use as a default across properties, to be used for timing transitions between one value and the next when no property-specific transition is set. Collision-based symbol fading is controlled independently of the style's `transition` property.",
        },
        layers: {
          required: !0,
          type: 'array',
          value: 'layer',
          'doc-en': 'Layers will be drawn in the order of this array.',
        },
      },
      sources: {
        '*': {
          type: 'source',
          'doc-en':
            'Specification of a data source. For vector and raster sources, either TileJSON or a URL to a TileJSON must be provided. For image and video sources, a URL must be provided. For GeoJSON sources, a URL or inline GeoJSON must be provided.',
        },
      },
      source: [
        'source_vector',
        'source_raster',
        'source_geojson',
        'source_video',
        'source_image',
        'source_sphere_image',
        'source_3d_model',
        'source_3d_tiles',
        'source_panorama',
      ],
      source_vector: {
        type: {
          required: !0,
          type: 'enum',
          values: { vector: { 'doc-en': 'A vector tile source.' } },
          'doc-en': 'The type of the source.',
        },
        url: {
          type: 'string',
          'doc-en':
            'A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `minemap://<Tileset ID>`.',
        },
        tiles: {
          type: 'array',
          value: 'string',
          'doc-en': 'An array of one or more tile source URLs, as in the TileJSON spec.',
        },
        bounds: {
          type: 'array',
          value: 'number',
          length: 4,
          default: [-180, -85.0511, 180, 85.0511],
          'doc-en':
            "An array containing the longitude and latitude of the southwest and northeast corners of the source's bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by minemap GL.",
        },
        scheme: {
          type: 'enum',
          values: {
            xyz: { 'doc-en': 'Slippy map tilenames scheme.' },
            tms: { 'doc-en': 'OSGeo spec scheme.' },
          },
          default: 'xyz',
          'doc-en':
            'Influences the y direction of the tile coordinates. The global-mercator (aka Spherical Mercator) profile is assumed.',
        },
        minzoom: {
          type: 'number',
          default: 0,
          'doc-en': 'Minimum zoom level for which tiles are available, as in the TileJSON spec.',
        },
        maxzoom: {
          type: 'number',
          default: 22,
          'doc-en':
            'Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels.',
        },
        attribution: {
          type: 'string',
          'doc-en': 'Contains an attribution to be displayed when the map is shown to a user.',
        },
        promoteId: {
          type: 'promoteId',
          'doc-en':
            'A property to use as a feature id (for feature state). Either a property name, or an object of the form `{<sourceLayer>: <propertyName>}`. If specified as a string for a vector tile source, the same property is used across all its source layers.',
        },
        '*': { type: '*', 'doc-en': 'Other keys to configure the data source.' },
      },
      source_raster: {
        type: {
          required: !0,
          type: 'enum',
          values: { raster: { 'doc-en': 'A raster tile source.' } },
          'doc-en': 'The type of the source.',
        },
        url: {
          type: 'string',
          'doc-en':
            'A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `minemap://<Tileset ID>`.',
        },
        tiles: {
          type: 'array',
          value: 'string',
          'doc-en': 'An array of one or more tile source URLs, as in the TileJSON spec.',
        },
        terrainTiles: { type: 'array', value: 'string' },
        bounds: {
          type: 'array',
          value: 'number',
          length: 4,
          default: [-180, -85.0511, 180, 85.0511],
          'doc-en':
            "An array containing the longitude and latitude of the southwest and northeast corners of the source's bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by minemap GL.",
        },
        minzoom: {
          type: 'number',
          default: 0,
          'doc-en': 'Minimum zoom level for which tiles are available, as in the TileJSON spec.',
        },
        maxzoom: {
          type: 'number',
          default: 22,
          'doc-en':
            'Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels.',
        },
        tileSize: {
          type: 'number',
          default: 512,
          units: 'pixels',
          'doc-en':
            'The minimum visual size to display tiles for this layer. Only configurable for raster layers.',
        },
        scheme: {
          type: 'enum',
          values: {
            xyz: { 'doc-en': 'Slippy map tilenames scheme.' },
            tms: { 'doc-en': 'OSGeo spec scheme.' },
          },
          default: 'xyz',
          'doc-en':
            'Influences the y direction of the tile coordinates. The global-mercator (aka Spherical Mercator) profile is assumed.',
        },
        attribution: {
          type: 'string',
          'doc-en': 'Contains an attribution to be displayed when the map is shown to a user.',
        },
        '*': { type: '*', 'doc-en': 'Other keys to configure the data source.', expose: !1 },
      },
      source_geojson: {
        type: {
          required: !0,
          type: 'enum',
          values: { geojson: { 'doc-en': 'A GeoJSON data source.' } },
          'doc-en': 'The data type of the GeoJSON source.',
        },
        data: { type: '*', 'doc-en': 'A URL to a GeoJSON file, or inline GeoJSON.' },
        minzoom: {
          type: 'number',
          default: 1,
          'doc-en':
            'Creates the minimum zoom level for the vector tile (a lower scale level represents a smaller scale level).',
        },
        maxzoom: {
          type: 'number',
          default: 22,
          'doc-en':
            'Maximum zoom level at which to create vector tiles (higher means greater detail at high zoom levels).',
        },
        attribution: {
          type: 'string',
          'doc-en': 'Contains an attribution to be displayed when the map is shown to a user.',
        },
        buffer: {
          type: 'number',
          default: 128,
          maximum: 512,
          minimum: 0,
          'doc-en':
            'Size of the tile buffer on each side. A value of 0 produces no buffer. A value of 512 produces a buffer as wide as the tile itself. Larger values produce fewer rendering artifacts near tile edges and slower performance.',
        },
        tolerance: {
          type: 'number',
          default: 0.375,
          'doc-en':
            'Douglas-Peucker simplification tolerance (higher means simpler geometries and faster performance).',
        },
        cluster: {
          type: 'boolean',
          default: !1,
          'doc-en':
            'If the data is a collection of point features, setting this to true clusters the points by radius into groups. Cluster groups become new `Point` features in the source with additional properties:\n * `cluster` Is `true` if the point is a cluster \n * `cluster_id` A unqiue id for the cluster to be used in conjunction with the [cluster inspection methods](https://www.minemap.com/minemap-gl-js/api/#geojsonsource#getclusterexpansionzoom)\n * `point_count` Number of original points grouped into this cluster\n * `point_count_abbreviated` An abbreviated point count',
        },
        clusterRadius: {
          type: 'number',
          default: 50,
          minimum: 0,
          'doc-en':
            'Radius of each cluster if clustering is enabled. A value of 512 indicates a radius equal to the width of a tile.',
        },
        clusterMaxZoom: {
          type: 'number',
          'doc-en':
            'Max zoom on which to cluster points if clustering is enabled. Defaults to one zoom less than maxzoom (so that last zoom features are not clustered).',
        },
        clusterMinPoints: { type: 'number' },
        clusterProperties: { type: '*' },
        lineMetrics: {
          type: 'boolean',
          default: !1,
          'doc-en':
            'Whether to calculate line distance metrics. This is required for line layers that specify `line-gradient` values.',
        },
        promoteId: {
          type: 'promoteId',
          'doc-en':
            'A property to use as a feature id (for feature state). Either a property name, or an object of the form `{<sourceLayer>: <propertyName>}`. If specified as a string for a vector tile source, the same property is used across all its source layers.',
        },
      },
      source_sphere_image: {
        type: { required: !0, type: 'enum', values: { 'sphere-image': {} } },
        url: { required: !0, type: 'string' },
        renderInner: { required: !0, type: 'boolean' },
        radius: { required: !0, type: 'number' },
        extractRadius: { required: !1, type: 'number' },
        gridSamples: { required: !1, type: 'number' },
        debug: { type: 'boolean' },
        renderAtmosphere: { type: 'boolean' },
        dayTextureUrl: { type: 'string' },
        nightTextureUrl: { type: 'string' },
      },
      source_3d_model: {
        type: { required: !0, type: 'enum', values: { '3d-model': {} } },
        data: { type: '*' },
        maxzoom: { type: 'number', default: 22 },
        attribution: { type: 'string' },
        bounds: { type: 'array', length: 4, value: { type: 'array', length: 2, value: 'number' } },
        location: { required: !0, type: 'array', value: { type: 'number' } },
        scale: { required: !0, type: 'array', value: { type: 'number' } },
        pickable: { type: 'boolean' },
        filter: { type: 'array', value: '*' },
        aabbFilter: { type: 'array', value: '*' },
        rotation: { required: !0, type: 'array', value: { type: 'number' } },
        'up-axis': { type: 'enum', values: { 'Y-UP': {}, 'Z-UP': {} } },
        translation: { required: !0, type: 'array', value: { type: 'number' } },
        modelFolder: { required: !0, type: 'string' },
        debug: { type: 'boolean' },
        configuration: { type: 'object' },
        log: { type: 'boolean', default: !1 },
        useMipmap: { type: 'boolean', default: !0 },
      },
      source_video: {
        type: {
          required: !0,
          type: 'enum',
          values: { video: { 'doc-en': 'A video data source.' } },
          'doc-en': 'The data type of the video source.',
        },
        urls: {
          required: !0,
          type: 'array',
          value: 'string',
          'doc-en': 'URLs to video content in order of preferred format.',
        },
        coordinates: {
          required: !0,
          'doc-en': 'Corners of video specified in longitude, latitude pairs.',
          type: 'array',
          length: 4,
          value: {
            type: 'array',
            length: 2,
            value: 'number',
            'doc-en': 'A single longitude, latitude pair.',
          },
        },
        grid: { type: 'number', default: 1 },
      },
      source_image: {
        type: {
          required: !0,
          type: 'enum',
          values: { image: { 'doc-en': 'An image data source.' } },
          'doc-en': 'The data type of the image source.',
        },
        url: { required: !0, type: 'string', 'doc-en': 'URL that points to an image.' },
        coordinates: {
          required: !0,
          'doc-en': 'Corners of image specified in longitude, latitude pairs.',
          type: 'array',
          length: 4,
          value: { type: 'array', length: 2, value: 'number', 'doc-en': '单个经度，纬度组。.' },
        },
        grid: { type: 'number', default: 1 },
        wms: { required: !1, type: 'boolean', 'doc-en': 'Whether use WMS service.' },
      },
      source_panorama: {
        type: { required: !0, type: 'enum', values: { image: {} } },
        url: { required: !0, type: 'string' },
      },
      source_3d_tiles: {
        type: { required: !0, type: 'enum', values: { '3d-tiles': {} } },
        url: { type: 'string', value: { type: 'any' } },
        urls: { type: 'array', value: { type: 'object' } },
        maxzoom: { type: 'number', default: 22 },
        minzoom: { type: 'number', default: 14 },
        maximumMemoryUsage: { type: 'number' },
        maximumScreenSpaceError: { type: 'number' },
        throttleRequests: { type: 'boolean' },
        attribution: { type: 'string' },
        bounds: { type: 'array', length: 4, value: { type: 'array', length: 2, value: 'number' } },
        collectResourceTiming: { required: !0, type: 'boolean' },
        'up-axis': { type: 'enum', values: { 'Y-UP': {}, 'Z-UP': {} } },
        pickable: { type: 'boolean' },
        debug: { type: 'boolean' },
        forceLocation: { type: 'array', value: { type: 'number' } },
        translation: { type: 'array', value: { type: 'number' } },
        log: { type: 'boolean', default: !1 },
        useMipmap: { type: 'boolean', default: !1 },
        viewFrustum: {
          type: 'object',
          'doc-en':
            'Used to set the distance between the far and near clipping planes of the visual cone of 3dtiles',
          default: null,
        },
      },
      layer: {
        id: { type: 'string', 'doc-en': 'Unique layer name.', required: !0 },
        type: {
          type: 'enum',
          values: {
            raster: {},
            fill: {},
            line: {},
            airline: {},
            symbol: {},
            circle: {},
            heatmap: {},
            extrusion: {},
            histogram: {},
            dynamicLine: {},
            tracking: {},
            sprite: {},
            '3d-model': {},
            '3d-tiles': {},
            panorama: {},
            symtracking: {},
            background: { 'doc-en': 'The background color or pattern of the map.' },
          },
          'doc-en': 'Rendering type of this layer.',
          required: !0,
        },
        metadata: {
          type: '*',
          'doc-en':
            "Arbitrary properties useful to track with the layer, but do not influence rendering. Properties should be prefixed to avoid collisions, like 'minemap:'.",
        },
        source: {
          type: 'string',
          'doc-en':
            'Name of a source description to be used for this layer. Required for all layer types except `background`.',
        },
        'source-layer': {
          type: 'string',
          'doc-en':
            'Layer to use from a vector tile source. Required for vector tile sources; prohibited for all other source types, including GeoJSON sources.',
        },
        minzoom: {
          type: 'number',
          minimum: 0,
          maximum: 24,
          'doc-en':
            'The minimum zoom level for the layer. At zoom levels less than the minzoom, the layer will be hidden.',
        },
        maxzoom: {
          type: 'number',
          minimum: 0,
          maximum: 24,
          'doc-en':
            'The maximum zoom level for the layer. At zoom levels equal to or greater than the maxzoom, the layer will be hidden.',
        },
        filter: {
          type: 'filter',
          'doc-en':
            'A expression specifying conditions on source features. Only features that match the filter are displayed. Zoom expressions in filters are only evaluated at integer zoom levels. The `feature-state` expression is not supported in filter expressions.',
        },
        layout: { type: 'layout', 'doc-en': 'Layout properties for the layer.' },
        paint: { type: 'paint', 'doc-en': 'Default paint properties for this layer.' },
        'depth-test': { type: 'boolean', from: ['raster', 'circle', 'tracking'] },
        location: { type: 'array', value: { type: 'number' }, from: ['3d-model'] },
        rotation: { type: 'array', value: { type: 'number' }, from: ['3d-model'] },
        translation: { type: 'array', value: { type: 'number' }, from: ['3d-model'] },
        scale: { type: 'array', value: { type: 'number' }, from: ['3d-model'] },
        isSpecialLight: { type: 'boolean', from: ['3d-model'] },
        highLightColorsIndex: { type: 'number', from: ['3d-model'] },
        highLightColors: { type: 'array', value: { type: 'string' }, from: ['3d-model'] },
        'viewshed-render': { type: 'boolean', from: ['3d-model', '3d-tiles'] },
        cvtBGR2RGB: { type: 'boolean', from: ['3d-tiles'] },
        'radiation-regions': {
          type: 'array',
          value: { type: 'any' },
          required: !1,
          from: ['extrusion'],
        },
        'shadow-center': { type: 'array', value: { type: 'number' }, from: ['3d-model'] },
        specialLights: { type: 'array', value: { type: '*' }, from: ['3d-model'] },
        vectorRenderInSpace: { type: 'boolean', from: ['line', 'fill', 'symbol', 'symtracking'] },
        classificationType: { type: 'number', from: ['line', 'fill', '3d-model'] },
        lightingModel: { type: 'number', from: ['NONE', 'PHONG', 'PBR'] },
        phongLightConfig: { type: 'phongLightConfig', from: ['3d-model', '3d-tiles', 'extrusion'] },
        lightExposure: { type: 'number', from: ['3d-model'] },
      },
      phongLightConfig: {
        Ambient: { type: 'number', default: 0.6, minimum: 0, maximum: 1 },
        Diffuse: { type: 'number', minimum: 0, maximum: 1, default: 0.5 },
        SpecularColor: { type: 'number', minimum: 0, maximum: 1, default: 0.3 },
        Shininess: { type: 'number', default: 2, minimum: 0, maximum: 1e3 },
      },
      layout: [
        'layout_background',
        'layout_fill',
        'layout_line',
        'layout_airline',
        'layout_symbol',
        'layout_circle',
        'layout_heatmap',
        'layout_raster',
        'layout_extrusion',
        'layout_histogram',
        'layout_dynamicLine',
        'layout_tracking',
        'layout_sprite',
        'layout_3d-model',
        'layout_3d-tiles',
        'layout_panorama',
        'layout_symtracking',
      ],
      layout_background: {
        visibility: {
          type: 'enum',
          values: {
            visible: { 'doc-en': 'The layer is shown.' },
            none: { 'doc-en': 'The layer is not shown.' },
          },
          default: 'visible',
          'doc-en': 'Whether this layer is displayed.',
          'property-type': 'constant',
        },
      },
      layout_sprite: {
        'sprite-cap': {
          type: 'enum',
          values: {
            butt: {
              'doc-en':
                'A cap with a squared-off end which is drawn to the exact endpoint of the line.',
            },
            round: {
              'doc-en':
                "A cap with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line.",
            },
            square: {
              'doc-en':
                "A cap with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width.",
            },
          },
          default: 'butt',
          'doc-en': 'The display of line endings.',
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'sprite-join': {
          type: 'enum',
          values: {
            bevel: {
              'doc-en':
                "A join with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width.",
            },
            round: {
              'doc-en':
                "A join with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line.",
            },
            miter: {
              'doc-en':
                'A join with a sharp, angled corner which is drawn with the outer sides beyond the endpoint of the path until they meet.',
            },
          },
          default: 'miter',
          'doc-en': 'The display of lines when joining.',
          expression: { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'sprite-miter-limit': {
          type: 'number',
          default: 2,
          'doc-en': 'Used to automatically convert miter joins to bevel joins for sharp angles.',
          requires: [{ 'sprite-join': 'miter' }],
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'sprite-round-limit': {
          type: 'number',
          default: 1.05,
          'doc-en': 'Used to automatically convert round joins to miter joins for shallow angles.',
          requires: [{ 'sprite-join': 'round' }],
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'sprite-sort-key': {
          type: 'number',
          'doc-en':
            'Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.',
          expression: { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        visibility: {
          type: 'enum',
          values: {
            visible: { 'doc-en': 'The layer is shown.' },
            none: { 'doc-en': 'The layer is not shown.' },
          },
          default: 'visible',
          'doc-en': 'Whether this layer is displayed.',
          'property-type': 'constant',
        },
      },
      layout_raster: {
        visibility: {
          type: 'enum',
          values: {
            visible: { 'doc-en': 'The layer is shown.' },
            none: { 'doc-en': 'The layer is not shown.' },
          },
          default: 'visible',
          'doc-en': 'Whether this layer is displayed.',
          'property-type': 'constant',
        },
      },
      layout_fill: {
        'fill-sort-key': {
          type: 'number',
          'doc-en':
            'Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.',
          expression: { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        visibility: {
          type: 'enum',
          values: {
            visible: { 'doc-en': 'The layer is shown.' },
            none: { 'doc-en': 'The layer is not shown.' },
          },
          default: 'visible',
          'doc-en': 'Whether this layer is displayed.',
          'property-type': 'constant',
        },
        dynamic: {
          type: 'enum',
          values: { water: {}, none: {} },
          default: 'none',
          expression: { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'constant',
        },
      },
      layout_airline: {
        'airline-cap': {
          type: 'enum',
          values: {
            butt: {
              'doc-en':
                'A cap with a squared-off end which is drawn to the exact endpoint of the line.',
            },
            round: {
              'doc-en':
                "A cap with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line.",
            },
            square: {
              'doc-en':
                "A cap with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width.",
            },
          },
          default: 'butt',
          'doc-en': 'The display of line endings.',
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'airline-join': {
          type: 'enum',
          values: {
            bevel: {
              'doc-en':
                "A join with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width.",
            },
            round: {
              'doc-en':
                "A join with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line.",
            },
            miter: {
              'doc-en':
                'A join with a sharp, angled corner which is drawn with the outer sides beyond the endpoint of the path until they meet.',
            },
          },
          default: 'miter',
          'doc-en': 'The display of lines when joining.',
          expression: { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'airline-miter-limit': {
          type: 'number',
          default: 2,
          'doc-en': 'Used to automatically convert miter joins to bevel joins for sharp angles.',
          requires: [{ 'tracking-join': 'miter' }],
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'airline-round-limit': {
          type: 'number',
          default: 1.05,
          'doc-en': 'Used to automatically convert round joins to miter joins for shallow angles.',
          requires: [{ 'tracking-join': 'round' }],
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'airline-sort-key': {
          type: 'number',
          'doc-en':
            'Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.',
          expression: { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        visibility: {
          type: 'enum',
          values: {
            visible: { 'doc-en': 'The layer is shown.' },
            none: { 'doc-en': 'The layer is not shown.' },
          },
          default: 'visible',
          'doc-en': 'Whether this layer is displayed.',
          'property-type': 'constant',
        },
        'airline-display-mode': {
          type: 'enum',
          function: 'piecewise-constant',
          values: ['loop', 'reverse', 'loop-reserve', 'reverse-reserve'],
          default: 'loop',
          'property-type': 'data-constant',
        },
      },
      layout_line: {
        'line-cap': {
          type: 'enum',
          values: {
            butt: {
              'doc-en':
                'A cap with a squared-off end which is drawn to the exact endpoint of the line.',
            },
            'round-butt': {
              'doc-en':
                'A cap with a squared-off end which is drawn to the exact endpoint of the line.',
            },
            round: {
              'doc-en':
                "A cap with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line.",
            },
            square: {
              'doc-en':
                "A cap with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width.",
            },
          },
          default: 'butt',
          'doc-en': 'The display of line endings.',
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'line-join': {
          type: 'enum',
          values: {
            bevel: {
              'doc-en':
                "A join with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width.",
            },
            round: {
              'doc-en':
                "A join with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line.",
            },
            miter: {
              'doc-en':
                'A join with a sharp, angled corner which is drawn with the outer sides beyond the endpoint of the path until they meet.',
            },
          },
          default: 'miter',
          'doc-en': 'The display of lines when joining.',
          expression: { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'line-miter-limit': {
          type: 'number',
          default: 2,
          'doc-en': 'Used to automatically convert miter joins to bevel joins for sharp angles.',
          requires: [{ 'line-join': 'miter' }],
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'line-round-limit': {
          type: 'number',
          default: 1.05,
          'doc-en': 'Used to automatically convert round joins to miter joins for shallow angles.',
          requires: [{ 'line-join': 'round' }],
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'line-sort-key': {
          type: 'number',
          'doc-en':
            'Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.',
          expression: { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'line-height-offset': {
          type: 'number',
          expression: { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        visibility: {
          type: 'enum',
          values: {
            visible: { 'doc-en': 'The layer is shown.' },
            none: { 'doc-en': 'The layer is not shown.' },
          },
          default: 'visible',
          'doc-en': 'Whether this layer is displayed.',
          'property-type': 'constant',
        },
        'border-visibility': {
          type: 'enum',
          default: 'none',
          values: {
            visible: { 'doc-en': 'The layer is shown.' },
            none: { 'doc-en': 'The layer is not shown.' },
          },
          'doc-en': 'Whether draw border.',
          'property-type': 'constant',
        },
      },
      layout_symbol: {
        'symbol-placement': {
          type: 'enum',
          values: {
            point: { 'doc-en': 'The label is placed at the point where the geometry is located.' },
            line: {
              'doc-en':
                'The label is placed along the line of the geometry. Can only be used on `LineString` and `Polygon` geometries.',
            },
            'line-center': {
              'doc-en':
                'The label is placed at the center of the line of the geometry. Can only be used on `LineString` and `Polygon` geometries. Note that a single feature in a vector tile may contain multiple line geometries.',
            },
          },
          default: 'point',
          'doc-en': 'Label placement relative to its geometry.',
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'symbol-spacing': {
          type: 'number',
          default: 250,
          minimum: 1,
          units: 'pixels',
          'doc-en': 'Distance between two symbol anchors.',
          requires: [{ 'symbol-placement': 'line' }],
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'symbol-avoid-edges': {
          type: 'boolean',
          default: !1,
          'doc-en':
            "If true, the symbols will not cross tile edges to avoid mutual collisions. Recommended in layers that don't have enough padding in the vector tile to prevent collisions, or if it is a point symbol layer placed after a line symbol layer.",
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'symbol-sort-key': {
          type: 'number',
          'doc-en':
            'Sorts features in ascending order based on this value. Features with lower sort keys are drawn and placed first.  When `icon-allow-overlap` or `text-allow-overlap` is `false`, features with a lower sort key will have priority during placement. When `icon-allow-overlap` or `text-allow-overlap` is set to `true`, features with a higher sort key will overlap over features with a lower sort key.',
          expression: { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'symbol-z-order': {
          type: 'enum',
          values: {
            auto: {
              'doc-en':
                'Sorts symbols by `symbol-sort-key` if set. Otherwise, sorts symbols by their y-position relative to the viewport if `icon-allow-overlap` or `text-allow-overlap` is set to `true` or `icon-ignore-placement` or `text-ignore-placement` is `false`.',
            },
            'viewport-y': {
              'doc-en':
                'Sorts symbols by their y-position relative to the viewport if `icon-allow-overlap` or `text-allow-overlap` is set to `true` or `icon-ignore-placement` or `text-ignore-placement` is `false`.',
            },
            source: {
              'doc-en':
                'Sorts symbols by `symbol-sort-key` if set. Otherwise, no sorting is applied; symbols are rendered in the same order as the source data.',
            },
          },
          default: 'auto',
          'doc-en':
            'Determines whether overlapping symbols in the same layer are rendered in the order that they appear in the data source or by their y-position relative to the viewport. To control the order and prioritization of symbols otherwise, use `symbol-sort-key`.',
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'symbol-height-key': {
          type: 'string',
          default: 'symbolHeight',
          'property-type': 'constant',
        },
        'symbol-height-offset': {
          type: 'number',
          expression: { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'symbol-pick-color': {
          type: 'boolean',
          default: !1,
          'doc-en':
            "If you want to query a symbol with height properties, set it true, otherwise the result won't be accurate. Set it to false when all symbols are rendered by zero height.",
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'icon-allow-overlap': {
          type: 'boolean',
          default: !1,
          'doc-en':
            'If true, the icon will be visible even if it collides with other previously drawn symbols.',
          requires: ['icon-image'],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'icon-ignore-placement': {
          type: 'boolean',
          default: !1,
          'doc-en': 'If true, other symbols can be visible even if they collide with the icon.',
          requires: ['icon-image'],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'icon-optional': {
          type: 'boolean',
          default: !1,
          'doc-en':
            'If true, text will display without their corresponding icons when the icon collides with other symbols and the text does not.',
          requires: ['icon-image', 'text-field'],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'icon-rotation-alignment': {
          type: 'enum',
          values: {
            map: {
              'doc-en':
                'When `symbol-placement` is set to `point`, aligns icons east-west. When `symbol-placement` is set to `line` or `line-center`, aligns icon x-axes with the line.',
            },
            viewport: {
              'doc-en':
                'Produces icons whose x-axes are aligned with the x-axis of the viewport, regardless of the value of `symbol-placement`.',
            },
            auto: {
              'doc-en':
                'When `symbol-placement` is set to `point`, this is equivalent to `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is equivalent to `map`.',
            },
          },
          default: 'auto',
          'doc-en':
            'In combination with `symbol-placement`, determines the rotation behavior of icons.',
          requires: ['icon-image'],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'icon-size': {
          type: 'number',
          default: 1,
          minimum: 0,
          units: 'factor of the original icon size',
          'doc-en':
            'Scales the original size of the icon by the provided factor. The new pixel size of the image will be the original pixel size multiplied by `icon-size`. 1 is the original size; 3 triples the size of the image.',
          requires: ['icon-image'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'icon-text-fit': {
          type: 'enum',
          values: {
            none: { 'doc-en': 'The icon is displayed at its intrinsic aspect ratio.' },
            width: {
              'doc-en': 'The icon is scaled in the x-dimension to fit the width of the text.',
            },
            height: {
              'doc-en': 'The icon is scaled in the y-dimension to fit the height of the text.',
            },
            both: { 'doc-en': 'The icon is scaled in both x- and y-dimensions.' },
          },
          default: 'none',
          'doc-en': 'Scales the icon to fit around the associated text.',
          requires: ['icon-image', 'text-field'],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'icon-text-fit-padding': {
          type: 'array',
          value: 'number',
          length: 4,
          default: [0, 0, 0, 0],
          units: 'pixels',
          'doc-en':
            'Size of the additional area added to dimensions determined by `icon-text-fit`, in clockwise order: top, right, bottom, left.',
          requires: ['icon-image', 'text-field', { 'icon-text-fit': ['both', 'width', 'height'] }],
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'icon-image': {
          type: 'resolvedImage',
          'doc-en': 'Name of image in sprite to use for drawing an image background.',
          tokens: !0,
          expression: { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'icon-rotate': {
          type: 'number',
          default: 0,
          period: 360,
          units: 'degrees',
          'doc-en': 'Rotates the icon clockwise.',
          requires: ['icon-image'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'icon-padding': {
          type: 'number',
          default: 2,
          minimum: 0,
          units: 'pixels',
          'doc-en':
            'Size of the additional area around the icon bounding box used for detecting symbol collisions.',
          requires: ['icon-image'],
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'icon-keep-upright': {
          type: 'boolean',
          default: !1,
          'doc-en':
            'If true, the icon may be flipped to prevent it from being rendered upside-down.',
          requires: [
            'icon-image',
            { 'icon-rotation-alignment': 'map' },
            { 'symbol-placement': ['line', 'line-center'] },
          ],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'icon-offset': {
          type: 'array',
          value: 'number',
          length: 2,
          default: [0, 0],
          'doc-en':
            'Offset distance of icon from its anchor. Positive values indicate right and down, while negative values indicate left and up. Each component is multiplied by the value of `icon-size` to obtain the final offset in pixels. When combined with `icon-rotate` the offset will be as if the rotated direction was up.',
          requires: ['icon-image'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'icon-anchor': {
          type: 'enum',
          values: {
            center: { 'doc-en': 'The center of the icon is placed closest to the anchor.' },
            left: { 'doc-en': 'The left side of the icon is placed closest to the anchor.' },
            right: { 'doc-en': 'The right side of the icon is placed closest to the anchor.' },
            top: { 'doc-en': 'The top of the icon is placed closest to the anchor.' },
            bottom: { 'doc-en': 'The bottom of the icon is placed closest to the anchor.' },
            'top-left': {
              'doc-en': 'The top left corner of the icon is placed closest to the anchor.',
            },
            'top-right': {
              'doc-en': 'The top right corner of the icon is placed closest to the anchor.',
            },
            'bottom-left': {
              'doc-en': 'The bottom left corner of the icon is placed closest to the anchor.',
            },
            'bottom-right': {
              'doc-en': 'The bottom right corner of the icon is placed closest to the anchor.',
            },
          },
          default: 'center',
          'doc-en': 'Part of the icon placed closest to the anchor.',
          requires: ['icon-image'],
          expression: { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'icon-pitch-alignment': {
          type: 'enum',
          values: {
            map: { 'doc-en': 'The icon is aligned to the plane of the map.' },
            viewport: { 'doc-en': 'The icon is aligned to the plane of the viewport.' },
            auto: { 'doc-en': 'Automatically matches the value of `icon-rotation-alignment`.' },
          },
          default: 'auto',
          'doc-en': 'Orientation of icon when map is pitched.',
          requires: ['icon-image'],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'text-pitch-alignment': {
          type: 'enum',
          values: {
            map: { 'doc-en': 'The text is aligned to the plane of the map.' },
            viewport: { 'doc-en': 'The text is aligned to the plane of the viewport.' },
            auto: { 'doc-en': 'Automatically matches the value of `text-rotation-alignment`.' },
          },
          default: 'auto',
          'doc-en': 'Orientation of text when map is pitched.',
          requires: ['text-field'],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'text-rotation-alignment': {
          type: 'enum',
          values: {
            map: {
              'doc-en':
                'When `symbol-placement` is set to `point`, aligns text east-west. When `symbol-placement` is set to `line` or `line-center`, aligns text x-axes with the line.',
            },
            viewport: {
              'doc-en':
                'Produces glyphs whose x-axes are aligned with the x-axis of the viewport, regardless of the value of `symbol-placement`.',
            },
            auto: {
              'doc-en':
                'When `symbol-placement` is set to `point`, this is equivalent to `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is equivalent to `map`.',
            },
          },
          default: 'auto',
          'doc-en':
            'In combination with `symbol-placement`, determines the rotation behavior of the individual glyphs forming the text.',
          requires: ['text-field'],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'text-field': {
          type: 'formatted',
          default: '',
          tokens: !0,
          'doc-en':
            'Value to use for a text label. If a plain `string` is provided, it will be treated as a `formatted` with default/inherited formatting options.',
          expression: { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'text-font': {
          type: 'array',
          value: 'string',
          default: ['Open Sans Regular', 'Arial Unicode MS Regular'],
          'doc-en': 'Font stack to use for displaying text.',
          requires: ['text-field'],
          expression: { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'text-size': {
          type: 'number',
          default: 16,
          minimum: 0,
          units: 'pixels',
          requires: ['text-field'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'text-max-width': {
          type: 'number',
          default: 10,
          minimum: 0,
          units: 'ems',
          'doc-en': 'The maximum line width for text wrapping.',
          requires: ['text-field'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'text-line-height': {
          type: 'number',
          default: 1.2,
          units: 'ems',
          'doc-en': 'Text leading value for multi-line text.',
          requires: ['text-field'],
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
          expose: !0,
        },
        'text-letter-spacing': {
          type: 'number',
          default: 0,
          units: 'ems',
          'doc-en': 'Text tracking amount.',
          requires: ['text-field'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'text-justify': {
          type: 'enum',
          values: {
            left: { 'doc-en': 'The text is aligned to the left.' },
            center: { 'doc-en': 'The text is centered.' },
            right: { 'doc-en': 'The text is aligned to the right.' },
          },
          default: 'center',
          'doc-en': 'Text justification options.',
          requires: ['text-field'],
          expression: { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
          expose: !1,
        },
        'text-anchor': {
          type: 'enum',
          values: {
            center: { 'doc-en': 'The center of the text is placed closest to the anchor.' },
            left: { 'doc-en': 'The left side of the text is placed closest to the anchor.' },
            right: { 'doc-en': 'The right side of the text is placed closest to the anchor.' },
            top: { 'doc-en': 'The top of the text is placed closest to the anchor.' },
            bottom: { 'doc-en': 'The bottom of the text is placed closest to the anchor.' },
            'top-left': {
              'doc-en': 'The top left corner of the text is placed closest to the anchor.',
            },
            'top-right': {
              'doc-en': 'The top right corner of the text is placed closest to the anchor.',
            },
            'bottom-left': {
              'doc-en': 'The bottom left corner of the text is placed closest to the anchor.',
            },
            'bottom-right': {
              'doc-en': 'The bottom right corner of the text is placed closest to the anchor.',
            },
          },
          default: 'center',
          'doc-en': 'Part of the text placed closest to the anchor.',
          requires: ['text-field'],
          expression: { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'text-max-angle': {
          type: 'number',
          default: 45,
          units: 'degrees',
          'doc-en': 'Maximum angle change between adjacent characters.',
          requires: ['text-field', { 'symbol-placement': ['line', 'line-center'] }],
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'text-rotate': {
          type: 'number',
          default: 0,
          period: 360,
          units: 'degrees',
          'doc-en': 'Rotates the text clockwise.',
          requires: ['text-field'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'text-padding': {
          type: 'number',
          default: 2,
          minimum: 0,
          units: 'pixels',
          'doc-en':
            'Size of the additional area around the text bounding box used for detecting symbol collisions.',
          requires: ['text-field'],
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'text-keep-upright': {
          type: 'boolean',
          default: !0,
          'doc-en':
            'If true, the text may be flipped vertically to prevent it from being rendered upside-down.',
          requires: [
            'text-field',
            { 'text-rotation-alignment': 'map' },
            { 'symbol-placement': ['line', 'line-center'] },
          ],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'text-transform': {
          type: 'enum',
          values: {
            none: { 'doc-en': 'The text is not altered.' },
            uppercase: { 'doc-en': 'Forces all letters to be displayed in uppercase.' },
            lowercase: { 'doc-en': 'Forces all letters to be displayed in lowercase.' },
          },
          default: 'none',
          'doc-en':
            'Specifies how to capitalize text, similar to the CSS `text-transform` property.',
          requires: ['text-field'],
          expression: { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'text-offset': {
          type: 'array',
          'doc-en':
            'Offset distance of text from its anchor. Positive values indicate right and down, while negative values indicate left and up. If used with text-variable-anchor, input values will be taken as absolute values. Offsets along the x- and y-axis will be applied automatically based on the anchor position.',
          value: 'number',
          units: 'ems',
          length: 2,
          default: [0, 0],
          requires: ['text-field'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'text-allow-overlap': {
          type: 'boolean',
          default: !1,
          'doc-en':
            'If true, the text will be visible even if it collides with other previously drawn symbols.',
          requires: ['text-field'],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'text-ignore-placement': {
          type: 'boolean',
          default: !1,
          'doc-en': 'If true, other symbols can be visible even if they collide with the text.',
          requires: ['text-field'],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'text-optional': {
          type: 'boolean',
          default: !1,
          'doc-en':
            'If true, icons will display without their corresponding text when the text collides with other symbols and the icon does not.',
          requires: ['text-field', 'icon-image'],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        visibility: {
          type: 'enum',
          values: {
            visible: { 'doc-en': 'The layer is shown.' },
            none: { 'doc-en': 'The layer is not shown.' },
          },
          default: 'visible',
          'doc-en': 'Whether this layer is displayed.',
          'property-type': 'constant',
        },
      },
      layout_circle: {
        'circle-sort-key': {
          type: 'number',
          'doc-en':
            '基于此值按升序对要素排序。具有较高排序键的功能将显示在具有较低排序键的功能上方。',
          expression: { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        visibility: {
          type: 'enum',
          values: {
            visible: { 'doc-en': 'The layer is shown.' },
            none: { 'doc-en': 'The layer is not shown.' },
          },
          default: 'visible',
          'doc-en': 'Whether this layer is displayed.',
          'property-type': 'constant',
        },
      },
      layout_heatmap: {
        visibility: {
          type: 'enum',
          values: {
            visible: { 'doc-en': 'The layer is shown.' },
            none: { 'doc-en': 'The layer is not shown.' },
          },
          default: 'visible',
          'doc-en': 'Whether this layer is displayed.',
          'property-type': 'constant',
        },
        'display-mode': {
          type: 'enum',
          values: {
            '2d': { 'doc-en': 'The layer is 2d.' },
            '3d': { 'doc-en': 'The layer is 3d.' },
          },
          default: '2d',
          'doc-en': 'Whether this layer is 2d or 3d.',
          'property-type': 'constant',
        },
      },
      layout_extrusion: {
        visibility: {
          type: 'enum',
          values: {
            visible: { 'doc-en': 'The layer is shown.' },
            none: { 'doc-en': 'The layer is not shown.' },
          },
          default: 'visible',
          'doc-en': 'Whether this layer is displayed.',
          'property-type': 'constant',
        },
      },
      layout_histogram: {
        visibility: {
          type: 'enum',
          values: {
            visible: { 'doc-en': 'The layer is shown.' },
            none: { 'doc-en': 'The layer is not shown.' },
          },
          default: 'visible',
          'doc-en': 'Whether this layer is displayed.',
          'property-type': 'constant',
        },
        'histogram-max-height-render': {
          type: 'boolean',
          default: !1,
          'doc-en': "If true, histogram's height * 100",
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'histogram-color-render': {
          type: 'boolean',
          default: !1,
          'doc-en':
            "If true, histogram's color becomes a single histogram longitudinal difference value rendering, use the 'histogram-colors' attribute in paint to render",
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
      },
      layout_dynamicLine: {
        'dynamicLine-cap': {
          type: 'enum',
          values: {
            butt: {
              'doc-en':
                'A cap with a squared-off end which is drawn to the exact endpoint of the line.',
            },
            round: {
              'doc-en':
                "A cap with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line.",
            },
            square: {
              'doc-en':
                "A cap with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width.",
            },
          },
          default: 'butt',
          'doc-en': 'The display of dynamicLine endings.',
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'dynamicLine-join': {
          type: 'enum',
          values: {
            bevel: {
              'doc-en':
                "A join with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width.",
            },
            round: {
              'doc-en':
                "A join with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line.",
            },
            miter: {
              'doc-en':
                'A join with a sharp, angled corner which is drawn with the outer sides beyond the endpoint of the path until they meet.',
            },
          },
          default: 'miter',
          'doc-en': 'The display of dynamicLine when joining.',
          expression: { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'dynamicLine-miter-limit': {
          type: 'number',
          default: 2,
          'doc-en': 'Used to automatically convert miter joins to bevel joins for sharp angles.',
          requires: [{ 'dynamicLine-join': 'miter' }],
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'dynamicLine-round-limit': {
          type: 'number',
          default: 1.05,
          'doc-en': 'Used to automatically convert round joins to miter joins for shallow angles.',
          requires: [{ 'dynamicLine-join': 'round' }],
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'dynamicLine-sort-key': {
          type: 'number',
          'doc-en':
            'Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.',
          expression: { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        visibility: {
          type: 'enum',
          values: {
            visible: { 'doc-en': 'The layer is shown.' },
            none: { 'doc-en': 'The layer is not shown.' },
          },
          default: 'visible',
          'doc-en': 'Whether this layer is displayed.',
          'property-type': 'constant',
        },
      },
      layout_tracking: {
        'tracking-cap': {
          type: 'enum',
          values: {
            butt: {
              'doc-en':
                'A cap with a squared-off end which is drawn to the exact endpoint of the line.',
            },
            round: {
              'doc-en':
                "A cap with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line.",
            },
            square: {
              'doc-en':
                "A cap with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width.",
            },
          },
          default: 'butt',
          'doc-en': 'The display of line endings.',
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'tracking-join': {
          type: 'enum',
          values: {
            bevel: {
              'doc-en':
                "A join with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width.",
            },
            round: {
              'doc-en':
                "A join with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line.",
            },
            miter: {
              'doc-en':
                'A join with a sharp, angled corner which is drawn with the outer sides beyond the endpoint of the path until they meet.',
            },
          },
          default: 'miter',
          'doc-en': 'The display of lines when joining.',
          expression: { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'tracking-miter-limit': {
          type: 'number',
          default: 2,
          'doc-en': 'Used to automatically convert miter joins to bevel joins for sharp angles.',
          requires: [{ 'tracking-join': 'miter' }],
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
          expose: !1,
        },
        'tracking-round-limit': {
          type: 'number',
          default: 1.05,
          'doc-en': 'Used to automatically convert round joins to miter joins for shallow angles.',
          requires: [{ 'tracking-join': 'round' }],
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'tracking-sort-key': {
          type: 'number',
          'doc-en':
            '基于此值按升序对要素排序。具有较高排序键的功能将显示在具有较低排序键的功能上方。',
          expression: { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        visibility: {
          type: 'enum',
          values: {
            visible: { 'doc-en': 'The layer is shown.' },
            none: { 'doc-en': 'The layer is not shown.' },
          },
          default: 'visible',
          'doc-en': 'Whether this layer is displayed.',
          'property-type': 'constant',
        },
        'tracking-display-mode': {
          type: 'enum',
          function: 'piecewise-constant',
          values: { loop: {}, reverse: {}, 'loop-reserve': {}, 'reverse-reserve': {} },
          default: 'loop',
          'property-type': 'data-constant',
        },
      },
      'layout_3d-model': {
        visibility: {
          type: 'enum',
          values: { visible: {}, none: {} },
          default: 'visible',
          'property-type': 'constant',
        },
      },
      'layout_3d-tiles': {
        visibility: {
          type: 'enum',
          values: { visible: {}, none: {} },
          default: 'visible',
          'property-type': 'constant',
        },
      },
      layout_panorama: {
        visibility: {
          type: 'enum',
          values: { visible: {}, none: {} },
          default: 'visible',
          'doc-en': 'Whether this layer is displayed.',
          'property-type': 'constant',
        },
      },
      layout_symtracking: {
        'symtracking-display-mode': {
          type: 'enum',
          function: 'piecewise-constant',
          values: { default: {}, 'time-sequence': {}, timestamp: {} },
          default: 'default',
          'property-type': 'data-constant',
        },
        'symtracking-time-segment': {
          type: 'number',
          default: 20,
          minimum: 1,
          units: 'second',
          'property-type': 'constant',
        },
        'symtracking-fps': { type: 'number', default: 1, minimum: 1, 'property-type': 'constant' },
        'symtracking-sort-key': {
          type: 'number',
          'doc-en':
            'Sorts features in ascending order based on this value. Features with lower sort keys are drawn and placed first.  When `icon-allow-overlap` or `text-allow-overlap` is `false`, features with a lower sort key will have priority during placement. When `icon-allow-overlap` or `text-allow-overlap` is set to `true`, features with a higher sort key will overlap over features with a lower sort key.',
          expression: { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'symtracking-z-order': {
          type: 'enum',
          values: {
            auto: {
              'doc-en':
                'Sorts symbols by `symbol-sort-key` if set. Otherwise, sorts symbols by their y-position relative to the viewport if `icon-allow-overlap` or `text-allow-overlap` is set to `true` or `icon-ignore-placement` or `text-ignore-placement` is `false`.',
            },
            'viewport-y': {
              'doc-en':
                'Sorts symbols by their y-position relative to the viewport if `icon-allow-overlap` or `text-allow-overlap` is set to `true` or `icon-ignore-placement` or `text-ignore-placement` is `false`.',
            },
            source: {
              'doc-en':
                'Sorts symbols by `symbol-sort-key` if set. Otherwise, no sorting is applied; symbols are rendered in the same order as the source data.',
            },
          },
          default: 'auto',
          'doc-en':
            'Determines whether overlapping symbols in the same layer are rendered in the order that they appear in the data source or by their y-position relative to the viewport. To control the order and prioritization of symbols otherwise, use `symbol-sort-key`.',
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'compatible-mode': { type: 'boolean', default: !0, 'property-type': 'constant' },
        'symbol-placement': {
          type: 'enum',
          values: {
            point: { 'doc-en': 'The label is placed at the point where the geometry is located.' },
            line: {
              'doc-en':
                'The label is placed along the line of the geometry. Can only be used on `LineString` and `Polygon` geometries.',
            },
            'line-center': {
              'doc-en':
                'The label is placed at the center of the line of the geometry. Can only be used on `LineString` and `Polygon` geometries. Note that a single feature in a vector tile may contain multiple line geometries.',
            },
          },
          default: 'point',
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
          expose: !1,
        },
        'symbol-spacing': {
          type: 'number',
          default: 250,
          minimum: 1,
          units: 'pixels',
          'doc-en': 'Distance between two symbol anchors.',
          requires: [{ 'symbol-placement': 'line' }],
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'symbol-avoid-edges': {
          type: 'boolean',
          default: !1,
          'doc-en':
            "If true, the symbols will not cross tile edges to avoid mutual collisions. Recommended in layers that don't have enough padding in the vector tile to prevent collisions, or if it is a point symbol layer placed after a line symbol layer. When using a client that supports global collision detection, like minemap GL JS version 0.42.0 or greater, enabling this property is not needed to prevent clipped labels at tile boundaries.",
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
          expose: !1,
        },
        'icon-allow-overlap': {
          type: 'boolean',
          default: !1,
          'doc-en':
            'If true, the icon will be visible even if it collides with other previously drawn symbols.',
          requires: ['icon-image'],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
          expose: !1,
        },
        'icon-ignore-placement': {
          type: 'boolean',
          default: !1,
          'doc-en': 'If true, other symbols can be visible even if they collide with the icon.',
          requires: ['icon-image'],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
          expose: !1,
        },
        'icon-optional': {
          type: 'boolean',
          default: !1,
          requires: ['icon-image', 'text-field'],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
          expose: !1,
        },
        'icon-rotation-alignment': {
          type: 'enum',
          values: {
            map: {
              'doc-en':
                'When `symbol-placement` is set to `point`, aligns icons east-west. When `symbol-placement` is set to `line` or `line-center`, aligns icon x-axes with the line.',
            },
            viewport: {
              'doc-en':
                'Produces icons whose x-axes are aligned with the x-axis of the viewport, regardless of the value of `symbol-placement`.',
            },
            auto: {
              'doc-en':
                'When `symbol-placement` is set to `point`, this is equivalent to `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is equivalent to `map`.',
            },
          },
          default: 'map',
          'doc-en':
            'In combination with `symbol-placement`, determines the rotation behavior of icons.',
          requires: ['icon-image'],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
          expose: !1,
        },
        'icon-size': {
          type: 'number',
          default: 1,
          minimum: 0,
          units: '图标原始大小的倍数因子',
          'units-en': 'factor of the original icon size',
          'doc-en':
            'Scales the original size of the icon by the provided factor. The new pixel size of the image will be the original pixel size multiplied by `icon-size`. 1 is the original size; 3 triples the size of the image.',
          requires: ['icon-image'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'icon-text-fit': {
          type: 'enum',
          values: {
            none: { 'doc-en': 'The icon is displayed at its intrinsic aspect ratio.' },
            width: {
              'doc-en': 'The icon is scaled in the x-dimension to fit the width of the text.',
            },
            height: {
              'doc-en': 'The icon is scaled in the y-dimension to fit the height of the text.',
            },
            both: { 'doc-en': 'The icon is scaled in both x- and y-dimensions.' },
          },
          default: 'none',
          'doc-en': 'Scales the icon to fit around the associated text.',
          requires: ['icon-image', 'text-field'],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
          expose: !1,
        },
        'icon-text-fit-padding': {
          type: 'array',
          value: 'number',
          length: 4,
          default: [0, 0, 0, 0],
          units: 'pixels',
          requires: ['icon-image', 'text-field', { 'icon-text-fit': ['both', 'width', 'height'] }],
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
          expose: !1,
        },
        'icon-image': {
          type: 'resolvedImage',
          'doc-en': 'Name of image in sprite to use for drawing an image background.',
          tokens: !0,
          expression: { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'icon-rotate': {
          type: 'number',
          default: 0,
          period: 360,
          units: 'degrees',
          'doc-en': 'Rotates the icon clockwise.',
          requires: ['icon-image'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
          expose: !1,
        },
        'icon-padding': {
          type: 'number',
          default: 2,
          minimum: 0,
          units: 'pixels',
          'doc-en':
            'Size of the additional area around the icon bounding box used for detecting symbol collisions.',
          requires: ['icon-image'],
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
          expose: !1,
        },
        'icon-keep-upright': {
          type: 'boolean',
          default: !1,
          'doc-en':
            'If true, the icon may be flipped to prevent it from being rendered upside-down.',
          requires: [
            'icon-image',
            { 'icon-rotation-alignment': 'map' },
            { 'symbol-placement': ['line', 'line-center'] },
          ],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
          expose: !1,
        },
        'icon-offset': {
          type: 'array',
          value: 'number',
          length: 2,
          default: [0, 0],
          'doc-en':
            'Offset distance of icon from its anchor. Positive values indicate right and down, while negative values indicate left and up. Each component is multiplied by the value of `icon-size` to obtain the final offset in pixels. When combined with `icon-rotate` the offset will be as if the rotated direction was up.',
          requires: ['icon-image'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
        'icon-anchor': {
          type: 'enum',
          values: {
            center: { 'doc-en': 'The center of the icon is placed closest to the anchor.' },
            left: { 'doc-en': 'The left side of the icon is placed closest to the anchor.' },
            right: { 'doc-en': 'The right side of the icon is placed closest to the anchor.' },
            top: { 'doc-en': 'The top of the icon is placed closest to the anchor.' },
            bottom: { 'doc-en': 'The bottom of the icon is placed closest to the anchor.' },
            'top-left': {
              'doc-en': 'The top left corner of the icon is placed closest to the anchor.',
            },
            'top-right': {
              'doc-en': 'The top right corner of the icon is placed closest to the anchor.',
            },
            'bottom-left': {
              'doc-en': 'The bottom left corner of the icon is placed closest to the anchor.',
            },
            'bottom-right': {
              'doc-en': 'The bottom right corner of the icon is placed closest to the anchor.',
            },
          },
          default: 'center',
          'doc-en': 'Part of the icon placed closest to the anchor.',
          requires: ['icon-image'],
          expression: { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
          expose: !1,
        },
        'icon-pitch-alignment': {
          type: 'enum',
          values: {
            map: { 'doc-en': 'The icon is aligned to the plane of the map.' },
            viewport: { 'doc-en': 'The icon is aligned to the plane of the viewport.' },
            auto: { 'doc-en': 'Automatically matches the value of `icon-rotation-alignment`.' },
          },
          default: 'auto',
          'doc-en': 'Orientation of icon when map is pitched.',
          requires: ['icon-image'],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
          expose: !1,
        },
        'text-pitch-alignment': {
          type: 'enum',
          values: {
            map: { 'doc-en': 'The text is aligned to the plane of the map.' },
            viewport: { 'doc-en': 'The text is aligned to the plane of the viewport.' },
            auto: { 'doc-en': 'Automatically matches the value of `text-rotation-alignment`.' },
          },
          default: 'auto',
          'doc-en': 'Orientation of text when map is pitched.',
          requires: ['text-field'],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
          expose: !1,
        },
        'text-rotation-alignment': {
          type: 'enum',
          values: {
            map: {
              'doc-en':
                'When `symbol-placement` is set to `point`, aligns text east-west. When `symbol-placement` is set to `line` or `line-center`, aligns text x-axes with the line.',
            },
            viewport: {
              'doc-en':
                'Produces glyphs whose x-axes are aligned with the x-axis of the viewport, regardless of the value of `symbol-placement`.',
            },
            auto: {
              'doc-en':
                'When `symbol-placement` is set to `point`, this is equivalent to `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is equivalent to `map`.',
            },
          },
          default: 'auto',
          'doc-en':
            'In combination with `symbol-placement`, determines the rotation behavior of the individual glyphs forming the text.',
          requires: ['text-field'],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
          expose: !1,
        },
        'text-field': {
          type: 'string',
          default: '',
          tokens: !0,
          'doc-en': 'Value to use for a text label.',
          expression: { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
          expose: !1,
        },
        'text-font': {
          type: 'array',
          value: 'string',
          default: ['Open Sans Regular', 'Arial Unicode MS Regular'],
          requires: ['text-field'],
          expression: { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
          expose: !1,
        },
        'text-size': {
          type: 'number',
          default: 16,
          minimum: 0,
          units: 'pixels',
          requires: ['text-field'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
          expose: !1,
        },
        'text-max-width': {
          type: 'number',
          default: 10,
          minimum: 0,
          units: 'ems',
          requires: ['text-field'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
          expose: !1,
        },
        'text-line-height': {
          type: 'number',
          default: 1.2,
          units: 'ems',
          requires: ['text-field'],
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
          expose: !1,
        },
        'text-letter-spacing': {
          type: 'number',
          default: 0,
          units: 'ems',
          requires: ['text-field'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
          expose: !1,
        },
        'text-justify': {
          type: 'enum',
          values: { left: {}, center: {}, right: {} },
          default: 'center',
          requires: ['text-field'],
          expression: { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
          expose: !1,
        },
        'text-anchor': {
          type: 'enum',
          values: {
            center: {},
            left: {},
            right: {},
            top: {},
            bottom: {},
            'top-left': {},
            'top-right': {},
            'bottom-left': {},
            'bottom-right': {},
          },
          default: 'center',
          requires: ['text-field'],
          expression: { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
          expose: !1,
        },
        'text-max-angle': {
          type: 'number',
          default: 45,
          units: 'degrees',
          requires: ['text-field', { 'symbol-placement': ['line', 'line-center'] }],
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
          expose: !1,
        },
        'text-rotate': {
          type: 'number',
          default: 0,
          period: 360,
          units: 'degrees',
          requires: ['text-field'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
          expose: !1,
        },
        'text-padding': {
          type: 'number',
          default: 2,
          minimum: 0,
          units: 'pixels',
          requires: ['text-field'],
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
          expose: !1,
        },
        'text-keep-upright': {
          type: 'boolean',
          default: !0,
          requires: [
            'text-field',
            { 'text-rotation-alignment': 'map' },
            { 'symbol-placement': ['line', 'line-center'] },
          ],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
          expose: !1,
        },
        'text-transform': {
          type: 'enum',
          values: { none: {}, uppercase: {}, lowercase: {} },
          default: 'none',
          requires: ['text-field'],
          expression: { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
          expose: !1,
        },
        'text-offset': {
          type: 'array',
          value: 'number',
          units: 'ems',
          length: 2,
          default: [0, 0],
          requires: ['text-field'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
          expose: !1,
        },
        'text-allow-overlap': {
          type: 'boolean',
          default: !1,
          requires: ['text-field'],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
          expose: !1,
        },
        'text-ignore-placement': {
          type: 'boolean',
          default: !1,
          requires: ['text-field'],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
          expose: !1,
        },
        'text-optional': {
          type: 'boolean',
          default: !1,
          'doc-en':
            'If true, icons will display without their corresponding text when the text collides with other symbols and the icon does not.',
          requires: ['text-field', 'icon-image'],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        visibility: {
          type: 'enum',
          values: {
            visible: { 'doc-en': 'The layer is shown.' },
            none: { 'doc-en': 'The layer is not shown.' },
          },
          default: 'visible',
          'doc-en': 'Whether this layer is displayed.',
          'property-type': 'constant',
        },
      },
      filter: {
        type: 'array',
        value: '*',
        'doc-en': 'A filter selects specific features from a layer.',
      },
      filter_operator: {
        type: 'enum',
        values: {
          '==': {},
          like: {},
          '!like': {},
          '!=': {},
          '>': {},
          '>=': {},
          '<': {},
          '<=': {},
          in: {},
          '!in': {},
          arrin: {},
          '!arrin': {},
          all: {},
          any: {},
          none: {},
          has: {},
          '!has': {},
          within: {},
        },
      },
      geometry_type: {
        type: 'enum',
        values: {
          Point: { 'doc-en': 'Filter to point geometries.' },
          LineString: { 'doc-en': 'Filter to line geometries.' },
          Polygon: { 'doc-en': 'Filter to polygon geometries.' },
        },
        'doc-en': 'The geometry type for the filter to select.',
      },
      function: {
        expression: { type: 'expression', 'doc-en': 'An expression.' },
        stops: { type: 'array', 'doc-en': 'An array of stops.', value: 'function_stop' },
        base: {
          type: 'number',
          default: 1,
          minimum: 0,
          'doc-en':
            'The exponential base of the interpolation curve. It controls the rate at which the result increases. Higher values make the result increase more towards the high end of the range. With `1` the stops are interpolated linearly.',
        },
        property: {
          type: 'string',
          'doc-en': 'The name of a feature property to use as the function input.',
          default: '$zoom',
        },
        type: {
          type: 'enum',
          values: {
            identity: { 'doc-en': 'Return the input value as the output value.' },
            exponential: {
              'doc-en':
                'Generate an output by interpolating between stops just less than and just greater than the function input.',
            },
            interval: {
              'doc-en': 'Return the output value of the stop just less than the function input.',
            },
            categorical: {
              'doc-en': 'Return the output value of the stop equal to the function input.',
            },
          },
          'doc-en': 'The interpolation strategy to use in function evaluation.',
          default: 'exponential',
        },
        colorSpace: {
          type: 'enum',
          values: {
            rgb: { 'doc-en': 'Use the RGB color space to interpolate color values' },
            lab: { 'doc-en': 'Use the LAB color space to interpolate color values.' },
            hcl: {
              'doc-en':
                'Use the HCL color space to interpolate color values, interpolating the Hue, Chroma, and Luminance channels individually.',
            },
          },
          'doc-en':
            'The color space in which colors interpolated. Interpolating colors in perceptual color spaces like LAB and HCL tend to produce color ramps that look more consistent and produce colors that can be differentiated more easily than those interpolated in RGB space.',
          default: 'rgb',
        },
        default: {
          type: '*',
          required: !1,
          'doc-en':
            "A value to serve as a fallback function result when a value isn't otherwise available. It is used in the following circumstances:\n* In categorical functions, when the feature value does not match any of the stop domain values.\n* In property and zoom-and-property functions, when a feature does not contain a value for the specified property.\n* In identity functions, when the feature value is not valid for the style property (for example, if the function is being used for a `circle-color` property but the feature property value is not a string or not a valid color).\n* In interval or exponential property and zoom-and-property functions, when the feature value is not numeric.\nIf no default is provided, the style property's default is used in these circumstances.",
        },
      },
      function_stop: {
        type: 'array',
        minimum: 0,
        maximum: 22,
        value: ['number', 'color'],
        length: 2,
        'doc-en': 'Zoom level and value pair.',
      },
      expression: {
        type: 'array',
        value: '*',
        minimum: 1,
        'doc-en':
          'An expression defines a function that can be used for data-driven style properties or feature filters.',
      },
      light: {
        anchor: {
          type: 'enum',
          default: 'viewport',
          values: {
            map: {
              'doc-en': 'The position of the light source is aligned to the rotation of the map.',
            },
            viewport: {
              'doc-en':
                'The position of the light source is aligned to the rotation of the viewport.',
            },
          },
          'property-type': 'data-constant',
          transition: !1,
          expression: { interpolated: !1, parameters: ['zoom'] },
        },
        position: {
          type: 'array',
          default: [1.15, 210, 30],
          length: 3,
          value: 'number',
          'property-type': 'data-constant',
          transition: !0,
          expression: { interpolated: !0, parameters: ['zoom'] },
        },
        color: {
          type: 'color',
          'property-type': 'data-constant',
          default: '#ffffff',
          expression: { interpolated: !0, parameters: ['zoom'] },
          transition: !0,
        },
        intensity: {
          type: 'number',
          'property-type': 'data-constant',
          default: 0.5,
          minimum: 0,
          maximum: 1,
          expression: { interpolated: !0, parameters: ['zoom'] },
          transition: !0,
        },
      },
      paint: [
        'paint_background',
        'paint_fill',
        'paint_line',
        'paint_airline',
        'paint_symbol',
        'paint_circle',
        'paint_heatmap',
        'paint_raster',
        'paint_extrusion',
        'paint_histogram',
        'paint_dynamicLine',
        'paint_tracking',
        'paint_sprite',
        'paint_3d-model',
        'paint_3d-tiles',
        'paint_panorama',
        'paint_symtracking',
      ],
      paint_background: {
        'background-color': {
          type: 'color',
          default: '#000000',
          'doc-en': 'The color with which the background will be drawn.',
          transition: !0,
          requires: [{ '!': 'background-pattern' }],
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'background-pattern': {
          type: 'string',
          transition: !0,
          'doc-en':
            'Name of image in sprite to use for drawing an image background. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.',
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'cross-faded',
        },
        'background-pattern-fixed': {
          type: 'boolean',
          transition: !0,
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'background-opacity': {
          type: 'number',
          default: 1,
          minimum: 0,
          maximum: 1,
          'doc-en': 'The opacity at which the background will be drawn.',
          transition: !0,
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'background-terrain-analysis': {
          type: 'color',
          'doc-en': 'The color with which the slope or aspect of terrain will be drawn.',
          default: '#000000',
          transition: !0,
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
      },
      paint_raster: {
        'raster-opacity': {
          type: 'number',
          'doc-en': 'The opacity at which the image will be drawn.',
          default: 1,
          minimum: 0,
          maximum: 1,
          transition: !0,
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'raster-hue-rotate': {
          type: 'number',
          default: 0,
          period: 360,
          transition: !0,
          units: 'degrees',
          'doc-en': 'Rotates hues around the color wheel.',
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'raster-brightness-min': {
          type: 'number',
          'doc-en':
            'Increase or reduce the brightness of the image. The value is the minimum brightness.',
          default: 0,
          minimum: 0,
          maximum: 1,
          transition: !0,
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'raster-brightness-max': {
          type: 'number',
          'doc-en':
            'Increase or reduce the brightness of the image. The value is the maximum brightness.',
          default: 1,
          minimum: 0,
          maximum: 1,
          transition: !0,
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'raster-saturation': {
          type: 'number',
          'doc-en': 'Increase or reduce the saturation of the image.',
          default: 0,
          minimum: -1,
          maximum: 1,
          transition: !0,
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'raster-contrast': {
          type: 'number',
          'doc-en': 'Increase or reduce the contrast of the image.',
          default: 0,
          minimum: -1,
          maximum: 1,
          transition: !0,
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'raster-resampling': {
          type: 'enum',
          'doc-en':
            'The resampling/interpolation method to use for overscaling, also known as texture magnification filter',
          values: {
            linear: {
              'doc-en':
                '(Bi)linear filtering interpolates pixel values using the weighted average of the four closest original source pixels creating a smooth but blurry look when overscaled',
            },
            nearest: {
              'doc-en':
                'Nearest neighbor filtering interpolates pixel values using the nearest original source pixel creating a sharp but pixelated look when overscaled',
            },
          },
          default: 'linear',
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'raster-fade-duration': {
          type: 'number',
          default: 300,
          minimum: 0,
          transition: !1,
          units: 'milliseconds',
          'doc-en': 'Fade duration when a new tile is added.',
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
      },
      paint_fill: {
        'fill-antialias': {
          type: 'boolean',
          default: !0,
          'doc-en': 'Whether or not the fill should be antialiased.',
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'fill-opacity': {
          type: 'number',
          default: 1,
          minimum: 0,
          maximum: 1,
          'doc-en':
            'The opacity of the entire fill layer. In contrast to the `fill-color`, this value will also affect the 1px stroke around the fill, if the stroke is used.',
          transition: !0,
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'fill-water-texture': {
          type: 'string',
          default: '',
          'doc-en': 'Texture object url link',
          'property-type': 'data-constant',
        },
        'fill-water-mirror-texture': {
          type: 'string',
          default: '',
          'doc-en': 'Mirror texture object url link',
          'property-type': 'data-constant',
        },
        'fill-water-speed': {
          type: 'number',
          default: 1,
          'doc-en': 'The speed of water',
          'property-type': 'data-constant',
        },
        'fill-water-wave-size': {
          type: 'number',
          default: 1,
          'doc-en': 'Describe the speed of water ripples',
          'property-type': 'data-constant',
        },
        'sunlight-color': { type: 'color', default: '#76ca17', 'property-type': 'data-constant' },
        'sunlight-direction': {
          type: 'array',
          value: 'number',
          length: 3,
          default: [1, 1.0349, -0.0994],
          'property-type': 'data-constant',
        },
        'sky-color': { type: 'color', default: '#ffffff', 'property-type': 'data-constant' },
        'fill-color': {
          type: 'color',
          default: '#000000',
          'doc-en':
            "The color of the filled part of this layer. This color can be specified as `rgba` with an alpha component and the color's opacity will not affect the opacity of the 1px stroke, if it is used.",
          transition: !0,
          requires: [{ '!': 'fill-pattern' }],
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
          expose: !1,
        },
        'fill-outline-color': {
          type: 'color',
          'doc-en':
            'The outline color of the fill. Matches the value of `fill-color` if unspecified.',
          transition: !0,
          requires: [{ '!': 'fill-pattern' }, { 'fill-antialias': !0 }],
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'fill-translate': {
          type: 'array',
          value: 'number',
          length: 2,
          default: [0, 0],
          transition: !0,
          units: 'pixels',
          'doc-en':
            "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-driven',
          expose: !1,
        },
        'fill-translate-anchor': {
          type: 'enum',
          values: { map: {}, viewport: {} },
          'doc-en': 'Controls the frame of reference for `fill-translate`.',
          default: 'map',
          requires: ['fill-translate'],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-driven',
        },
        'fill-pattern': {
          type: 'resolvedImage',
          transition: !1,
          'doc-en':
            'Name of image in sprite to use for drawing image fills. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.',
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'cross-faded',
        },
        'fill-water': {
          type: 'string',
          default: 'none',
          'doc-en': 'Whether it is water ripple',
          'property-type': 'data-constant',
        },
        'fill-dynamic-speed': {
          type: 'number',
          default: 0.5,
          minimum: 0,
          maximum: 1,
          transition: !0,
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'fill-dynamic-image-url': {
          type: 'string',
          transition: !0,
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'cross-faded',
        },
      },
      paint_line: {
        'line-opacity': {
          type: 'number',
          'doc-en': 'The opacity at which the line will be drawn.',
          default: 1,
          minimum: 0,
          maximum: 1,
          transition: !0,
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'line-color': {
          type: 'color',
          'doc-en': 'The color with which the line will be drawn.',
          default: '#000000',
          transition: !0,
          requires: [{ '!': 'line-pattern' }],
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'line-translate': {
          type: 'array',
          value: 'number',
          length: 2,
          default: [0, 0],
          transition: !0,
          units: 'pixels',
          'doc-en':
            "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-driven',
        },
        'line-translate-anchor': {
          type: 'enum',
          values: {
            map: { 'doc-en': 'The line is translated relative to the map.' },
            viewport: { 'doc-en': 'The line is translated relative to the viewport.' },
          },
          'doc-en': 'Controls the frame of reference for `line-translate`.',
          default: 'map',
          requires: ['line-translate'],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-driven',
        },
        'line-width': {
          type: 'number',
          default: 1,
          minimum: 0,
          transition: !0,
          units: 'pixels',
          'doc-en': 'Stroke thickness.',
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'line-border-width': {
          type: 'number',
          default: 0,
          minimum: 0,
          function: 'interpolated',
          transition: !0,
          units: 'pixels',
          'doc-en': 'Stroke thickness.',
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'line-border-opacity': {
          type: 'number',
          'doc-en': 'The opacity at which the line will be drawn.',
          function: 'interpolated',
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          default: 1,
          minimum: 0,
          maximum: 1,
          transition: !0,
          'property-type': 'data-driven',
        },
        'line-border-color': {
          type: 'color',
          'doc-en': 'The color with which the line will be drawn.',
          default: '#000000',
          function: 'interpolated',
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          transition: !0,
          requires: [{ '!': 'line-pattern' }],
          'property-type': 'data-driven',
        },
        'line-gap-width': {
          type: 'number',
          default: 0,
          minimum: 0,
          'doc-en':
            "Draws a line casing outside of a line's actual path. Value indicates the width of the inner gap.",
          transition: !0,
          units: 'pixels',
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'line-offset': {
          type: 'number',
          default: 0,
          'doc-en':
            "The line's offset. For linear features, a positive value offsets the line to the right, relative to the direction of the line, and a negative value to the left. For polygon features, a positive value results in an inset, and a negative value results in an outset.",
          transition: !0,
          units: 'pixels',
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'line-blur': {
          type: 'number',
          default: 0,
          minimum: 0,
          transition: !0,
          units: 'pixels',
          'doc-en': 'Blur applied to the line, in pixels.',
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'line-dasharray': {
          type: 'array',
          value: 'number',
          'doc-en':
            "Specifies the lengths of the alternating dashes and gaps that form the dash pattern. The lengths are later scaled by the line width. To convert a dash length to pixels, multiply the length by the current line width. Note that GeoJSON sources with `lineMetrics: true` specified won't render dashed lines to the expected scale. Also note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
          minimum: 0,
          transition: !0,
          units: 'line widths',
          requires: [{ '!': 'line-pattern' }],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'cross-faded',
        },
        'line-pattern': {
          type: 'resolvedImage',
          transition: !0,
          'doc-en':
            'Name of image in sprite to use for drawing image lines. For seamless patterns, image width must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.',
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'cross-faded',
        },
        'line-gradient': {
          type: 'color',
          'doc-en':
            'Defines a gradient with which to color a line feature. Can only be used with GeoJSON sources that specify `"lineMetrics": true`.',
          transition: !1,
          requires: [
            { '!': 'line-dasharray' },
            { '!': 'line-pattern' },
            { source: 'geojson', has: { lineMetrics: !0 } },
          ],
          expression: { interpolated: !0, parameters: ['line-progress'] },
          'property-type': 'color-ramp',
        },
        'half-render': {
          type: 'boolean',
          default: !1,
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'line-normal-direction': {
          type: 'boolean',
          default: !0,
          expression: { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'data-driven',
        },
      },
      paint_airline: {
        'airline-opacity': {
          type: 'number',
          'doc-en': 'The opacity at which the line will be drawn.',
          default: 1,
          minimum: 0,
          maximum: 1,
          transition: !0,
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'airline-color': {
          type: 'color',
          'doc-en': 'The color with which the line will be drawn.',
          default: '#000000',
          transition: !0,
          requires: [{ '!': 'tracking-pattern' }],
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'airline-translate': {
          type: 'array',
          value: 'number',
          length: 2,
          default: [0, 0],
          transition: !0,
          units: 'pixels',
          'doc-en':
            "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'airline-translate-anchor': {
          type: 'enum',
          values: {
            map: { 'doc-en': 'The line is translated relative to the map.' },
            viewport: { 'doc-en': 'The line is translated relative to the viewport.' },
          },
          'doc-en': 'Controls the frame of reference for `airline-translate`.',
          default: 'map',
          requires: ['tracking-translate'],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'airline-width': {
          type: 'number',
          default: 1,
          minimum: 0,
          transition: !0,
          units: 'pixels',
          'doc-en': 'Stroke thickness.',
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'airline-gap-width': {
          type: 'number',
          default: 0,
          minimum: 0,
          'doc-en':
            "Draws a line casing outside of a line's actual path. Value indicates the width of the inner gap.",
          transition: !0,
          units: 'pixels',
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'airline-offset': {
          type: 'number',
          default: 0,
          'doc-en':
            "The line's offset. For linear features, a positive value offsets the line to the right, relative to the direction of the line, and a negative value to the left. For polygon features, a positive value results in an inset, and a negative value results in an outset.",
          transition: !0,
          units: 'pixels',
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'airline-blur': {
          type: 'number',
          default: 0,
          minimum: 0,
          transition: !0,
          units: 'pixels',
          'doc-en': 'Blur applied to the line, in pixels.',
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'airline-type': {
          type: 'enum',
          function: 'piecewise-constant',
          values: ['none', 'history'],
          default: 'real-time',
          'property-type': 'constant',
        },
        'airline-seg-group': {
          type: 'number',
          default: 1,
          requires: [{ 'airline-type': 'history' }],
          minimum: 1,
          maximum: 600,
          'property-type': 'constant',
        },
        'airline-speed': {
          type: 'number',
          function: 'interpolated',
          default: 10,
          minimum: 1,
          maximum: 500,
          transition: !0,
          'property-type': 'constant',
        },
      },
      paint_symbol: {
        'icon-opacity': {
          'doc-en': 'The opacity at which the icon will be drawn.',
          type: 'number',
          default: 1,
          minimum: 0,
          maximum: 1,
          transition: !0,
          requires: ['icon-image'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'icon-color': {
          type: 'color',
          default: '#000000',
          transition: !0,
          'doc-en': 'The color of the icon. This can only be used with sdf icons.',
          requires: ['icon-image'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'icon-halo-color': {
          type: 'color',
          default: 'rgba(0, 0, 0, 0)',
          transition: !0,
          'doc-en': "The color of the icon's halo. Icon halos can only be used with SDF icons.",
          requires: ['icon-image'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'icon-halo-width': {
          type: 'number',
          default: 0,
          minimum: 0,
          transition: !0,
          units: 'pixels',
          'doc-en': 'Distance of halo to the icon outline.',
          requires: ['icon-image'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'icon-halo-blur': {
          type: 'number',
          default: 0,
          minimum: 0,
          transition: !0,
          units: 'pixels',
          'doc-en': 'Fade out the halo towards the outside.',
          requires: ['icon-image'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'icon-translate': {
          type: 'array',
          value: 'number',
          length: 2,
          default: [0, 0],
          transition: !0,
          units: 'pixels',
          'doc-en':
            "Distance that the icon's anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.",
          requires: ['icon-image'],
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-driven',
        },
        'icon-translate-anchor': {
          type: 'enum',
          values: {
            map: { 'doc-en': 'Icons are translated relative to the map.' },
            viewport: { 'doc-en': 'Icons are translated relative to the viewport.' },
          },
          'doc-en': 'Controls the frame of reference for `icon-translate`.',
          default: 'map',
          requires: ['icon-image', 'icon-translate'],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'text-opacity': {
          type: 'number',
          'doc-en': 'The opacity at which the text will be drawn.',
          default: 1,
          minimum: 0,
          maximum: 1,
          transition: !0,
          requires: ['text-field'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'text-color': {
          type: 'color',
          'doc-en': 'The color with which the text will be drawn.',
          default: '#000000',
          transition: !0,
          requires: ['text-field'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'text-halo-color': {
          type: 'color',
          default: 'rgba(0, 0, 0, 0)',
          transition: !0,
          'doc-en': "The color of the text's halo, which helps it stand out from backgrounds.",
          requires: ['text-field'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'text-halo-width': {
          type: 'number',
          default: 0,
          minimum: 0,
          transition: !0,
          units: 'pixels',
          'doc-en':
            'Distance of halo to the font outline. Max text halo width is 1/4 of the font-size.',
          requires: ['text-field'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'text-halo-blur': {
          type: 'number',
          default: 0,
          minimum: 0,
          transition: !0,
          units: 'pixels',
          'doc-en': "The halo's fadeout distance towards the outside.",
          requires: ['text-field'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'text-translate': {
          type: 'array',
          value: 'number',
          length: 2,
          default: [0, 0],
          transition: !0,
          units: 'pixels',
          'doc-en':
            "Distance that the text's anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.",
          requires: ['text-field'],
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-driven',
        },
        'text-translate-anchor': {
          type: 'enum',
          values: {
            map: { 'doc-en': 'The text is translated relative to the map.' },
            viewport: { 'doc-en': 'The text is translated relative to the viewport.' },
          },
          'doc-en': 'Controls the frame of reference for `text-translate`.',
          default: 'map',
          requires: ['text-field', 'text-translate'],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
      },
      paint_circle: {
        'circle-radius': {
          type: 'number',
          default: 5,
          minimum: 0,
          transition: !0,
          units: 'pixels',
          'doc-en': 'Circle radius.',
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'circle-color': {
          type: 'color',
          default: '#000000',
          'doc-en': 'The fill color of the circle.',
          transition: !0,
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'circle-blur': {
          type: 'number',
          default: 0,
          'doc-en':
            'Amount to blur the circle. 1 blurs the circle such that only the centerpoint is full opacity.',
          transition: !0,
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'circle-opacity': {
          type: 'number',
          'doc-en': 'The opacity at which the circle will be drawn.',
          default: 1,
          minimum: 0,
          maximum: 1,
          transition: !0,
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'circle-translate': {
          type: 'array',
          value: 'number',
          length: 2,
          default: [0, 0],
          transition: !0,
          units: 'pixels',
          'doc-en':
            "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'circle-translate-anchor': {
          type: 'enum',
          values: {
            map: { 'doc-en': 'The circle is translated relative to the map.' },
            viewport: { 'doc-en': 'The circle is translated relative to the viewport.' },
          },
          'doc-en': 'Controls the frame of reference for `circle-translate`.',
          default: 'map',
          requires: ['circle-translate'],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'circle-pitch-scale': {
          type: 'enum',
          values: {
            map: {
              'doc-en': 'Circles are scaled according to their apparent distance to the camera.',
            },
            viewport: { 'doc-en': 'Circles are not scaled.' },
          },
          default: 'map',
          'doc-en': 'Controls the scaling behavior of the circle when the map is pitched.',
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'circle-pitch-alignment': {
          type: 'enum',
          values: {
            map: { 'doc-en': 'The circle is aligned to the plane of the map.' },
            viewport: { 'doc-en': 'The circle is aligned to the plane of the viewport.' },
          },
          default: 'viewport',
          'doc-en': 'Orientation of circle when map is pitched.',
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'circle-stroke-width': {
          type: 'number',
          default: 0,
          minimum: 0,
          transition: !0,
          units: 'pixels',
          'doc-en':
            "The width of the circle's stroke. Strokes are placed outside of the `circle-radius`.",
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'circle-stroke-color': {
          type: 'color',
          default: '#000000',
          'doc-en': 'The stroke color of the circle.',
          transition: !0,
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'circle-stroke-opacity': {
          type: 'number',
          'doc-en': "The opacity of the circle's stroke.",
          default: 1,
          minimum: 0,
          maximum: 1,
          transition: !0,
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
      },
      paint_heatmap: {
        'heatmap-height': {
          type: 'number',
          default: 0,
          minimum: 0,
          expression: { interpolated: !1, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'constant',
        },
        'heatmap-radius': {
          type: 'number',
          default: 30,
          minimum: 1,
          transition: !0,
          units: 'pixels',
          'doc-en':
            'Radius of influence of one heatmap point in pixels. Increasing the value makes the heatmap smoother, but less detailed.',
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'heatmap-weight': {
          type: 'number',
          default: 1,
          minimum: 0,
          transition: !1,
          'doc-en':
            'A measure of how much an individual point contributes to the heatmap. A value of 10 would be equivalent to having 10 points of weight 1 in the same spot. Especially useful when combined with clustering.',
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'heatmap-intensity': {
          type: 'number',
          default: 1,
          minimum: 0,
          transition: !0,
          'doc-en':
            'Similar to `heatmap-weight` but controls the intensity of the heatmap globally. Primarily used for adjusting the heatmap based on zoom level.',
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'heatmap-color': {
          type: 'color',
          default: [
            'interpolate',
            ['linear'],
            ['heatmap-density'],
            0,
            'rgba(0, 0, 255, 0)',
            0.1,
            'royalblue',
            0.3,
            'cyan',
            0.5,
            'lime',
            0.7,
            'yellow',
            1,
            'red',
          ],
          'doc-en':
            'Defines the color of each pixel based on its density value in a heatmap.  Should be an expression that uses `["heatmap-density"]` as input.',
          transition: !1,
          expression: { interpolated: !0, parameters: ['heatmap-density'] },
          'property-type': 'color-ramp',
        },
        'heatmap-opacity': {
          type: 'number',
          'doc-en': 'The global opacity at which the heatmap layer will be drawn.',
          default: 1,
          minimum: 0,
          maximum: 1,
          transition: !0,
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'heatmap-height-factor': {
          type: 'number',
          default: 100,
          minimum: 0,
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-driven',
        },
      },
      paint_extrusion: {
        'extrusion-opacity': {
          type: 'number',
          default: 1,
          minimum: 0,
          maximum: 1,
          'doc-en':
            'The opacity of the entire fill extrusion layer. This is rendered on a per-layer, not per-feature, basis, and data-driven styling is not available.',
          transition: !0,
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-driven',
        },
        'extrusion-color': {
          type: 'color',
          default: '#000000',
          'doc-en':
            "The base color of the extruded fill. The extrusion's surfaces will be shaded differently based on this color in combination with the root `light` settings. If this color is specified as `rgba` with an alpha component, the alpha component will be ignored; use `extrusion-opacity` to set layer opacity.",
          transition: !0,
          requires: [{ '!': 'extrusion-pattern' }],
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'extrusion-translate': {
          type: 'array',
          value: 'number',
          length: 2,
          default: [0, 0],
          transition: !0,
          units: 'pixels',
          'doc-en':
            "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-driven',
        },
        'extrusion-translate-anchor': {
          type: 'enum',
          values: {
            map: { 'doc-en': 'The fill-extrusion is translated relative to the map.' },
            viewport: { 'doc-en': 'The fill-extrusion is translated relative to the viewport.' },
          },
          'doc-en': 'Controls the frame of reference for `extrusion-translate`.',
          default: 'map',
          requires: ['extrusion-translate'],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-driven',
        },
        'extrusion-pattern': {
          type: 'resolvedImage',
          transition: !1,
          'doc-en':
            'Name of image in sprite to use for drawing images on extruded fills. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.',
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'cross-faded',
        },
        'extrusion-top-pattern': {
          type: 'resolvedImage',
          transition: !1,
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'cross-faded',
        },
        'extrusion-height': {
          type: 'number',
          default: 0,
          minimum: 0,
          units: 'meters',
          'doc-en': 'The height with which to extrude this layer.',
          transition: !0,
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'extrusion-base': {
          type: 'number',
          default: 0,
          minimum: 0,
          units: 'meters',
          'doc-en':
            'The height with which to extrude the base of this layer. Must be less than or equal to `extrusion-height`.',
          transition: !0,
          requires: ['extrusion-height'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'extrusion-pattern-factor': {
          type: 'array',
          value: 'number',
          length: 2,
          'property-type': 'constant',
        },
        'extrusion-self-bloom': {
          type: 'boolean',
          default: !1,
          'doc-en': 'The  extrude  layer generate bloom by oneself.',
          'property-type': 'data-constant',
        },
        'extrusion-bloom-height': {
          type: 'number',
          default: !1,
          'doc-en': 'Maximum height of self illumination of building white mode',
          'property-type': 'data-constant',
        },
        'extrusion-glow-pure-color-height': {
          type: 'number',
          default: 0.4,
          'doc-en': 'building white mold height to control the building white mold gradient range.',
          'property-type': 'data-constant',
        },
        'extrusion-glow-width': {
          type: 'number',
          default: 0.005,
          'doc-en': 'width of building white mold refresh strip.',
          'property-type': 'data-constant',
        },
        'extrusion-glow-speed': {
          type: 'number',
          default: 12,
          'doc-en': 'speed of building white strip refresh.',
          'property-type': 'data-constant',
        },
        'extrusion-roughness': {
          type: 'number',
          default: 0,
          minimum: 0,
          maximum: 1,
          'doc-en': 'The roughness of the building white mold',
          'property-type': 'data-constant',
        },
      },
      paint_histogram: {
        'histogram-opacity': {
          type: 'number',
          default: 1,
          minimum: 0,
          maximum: 1,
          'doc-en':
            'The opacity of the entire fill histogram layer. This is rendered on a per-layer, not per-feature, basis, and data-driven styling is not available.',
          transition: !0,
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'histogram-color': {
          type: 'color',
          default: '#000000',
          'doc-en':
            "The base color of the extruded fill. The histogram's surfaces will be shaded differently based on this color in combination with the root `light` settings. If this color is specified as `rgba` with an alpha component, the alpha component will be ignored; use `extrusion-opacity` to set layer opacity.",
          transition: !0,
          requires: [{ '!': 'extrusion-pattern' }],
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'histogram-colors': {
          type: 'array',
          value: 'string',
          length: 5,
          default: ['#ffc1e0', '#bbffff', '#00e3e3', '#005757', '#ea0000'],
          requires: [{ '!': 'histogram-color-render' }],
          'doc-en':
            'Histogram segmented color, this parameter has effect only when histogram-color-render is enabled.',
          'property-type': 'data-constant',
        },
        'histogram-translate': {
          type: 'array',
          value: 'number',
          length: 2,
          default: [0, 0],
          transition: !0,
          units: 'pixels',
          'doc-en':
            "The geometry's offset. Values are [x, y] where negatives indicate left and up (on the flat plane), respectively.",
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'histogram-translate-anchor': {
          type: 'enum',
          values: { map: {}, viewport: {} },
          'doc-en': 'Controls the frame of reference for `extrusion-translate`.',
          default: 'map',
          requires: ['extrusion-translate'],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'histogram-height': {
          type: 'number',
          default: 0,
          minimum: 0,
          units: 'meters',
          'doc-en': 'The height with which to extrude this layer.',
          transition: !0,
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'histogram-base': {
          type: 'number',
          default: 0,
          minimum: 0,
          units: 'meters',
          'doc-en':
            'The height with which to extrude the base of this layer. Must be less than or equal to `extrusion-height`.',
          transition: !0,
          requires: ['extrusion-height'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'histogram-vertical-gradient': {
          type: 'boolean',
          default: !0,
          'doc-en':
            'Whether to apply a vertical gradient to the sides of a histogram layer. If true, sides will be shaded slightly darker farther down.',
          transition: !1,
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'histogram-dynamic': {
          type: 'boolean',
          default: !1,
          'doc-en': 'Whether to perform dynamic up and down rendering',
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          expose: !1,
          'property-type': 'data-constant',
        },
        'histogram-heightArr1': {
          type: 'color',
          default: [0, 0, 0, 0],
          'doc-en': 'The first trajectory of dynamic histogram',
          transition: !0,
          units: 'x-color',
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          expose: !1,
          'property-type': 'data-driven',
        },
        'histogram-heightArr2': {
          type: 'color',
          default: [0, 0, 0, 0],
          'doc-en': 'The second trajectory of dynamic histogram',
          transition: !0,
          units: 'x-color',
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          expose: !1,
          'property-type': 'data-driven',
        },
        'histogram-heightArr3': {
          type: 'color',
          default: [0, 0, 0, 0],
          'doc-en': 'The third trajectory of dynamic histogram',
          transition: !0,
          units: 'x-color',
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          expose: !1,
          'property-type': 'data-driven',
        },
        'histogram-speed': {
          type: 'number',
          'doc-en': 'The speed of dynamic up and down rendering',
          default: 1,
          minimum: 1,
          maximum: 1e3,
          transition: !0,
          'property-type': 'data-constant',
        },
        'histogram-count': {
          type: 'number',
          default: 12,
          'doc-en': 'The count of dynamic up and down rendering',
          minimum: 1,
          maximum: 12,
          units: 'millisecond',
          transition: !0,
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'histogram-max-height': {
          type: 'number',
          default: 200,
          minimum: 0,
          units: 'meters',
          'doc-en':
            "The maximum height of the histogram, 'only effective when' histogram-color-render 'is turned on, When this value is identical with 'histostore-height', the column will be equally divided into 4 sections of colors from bottom to top according to the colors specified by 'histostore-colors'",
          'property-type': 'data-constant',
        },
        'depth-change': {
          type: 'boolean',
          default: !1,
          transition: !0,
          'doc-en': 'Turn on or off the transparency gradient from top to bottom',
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-constant',
        },
      },
      paint_dynamicLine: {
        'dynamicLine-opacity': {
          type: 'number',
          'doc-en': 'The opacity at which the dynamicLine will be drawn.',
          default: 1,
          minimum: 0,
          maximum: 1,
          transition: !0,
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'dynamicLine-color': {
          type: 'color',
          'doc-en': 'The color with which the dynamicLine will be drawn.',
          default: '#000000',
          transition: !0,
          requires: [{ '!': 'dynamicLine-pattern' }],
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'dynamicLine-width': {
          type: 'number',
          default: 1,
          minimum: 0,
          transition: !0,
          units: 'pixels',
          'doc-en': 'Stroke thickness.',
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'dynamicLine-gap-width': {
          type: 'number',
          default: 0,
          minimum: 0,
          'doc-en':
            "Draws a line casing outside of a line's actual path. Value indicates the width of the inner gap.",
          transition: !0,
          units: 'pixels',
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
          expose: !1,
        },
        'dynamicLine-blur': {
          type: 'number',
          default: 0,
          minimum: 0,
          transition: !0,
          units: 'pixels',
          'doc-en': 'Blur applied to the line, in pixels.',
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'dynamicLine-seg-group': {
          type: 'number',
          'doc-en':
            'The number of displayed segments of the dynamicLine. When the value is 1, the dynamicLine displays only one segment. The larger the value, the more segments the dynamicLine displays',
          default: 20,
          minimum: 1,
          maximum: 600,
          'property-type': 'constant',
        },
        'dynamicLine-speed': {
          type: 'number',
          'doc-en': 'The moving speed of dynamicLines, the higher the value, the faster the speed',
          default: 1,
          minimum: 1,
          maximum: 500,
          'property-type': 'constant',
        },
      },
      paint_tracking: {
        'tracking-opacity': {
          type: 'number',
          'doc-en': 'The opacity at which the line will be drawn.',
          default: 1,
          minimum: 0,
          maximum: 1,
          transition: !0,
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'tracking-color': {
          type: 'color',
          'doc-en': 'The color with which the line will be drawn.',
          default: '#000000',
          transition: !0,
          requires: [{ '!': 'tracking-pattern' }],
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'tracking-translate': {
          type: 'array',
          value: 'number',
          length: 2,
          default: [0, 0],
          transition: !0,
          units: 'pixels',
          'doc-en':
            "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'tracking-translate-anchor': {
          type: 'enum',
          values: {
            map: { 'doc-en': 'The line is translated relative to the map.' },
            viewport: { 'doc-en': 'The line is translated relative to the viewport.' },
          },
          'doc-en': 'Controls the frame of reference for `tracking-translate`.',
          default: 'map',
          requires: ['tracking-translate'],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
        'tracking-width': {
          type: 'number',
          default: 1,
          minimum: 0,
          transition: !0,
          units: 'pixels',
          'doc-en': 'Stroke thickness.',
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'tracking-gap-width': {
          type: 'number',
          default: 0,
          minimum: 0,
          'doc-en':
            "Draws a line casing outside of a line's actual path. Value indicates the width of the inner gap.",
          transition: !0,
          units: 'pixels',
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'tracking-offset': {
          type: 'number',
          default: 0,
          'doc-en':
            "The line's offset. For linear features, a positive value offsets the line to the right, relative to the direction of the line, and a negative value to the left. For polygon features, a positive value results in an inset, and a negative value results in an outset.",
          transition: !0,
          units: 'pixels',
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'tracking-blur': {
          type: 'number',
          default: 0,
          minimum: 0,
          transition: !0,
          units: 'pixels',
          'doc-en': 'Blur applied to the line, in pixels.',
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'tracking-type': {
          type: 'enum',
          function: 'piecewise-constant',
          values: ['real-time', 'history', 'trips'],
          default: 'real-time',
          'property-type': 'constant',
        },
        'tracking-run-time': {
          type: 'number',
          default: 0,
          minimum: 0,
          'property-type': 'constant',
        },
        'tracking-seg-count': {
          type: 'number',
          function: 'interpolated',
          default: 700,
          minimum: 0,
          maximum: 1e4,
          transition: !0,
          'property-type': 'constant',
        },
        'tracking-seg-group': {
          type: 'number',
          function: 'interpolated',
          default: 20,
          minimum: 1,
          maximum: 600,
          transition: !0,
          'property-type': 'constant',
        },
        'tracking-speed': {
          type: 'number',
          function: 'interpolated',
          default: 1,
          minimum: 1,
          maximum: 500,
          transition: !0,
          'property-type': 'constant',
        },
        'tracking-delay': {
          type: 'number',
          default: 20,
          minimum: 0,
          maximum: 120,
          transition: !0,
          'property-type': 'constant',
        },
        'tracking-speed-factor': {
          type: 'number',
          default: 1,
          minimum: 0,
          function: 'interpolated',
          transition: !0,
          units: 'pixels',
          'property-type': 'constant',
        },
      },
      paint_sprite: {
        'sprite-opacity': {
          type: 'number',
          'doc-en': 'The opacity at which the line will be drawn.',
          default: 1,
          minimum: 0,
          maximum: 1,
          transition: !0,
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'sprite-color': {
          type: 'color',
          'doc-en': 'The color with which the line will be drawn.',
          default: '#000000',
          transition: !0,
          requires: [{ '!': 'sprite-pattern' }],
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'sprite-translate': {
          type: 'array',
          value: 'number',
          length: 2,
          default: [0, 0],
          transition: !0,
          units: 'pixels',
          'doc-en':
            "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-driven',
        },
        'sprite-translate-anchor': {
          type: 'enum',
          values: {
            map: { 'doc-en': 'The line is translated relative to the map.' },
            viewport: { 'doc-en': 'The line is translated relative to the viewport.' },
          },
          'doc-en': 'Controls the frame of reference for `sprite-translate`.',
          default: 'map',
          requires: ['sprite-translate'],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-driven',
        },
        'sprite-width': {
          type: 'number',
          default: 1,
          minimum: 0,
          transition: !0,
          units: 'pixels',
          'doc-en': 'Stroke thickness.',
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'sprite-gap-width': {
          type: 'number',
          default: 0,
          minimum: 0,
          'doc-en':
            "Draws a line casing outside of a line's actual path. Value indicates the width of the inner gap.",
          transition: !0,
          units: 'pixels',
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'sprite-offset': {
          type: 'number',
          default: 0,
          'doc-en':
            "The line's offset. For linear features, a positive value offsets the line to the right, relative to the direction of the line, and a negative value to the left. For polygon features, a positive value results in an inset, and a negative value results in an outset.",
          transition: !0,
          units: 'pixels',
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'sprite-blur': {
          type: 'number',
          default: 0,
          minimum: 0,
          transition: !0,
          units: 'pixels',
          'doc-en': 'Blur applied to the line, in pixels.',
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'sprite-speed-factor': {
          type: 'number',
          default: 1,
          minimum: 0,
          transition: !0,
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'sprite-speed': {
          type: 'number',
          'doc-en': 'Play speed of sprite',
          default: 60,
          minimum: 1e-6,
          maximum: 2e3,
          transition: !0,
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'sprite-pattern': {
          type: 'resolvedImage',
          transition: !0,
          'doc-en':
            'Name of image in sprite to use for drawing image lines. For seamless patterns, image width must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.',
          expression: { interpolated: !1, parameters: ['zoom', 'feature'] },
          'property-type': 'cross-faded-data-driven',
        },
        'sprite-move-direction': {
          type: 'number',
          'doc-en':
            'The direction of Sprite when playing, the number 2 represents the starting point to the end point of road data, and the number 3 represents the starting point to the end point of road data',
          default: 2,
          minimum: 0,
          maximum: 10,
          transition: !0,
          requires: ['sprite-pattern'],
          expression: { interpolated: !1, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'sprite-interpolate': {
          type: 'boolean',
          function: 'piecewise-constant',
          default: !1,
          'property-type': 'data-constant',
        },
        'sprite-status': {
          type: 'number',
          function: 'interpolated',
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          default: 1,
          minimum: 1,
          maximum: 5,
          transition: !0,
          'property-type': 'data-driven',
        },
        'sprite-instatus': {
          type: 'number',
          function: 'interpolated',
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          default: 1,
          minimum: 1,
          maximum: 5,
          transition: !0,
          'property-type': 'data-driven',
        },
        'sprite-height-offset': {
          type: 'number',
          function: 'piecewise-constant',
          default: 0,
          minimum: 0,
          maximum: 100,
          'property-type': 'data-constant',
        },
      },
      'paint_3d-model': {
        '3d-model-opacity': {
          type: 'number',
          default: 1,
          minimum: 0,
          maximum: 1,
          transition: !0,
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
      },
      'paint_3d-tiles': {
        'point-cloud-color': {
          type: 'color',
          'doc-en': 'The color with which the point cloud will be drawn.',
          default: '#000000',
          transition: !0,
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
      },
      paint_panorama: {
        'panorama-opacity': {
          type: 'number',
          default: 1,
          minimum: 0,
          maximum: 1,
          transition: !0,
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
        },
      },
      paint_symtracking: {
        'icon-opacity': {
          'doc-en': 'The opacity at which the icon will be drawn.',
          type: 'number',
          default: 1,
          minimum: 0,
          maximum: 1,
          transition: !0,
          requires: ['icon-image'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'icon-color': {
          type: 'color',
          default: '#000000',
          transition: !0,
          'doc-en': 'The color of the icon. This can only be used with sdf icons.',
          requires: ['icon-image'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'icon-halo-color': {
          type: 'color',
          default: 'rgba(0, 0, 0, 0)',
          transition: !0,
          'doc-en': "The color of the icon's halo. Icon halos can only be used with SDF icons.",
          requires: ['icon-image'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'icon-halo-width': {
          type: 'number',
          default: 0,
          minimum: 0,
          transition: !0,
          units: 'pixels',
          'doc-en': 'Distance of halo to the icon outline.',
          requires: ['icon-image'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'icon-halo-blur': {
          type: 'number',
          default: 0,
          minimum: 0,
          transition: !0,
          units: 'pixels',
          'doc-en': 'Fade out the halo towards the outside.',
          requires: ['icon-image'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
        },
        'icon-translate': {
          type: 'array',
          value: 'number',
          length: 2,
          default: [0, 0],
          transition: !0,
          units: 'pixels',
          'doc-en':
            "Distance that the icon's anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.",
          requires: ['icon-image'],
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
          expose: !1,
        },
        'icon-translate-anchor': {
          type: 'enum',
          values: {
            map: { 'doc-en': 'Icons are translated relative to the map.' },
            viewport: { 'doc-en': 'Icons are translated relative to the viewport.' },
          },
          'doc-en': 'Controls the frame of reference for `icon-translate`.',
          default: 'map',
          requires: ['icon-image', 'icon-translate'],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
          expose: !1,
        },
        'text-opacity': {
          type: 'number',
          'doc-en': 'The opacity at which the text will be drawn.',
          default: 1,
          minimum: 0,
          maximum: 1,
          transition: !0,
          requires: ['text-field'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
          expose: !1,
        },
        'text-color': {
          type: 'color',
          'doc-en': 'The color with which the text will be drawn.',
          default: '#000000',
          transition: !0,
          requires: ['text-field'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
          expose: !1,
        },
        'text-halo-color': {
          type: 'color',
          default: 'rgba(0, 0, 0, 0)',
          transition: !0,
          'doc-en': "The color of the text's halo, which helps it stand out from backgrounds.",
          requires: ['text-field'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
          expose: !1,
        },
        'text-halo-width': {
          type: 'number',
          default: 0,
          minimum: 0,
          transition: !0,
          units: 'pixels',
          'doc-en':
            'Distance of halo to the font outline. Max text halo width is 1/4 of the font-size.',
          requires: ['text-field'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
          expose: !1,
        },
        'text-halo-blur': {
          type: 'number',
          default: 0,
          minimum: 0,
          transition: !0,
          units: 'pixels',
          'doc-en': "The halo's fadeout distance towards the outside.",
          requires: ['text-field'],
          expression: { interpolated: !0, parameters: ['zoom', 'feature', 'feature-state'] },
          'property-type': 'data-driven',
          expose: !1,
        },
        'text-translate': {
          type: 'array',
          value: 'number',
          length: 2,
          default: [0, 0],
          transition: !0,
          units: 'pixels',
          'doc-en':
            "Distance that the text's anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.",
          requires: ['text-field'],
          expression: { interpolated: !0, parameters: ['zoom'] },
          'property-type': 'data-constant',
          expose: !1,
        },
        'text-translate-anchor': {
          type: 'enum',
          values: {
            map: { 'doc-en': 'The text is translated relative to the map.' },
            viewport: { 'doc-en': 'The text is translated relative to the viewport.' },
          },
          'doc-en': 'Controls the frame of reference for `text-translate`.',
          default: 'map',
          requires: ['text-field', 'text-translate'],
          expression: { interpolated: !1, parameters: ['zoom'] },
          'property-type': 'data-constant',
          expose: !1,
        },
        'symtracking-delay': {
          type: 'number',
          default: 10,
          minimum: 0,
          maximum: 120,
          'doc-en':
            'Motion icon update delay, which is the cycle interval time. If the value is 0, there is no interval for the animation cycle. If it is 5, the interval between animation cycles will be 5 seconds.',
          'property-type': 'constant',
        },
      },
      transition: {
        duration: {
          type: 'number',
          default: 300,
          minimum: 0,
          units: 'milliseconds',
          'doc-en': 'Time allotted for transitions to complete.',
        },
        delay: {
          type: 'number',
          default: 0,
          minimum: 0,
          units: 'milliseconds',
          'doc-en': 'Length of time before a transition begins.',
        },
      },
      'property-type': {
        'data-driven': {
          type: 'property-type',
          'doc-en': 'Property is interpolable and can be represented using a property expression.',
        },
        'cross-faded': {
          type: 'property-type',
          'doc-en':
            'Property is non-interpolable; rather, its values will be cross-faded to smoothly transition between integer zooms.',
        },
        'cross-faded-data-driven': {
          type: 'property-type',
          'doc-en':
            'Property is non-interpolable; rather, its values will be cross-faded to smoothly transition between integer zooms. It can be represented using a property expression.',
        },
        'color-ramp': {
          type: 'property-type',
          'doc-en':
            'Property should be specified using a color ramp from which the output color can be sampled based on a property calculation.',
        },
        'data-constant': {
          type: 'property-type',
          'doc-en':
            'Property is interpolable but cannot be represented using a property expression.',
        },
        constant: {
          type: 'property-type',
          'doc-en': 'Property is constant across all zoom levels and property values.',
        },
      },
      promoteId: { '*': { type: 'string' } },
    };
    const fm = new Vd({
      'symbol-placement': new Od(pm.layout_symbol['symbol-placement']),
      'symbol-spacing': new Od(pm.layout_symbol['symbol-spacing']),
      'symbol-avoid-edges': new Od(pm.layout_symbol['symbol-avoid-edges']),
      'symbol-sort-key': new Dd(pm.layout_symbol['symbol-sort-key']),
      'symbol-z-order': new Od(pm.layout_symbol['symbol-z-order']),
      'symbol-height-key': new Od(pm.layout_symbol['symbol-height-key']),
      'symbol-height-offset': new Dd(pm.layout_symbol['symbol-height-offset']),
      'symbol-pick-color': new Od(pm.layout_symbol['symbol-pick-color']),
      'icon-allow-overlap': new Od(pm.layout_symbol['icon-allow-overlap']),
      'icon-ignore-placement': new Od(pm.layout_symbol['icon-ignore-placement']),
      'icon-optional': new Od(pm.layout_symbol['icon-optional']),
      'icon-rotation-alignment': new Od(pm.layout_symbol['icon-rotation-alignment']),
      'icon-size': new Dd(pm.layout_symbol['icon-size']),
      'icon-text-fit': new Od(pm.layout_symbol['icon-text-fit']),
      'icon-text-fit-padding': new Od(pm.layout_symbol['icon-text-fit-padding']),
      'icon-image': new Dd(pm.layout_symbol['icon-image']),
      'icon-rotate': new Dd(pm.layout_symbol['icon-rotate']),
      'icon-padding': new Od(pm.layout_symbol['icon-padding']),
      'icon-keep-upright': new Od(pm.layout_symbol['icon-keep-upright']),
      'icon-offset': new Dd(pm.layout_symbol['icon-offset']),
      'icon-anchor': new Dd(pm.layout_symbol['icon-anchor']),
      'icon-pitch-alignment': new Od(pm.layout_symbol['icon-pitch-alignment']),
      'text-pitch-alignment': new Od(pm.layout_symbol['text-pitch-alignment']),
      'text-rotation-alignment': new Od(pm.layout_symbol['text-rotation-alignment']),
      'text-field': new Dd(pm.layout_symbol['text-field']),
      'text-font': new Dd(pm.layout_symbol['text-font']),
      'text-size': new Dd(pm.layout_symbol['text-size']),
      'text-max-width': new Dd(pm.layout_symbol['text-max-width']),
      'text-line-height': new Od(pm.layout_symbol['text-line-height']),
      'text-letter-spacing': new Dd(pm.layout_symbol['text-letter-spacing']),
      'text-justify': new Dd(pm.layout_symbol['text-justify']),
      'text-anchor': new Dd(pm.layout_symbol['text-anchor']),
      'text-max-angle': new Od(pm.layout_symbol['text-max-angle']),
      'text-rotate': new Dd(pm.layout_symbol['text-rotate']),
      'text-padding': new Od(pm.layout_symbol['text-padding']),
      'text-keep-upright': new Od(pm.layout_symbol['text-keep-upright']),
      'text-transform': new Dd(pm.layout_symbol['text-transform']),
      'text-offset': new Dd(pm.layout_symbol['text-offset']),
      'text-allow-overlap': new Od(pm.layout_symbol['text-allow-overlap']),
      'text-ignore-placement': new Od(pm.layout_symbol['text-ignore-placement']),
      'text-optional': new Od(pm.layout_symbol['text-optional']),
    });
    var mm = {
      paint: new Vd({
        'icon-opacity': new Dd(pm.paint_symbol['icon-opacity']),
        'icon-color': new Dd(pm.paint_symbol['icon-color']),
        'icon-halo-color': new Dd(pm.paint_symbol['icon-halo-color']),
        'icon-halo-width': new Dd(pm.paint_symbol['icon-halo-width']),
        'icon-halo-blur': new Dd(pm.paint_symbol['icon-halo-blur']),
        'icon-translate': new Dd(pm.paint_symbol['icon-translate']),
        'icon-translate-anchor': new Od(pm.paint_symbol['icon-translate-anchor']),
        'text-opacity': new Dd(pm.paint_symbol['text-opacity']),
        'text-color': new Dd(pm.paint_symbol['text-color']),
        'text-halo-color': new Dd(pm.paint_symbol['text-halo-color']),
        'text-halo-width': new Dd(pm.paint_symbol['text-halo-width']),
        'text-halo-blur': new Dd(pm.paint_symbol['text-halo-blur']),
        'text-translate': new Dd(pm.paint_symbol['text-translate']),
        'text-translate-anchor': new Od(pm.paint_symbol['text-translate-anchor']),
      }),
      layout: fm,
    };
    const _m = Gt([
        { name: 'a_POSITION', components: 3, type: 'Float32' },
        { name: 'a_offset', components: 2, type: 'Int16' },
        { name: 'a_data', components: 4, type: 'Uint16' },
        { name: 'a_extra', components: 3, type: 'Uint16' },
      ]),
      gm = Gt(
        [
          { name: 'a_CARTESIAN', components: 3, type: 'Float32' },
          { name: 'a_projected_pos', components: 3, type: 'Float32' },
        ],
        4,
      );
    Gt([{ name: 'a_fade_opacity', components: 1, type: 'Uint32' }], 4);
    const ym = Gt([{ name: 'a_placed', components: 2, type: 'Uint8' }], 4);
    Gt([
      { type: 'Int16', name: 'anchorPointX' },
      { type: 'Int16', name: 'anchorPointY' },
      { type: 'Int16', name: 'x1' },
      { type: 'Int16', name: 'y1' },
      { type: 'Int16', name: 'x2' },
      { type: 'Int16', name: 'y2' },
      { type: 'Uint32', name: 'featureIndex' },
      { type: 'Uint16', name: 'sourceLayerIndex' },
      { type: 'Uint16', name: 'bucketIndex' },
      { type: 'Int16', name: 'radius' },
      { type: 'Int16', name: 'signedDistanceFromAnchor' },
    ]);
    const xm = Gt(
        [
          { name: 'a_POSITION', components: 3, type: 'Float32' },
          { name: 'a_anchor_pos', components: 2, type: 'Int16' },
          { name: 'a_extrude', components: 2, type: 'Int16' },
        ],
        4,
      ),
      vm = Gt(
        [
          { name: 'a_POSITION', components: 3, type: 'Float32' },
          { name: 'a_anchor_pos', components: 2, type: 'Int16' },
          { name: 'a_extrude', components: 2, type: 'Int16' },
        ],
        4,
      );
    Gt([
      { type: 'Int16', name: 'anchorX' },
      { type: 'Int16', name: 'anchorY' },
      { type: 'Uint16', name: 'glyphStartIndex' },
      { type: 'Uint16', name: 'numGlyphs' },
      { type: 'Uint32', name: 'vertexStartIndex' },
      { type: 'Uint32', name: 'lineStartIndex' },
      { type: 'Uint32', name: 'lineLength' },
      { type: 'Uint16', name: 'segment' },
      { type: 'Uint16', name: 'lowerSize' },
      { type: 'Uint16', name: 'upperSize' },
      { type: 'Float32', name: 'lineOffsetX' },
      { type: 'Float32', name: 'lineOffsetY' },
      { type: 'Uint8', name: 'writingMode' },
      { type: 'Uint8', name: 'hidden' },
    ]),
      Gt([{ type: 'Float32', name: 'offsetX' }]),
      Gt([
        { type: 'Int16', name: 'x' },
        { type: 'Int16', name: 'y' },
        { type: 'Int16', name: 'tileUnitDistanceFromAnchor' },
      ]);
    const wm = Qf.VectorTileFeature.types,
      Tm = [{ name: 'a_fade_opacity', components: 1, type: 'Uint8', offset: 0 }];
    function bm(e, t, i, n, r, o, a, s, l, c) {
      e.emplaceBack(
        t.x,
        t.y,
        t.z,
        Math.round(32 * i),
        Math.round(32 * n),
        r,
        o,
        a ? a[0] : 0,
        a ? a[1] : 0,
        s,
        l,
        c || 0,
      );
    }
    class Sm {
      constructor(e) {
        (this.layoutVertexArray = new Qo()),
          (this.indexArray = new ea()),
          (this.programConfigurations = e),
          (this.segments = new Yh()),
          (this.dynamicLayoutVertexArray = new Mo()),
          (this.opacityVertexArray = new Yo()),
          (this.placedSymbolArray = new sa());
      }
      upload(e, t, i, n) {
        i &&
          ((this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, _m.members)),
          (this.indexBuffer = e.createIndexBuffer(this.indexArray, t)),
          (this.dynamicLayoutVertexBuffer = e.createVertexBuffer(
            this.dynamicLayoutVertexArray,
            gm.members,
            !0,
          )),
          (this.opacityVertexBuffer = e.createVertexBuffer(this.opacityVertexArray, Tm, !0)),
          (this.opacityVertexBuffer.itemSize = 1)),
          (i || n) && this.programConfigurations.upload(e);
      }
      destroy() {
        this.layoutVertexBuffer &&
          (this.layoutVertexBuffer.destroy(),
          this.indexBuffer.destroy(),
          this.programConfigurations.destroy(),
          this.segments.destroy(),
          this.dynamicLayoutVertexBuffer.destroy(),
          this.opacityVertexBuffer.destroy());
      }
    }
    fo('SphereSymtrackingBuffers', Sm);
    class Am {
      constructor(e, t, i) {
        (this.layoutVertexArray = new e()),
          (this.layoutAttributes = t),
          (this.indexArray = new i()),
          (this.segments = new Yh()),
          (this.collisionVertexArray = new Xo());
      }
      upload(e) {
        (this.layoutVertexBuffer = e.createVertexBuffer(
          this.layoutVertexArray,
          this.layoutAttributes,
        )),
          (this.indexBuffer = e.createIndexBuffer(this.indexArray)),
          (this.collisionVertexBuffer = e.createVertexBuffer(
            this.collisionVertexArray,
            ym.members,
            !0,
          ));
      }
      destroy() {
        this.layoutVertexBuffer &&
          (this.layoutVertexBuffer.destroy(),
          this.indexBuffer.destroy(),
          this.segments.destroy(),
          this.collisionVertexBuffer.destroy());
      }
    }
    fo('SphereSymtrackingCollisionBuffers', Am);
    class Pm {
      constructor(e) {
        (this.collisionBoxArray = e.collisionBoxArray),
          (this.zoom = e.zoom),
          (this.overscaling = e.overscaling),
          (this.layers = e.layers),
          (this.layerIds = this.layers.map((e) => e.id)),
          (this.index = e.index),
          (this.pixelRatio = e.pixelRatio),
          (this.sourceLayerIndex = e.sourceLayerIndex),
          (this.hasRTLText = !1),
          (this.glyphQuadsArray = []),
          (this.symbolHeightsArray = []),
          (this.type = tm.SYMTRACKING);
        const t = this.layers[0]._unevaluatedLayout._values;
        (this.textSizeData = Rf(this.zoom, t['text-size'])),
          (this.iconSizeData = Rf(this.zoom, t['icon-size']));
        const i = this.layers[0].layout;
        (this.sortFeaturesByY =
          i.get('text-allow-overlap') ||
          i.get('icon-allow-overlap') ||
          i.get('text-ignore-placement') ||
          i.get('icon-ignore-placement')),
          (this.sourceID = e.sourceID),
          (this.projection = e.projection || Ot.MERCATOR);
      }
      createArrays() {
        (this.text = new Sm(new cp(_m.members, this.layers, this.zoom, (e) => /^text/.test(e)))),
          (this.icon = new Sm(new cp(_m.members, this.layers, this.zoom, (e) => /^icon/.test(e)))),
          (this.collisionBox = new Am(Ko, xm.members, ia)),
          (this.collisionCircle = new Am(Ko, vm.members, ea)),
          (this.glyphOffsetArray = new ca()),
          (this.lineVertexArray = new ha());
      }
      calculateGlyphDependencies(e, t, i, n) {
        for (let r = 0; r < e.length; r++)
          if (((t[e.charCodeAt(r)] = !0), i && n)) {
            const i = Jf[e.charAt(r)];
            i && (t[i.charCodeAt(0)] = !0);
          }
      }
      populate(e, t, i) {
        this.referencePoint ||
          ((this.x = t.x),
          (this.y = t.y),
          (this.z = t.z),
          (this.zPow = Math.pow(2, this.z)),
          (this.referencePoint = Xs(this.x, this.y, this.z, this.projection)),
          (this.matrix = new Je()),
          (this.matrix[12] = this.referencePoint[0]),
          (this.matrix[13] = this.referencePoint[1]),
          (this.matrix[14] = this.referencePoint[2]));
        const n = this.layers[0],
          r = n.layout,
          o = r.get('text-font'),
          a = r.get('text-field'),
          s = r.get('icon-image'),
          l =
            ('constant' !== a.value.kind || a.value.value.toString().length > 0) &&
            ('constant' !== o.value.kind || o.value.value.length > 0),
          c = 'constant' !== s.value.kind || (s.value.value && s.value.value.length > 0);
        if (((this.features = []), !l && !c)) return;
        const u = t.iconDependencies,
          h = t.glyphDependencies,
          d = t.availableImages,
          p = new fd(this.zoom);
        for (const { feature: t, index: a, sourceLayerIndex: s } of e) {
          if (!n._featureFilter(p, t)) continue;
          let e, f;
          if (l) {
            const r = n.getValueAndResolveTokens('text-field', t, i, d),
              o = Vi.factory(r);
            o.containsRTLText() && (this.hasRTLText = !0),
              (!this.hasRTLText || 'unavailable' === hd() || (this.hasRTLText && pd.isParsed())) &&
                (e = Gf(o, n, t));
          }
          if (c) {
            const e = n.getValueAndResolveTokens('icon-image', t, i, d);
            f = e instanceof Ui ? e : Ui.fromString(e);
          }
          if (!e && !f) continue;
          const m = {
            text: e,
            icon: f,
            index: a,
            sourceLayerIndex: s,
            geometry: qf(t),
            properties: t.properties,
            type: wm[t.type],
          };
          if (
            (void 0 !== t.id && (m.id = t.id),
            this.features.push(m),
            f && f instanceof Ui && (u[f.name] = !0),
            e)
          ) {
            const i = o.evaluate(t, {}).join(','),
              n = (h[i] = h[i] || {}),
              a =
                'map' === r.get('text-rotation-alignment') && 'point' !== r.get('symbol-placement');
            if (e instanceof Vi)
              for (const t of e.sections) {
                const n = Li(e.toString()),
                  r = t.fontStack || i,
                  o = (h[r] = h[r] || {});
                this.calculateGlyphDependencies(t.text, o, a, n);
              }
            else {
              const t = Li(e);
              this.calculateGlyphDependencies(e, n, a, t);
            }
          }
        }
        'line' === r.get('symbol-placement') && (this.features = Hf(this.features));
      }
      update(e, t) {
        this.stateDependentLayers.length &&
          (this.text.programConfigurations.updatePaintArrays(e, t, this.layers),
          this.icon.programConfigurations.updatePaintArrays(e, t, this.layers));
      }
      isEmpty() {
        return 0 === this.symbolInstances.length && !this.hasRTLText;
      }
      uploadPending() {
        return (
          !this.uploaded ||
          this.text.programConfigurations.needsUpload ||
          this.icon.programConfigurations.needsUpload
        );
      }
      upload(e) {
        this.uploaded || (this.collisionBox.upload(e), this.collisionCircle.upload(e)),
          this.text.upload(
            e,
            this.sortFeaturesByY,
            !this.uploaded,
            this.text.programConfigurations.needsUpload,
          ),
          this.icon.upload(
            e,
            this.sortFeaturesByY,
            !this.uploaded,
            this.icon.programConfigurations.needsUpload,
          ),
          (this.uploaded = !0);
      }
      destroy() {
        this.text.destroy(),
          this.icon.destroy(),
          this.collisionBox.destroy(),
          this.collisionCircle.destroy();
      }
      addToLineVertexArray(e, t) {
        const i = this.lineVertexArray.length;
        if (void 0 !== e.segment) {
          let i = e.dist(t[e.segment + 1]),
            n = e.dist(t[e.segment]);
          const r = {};
          for (let n = e.segment + 1; n < t.length; n++)
            (r[n] = { x: t[n].x, y: t[n].y, tileUnitDistanceFromAnchor: i }),
              n < t.length - 1 && (i += t[n + 1].dist(t[n]));
          for (let i = e.segment || 0; i >= 0; i--)
            (r[i] = { x: t[i].x, y: t[i].y, tileUnitDistanceFromAnchor: n }),
              i > 0 && (n += t[i - 1].dist(t[i]));
          for (let e = 0; e < t.length; e++) {
            const t = r[e];
            this.lineVertexArray.emplaceBack(t.x, t.y, t.tileUnitDistanceFromAnchor);
          }
        }
        return { lineStartIndex: i, lineLength: this.lineVertexArray.length - i };
      }
      addSymbols(e, t, i, n, r, o, a, s, l, c, u) {
        const h = e.indexArray,
          d = e.layoutVertexArray,
          p = e.dynamicLayoutVertexArray,
          f = e.segments.prepareSegment(4 * t.length, e.layoutVertexArray, e.indexArray),
          m = this.glyphOffsetArray.length,
          _ = f.vertexLength;
        for (const e of t) {
          const t = e.tl,
            n = e.tr,
            r = e.bl,
            a = e.br,
            l = e.tex,
            c = f.vertexLength,
            u = e.glyphOffset[1],
            m = this.calcTDSpacePoint(s.x, s.y),
            _ = o.properties;
          let g, y, x;
          _.hasOwnProperty('link_seq')
            ? ((g = _.link_seq), (y = _.link_total || 0), (x = 0))
            : _.hasOwnProperty('link_time') &&
              ((g = _.link_time % 1e4),
              (y = _.link_time_before % 1e4),
              (x = _.link_time_end % 1e4),
              this.timestampExtraData ||
                (this.timestampExtraData = {
                  total_time_end: _.total_time_end % 1e4,
                  total_time_start: _.total_time_start % 1e4,
                })),
            bm(d, m, t.x, u + t.y, l.x, l.y, i, g, y, x),
            bm(d, m, n.x, u + n.y, l.x + l.w, l.y, i, g, y, x),
            bm(d, m, r.x, u + r.y, l.x, l.y + l.h, i, g, y, x),
            bm(d, m, a.x, u + a.y, l.x + l.w, l.y + l.h, i, g, y, x);
          const v = [
            [32 * t.x, 32 * (u + t.y)],
            [32 * n.x, 32 * (u + n.y)],
            [32 * r.x, 32 * (u + r.y)],
            [32 * a.x, 32 * (u + a.y)],
          ];
          cm(
            p,
            s,
            0,
            s,
            1,
            [this.x, this.y, this.z],
            v,
            this.projection,
            this.z,
            this.referencePoint,
            0,
          ),
            h.emplaceBack(c, c + 1, c + 2),
            h.emplaceBack(c + 1, c + 2, c + 3),
            (f.vertexLength += 4),
            (f.primitiveLength += 2),
            this.glyphOffsetArray.emplaceBack(e.glyphOffset[0]),
            this.glyphQuadsArray.push(v),
            this.symbolHeightsArray.push(0);
        }
        e.placedSymbolArray.emplaceBack(
          s.x,
          s.y,
          m,
          this.glyphOffsetArray.length - m,
          _,
          l,
          c,
          s.segment,
          i ? i[0] : 0,
          i ? i[1] : 0,
          n[0],
          n[1],
          a,
          !1,
        ),
          e.programConfigurations.populatePaintArrays(
            e.layoutVertexArray.length,
            o,
            o.index,
            {},
            u,
          );
      }
      _addCollisionDebugVertex(e, t, i, n, r) {
        return (
          t.emplaceBack(0, 0),
          e.emplaceBack(i.x, i.y, i.z, n.x, n.y, Math.round(r.x), Math.round(r.y))
        );
      }
      addCollisionDebugVertices(e, t, i, n, r, o, a, s) {
        const l = r.segments.prepareSegment(4, r.layoutVertexArray, r.indexArray),
          c = l.vertexLength,
          u = r.layoutVertexArray,
          h = r.collisionVertexArray,
          d = this.calcTDSpacePoint(o.x, o.y);
        if (
          (this._addCollisionDebugVertex(u, h, d, a.anchor, new te(e, t)),
          this._addCollisionDebugVertex(u, h, d, a.anchor, new te(i, t)),
          this._addCollisionDebugVertex(u, h, d, a.anchor, new te(i, n)),
          this._addCollisionDebugVertex(u, h, d, a.anchor, new te(e, n)),
          (l.vertexLength += 4),
          s)
        ) {
          const e = r.indexArray;
          e.emplaceBack(c, c + 1, c + 2), e.emplaceBack(c, c + 2, c + 3), (l.primitiveLength += 2);
        } else {
          const e = r.indexArray;
          e.emplaceBack(c, c + 1),
            e.emplaceBack(c + 1, c + 2),
            e.emplaceBack(c + 2, c + 3),
            e.emplaceBack(c + 3, c),
            (l.primitiveLength += 4);
        }
      }
      generateCollisionDebugBuffers() {
        for (const e of this.symbolInstances) {
          (e.textCollisionFeature = {
            boxStartIndex: e.textBoxStartIndex,
            boxEndIndex: e.textBoxEndIndex,
          }),
            (e.iconCollisionFeature = {
              boxStartIndex: e.iconBoxStartIndex,
              boxEndIndex: e.iconBoxEndIndex,
            });
          for (let t = 0; t < 2; t++) {
            const i = e[0 === t ? 'textCollisionFeature' : 'iconCollisionFeature'];
            if (i)
              for (let t = i.boxStartIndex; t < i.boxEndIndex; t++) {
                const i = this.collisionBoxArray.get(t),
                  n = i.radius > 0;
                this.addCollisionDebugVertices(
                  i.x1,
                  i.y1,
                  i.x2,
                  i.y2,
                  n ? this.collisionCircle : this.collisionBox,
                  i.anchorPoint,
                  e,
                  n,
                );
              }
          }
        }
      }
      deserializeCollisionBoxes(e, t, i, n, r) {
        const o = {};
        for (let n = t; n < i; n++) {
          const t = e.get(n);
          if (0 === t.radius) {
            (o.textBox = {
              x1: t.x1,
              y1: t.y1,
              x2: t.x2,
              y2: t.y2,
              anchorPointX: t.anchorPointX,
              anchorPointY: t.anchorPointY,
            }),
              (o.textFeatureIndex = t.featureIndex);
            break;
          }
          o.textCircles || ((o.textCircles = []), (o.textFeatureIndex = t.featureIndex)),
            o.textCircles.push(
              t.anchorPointX,
              t.anchorPointY,
              t.radius,
              t.signedDistanceFromAnchor,
              1,
            );
        }
        for (let t = n; t < r; t++) {
          const i = e.get(t);
          if (0 === i.radius) {
            (o.iconBox = {
              x1: i.x1,
              y1: i.y1,
              x2: i.x2,
              y2: i.y2,
              anchorPointX: i.anchorPointX,
              anchorPointY: i.anchorPointY,
            }),
              (o.iconFeatureIndex = i.featureIndex);
            break;
          }
        }
        return o;
      }
      hasTextData() {
        return this.text.segments.get().length > 0;
      }
      hasIconData() {
        return this.icon.segments.get().length > 0;
      }
      hasCollisionBoxData() {
        return this.collisionBox.segments.get().length > 0;
      }
      hasCollisionCircleData() {
        return this.collisionCircle.segments.get().length > 0;
      }
      sortFeatures(e) {
        if (!this.sortFeaturesByY) return;
        if (this.sortedAngle === e) return;
        if (
          ((this.sortedAngle = e),
          this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)
        )
          return;
        const t = [];
        for (let e = 0; e < this.symbolInstances.length; e++) t.push(e);
        const i = Math.sin(e),
          n = Math.cos(e);
        t.sort((e, t) => {
          const r = this.symbolInstances[e],
            o = this.symbolInstances[t];
          return (
            (0 | Math.round(i * r.anchor.x + n * r.anchor.y)) -
              (0 | Math.round(i * o.anchor.x + n * o.anchor.y)) || o.featureIndex - r.featureIndex
          );
        }),
          this.text.indexArray.clear(),
          this.icon.indexArray.clear(),
          (this.featureSortOrder = []);
        for (const e of t) {
          const t = this.symbolInstances[e];
          this.featureSortOrder.push(t.featureIndex);
          for (const e of t.placedTextSymbolIndices) {
            const t = this.text.placedSymbolArray.get(e),
              i = t.vertexStartIndex + 4 * t.numGlyphs;
            for (let e = t.vertexStartIndex; e < i; e += 4)
              this.text.indexArray.emplaceBack(e, e + 1, e + 2),
                this.text.indexArray.emplaceBack(e + 1, e + 2, e + 3);
          }
          const i = this.icon.placedSymbolArray.get(e);
          if (i.numGlyphs) {
            const e = i.vertexStartIndex;
            this.icon.indexArray.emplaceBack(e, e + 1, e + 2),
              this.icon.indexArray.emplaceBack(e + 1, e + 2, e + 3);
          }
        }
        this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray),
          this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
      }
      calcTDSpacePoint(e, t) {
        const i = qs(this.x + e / 8192, this.y + t / 8192, this.zPow, this.projection),
          n = Il.cartographicToCartesian3(new Pt(i[0], i[1], 0));
        return new te(
          n[0] - this.referencePoint[0],
          n[1] - this.referencePoint[1],
          n[2] - this.referencePoint[2],
        );
      }
    }
    fo('SymtrackingBucket', Pm, {
      omit: ['layers', 'collisionBoxArray', 'features', 'compareText'],
      shallow: ['symbolInstances'],
    }),
      (Pm.MAX_GLYPHS = 65535),
      (Pm.addDynamicAttributes = cm);
    const Em = { horizontal: 1, vertical: 2, horizontalOnly: 3 };
    class Cm {
      constructor() {
        (this.text = ''), (this.sectionIndex = []), (this.sections = []);
      }
      static fromFeature(e, t) {
        const i = new Cm();
        if (e instanceof Vi)
          for (let n = 0; n < e.sections.length; n++) {
            const r = e.sections[n];
            i.sections.push({ scale: r.scale || 1, fontStack: r.fontStack || t }),
              (i.text += r.text);
            for (let e = 0; e < r.text.length; e++) i.sectionIndex.push(n);
          }
        else {
          (i.text = e), i.sections.push({ scale: 1, fontStack: t });
          for (let t = 0; t < e.length; t++) i.sectionIndex.push(0);
        }
        return i;
      }
      length() {
        return this.text.length;
      }
      getSection(e) {
        return this.sections[this.sectionIndex[e]];
      }
      getCharCode(e) {
        return this.text.charCodeAt(e);
      }
      verticalizePunctuation() {
        this.text = (function (e) {
          let t = '';
          for (let i = 0; i < e.length; i++) {
            const n = e.charCodeAt(i + 1) || null,
              r = e.charCodeAt(i - 1) || null;
            t +=
              (n && Oi(n) && !Jf[e[i + 1]]) || (r && Oi(r) && !Jf[e[i - 1]]) || !Jf[e[i]]
                ? e[i]
                : Jf[e[i]];
          }
          return t;
        })(this.text);
      }
      trim() {
        let e = 0;
        for (let t = 0; t < this.text.length && Im[this.text.charCodeAt(t)]; t++) e++;
        let t = this.text.length;
        for (let i = this.text.length - 1; i >= 0 && i >= e && Im[this.text.charCodeAt(i)]; i--)
          t--;
        (this.text = this.text.substring(e, t)),
          (this.sectionIndex = this.sectionIndex.slice(e, t));
      }
      substring(e, t) {
        const i = new Cm();
        return (
          (i.text = this.text.substring(e, t)),
          (i.sectionIndex = this.sectionIndex.slice(e, t)),
          (i.sections = this.sections),
          i
        );
      }
      toString() {
        return this.text;
      }
      getMaxScale() {
        return this.sectionIndex.reduce((e, t) => Math.max(e, this.sections[t].scale), 0);
      }
    }
    function Mm(e, t) {
      const i = [],
        n = e.text;
      let r = 0;
      for (const n of t) i.push(e.substring(r, n)), (r = n);
      return r < n.length && i.push(e.substring(r, n.length)), i;
    }
    const Im = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 },
      Lm = {
        10: !0,
        32: !0,
        38: !0,
        40: !0,
        41: !0,
        43: !0,
        45: !0,
        47: !0,
        173: !0,
        183: !0,
        8203: !0,
        8208: !0,
        8211: !0,
        8231: !0,
      };
    function Rm(e, t, i, n) {
      const r = Math.pow(e - t, 2);
      return n ? (e < t ? r / 2 : 2 * r) : r + Math.abs(i) * i;
    }
    function Nm(e, t) {
      let i = 0;
      return (
        10 === e && (i -= 1e4),
        (40 !== e && 65288 !== e) || (i += 50),
        (41 !== t && 65289 !== t) || (i += 50),
        i
      );
    }
    function Om(e, t, i, n, r, o) {
      let a = null,
        s = Rm(t, i, r, o);
      for (const e of n) {
        const n = Rm(t - e.x, i, r, o) + e.badness;
        n <= s && ((a = e), (s = n));
      }
      return { index: e, x: t, priorBreak: a, badness: s };
    }
    function Dm(e) {
      return e ? Dm(e.priorBreak).concat(e.index) : [];
    }
    function Fm(e, t, i, n) {
      if (!i) return [];
      if (!e) return [];
      const r = [],
        o = (function (e, t, i, n) {
          let r = 0;
          for (let i = 0; i < e.length(); i++) {
            const o = e.getSection(i),
              a = n[o.fontStack],
              s = a && a[e.getCharCode(i)];
            s && (r += s.metrics.advance * o.scale + t);
          }
          return r / Math.max(1, Math.ceil(r / i));
        })(e, t, i, n);
      let a = 0;
      for (let i = 0; i < e.length(); i++) {
        const l = e.getSection(i),
          c = e.getCharCode(i),
          u = n[l.fontStack],
          h = u && u[c];
        h && !Im[c] && (a += h.metrics.advance * l.scale + t),
          i < e.length() - 1 &&
            (Lm[c] ||
              (!((s = c) < 11904) &&
                (Ii['Bopomofo Extended'](s) ||
                  Ii.Bopomofo(s) ||
                  Ii['CJK Compatibility Forms'](s) ||
                  Ii['CJK Compatibility Ideographs'](s) ||
                  Ii['CJK Compatibility'](s) ||
                  Ii['CJK Radicals Supplement'](s) ||
                  Ii['CJK Strokes'](s) ||
                  Ii['CJK Symbols and Punctuation'](s) ||
                  Ii['CJK Unified Ideographs Extension A'](s) ||
                  Ii['CJK Unified Ideographs'](s) ||
                  Ii['Enclosed CJK Letters and Months'](s) ||
                  Ii['Halfwidth and Fullwidth Forms'](s) ||
                  Ii.Hiragana(s) ||
                  Ii['Ideographic Description Characters'](s) ||
                  Ii['Kangxi Radicals'](s) ||
                  Ii['Katakana Phonetic Extensions'](s) ||
                  Ii.Katakana(s) ||
                  Ii['Vertical Forms'](s) ||
                  Ii['Yi Radicals'](s) ||
                  Ii['Yi Syllables'](s)))) &&
            r.push(Om(i + 1, a, o, r, Nm(c, e.getCharCode(i + 1)), !1));
      }
      var s;
      return Dm(Om(e.length(), a, o, r, 0, !0));
    }
    function zm(e) {
      let t = 0.5,
        i = 0.5;
      switch (e) {
        case 'right':
        case 'top-right':
        case 'bottom-right':
          t = 1;
          break;
        case 'left':
        case 'top-left':
        case 'bottom-left':
          t = 0;
      }
      switch (e) {
        case 'bottom':
        case 'bottom-right':
        case 'bottom-left':
          i = 1;
          break;
        case 'top':
        case 'top-right':
        case 'top-left':
          i = 0;
      }
      return { horizontalAlign: t, verticalAlign: i };
    }
    function Bm(e, t, i, n, r) {
      if (!r) return;
      const o = e[n],
        a = t[o.fontStack],
        s = a && a[o.glyph];
      if (s) {
        const t = (e[n].x + s.metrics.advance * o.scale) * r;
        for (let r = i; r <= n; r++) e[r].x -= t;
      }
    }
    const Vm = mm.layout;
    function Um(e, t, i, n, r) {
      const o = new Je();
      return (
        t
          ? (o.scale([1 / r, 1 / r, 1]),
            i || o.rotateZ(-n.getMapViewParams().bearing * Me.TRANSFORM.DEG_TO_RAD))
          : (o.scale([n.width / 2, -n.height / 2, 1]), o.translate([1, -1, 0]), o.multiplyRight(e)),
        o
      );
    }
    function km(e, t) {
      const i = [e.x, e.y, 0, 1];
      Zm(i, i, t);
      const n = i[3];
      return { point: new te(i[0] / n, i[1] / n), signedDistanceFromCamera: n };
    }
    function Gm(e, t) {
      const i = e[0] / e[3],
        n = e[1] / e[3];
      return i >= -t[0] && i <= t[0] && n >= -t[1] && n <= t[1];
    }
    function Hm(e, t, i, n, r, o, a, s, l, c, u, h) {
      const d = s.glyphStartIndex + s.numGlyphs,
        p = s.lineStartIndex,
        f = s.lineStartIndex + s.lineLength,
        m = t.getoffsetX(s.glyphStartIndex),
        _ = t.getoffsetX(d - 1),
        g = jm(e * m, i, n, r, o, a, s.segment, p, f, l, c, u, h);
      if (!g) return null;
      const y = jm(e * _, i, n, r, o, a, s.segment, p, f, l, c, u, h);
      return y ? { first: g, last: y } : null;
    }
    function Ym(e, t, i, n) {
      return e === Em.horizontal && Math.abs(i.y - t.y) > Math.abs(i.x - t.x) * n
        ? { useVertical: !0 }
        : (e === Em.vertical ? t.y < i.y : t.x > i.x)
        ? { needsFlipping: !0 }
        : null;
    }
    function qm(e, t, i, n, r, o, a, s, l, c, u, h, d, p, f, m, _, g, y) {
      const x = t / 24,
        v = e.lineOffsetX * t,
        w = e.lineOffsetY * t,
        T = [],
        b = [];
      let S;
      if (e.numGlyphs > 1) {
        const t = e.glyphStartIndex + e.numGlyphs,
          r = e.lineStartIndex,
          c = e.lineStartIndex + e.lineLength,
          f = Hm(x, s, v, w, i, u, h, e, l, o, d, !1);
        if (!f) return { notEnoughRoom: !0 };
        const m = km(f.first.point, a).point,
          g = km(f.last.point, a).point;
        if (n && !i) {
          const t = Ym(e.writingMode, m, g, p);
          if (t) return t;
        }
        (S = [f.first]), T.push(_[e.glyphStartIndex]), b.push(y[e.glyphStartIndex]);
        for (let n = e.glyphStartIndex + 1; n < t - 1; n++)
          S.push(jm(x * s.getoffsetX(n), v, w, i, u, h, e.segment, r, c, l, o, d, !1)),
            T.push(_[n]),
            b.push(y[n]);
        S.push(f.last), T.push(_[t - 1]), b.push(y[t - 1]);
      } else {
        if (n && !i) {
          const t = km(h, r).point,
            i = e.lineStartIndex + e.segment + 1,
            n = new te(l.getx(i), l.gety(i)),
            o = km(n, r),
            a = o.signedDistanceFromCamera > 0 ? o.point : Xm(h, n, t, 1, r),
            s = Ym(e.writingMode, t, a, p);
          if (s) return s;
        }
        const t = jm(
          x * s.getoffsetX(e.glyphStartIndex),
          v,
          w,
          i,
          u,
          h,
          e.segment,
          e.lineStartIndex,
          e.lineStartIndex + e.lineLength,
          l,
          o,
          d,
          !1,
        );
        if (!t) return { notEnoughRoom: !0 };
        (S = [t]), T.push(_[e.glyphStartIndex]), b.push(y[e.glyphStartIndex]);
      }
      for (let e = 0; e < S.length; e++) {
        const i = S[e],
          n = b[e];
        cm(
          c,
          i.point,
          i.angle,
          i.anchorPoint,
          (t / 15 / f.height) * 822,
          m,
          T[e],
          f.projection,
          f.getMapViewParams().zoom,
          g,
          n,
        );
      }
      return {};
    }
    function Xm(e, t, i, n, r) {
      const o = km(e.add(e.sub(t)._unit()), r).point,
        a = i.sub(o);
      return i.add(a._mult(n / a.mag()));
    }
    function jm(e, t, i, n, r, o, a, s, l, c, u, h, d) {
      const p = n ? e - t : e + t;
      let f = p > 0 ? 1 : -1,
        m = 0;
      n && ((f *= -1), (m = Math.PI)), f < 0 && (m += Math.PI);
      let _ = f > 0 ? s + a : s + a + 1;
      const g = _;
      let y = r,
        x = r,
        v = 0,
        w = 0;
      const T = Math.abs(p);
      for (; v + w <= T; ) {
        if (((_ += f), _ < s || _ >= l)) return null;
        if (((x = y), (y = h[_]), void 0 === y)) {
          const e = new te(c.getx(_), c.gety(_)),
            t = km(e, u);
          if (t.signedDistanceFromCamera > 0) y = h[_] = t.point;
          else {
            const t = _ - f;
            y = Xm(0 === v ? o : new te(c.getx(t), c.gety(t)), e, x, T - v + 1, u);
          }
        }
        (v += w), (w = x.dist(y));
      }
      const b = (T - v) / w,
        S = y.sub(x),
        A = S.mult(b)._add(x);
      return (
        A._add(
          S._unit()
            ._perp()
            ._mult(i * f),
        ),
        {
          point: A,
          angle: m + Math.atan2(y.y - x.y, y.x - x.x),
          anchorPoint: r,
          tileDistance: d
            ? {
                prevTileDistance: _ - f === g ? 0 : c.gettileUnitDistanceFromAnchor(_ - f),
                lastSegmentViewportDistance: T - v,
              }
            : null,
        }
      );
    }
    const Wm = new Float64Array([
      -1 / 0,
      -1 / 0,
      0,
      -1 / 0,
      -1 / 0,
      0,
      -1 / 0,
      -1 / 0,
      0,
      -1 / 0,
      -1 / 0,
      0,
    ]);
    function $m(e, t) {
      for (let i = 0; i < e; i++) {
        const e = t.length;
        t.resize(e + 4), t.float32.set(Wm, 6 * e);
      }
    }
    function Zm(e, t, i) {
      const n = t[0],
        r = t[1];
      return (
        (e[0] = i[0] * n + i[4] * r + i[12]),
        (e[1] = i[1] * n + i[5] * r + i[13]),
        (e[3] = i[3] * n + i[7] * r + i[15]),
        e
      );
    }
    const Km = mm.layout,
      Qm = new $e(),
      Jm = new $e(),
      e_ = new $e();
    class t_ extends Wp {
      tile = void 0;
      constructor(e) {
        super(e),
          (this.layer = e.layer),
          (this.tile = e.tile),
          (this.coord = e.tile.tileID),
          (this._programConfiguration = e.programConfiguration),
          (this._renderState = e.renderState),
          (this.type = e.type),
          (this.isText = e.isText),
          (this.isSDF = e.isSDF),
          (this.modeNum = e.modeNum),
          (this.sizeData = e.sizeData),
          (this.bucket = e.bucket),
          (this.ishalo = !1),
          (this.hasHalo = e.hasHalo),
          (this.size = void 0),
          (this.defines = { SYM_TRACKING: 'symtracking' === this.layer.type }),
          this.#I(e.painter);
      }
      updateDepthTest() {
        this.renderState.depthTest = { enabled: this.layer.depthTest, func: Ll.LESS };
      }
      update(e, t, i = {}) {
        super.update(e, t, i), this.#L(e), this.updateDepthTest();
      }
      #I(e) {
        this._uniforms.set(
          'u_GlUnitsToPixels',
          () => (Qm.set(e.transform.width / 2, -e.transform.height / 2), Qm),
        ),
          this.pushMinimumUniform('u_GlUnitsToPixels'),
          this._uniforms.set('u_pitch_with_map', () =>
            this.isText
              ? 'map' == this.layer.layout.get('text-pitch-alignment')
              : 'map' == this.layer.layout.get('icon-pitch-alignment'),
          ),
          this.pushMinimumUniform('u_pitch_with_map'),
          this._uniforms.set('u_is_text', () => this.isText),
          this.pushMinimumUniform('u_is_text'),
          this._uniforms.set(
            'u_pitch',
            () => e.transform.getMapViewParams().pitch * Me.TRANSFORM.DEG_TO_RAD,
          ),
          this.pushMinimumUniform('u_pitch'),
          this._uniforms.set(
            'u_is_size_zoom_constant',
            () =>
              'constant' === this.sizeData.functionType || 'source' === this.sizeData.functionType,
          ),
          this.pushMinimumUniform('u_is_size_zoom_constant'),
          this._uniforms.set(
            'u_is_size_feature_constant',
            () =>
              'constant' === this.sizeData.functionType || 'camera' === this.sizeData.functionType,
          ),
          this.pushMinimumUniform('u_is_size_feature_constant'),
          this._uniforms.set(
            'u_camera_to_center_distance',
            () => e.transform.cameraToCenterDistance,
          ),
          this._uniforms.set('u_aspect_ratio', () => e.transform.width / e.transform.height),
          this._uniforms.set('u_rotate_symbol', () => {
            const e = 'map' === this.layer.layout.get('icon-rotation-alignment'),
              t = 'map' === this.layer.layout.get('icon-pitch-alignment'),
              i = e && 'point' !== this.layer.layout.get('symbol-placement');
            return e && !t && !i;
          }),
          this.pushMinimumUniform('u_rotate_symbol'),
          this._uniforms.set('u_rotate_with_map', () =>
            this.isText
              ? 'map' == this.layer.layout.get('text-rotation-alignment')
              : 'map' == this.layer.layout.get('icon-rotation-alignment'),
          ),
          this.pushMinimumUniform('u_rotate_with_map'),
          this.isText
            ? (this._uniforms.set(
                'u_BaseColorSampler',
                () => (
                  this.tile.glyphAtlasTexture?.bind(Ll.LINEAR, Ll.CLAMP_TO_EDGE),
                  this.tile.glyphAtlasTexture
                ),
              ),
              this._uniforms.set('u_texsize', () => {
                const e = this.tile.glyphAtlasTexture.size;
                return Jm.set(e[0], e[1]), Jm;
              }))
            : (this._uniforms.set('u_BaseColorSampler', () => {
                const t = e.transform.getMapViewParams().pitch * Me.TRANSFORM.DEG_TO_RAD,
                  i =
                    1 !== this.layer.layout.get('icon-size').constantOr(0) ||
                    this.bucket.iconsNeedLinear,
                  n = 'map' === this.layer.layout.get('icon-pitch-alignment') || 0 !== t;
                return (
                  this.tile.imageAtlasTexture.bind(
                    this.isSDF || e.options.rotating || e.options.zooming || i || n
                      ? Ll.LINEAR
                      : Ll.NEAREST,
                    Ll.CLAMP_TO_EDGE,
                  ),
                  this.tile.imageAtlasTexture
                );
              }),
              this._uniforms.set('u_texsize', () => {
                const e = this.tile.imageAtlasTexture.size;
                return Jm.set(e[0], e[1]), Jm;
              })),
          this.pushMinimumUniform('u_BaseColorSampler'),
          this.pushMinimumUniform('u_texsize'),
          this._uniforms.set('u_fade_change', () =>
            e.options.fadeDuration ? e.symbolFadeChange : 1,
          ),
          this.pushMinimumUniform('u_fade_change'),
          this._uniforms.set('u_is_halo', () => this.ishalo),
          this.pushMinimumUniform('u_is_halo'),
          'symtracking' === this.layer.type &&
            (2 == this.modeNum &&
              (this._uniforms.set('u_timestamp_se', () => {
                const e = this.bucket.timestampExtraData;
                return e_.set(e.total_time_start, e.total_time_end), e_;
              }),
              this.pushMinimumUniform('u_timestamp_se')),
            this._uniforms.set('u_seq', () => (this.layer._count ? this.layer._count : 0)),
            this.pushMinimumUniform('u_seq'),
            this._uniforms.set('u_display_mode', () => this.modeNum),
            this.pushMinimumUniform('u_display_mode'));
      }
      #R(e) {
        const t = this.isText
            ? 'map' == this.layer.layout.get('text-rotation-alignment')
            : 'map' == this.layer.layout.get('icon-rotation-alignment'),
          i = Lf(this.tile, 1, e.transform.getMapViewParams().zoom),
          n = e.transform.calculatePosMatrix(this.tile.tileID.toUnwrapped()),
          r = Um(n, !0, t, e.transform, i),
          o = (function (e, t, i, n, r, o) {
            const a = new Je();
            return (
              a.multiplyRight(e),
              a.scale([r, r, 1]),
              i || a.rotateZ(n.getMapViewParams().bearing * Me.TRANSFORM.DEG_TO_RAD),
              a
            );
          })(n, 0, t, e.transform, i);
        !(function (e, t, i, n, r, o, a, s) {
          const l = n ? e.textSizeData : e.iconSizeData,
            c = Of(
              l,
              i.style.getNearestTileZoom(),
              Vm && Vm.properties && Vm.properties[n ? 'text-size' : 'icon-size'],
            ),
            u = [(256 / i.width) * 2 + 1, (256 / i.height) * 2 + 1],
            h = n ? e.text.dynamicLayoutVertexArray : e.icon.dynamicLayoutVertexArray;
          h.clear();
          const d = e.lineVertexArray,
            p = n ? e.text.placedSymbolArray : e.icon.placedSymbolArray,
            f = e.glyphQuadsArray,
            m = e.symbolHeightsArray,
            _ = i.transform.width / i.transform.height;
          let g = !1;
          for (let n = 0; n < p.length; n++) {
            const a = p.get(n);
            if (a.hidden || (a.writingMode === Em.vertical && !g)) {
              $m(a.numGlyphs, h);
              continue;
            }
            g = !1;
            const y = new Ge([a.anchorX, a.anchorY, 0, 1]);
            if ((y.transform(t), !Gm(y, u))) {
              $m(a.numGlyphs, h);
              continue;
            }
            const x = Nf(l, c, a),
              v = new te(a.anchorX, a.anchorY),
              w = km(v, r).point,
              T = {},
              b = qm(
                a,
                x,
                !1,
                s,
                t,
                r,
                o,
                e.glyphOffsetArray,
                d,
                h,
                w,
                v,
                T,
                _,
                i.transform,
                [e.x, e.y, e.z],
                f,
                e.referencePoint,
                m,
              );
            (g = b.useVertical),
              (b.notEnoughRoom ||
                g ||
                (b.needsFlipping &&
                  qm(
                    a,
                    x,
                    !0,
                    s,
                    t,
                    r,
                    o,
                    e.glyphOffsetArray,
                    d,
                    h,
                    w,
                    v,
                    T,
                    _,
                    i.transform,
                    [e.x, e.y, e.z],
                    f,
                    e.referencePoint,
                    m,
                  ).notEnoughRoom)) &&
                $m(a.numGlyphs, h);
          }
          n
            ? e.text.dynamicLayoutVertexBuffer.updateData(h)
            : e.icon.dynamicLayoutVertexBuffer.updateData(h);
        })(
          this.bucket,
          n,
          e,
          this.isText,
          r,
          o,
          0,
          this.layer.layout.get(this.isText ? 'text-keep-upright' : 'icon-keep-upright'),
        );
      }
      #L(e) {
        const t =
            'map' === this.layer.layout.get('text-rotation-alignment') &&
            'point' !== this.layer.layout.get('symbol-placement'),
          i =
            'map' === this.layer.layout.get('icon-rotation-alignment') &&
            'point' !== this.layer.layout.get('symbol-placement');
        this.isText ? t && this.#R(e) : i && this.#R(e),
          this._uniforms.set('u_along_line', () => (this.isText ? t : i)),
          this.pushMinimumUniform('u_along_line'),
          (this.size = Of(
            this.sizeData,
            e.transform.zoom,
            Km.properties[this.isText ? 'text-size' : 'icon-size'],
          )),
          void 0 !== this.size.uSizeT &&
            (this._uniforms.set('u_size_t', () => this.size.uSizeT),
            this.pushMinimumUniform('u_size_t')),
          void 0 !== this.size.uSize &&
            (this._uniforms.set('u_size', () => this.size.uSize),
            this.pushMinimumUniform('u_size'));
      }
      toPickColor() {
        (this.defines = { PICK_COLOR: !0 }),
          (this.renderState = {
            depthTest: { enabled: !0, func: Ll.LESS },
            blending: {
              color: { red: 0, green: 0, blue: 0, alpha: 0 },
              enabled: !1,
              equationRgb: Ll.FUNC_ADD,
              equationAlpha: Ll.FUNC_ADD,
              functionSourceRgb: Ll.SRC_ALPHA,
              functionSourceAlpha: Ll.ONE,
              functionDestinationRgb: Ll.ONE_MINUS_SRC_ALPHA,
              functionDestinationAlpha: Ll.ONE_MINUS_SRC_ALPHA,
            },
            stencilTest: {
              enabled: !1,
              frontFunction: Ll.ALWAYS,
              backFunction: Ll.ALWAYS,
              reference: 0,
              mask: 0,
              frontOperation: { fail: Ll.KEEP, zFail: Ll.KEEP, zPass: Ll.REPLACE },
              backOperation: { fail: Ll.KEEP, zFail: Ll.KEEP, zPass: Ll.REPLACE },
            },
          });
      }
      fromPickColor() {
        (this.defines = { PICK_COLOR: !1 }), (this.renderState = Wp.getDefaultRenderState());
      }
      destroy() {
        super.destroy(),
          (this.tile = void 0),
          (this.coord = void 0),
          (this._programConfiguration = void 0),
          (this.isText = void 0),
          (this.isSDF = void 0),
          (this.modeNum = void 0),
          (this.sizeData = void 0),
          (this.bucket = void 0);
      }
      static updateSymtrackingLayerProperty(e, t, i) {
        const n = e.layout.get('symtracking-display-mode');
        if (n === Ie.SYMTRACKING_DISPLAY_MODE.DEFAULT) {
          (e._count = e._count ? e._count : 0),
            void 0 === e.first && (e.first = !0),
            (e.startOffset = e.startOffset ? e.startOffset : 0),
            (e.preFps = e.preFps ? e.preFps : 0),
            (e.fpsDifference = e.fpsDifference ? e.fpsDifference : 0),
            (e.fpsOffset = e.fpsOffset ? e.fpsOffset : 0),
            (e.totalFpsOffset = e.totalFpsOffset ? e.totalFpsOffset : 0);
          const i = e.layout.get('symtracking-fps'),
            n = e.layout.get('symtracking-time-segment');
          e.offset = e.paint.get('symtracking-delay');
          const r = i * (n + e.offset);
          e.first &&
            ((e.startOffset = t._map.timer.totalTime * i), (e.first = !1), (e.fpsFirst = i));
          const o = t._map.timer.totalTime;
          e.preFps &&
            e.preFps !== e.layout.get('symtracking-fps') &&
            ((e.fpsDifference = e.layout.get('symtracking-fps') - e.preFps),
            (e.fpsOffset = o * e.fpsDifference),
            (e.totalFpsOffset += e.fpsOffset)),
            (e.preFps = i),
            (e._count = Math.round(o * i - e.startOffset - e.totalFpsOffset)),
            (e._count %= r);
        }
        let r = 0;
        return (
          n === Ie.SYMTRACKING_DISPLAY_MODE.DEFAULT
            ? (r = 0)
            : n === Ie.SYMTRACKING_DISPLAY_MODE.SEQUENCE
            ? ((r = 1), (e._count = t_.calcSymTrackingInterval(i.getSource()._timestamp)))
            : ((r = 2), (e._count = t_.calcSymTrackingTimeStamp(i.getSource()._timestamp))),
          r
        );
      }
      static calcSymTrackingInterval(e) {
        let t = (Date.now() - e) / 1e3;
        return t > 1 ? (t = 1) : t < 0 && (t = 0), t;
      }
      static calcSymTrackingTimeStamp(e) {
        return Date.now() - e;
      }
    }
    const i_ = {
      TERRAIN: 0,
      MINEMAP_3D_TILE: 1,
      BOTH: 2,
      SINGULARIZATION: 3,
      NONE: 4,
      ALL: 5,
      IGNORECLASSIFICATION: 6,
      VECTOR_WITH_HEIGHT: 7,
      FORCE_VECTOR_OVER_MODEL: 8,
    };
    var n_ = Object.freeze(i_);
    function r_(e) {
      return (
        !!t(e) &&
        (e === i_.ALL ||
          e === i_.BOTH ||
          e === i_.TERRAIN ||
          e === i_.MINEMAP_3D_TILE ||
          e === i_.SINGULARIZATION)
      );
    }
    class o_ extends Ta {
      constructor(e) {
        super(),
          (e.modelMatrix = Z(e.modelMatrix, new Je())),
          t(e.id) && (this.customId = e.id),
          (this.id = Z(e.id, de())),
          (this.name = Z(e.name, void 0)),
          (this.skinsIndex = Z(e.skinsIndex, void 0)),
          (this.keepGeometryWhenFree = e.keepGeometryWhenFree),
          (this._geometry = Z(e.geometry, void 0)),
          (this._material = Z(e.material, void 0)),
          (this.framebuffer = Z(e.framebuffer, void 0)),
          (this.properties = Z(e.properties, void 0)),
          (this.castShadow = Z(e.castShadow, void 0)),
          (this.receiveShadow = Z(e.receiveShadow, void 0)),
          (this.clearStates = Z(e.clearStates, void 0)),
          (this.nextShadowVolumePrimitiveIDs = []),
          (this.usedVideoProjection = Z(e.usedVideoProjection, !1)),
          (this._adaptTerrain = Z(e.adaptTerrain, !1)),
          (this.classificationType = this._adaptTerrain ? n_.ALL : e.classificationType || n_.NONE),
          (this._rootId = null),
          (this.pickId = void 0),
          (this._owner = Z(e.owner, void 0)),
          (this.allowPick = Z(e.allowPick, void 0)),
          (this._show = Z(e.show, !0)),
          (this._visible = Z(e.visible, !0)),
          (this.state = th.UNPROCESSING),
          (this._filterPassIds = []),
          (this._oldMatrixWorld = this.matrixWorld.clone()),
          (this.ready = !1),
          (this.animationPropertyCollection = new ju()),
          (this._isPrimitive = !0),
          e.allowPick && (this._owner = this._geometry),
          (this._modelInstanceCollection = void 0),
          e.positions
            ? ((this.positions = e.positions),
              (this.modelInstanceCollection = new Xu({
                instances: Xu.generateInstanceModelMatrix({ positions: e.positions }),
              })))
            : (this.applyMatrix(e.modelMatrix),
              this.updateMatrixWorld(!0),
              (this._modelMatrix = e.modelMatrix)),
          (this.particleSystemInstanceCollection = void 0),
          Z(e.particleSystem, void 0) && (this.particleSystemInstanceCollection = new df()),
          e.adaptTerrain &&
            (this._geometry instanceof Jh || this._geometry instanceof If) &&
            (this._geometry.setAdaptTerrain(e.adaptTerrain),
            (this._material.defines = { SHADOW_VOLUME: e.adaptTerrain }));
        const i = this.matrix.clone(),
          n = this.position.clone(),
          r = Il.eastNorthUpToFixedFrame(n.clone()).invert();
        this.originalRotationScaleMatrix = i.multiplyLeft(r);
      }
      updateMatrixWorld(e) {
        super.updateMatrixWorld(e), this.computeBounding();
      }
      setMatrix(e) {
        e instanceof Je &&
          (this.matrixAutoUpdate && this.updateMatrix(),
          (this.matrix = e),
          this.matrix.decompose(this.position, this.quaternion, this.scale),
          this.updateMatrixWorld(!0),
          (this._modelMatrix = e));
      }
      computeBounding() {
        this._geometry &&
          this._geometry.boundingSphere &&
          (this._geometry.isTileGeometryType
            ? ((this.boundingSphere = gc.clone(this._geometry.boundingSphere)),
              (this.boundingBox = Dc.clone(this._geometry.boundingBox)))
            : ((this.boundingSphere = this._geometry.boundingSphere
                .clone()
                .transform(this.matrixWorld)),
              (this.boundingBox = this._geometry.boundingBox.clone().transform(this.matrixWorld))),
          (this.boundingVolume = Dc.clone(this.boundingBox)));
      }
      get filterPassIds() {
        return this._filterPassIds;
      }
      set filterPassIds(e) {
        for (let t = 0; t < e.length; t++) {
          for (let i = 0; i < this._filterPassIds.length && e[t] !== this._filterPassIds[i]; i++);
          this._filterPassIds.push(e);
        }
      }
      get modelInstanceCollection() {
        return this._modelInstanceCollection;
      }
      set modelInstanceCollection(e) {
        this._modelInstanceCollection = e;
      }
      get adaptTerrain() {
        return this._adaptTerrain;
      }
      set adaptTerrain(e) {
        e !== this._adaptTerrain &&
          ((this._adaptTerrain = e),
          (this._geometry instanceof Jh || this._geometry instanceof If) &&
            (this._geometry.setAdaptTerrain(e), (this._material.defines = { SHADOW_VOLUME: e }))),
          (this.classificationType = this._adaptTerrain
            ? n_.ALL
            : this.classificationType || n_.NONE);
      }
      set color(e) {
        if (e && 'string' != typeof e) this._material.baseColor.set(e[0], e[1], e[2], e[3]);
        else {
          const t = ai.parse(e);
          this._material.baseColor.set(t.r, t.g, t.b, t.a);
        }
      }
      get show() {
        return this._show;
      }
      set show(e) {
        (this._show = e), (this._visible = e);
      }
      get visible() {
        return this._visible;
      }
      set visible(e) {
        (this._visible = e), (this._show = e);
      }
      set rootId(e) {
        this._rootId = e;
      }
      get rootId() {
        return this._rootId;
      }
      get owner() {
        return this._owner;
      }
      set owner(e) {
        this._owner = e;
      }
      update(e, t, i = {}) {
        if (this.show) {
          if (
            (this.pickId ||
              !this.allowPick ||
              this._material instanceof t_ ||
              (this.pickId = e.context.createPickId(this)),
            (i.primitive = this),
            this?.owner?.extra?.batchTable && this.owner.extra.batchTable.update(e, t),
            null != t.overrideMaterial
              ? t.overrideMaterial.update(e, t, i)
              : (this._geometry._usedDoublePrecision &&
                  (this._material.defines = { DOUBLEPRECISION: !0 }),
                this._material.update(e, t, i)),
            this._geometry.update({ painter: e, primitive: this }),
            this.animationModelInstanceCollection)
          )
            this.animationModelInstanceCollection.update({ context: e.context }),
              this.setInstanceProperties();
          else if (
            this.particleSystemInstanceCollection &&
            this.particleSystemInstanceCollection._particleNum
          ) {
            (this._material.defines = { INSTANCE_MATRIX: !0, PARTICLSYSTEM: !0 }),
              this.particleSystemInstanceCollection.update({ context: e.context }),
              this._geometry._segmentVector.destroy();
            const t = new Yh();
            t.pushSegment({
              isInstance: !0,
              indicesCount: this._geometry.indices.length,
              instanceCount: this.particleSystemInstanceCollection._particleNum,
            }),
              (this._geometry._segmentVector = t),
              (this._geometry.instanceVerterBuffers =
                this.particleSystemInstanceCollection._insatnceBuffer);
          }
          if (
            (this._geometry.state === th.PROCESSINGFISH &&
              this._material.state === th.PROCESSINGFISH &&
              (this.ready = !0),
            'PolylineGeometry' === this._geometry.type && this._geometry._ready)
          ) {
            const e = Pt.negate(t.camera.direction, new Pt());
            this._geometry.boundingSphere.computePlaneDistances(
              t.camera.position,
              e,
              this._material._interval,
            );
          }
        }
      }
      render(e, t, i) {
        if (!this.show || !this.ready) return;
        if (!this.allowPick && i.overrideMaterial instanceof uf) return;
        let n = !!i.overrideMaterial;
        this._material instanceof t_ && i.overrideMaterial instanceof uf
          ? ((n = !1), this._material.toPickColor())
          : this._geometry._usedDoublePrecision &&
            (i.overrideMaterial instanceof rf ||
              i.overrideMaterial instanceof hf ||
              i.overrideMaterial instanceof uf)
          ? (i.overrideMaterial.defines = { DOUBLEPRECISION: !0 })
          : !this._geometry._usedDoublePrecision &&
            (i.overrideMaterial instanceof rf ||
              i.overrideMaterial instanceof hf ||
              i.overrideMaterial instanceof uf) &&
            (i.overrideMaterial.defines = { DOUBLEPRECISION: !1 }),
          e.SSRState && this._material._enableSSR && this.setEnableSSRParameter(e),
          e.context.draw({
            painter: e,
            layer: t,
            frameState: i,
            framebuffer: this.framebuffer ? this.framebuffer : i.framebuffer?.framebuffer,
            clearStates: this.clearStates,
            clearColorDepth: this.clearColorDepth,
            geometry: this._geometry,
            material: n ? i.overrideMaterial : this._material,
          }),
          this._material instanceof t_ &&
            i.overrideMaterial instanceof uf &&
            this._material.fromPickColor(),
          e.SSRState && this._material._enableSSR && this.setDisableSSRParameter();
      }
      setEnableSSRParameter(e) {
        (this._material._colorTexture = e.colorTexture),
          (this._material._normalTexture = e.normalTexture),
          (this._material._depthTexture = e.depthTexture),
          (this._material.SSRState = !0),
          (this._material.defines = { EnableSSR: !0 });
      }
      setDisableSSRParameter() {
        (this._material.SSRState = !1), (this._material.defines = { EnableSSR: !1 });
      }
      afterRender(e) {
        var t;
        ('function' == typeof (t = e) ||
          ('object' == typeof t && null !== t && !Array.isArray(t))) &&
          e();
      }
      updateAnimation(e) {
        if (this.animationPropertyCollection && this.animationPropertyCollection.size > 0) {
          const t = this.animationPropertyCollection.getAll();
          1 === t.length
            ? t[0].updateAnimation(this, e)
            : console.warn(`id为"${this.id}"的primitive轨迹动画只能有1个`);
        }
      }
      setInstanceProperties() {
        let e;
        (this._material.defines = { INSTANCE_MATRIX: !0 }),
          (e = this.animationModelInstanceCollection._particleNum
            ? this.animationModelInstanceCollection._particleNum
            : this.animationModelInstanceCollection._instances.size),
          this._geometry._segmentVector && this._geometry._segmentVector.destroy();
        const t = new Yh();
        t.pushSegment({
          isInstance: !0,
          indicesCount: this._geometry.indices.length,
          instanceCount: e,
        }),
          (this._geometry._segmentVector = t),
          (this._geometry.dynamicLayoutBuffer1 =
            this.animationModelInstanceCollection?.instanceBuffer);
      }
      serialize() {
        if (
          t(this.name) &&
          (-1 !== this.name.indexOf('debugVideo_') ||
            -1 !== this.name.indexOf('excavationBody') ||
            -1 !== this.name.indexOf('excavationBottom'))
        )
          return;
        const e = { geometry: this._geometry.serialize(), material: this._material.serialize() };
        return (
          Je.equals(this._modelMatrix, Je.IDENTITY) || (e.modelMatrix = this._modelMatrix),
          t(this.customId) && (e.id = this.customId),
          t(e.geometry) ? e : void 0
        );
      }
      destroy() {
        return (
          this.keepGeometryWhenFree || this?._geometry?.destroy(),
          this?._material?.destroy(),
          (this._material = null),
          (this._geometry = null),
          (this.framebuffer = void 0),
          (this.nextShadowVolumePrimitiveIDs = []),
          (this.clearStates = void 0),
          (this.receiveShadow = !1),
          (this.castShadow = !1),
          (this._owner = null),
          this.pickId && this.pickId.destroy(),
          this.modelInstanceCollection && this.modelInstanceCollection.destroy(),
          this.animationModelInstanceCollection && this.animationModelInstanceCollection.destroy(),
          this.particleSystemInstanceCollection && this.particleSystemInstanceCollection.destroy(),
          (this.animationPropertyCollection = void 0),
          (this._isPrimitive = void 0),
          (this.pickId = null),
          Vc(this)
        );
      }
    }
    class a_ {
      constructor(e) {
        if (!t(e.position)) throw new Error('options.position is required.');
        if (!t(e.normal)) throw new Error('options.normal is required.');
        (this._origin = e.position),
          (this._originModelMatrix = Il.eastNorthUpToFixedFrame(this._origin)),
          (this._relativeDistance = Z(e.distance, 0)),
          (this._relativeNormal = Pt.normalize(new Pt(e.normal), new Pt())),
          this.setReferenceCenter(this._originModelMatrix),
          (this.onChangeCallback = void 0),
          (this.index = -1);
      }
      get position() {
        return this._origin;
      }
      set position(e) {
        e instanceof Pt &&
          (t(this.onChangeCallback) &&
            !Pt.equals(this._origin, e) &&
            this.onChangeCallback(this.index),
          (this._origin = e),
          (this._originModelMatrix = Il.eastNorthUpToFixedFrame(this._origin)),
          this._update());
      }
      get distance() {
        return this._distance;
      }
      set distance(e) {
        Ae(e) &&
          (t(this.onChangeCallback) && e !== this._distance && this.onChangeCallback(this.index),
          (this._relativeDistance = e),
          (this._distance = this._absoluteDistance + this._relativeDistance));
      }
      get normal() {
        return this._normal;
      }
      set normal(e) {
        if (e instanceof Pt) {
          const i = Pt.normalize(new Pt(e), new Pt());
          t(this.onChangeCallback) &&
            !Pt.equals(this._normal, i) &&
            this.onChangeCallback(this.index),
            (this._relativeNormal = i),
            this._update();
        }
      }
      static fromPlane(e, i) {
        if (!(e instanceof Ca)) throw new Error('plane type must be Plane!');
        return (
          t(i)
            ? ((i.normal = e.normal), (i.distance = e.distance))
            : (i = new a_(e.normal, e.distance)),
          i
        );
      }
      static clone(e, i) {
        return t(i)
          ? ((i.normal = e.normal), (i.distance = e.distance), (i.position = e.position), i)
          : new a_({ normal: e.normal, distance: e.distance, position: e.position });
      }
      setReferenceCenter(e) {
        (this._modelMatrix = e.clone()), this._update();
      }
      _update() {
        let e = new Ge(
          this._relativeNormal[0],
          this._relativeNormal[1],
          this._relativeNormal[2],
          1,
        );
        const t = new Je();
        Je.inverse(this._modelMatrix, t);
        const i = new Je();
        t.multiplyRight(this._originModelMatrix, i),
          Je.multiplyByVector(i, e, e),
          (e = new Pt(e[0], e[1], e[2])),
          Pt.subtract(e, new Pt(i.getTranslation()), e),
          (this._normal = Pt.normalize(e, new Pt()));
        const n = new Ge(0, 0, 0, 1);
        Je.multiplyByVector(i, n, n),
          (this._absoluteDistance = Pt.dot(new Pt(-n[0], -n[1], -n[2]), this._normal)),
          (this._distance = this._absoluteDistance + this._relativeDistance);
      }
      serialize() {
        return {
          position: Pt.pack(this.position, new Array(3)),
          normal: Pt.pack(this._relativeNormal, new Array(3)),
          distance: this._relativeDistance,
        };
      }
    }
    function s_(e, t) {
      if (!e) throw new Error(`math.gl assertion failed. ${t}`);
    }
    const l_ = 1 / 256;
    new $e();
    const c_ = new Pt();
    new $e();
    const u_ = new $e(),
      h_ = new Uint8Array(1);
    function d_(e) {
      return (h_[0] = e), h_[0];
    }
    function p_(e, t = 255) {
      return (c(e, 0, t) / t) * 2 - 1;
    }
    function f_(e, t = 255) {
      return Math.round((0.5 * c(e, -1, 1) + 0.5) * t);
    }
    function m_(e) {
      return e < 0 ? -1 : 1;
    }
    function __(e, t, i) {
      const n = e._uint8View,
        r = e._planes;
      let o = 0;
      for (let e = t; e < i; ++e) {
        const t = r[e],
          i =
            ((a = t.normal),
            (s = new Ge()),
            (function (e, t, i) {
              s_(e), s_(i);
              const n = c_.from(e);
              if (
                (s_(Math.abs(n.magnitudeSquared() - 1) <= Me.TRANSFORM.EPSILON6),
                (i.x = e.x / (Math.abs(e.x) + Math.abs(e.y) + Math.abs(e.z))),
                (i.y = e.y / (Math.abs(e.x) + Math.abs(e.y) + Math.abs(e.z))),
                e.z < 0)
              ) {
                const e = i.x,
                  t = i.y;
                (i.x = (1 - Math.abs(t)) * m_(e)), (i.y = (1 - Math.abs(e)) * m_(t));
              }
              (i.x = f_(i.x, 65535)), (i.y = f_(i.y, 65535));
            })(a, 0, u_),
            (s.x = d_(u_.x * l_)),
            (s.y = d_(u_.x)),
            (s.z = d_(u_.y * l_)),
            (s.w = d_(u_.y)),
            s);
        (n[o] = i.x), (n[o + 1] = i.y), (n[o + 2] = i.z), (n[o + 3] = i.w);
        const l = Ge.packFloat(t.distance, new Ge());
        (n[o + 4] = l.x), (n[o + 5] = l.y), (n[o + 6] = l.z), (n[o + 7] = l.w), (o += 8);
      }
      var a, s;
    }
    function g_(e, t) {
      return (t.x = Math.min(e, Uc.maximumTextureSize)), (t.y = Math.ceil(e / t.x)), t;
    }
    function y_(e, t) {
      (e._multipleDirtyPlanes =
        e._multipleDirtyPlanes || (-1 !== e._dirtyIndex && e._dirtyIndex !== t)),
        (e._dirtyIndex = t);
    }
    function x_(e, t) {
      const i = e.length;
      for (let n = 0; n < i; ++n) if (Ca.equals(e[n], t)) return n;
      return -1;
    }
    function v_(e) {
      return e === Aa.OUTSIDE;
    }
    function w_(e) {
      return e === Aa.INSIDE;
    }
    class T_ {
      constructor(e) {
        (e = Z(e, Z.EMPTY_OBJECT)),
          (this._planes = []),
          (this._dirtyIndex = -1),
          (this._multipleDirtyPlanes = !1),
          (this._enabled = Z(e.enabled, !0)),
          (this.modelMatrix = Je.clone(Z(e.modelMatrix, Je.IDENTITY), new Je())),
          (this.edgeColor = ai.clone(Z(e.edgeColor, ai.white))),
          (this.edgeWidth = Z(e.edgeWidth, 0)),
          (this.planeAdded = new ya()),
          (this.planeRemoved = new ya()),
          (this._owner = void 0);
        const i = Z(e.unionClippingRegions, !0);
        (this._unionClippingRegions = i),
          (this._testIntersection = i ? v_ : w_),
          (this._uint8View = void 0),
          (this._float32View = void 0),
          (this._clippingPlanesTexture = void 0);
        const n = e.planes;
        if (t(n)) {
          const e = n.length;
          for (let t = 0; t < e; ++t) this.add(n[t]);
        }
      }
      get length() {
        return this._planes.length;
      }
      get unionClippingRegions() {
        return this._unionClippingRegions;
      }
      set unionClippingRegions(e) {
        this._unionClippingRegions !== e &&
          ((this._unionClippingRegions = e), (this._testIntersection = e ? v_ : w_));
      }
      get enabled() {
        return this._enabled;
      }
      set enabled(e) {
        this._enabled !== e && (this._enabled = e);
      }
      get texture() {
        return this._clippingPlanesTexture;
      }
      get owner() {
        return this._owner;
      }
      get clippingPlanesState() {
        return this._unionClippingRegions ? this._planes.length : -this._planes.length;
      }
      add(e) {
        const t = this._planes.length,
          i = this;
        (e.onChangeCallback = function (e) {
          y_(i, e);
        }),
          (e.index = t),
          y_(this, t),
          e.setReferenceCenter(this.modelMatrix),
          this._planes.push(e),
          this.planeAdded.fire(e, t);
      }
      get(e) {
        if (Ae(e)) return this._planes[e];
      }
      contains(e) {
        return -1 !== x_(this._planes, e);
      }
      remove(e) {
        const t = this._planes,
          i = x_(t, e);
        if (-1 === i) return !1;
        e instanceof a_ && ((e.onChangeCallback = void 0), (e.index = -1));
        const n = t.length - 1;
        for (let e = i; e < n; ++e) {
          const i = t[e + 1];
          (t[e] = i), i instanceof a_ && (i.index = e);
        }
        return (this._multipleDirtyPlanes = !0), (t.length = n), this.planeRemoved.fire(e, i), !0;
      }
      removeAll() {
        const e = this._planes,
          t = e.length;
        for (let i = 0; i < t; ++i) {
          const t = e[i];
          t instanceof a_ && ((t.onChangeCallback = void 0), (t.index = -1)),
            this.planeRemoved.fire(t, i);
        }
        (this._multipleDirtyPlanes = !0), (this._planes = []);
      }
      update(e) {
        let i = this._clippingPlanesTexture;
        const n = e.context,
          r = 2 * this.length;
        if (t(i)) {
          const e = i.width * i.height;
          (e < r || r < 0.25 * e) &&
            (i.destroy(), (i = void 0), (this._clippingPlanesTexture = void 0));
        }
        if (0 === this.length) return;
        if (!t(i)) {
          const e = g_(r, new $e());
          (e.y *= 2),
            (i = new Pu({
              context: n,
              width: e.x,
              height: e.y,
              pixelFormat: Qc.RGBA,
              pixelDatatype: Zc.UNSIGNED_BYTE,
              sampler: jc.NEAREST,
              flipY: !1,
            })),
            (this._uint8View = new Uint8Array(e.x * e.y * 4)),
            (this._clippingPlanesTexture = i),
            (this._multipleDirtyPlanes = !0);
        }
        const o = this._dirtyIndex;
        if (this._multipleDirtyPlanes || -1 !== o) {
          if (this._multipleDirtyPlanes)
            __(this, 0, this._planes.length),
              i.copyFrom({
                source: { width: i.width, height: i.height, arrayBufferView: this._uint8View },
              });
          else {
            let e = 0,
              t = 0;
            (t = Math.floor((2 * o) / i.width)),
              (e = Math.floor(2 * o - t * i.width)),
              __(this, o, o + 1),
              i.copyFrom({
                source: { width: 2, height: 1, arrayBufferView: this._uint8View },
                xOffset: e,
                yOffset: t,
              });
          }
          (this._multipleDirtyPlanes = !1), (this._dirtyIndex = -1);
        }
      }
      computeIntersectionWithBoundingVolume(e, i) {
        const n = this._planes,
          r = n.length;
        let o = this.modelMatrix;
        t(i) && (o = Je.multiply(i, o, new Je()));
        let a = Aa.INSIDE;
        !this.unionClippingRegions && r > 0 && (a = Aa.OUTSIDE);
        const s = new Ca(Pt.UNIT_X, 0);
        for (let t = 0; t < r; ++t) {
          Ca.transform(n[t], o, s);
          const i = e.intersectPlane(s);
          if (i === Aa.INTERSECTING) a = i;
          else if (this._testIntersection(i)) return i;
        }
        return a;
      }
      static setOwner(e, i, n) {
        if (e !== i[n] && ((i[n] = i[n] && i[n].destroy()), t(e))) {
          if (t(e._owner))
            throw new Error('ClippingPlaneCollection should only be assigned to one object');
          (e._owner = i), (i[n] = e);
        }
      }
      static useFloatTexture(e) {
        return e.floatingPointTexture;
      }
      static getTextureResolution(e) {
        const i = new $e(),
          n = e.texture;
        if (t(n)) return (i.x = n.width), (i.y = n.height), i;
        const r = g_(2 * e.length, i);
        return (r.y *= 2), r;
      }
      serialize() {
        const e = [];
        for (let t = 0; t < this.length; t++) e.push(this.get(t).serialize());
        return {
          modelMatrix: Je.pack(this.modelMatrix, new Array(16)),
          edgeColor: ai.pack(this.edgeColor, new Array(4)),
          edgeWidth: this.edgeWidth,
          enabled: this.enabled,
          unionClippingRegions: this.unionClippingRegions,
          planes: e,
        };
      }
      destroy() {
        return (
          (this._clippingPlanesTexture =
            this._clippingPlanesTexture && this._clippingPlanesTexture.destroy()),
          Vc(this)
        );
      }
    }
    var b_ = Object.freeze({ NONE: 0, PHONG: 1, PBR: 2 });
    class S_ {
      constructor(e, t, i, n) {
        (this.message = (e ? `${e}: ` : '') + i),
          n && (this.identifier = n),
          null != t && t.__line__ && (this.line = t.__line__);
      }
    }
    function A_(e) {
      const t = e.value;
      return t ? [new S_(e.key, t, 'constants have been deprecated as of v8')] : [];
    }
    function P_(e) {
      return e instanceof Number || e instanceof String || e instanceof Boolean ? e.valueOf() : e;
    }
    function E_(e) {
      if (Array.isArray(e)) return e.map(E_);
      if (
        e instanceof Object &&
        !(e instanceof Number || e instanceof String || e instanceof Boolean)
      ) {
        const t = {};
        for (const i in e) t[i] = E_(e[i]);
        return t;
      }
      return P_(e);
    }
    function C_(e) {
      const t = e.key,
        i = e.value,
        n = e.valueSpec || {},
        r = e.objectElementValidators || {},
        o = e.style,
        a = e.styleSpec;
      let s = [];
      const l = qr(i);
      if ('object' !== l) return [new S_(t, i, `object expected, ${l} found`)];
      for (const e in i) {
        const l = e.split('.')[0],
          c = n[l] || n['*'];
        let u;
        if (r[l]) u = r[l];
        else if (n[l]) u = ig;
        else if (r['*']) u = r['*'];
        else {
          if (!n['*']) {
            s.push(new S_(t, i[e], `unknown property "${e}"`));
            continue;
          }
          u = ig;
        }
        s = s.concat(
          u(
            {
              key: (t ? `${t}.` : t) + e,
              value: i[e],
              valueSpec: c,
              style: o,
              styleSpec: a,
              object: i,
              objectKey: e,
            },
            i,
          ),
        );
      }
      for (const e in n)
        r[e] ||
          (n[e].required &&
            void 0 === n[e].default &&
            void 0 === i[e] &&
            s.push(new S_(t, i, `missing required property "${e}"`)));
      return s;
    }
    function M_(e) {
      const t = e.value,
        i = e.valueSpec,
        n = e.style,
        r = e.styleSpec,
        o = e.key,
        a = e.arrayElementValidator || ig;
      if ('array' !== qr(t)) return [new S_(o, t, `array expected, ${qr(t)} found`)];
      if (i.length && t.length !== i.length)
        return [new S_(o, t, `array length ${i.length} expected, length ${t.length} found`)];
      if (i['min-length'] && t.length < i['min-length'])
        return [
          new S_(
            o,
            t,
            `array length at least ${i['min-length']} expected, length ${t.length} found`,
          ),
        ];
      let s = { type: i.value };
      r.$version < 7 && (s.function = i.function), 'object' === qr(i.value) && (s = i.value);
      let l = [];
      for (let e = 0; e < t.length; e++)
        l = l.concat(
          a({
            array: t,
            arrayIndex: e,
            value: t[e],
            valueSpec: s,
            style: n,
            styleSpec: r,
            key: `${o}[${e}]`,
          }),
        );
      return l;
    }
    function I_(e) {
      const t = e.key,
        i = e.value,
        n = e.valueSpec,
        r = qr(i);
      return 'number' !== r
        ? [new S_(t, i, `number expected, ${r} found`)]
        : 'minimum' in n && i < n.minimum
        ? [new S_(t, i, `${i} is less than the minimum value ${n.minimum}`)]
        : 'maximum' in n && i > n.maximum
        ? [new S_(t, i, `${i} is greater than the maximum value ${n.maximum}`)]
        : [];
    }
    function L_(e) {
      const t = e.valueSpec,
        i = P_(e.value.type);
      let n,
        r,
        o,
        a = {};
      const s = 'categorical' !== i && void 0 === e.value.property,
        l = !s,
        c =
          'array' === qr(e.value.stops) &&
          'array' === qr(e.value.stops[0]) &&
          'object' === qr(e.value.stops[0][0]),
        u = C_({
          key: e.key,
          value: e.value,
          valueSpec: e.styleSpec.function,
          style: e.style,
          styleSpec: e.styleSpec,
          objectElementValidators: {
            stops: function (e) {
              if ('identity' === i)
                return [
                  new S_(e.key, e.value, 'identity function may not have a "stops" property'),
                ];
              let t = [];
              const n = e.value;
              return (
                (t = t.concat(
                  M_({
                    key: e.key,
                    value: n,
                    valueSpec: e.valueSpec,
                    style: e.style,
                    styleSpec: e.styleSpec,
                    arrayElementValidator: h,
                  }),
                )),
                'array' === qr(n) &&
                  0 === n.length &&
                  t.push(new S_(e.key, n, 'array must have at least one stop')),
                t
              );
            },
            default: function (e) {
              return ig({
                key: e.key,
                value: e.value,
                valueSpec: t,
                style: e.style,
                styleSpec: e.styleSpec,
              });
            },
          },
        });
      return (
        'identity' === i &&
          s &&
          u.push(new S_(e.key, e.value, 'missing required property "property"')),
        'identity' === i ||
          e.value.stops ||
          u.push(new S_(e.key, e.value, 'missing required property "stops"')),
        'exponential' === i &&
          e.valueSpec.expression &&
          !Cr(e.valueSpec) &&
          u.push(new S_(e.key, e.value, 'exponential functions not supported')),
        e.styleSpec.$version >= 8 &&
          (l && !Pr(e.valueSpec)
            ? u.push(new S_(e.key, e.value, 'property functions not supported'))
            : s &&
              !Er(e.valueSpec) &&
              u.push(new S_(e.key, e.value, 'zoom functions not supported'))),
        ('categorical' !== i && !c) ||
          void 0 !== e.value.property ||
          u.push(new S_(e.key, e.value, '"property" property is required')),
        u
      );
      function h(e) {
        let i = [];
        const n = e.value,
          s = e.key;
        if ('array' !== qr(n)) return [new S_(s, n, `array expected, ${qr(n)} found`)];
        if (2 !== n.length)
          return [new S_(s, n, `array length 2 expected, length ${n.length} found`)];
        if (c) {
          if ('object' !== qr(n[0])) return [new S_(s, n, `object expected, ${qr(n[0])} found`)];
          if (void 0 === n[0].zoom) return [new S_(s, n, 'object stop key must have zoom')];
          if (void 0 === n[0].value) return [new S_(s, n, 'object stop key must have value')];
          if (o && o > P_(n[0].zoom))
            return [new S_(s, n[0].zoom, 'stop zoom values must appear in ascending order')];
          P_(n[0].zoom) !== o && ((o = P_(n[0].zoom)), (r = void 0), (a = {})),
            (i = i.concat(
              C_({
                key: `${s}[0]`,
                value: n[0],
                valueSpec: { zoom: {} },
                style: e.style,
                styleSpec: e.styleSpec,
                objectElementValidators: { zoom: I_, value: d },
              }),
            ));
        } else i = i.concat(d({ key: `${s}[0]`, value: n[0], valueSpec: {}, style: e.style, styleSpec: e.styleSpec }, n));
        return i.concat(
          ig({ key: `${s}[1]`, value: n[1], valueSpec: t, style: e.style, styleSpec: e.styleSpec }),
        );
      }
      function d(e, o) {
        const s = qr(e.value),
          l = P_(e.value),
          c = null !== e.value ? e.value : o;
        if (n) {
          if (s !== n)
            return [
              new S_(e.key, c, `${s} stop domain type must match previous stop domain type ${n}`),
            ];
        } else n = s;
        if ('number' !== s && 'string' !== s && 'boolean' !== s)
          return [new S_(e.key, c, 'stop domain value must be a number, string, or boolean')];
        if ('number' !== s && 'categorical' !== i) {
          let n = `number expected, ${s} found`;
          return (
            Pr(t) &&
              void 0 === i &&
              (n +=
                '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'),
            [new S_(e.key, c, n)]
          );
        }
        return 'categorical' !== i || 'number' !== s || (isFinite(l) && Math.floor(l) === l)
          ? 'categorical' !== i && 'number' === s && void 0 !== r && l < r
            ? [new S_(e.key, c, 'stop domain values must appear in ascending order')]
            : ((r = l),
              'categorical' === i && l in a
                ? [new S_(e.key, c, 'stop domain values must be unique')]
                : ((a[l] = !0), []))
          : [new S_(e.key, c, `integer expected, found ${l}`)];
      }
    }
    function R_(e) {
      const t = ('property' === e.expressionContext ? ao : no)(E_(e.value), e.valueSpec);
      return 'error' === t.result
        ? t.value.map((t) => new S_(`${e.key}${t.key}`, e.value, t.message))
        : 'property' === e.expressionContext &&
          'text-font' === e.propertyKey &&
          -1 !== t.value._styleExpression.expression.possibleOutputs().indexOf(void 0)
        ? [
            new S_(
              e.key,
              e.value,
              'Invalid data expression for "text-font". Output values must be contained as literals within the expression.',
            ),
          ]
        : 'property' !== e.expressionContext ||
          'layout' !== e.propertyType ||
          En(t.value._styleExpression.expression)
        ? []
        : [
            new S_(
              e.key,
              e.value,
              '"feature-state" data expressions are not supported with layout properties.',
            ),
          ];
    }
    function N_(e) {
      const t = e.key,
        i = e.value,
        n = e.valueSpec,
        r = [];
      return (
        Array.isArray(n.values)
          ? -1 === n.values.indexOf(P_(i)) &&
            r.push(
              new S_(t, i, `expected one of [${n.values.join(', ')}], ${JSON.stringify(i)} found`),
            )
          : -1 === Object.keys(n.values).indexOf(P_(i)) &&
            r.push(
              new S_(
                t,
                i,
                `expected one of [${Object.keys(n.values).join(', ')}], ${JSON.stringify(i)} found`,
              ),
            ),
        r
      );
    }
    function O_(e) {
      if (!0 === e || !1 === e) return !0;
      if (!Array.isArray(e) || 0 === e.length) return !1;
      switch (e[0]) {
        case 'has':
          return e.length >= 2 && '$id' !== e[1] && '$type' !== e[1];
        case 'in':
          return e.length >= 3 && ('string' != typeof e[1] || Array.isArray(e[2]));
        case '!in':
        case '!has':
        case 'none':
        case '!arrin':
        case 'arrin':
        case 'like':
        case '!like':
          return !1;
        case '==':
        case '!=':
        case '>':
        case '>=':
        case '<':
        case '<=':
        case 'start':
        case 'end':
          return 3 !== e.length || Array.isArray(e[1]) || Array.isArray(e[2]);
        case 'any':
        case 'all':
          for (const t of e.slice(1)) if (!O_(t) && 'boolean' != typeof t) return !1;
          return !0;
        default:
          return !0;
      }
    }
    const D_ = {
      type: 'boolean',
      default: !1,
      transition: !1,
      'property-type': 'data-driven',
      expression: { interpolated: !1, parameters: ['zoom', 'feature'] },
    };
    function F_(e) {
      if (!e) return () => !0;
      O_(e) || (e = B_(e));
      const t = no(e, D_);
      if ('error' === t.result)
        throw new Error(t.value.map((e) => `${e.key}: ${e.message}`).join(', '));
      return (e, i, n) => t.value.evaluate(e, i, {}, n);
    }
    function z_(e, t) {
      return e < t ? -1 : e > t ? 1 : 0;
    }
    function B_(e) {
      if (!e) return !0;
      const t = e[0];
      return e.length <= 1
        ? 'any' !== t
        : '==' === t
        ? V_(e[1], e[2], '==')
        : '!=' === t
        ? Y_(V_(e[1], e[2], '=='))
        : '<' === t || '>' === t || '<=' === t || '>=' === t
        ? V_(e[1], e[2], t)
        : 'any' === t
        ? ((i = e.slice(1)), ['any'].concat(i.map(B_)))
        : 'all' === t
        ? ['all'].concat(e.slice(1).map(B_))
        : 'none' === t
        ? ['all'].concat(e.slice(1).map(B_).map(Y_))
        : 'in' === t
        ? U_(e[1], e.slice(2))
        : '!in' === t
        ? Y_(U_(e[1], e.slice(2)))
        : 'has' === t
        ? H_(e[1])
        : '!has' === t
        ? Y_(H_(e[1]))
        : 'arrin' === t
        ? k_(e[1], e.slice(2))
        : '!arrin' === t
        ? Y_(k_(e[1], e.slice(2)))
        : 'like' === t
        ? G_(e[1], e.slice(2))
        : '!like' === t
        ? Y_(G_(e[1], e.slice(2)))
        : 'within' !== t || e;
      var i;
    }
    function V_(e, t, i) {
      switch (e) {
        case '$type':
          return [`filter-type-${i}`, t];
        case '$id':
          return [`filter-id-${i}`, t];
        default:
          return [`filter-${i}`, e, t];
      }
    }
    function U_(e, t) {
      if (0 === t.length) return !1;
      switch (e) {
        case '$type':
          return ['filter-type-in', ['literal', t]];
        case '$id':
          return ['filter-id-in', ['literal', t]];
        default:
          return t.length > 200 && !t.some((e) => typeof e != typeof t[0])
            ? ['filter-in-large', e, ['literal', t.sort(z_)]]
            : ['filter-in-small', e, ['literal', t]];
      }
    }
    function k_(e, t) {
      return (
        0 !== t.length &&
        ('$type' === e
          ? ['filter-type-arrin', ['literal', t]]
          : ['filter-arrin', e, ['literal', t]])
      );
    }
    function G_(e, t) {
      return (
        0 !== t.length &&
        ('$type' === e ? ['filter-type-like', ['literal', t]] : ['filter-like', e, ['literal', t]])
      );
    }
    function H_(e) {
      switch (e) {
        case '$type':
          return !0;
        case '$id':
          return ['filter-has-id'];
        default:
          return ['filter-has', e];
      }
    }
    function Y_(e) {
      return ['!', e];
    }
    function q_(e) {
      return O_(E_(e.value))
        ? R_(si({}, e, { expressionContext: 'filter', valueSpec: { value: 'boolean' } }))
        : X_(e);
    }
    function X_(e) {
      const t = e.value,
        i = e.key;
      if ('array' !== qr(t)) return [new S_(i, t, `array expected, ${qr(t)} found`)];
      const n = e.styleSpec;
      let r,
        o = [];
      if (t.length < 1) return [new S_(i, t, 'filter array must have at least 1 element')];
      switch (
        ((o = o.concat(
          N_({
            key: `${i}[0]`,
            value: t[0],
            valueSpec: n.filter_operator,
            style: e.style,
            styleSpec: e.styleSpec,
          }),
        )),
        P_(t[0]))
      ) {
        case '<':
        case '<=':
        case '>':
        case '>=':
          t.length >= 2 &&
            '$type' === P_(t[1]) &&
            o.push(new S_(i, t, `"$type" cannot be use with operator "${t[0]}"`));
        case '==':
        case '!=':
          3 !== t.length &&
            o.push(new S_(i, t, `filter array for operator "${t[0]}" must have 3 elements`));
        case 'in':
        case '!in':
          t.length >= 2 &&
            ((r = qr(t[1])),
            'string' !== r && o.push(new S_(`${i}[1]`, t[1], `string expected, ${r} found`)));
          for (let a = 2; a < t.length; a++)
            (r = qr(t[a])),
              '$type' === P_(t[1])
                ? (o = o.concat(
                    N_({
                      key: `${i}[${a}]`,
                      value: t[a],
                      valueSpec: n.geometry_type,
                      style: e.style,
                      styleSpec: e.styleSpec,
                    }),
                  ))
                : 'string' !== r &&
                  'number' !== r &&
                  'boolean' !== r &&
                  o.push(
                    new S_(`${i}[${a}]`, t[a], `string, number, or boolean expected, ${r} found`),
                  );
          break;
        case 'like':
        case '!like':
          t.length >= 2 &&
            ((r = qr(t[1])),
            'string' !== r && o.push(new S_(`${i}[1]`, t[1], `string expected, ${r} found`)));
          for (let a = 2; a < t.length; a++)
            (r = qr(t[a])),
              '$type' === P_(t[1])
                ? (o = o.concat(
                    N_({
                      key: `${i}[${a}]`,
                      value: t[a],
                      valueSpec: n.geometry_type,
                      style: e.style,
                      styleSpec: e.styleSpec,
                    }),
                  ))
                : 'string' !== r &&
                  'number' !== r &&
                  'boolean' !== r &&
                  o.push(
                    new S_(`${i}[${a}]`, t[a], `string, number, or boolean expected, ${r} found`),
                  );
          break;
        case 'any':
        case 'all':
        case 'none':
          for (let n = 1; n < t.length; n++)
            o = o.concat(
              X_({ key: `${i}[${n}]`, value: t[n], style: e.style, styleSpec: e.styleSpec }),
            );
          break;
        case 'has':
        case '!has':
          (r = qr(t[1])),
            2 !== t.length
              ? o.push(new S_(i, t, `filter array for "${t[0]}" operator must have 2 elements`))
              : 'string' !== r && o.push(new S_(`${i}[1]`, t[1], `string expected, ${r} found`));
          break;
        case 'within':
          (r = qr(t[1])),
            2 !== t.length
              ? o.push(new S_(i, t, `filter array for "${t[0]}" operator must have 2 elements`))
              : 'object' !== r && o.push(new S_(`${i}[1]`, t[1], `object expected, ${r} found`));
      }
      return o;
    }
    function j_(e, t) {
      const i = e.key,
        n = e.style,
        r = e.styleSpec,
        o = e.value,
        a = e.objectKey,
        s = r[`${t}_${e.layerType}`];
      if (!s) return [];
      const l = a.match(/^(.*)-transition$/);
      if ('paint' === t && l && s[l[1]] && s[l[1]].transition)
        return ig({ key: i, value: o, valueSpec: r.transition, style: n, styleSpec: r });
      const c = e.valueSpec || s[a];
      if (!c) return [new S_(i, o, `unknown property "${a}"`)];
      let u;
      if ('string' === qr(o) && Pr(c) && !c.tokens && (u = /^{([^}]+)}$/.exec(o)))
        return [
          new S_(
            i,
            o,
            `"${a}" does not support interpolation syntax\nUse an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(
              u[1],
            )} }\`.`,
          ),
        ];
      const h = [];
      return (
        'symbol' === e.layerType &&
          ('text-field' === a &&
            n &&
            !n.glyphs &&
            h.push(new S_(i, o, 'use of "text-field" requires a style "glyphs" property')),
          'text-font' === a &&
            Xr(E_(o)) &&
            'identity' === P_(o.type) &&
            h.push(new S_(i, o, '"text-font" does not support identity functions'))),
        h.concat(
          ig({
            key: e.key,
            value: o,
            valueSpec: c,
            style: n,
            styleSpec: r,
            expressionContext: 'property',
            propertyType: t,
            propertyKey: a,
          }),
        )
      );
    }
    function W_(e) {
      return j_(e, 'paint');
    }
    function $_(e) {
      return j_(e, 'layout');
    }
    function Z_(e) {
      let t = [];
      const i = e.value,
        n = e.key,
        r = e.style,
        o = e.styleSpec;
      i.type || i.ref || t.push(new S_(n, i, 'either "type" or "ref" is required'));
      let a = P_(i.type);
      const s = P_(i.ref);
      if (i.id) {
        const o = P_(i.id);
        for (let a = 0; a < e.arrayIndex; a++) {
          const e = r.layers[a];
          P_(e.id) === o &&
            t.push(
              new S_(
                n,
                i.id,
                `duplicate layer id "${i.id}", previously used at line ${e.id.__line__}`,
              ),
            );
        }
      }
      if ('ref' in i) {
        let e;
        ['type', 'source', 'source-layer', 'filter', 'layout'].forEach((e) => {
          e in i && t.push(new S_(n, i[e], `"${e}" is prohibited for ref layers`));
        }),
          r.layers.forEach((t) => {
            P_(t.id) === s && (e = t);
          }),
          e
            ? e.ref
              ? t.push(new S_(n, i.ref, 'ref cannot reference another ref layer'))
              : (a = P_(e.type))
            : t.push(new S_(n, i.ref, `ref layer "${s}" not found`));
      } else if ('background' !== a)
        if (i.source) {
          const e = r.sources && r.sources[i.source],
            o = e && P_(e.type);
          e
            ? 'vector' === o && 'raster' === a
              ? t.push(new S_(n, i.source, `layer "${i.id}" requires a raster source`))
              : 'raster' === o && 'raster' !== a
              ? t.push(new S_(n, i.source, `layer "${i.id}" requires a vector source`))
              : 'vector' !== o || i['source-layer']
              ? 'line' !== a ||
                !i.paint ||
                !i.paint['line-gradient'] ||
                ('geojson' === o && e.lineMetrics) ||
                t.push(
                  new S_(
                    n,
                    i,
                    `layer "${i.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`,
                  ),
                )
              : t.push(new S_(n, i, `layer "${i.id}" must specify a "source-layer"`))
            : t.push(new S_(n, i.source, `source "${i.source}" not found`));
        } else t.push(new S_(n, i, 'missing required property "source"'));
      return (
        (t = t.concat(
          C_({
            key: n,
            value: i,
            valueSpec: o.layer,
            style: e.style,
            styleSpec: e.styleSpec,
            objectElementValidators: {
              '*': () => [],
              type: () =>
                ig({
                  key: `${n}.type`,
                  value: i.type,
                  valueSpec: o.layer.type,
                  style: e.style,
                  styleSpec: e.styleSpec,
                  object: i,
                  objectKey: 'type',
                }),
              filter: q_,
              layout: (e) =>
                C_({
                  layer: i,
                  key: e.key,
                  value: e.value,
                  style: e.style,
                  styleSpec: e.styleSpec,
                  objectElementValidators: { '*': (e) => $_(si({ layerType: a }, e)) },
                }),
              paint: (e) =>
                C_({
                  layer: i,
                  key: e.key,
                  value: e.value,
                  style: e.style,
                  styleSpec: e.styleSpec,
                  objectElementValidators: { '*': (e) => W_(si({ layerType: a }, e)) },
                }),
            },
          }),
        )),
        t
      );
    }
    function K_(e) {
      const t = e.value,
        i = e.key,
        n = qr(t);
      return 'string' !== n ? [new S_(i, t, `string expected, ${n} found`)] : [];
    }
    const Q_ = {
      promoteId: function ({ key: e, value: t }) {
        if ('string' === qr(t)) return K_({ key: e, value: t });
        {
          const i = [];
          for (const n in t) i.push(...K_({ key: `${e}.${n}`, value: t[n] }));
          return i;
        }
      },
    };
    function J_(e) {
      const t = e.value,
        i = e.key,
        n = e.styleSpec,
        r = e.style;
      if (!t.type) return [new S_(i, t, '"type" is required')];
      const o = P_(t.type);
      let a = [];
      switch (o) {
        case 'vector':
        case 'raster':
        case 'raster-dem':
          if (
            ((a = a.concat(
              C_({
                key: i,
                value: t,
                valueSpec: n[`source_${o.replace('-', '_')}`],
                style: e.style,
                styleSpec: n,
                objectElementValidators: Q_,
              }),
            )),
            'url' in t)
          )
            for (const e in t)
              ['type', 'url', 'tileSize'].indexOf(e) < 0 &&
                a.push(
                  new S_(
                    `${i}.${e}`,
                    t[e],
                    `a source with a "url" property may not include a "${e}" property`,
                  ),
                );
          return a;
        case 'geojson':
          return C_({
            key: i,
            value: t,
            valueSpec: n.source_geojson,
            style: r,
            styleSpec: n,
            objectElementValidators: Q_,
          });
        case 'video':
          return C_({ key: i, value: t, valueSpec: n.source_video, style: r, styleSpec: n });
        case 'image':
          return C_({ key: i, value: t, valueSpec: n.source_image, style: r, styleSpec: n });
        case 'canvas':
          return (
            a.push(
              new S_(
                i,
                null,
                'Please use runtime APIs to add canvas sources, rather than including them in stylesheets.',
                'source.canvas',
              ),
            ),
            a
          );
        case 'sphere-image':
        case '3d-model':
        case '3d-tiles':
          return [];
        default:
          return N_({
            key: `${i}.type`,
            value: t.type,
            valueSpec: { values: ['vector', 'raster', 'raster-dem', 'geojson', 'video', 'image'] },
            style: r,
            styleSpec: n,
          });
      }
    }
    function eg(e) {
      const t = e.value,
        i = e.styleSpec,
        n = i.light,
        r = e.style;
      let o = [];
      const a = qr(t);
      if (void 0 === t) return o;
      if ('object' !== a)
        return (o = o.concat([new S_('light', t, `object expected, ${a} found`)])), o;
      for (const e in t) {
        const a = e.match(/^(.*)-transition$/);
        o = o.concat(
          a && n[a[1]] && n[a[1]].transition
            ? ig({ key: e, value: t[e], valueSpec: i.transition, style: r, styleSpec: i })
            : n[e]
            ? ig({ key: e, value: t[e], valueSpec: n[e], style: r, styleSpec: i })
            : [new S_(e, t[e], `unknown property "${e}"`)],
        );
      }
      return o;
    }
    const tg = {
      '*': () => [],
      any: () => [],
      array: M_,
      boolean: function (e) {
        const t = e.value,
          i = e.key,
          n = qr(t);
        return 'boolean' !== n ? [new S_(i, t, `boolean expected, ${n} found`)] : [];
      },
      number: I_,
      color: function (e) {
        const t = e.key,
          i = e.value,
          n = qr(i);
        return 'string' !== n
          ? [new S_(t, i, `color expected, ${n} found`)]
          : null === ti(i)
          ? [new S_(t, i, `color expected, "${i}" found`)]
          : [];
      },
      constants: A_,
      enum: N_,
      filter: q_,
      function: L_,
      layer: Z_,
      object: C_,
      source: J_,
      light: eg,
      string: K_,
      formatted: function (e) {
        return 0 === K_(e).length ? [] : R_(e);
      },
      resolvedImage: function (e) {
        return 0 === K_(e).length ? [] : R_(e);
      },
    };
    function ig(e) {
      const t = e.value,
        i = e.valueSpec,
        n = e.styleSpec;
      if (i.expression && Xr(P_(t))) return L_(e);
      if (i.expression && io(E_(t))) return R_(e);
      if (i.type && tg[i.type]) return tg[i.type](e);
      {
        const t = C_(si({}, e, { valueSpec: i.type ? n[i.type] : i }));
        return t || ve('not valid'), t;
      }
    }
    function ng(e) {
      const t = e.value,
        i = e.key,
        n = K_(e);
      return (
        n.length ||
          (-1 === t.indexOf('{fontstack}') &&
            n.push(new S_(i, t, '"glyphs" url must include a "{fontstack}" token')),
          -1 === t.indexOf('{range}') &&
            n.push(new S_(i, t, '"glyphs" url must include a "{range}" token'))),
        n
      );
    }
    function rg(e, t) {
      let i = [];
      return (
        (i = i.concat(
          ig({
            key: '',
            value: e,
            valueSpec: (t = t || pm).$root,
            styleSpec: t,
            style: e,
            objectElementValidators: { glyphs: ng, '*': () => [] },
          }),
        )),
        e.constants &&
          (i = i.concat(A_({ key: 'constants', value: e.constants, style: e, styleSpec: t }))),
        og(i)
      );
    }
    function og(e) {
      return [].concat(e).sort((e, t) => e.line - t.line);
    }
    function ag(e) {
      return function () {
        return og(e.apply(this, arguments));
      };
    }
    (rg.source = ag(J_)),
      (rg.light = ag(eg)),
      (rg.layer = ag(Z_)),
      (rg.filter = ag(q_)),
      (rg.paintProperty = ag(W_)),
      (rg.layoutProperty = ag($_));
    const sg = rg,
      lg = rg.paintProperty,
      cg = rg.layoutProperty;
    function ug(e, t) {
      let i = !1;
      if (t && t.length) for (const n of t) e.fire(new ga(new Error(n.message))), (i = !0);
      return i;
    }
    const hg = '-transition';
    class dg extends ya {
      constructor(e, t) {
        if ((super(), (this.id = e.id), (this._featureFilter = () => !0), 'custom' !== e.type)) {
          if (
            ((this.metadata = e.metadata),
            (this.type = e.type),
            (this.minzoom = e.minzoom),
            (this.maxzoom = e.maxzoom),
            (this.visibility = 'visible'),
            (this.depthTest = e['depth-test'] || !1),
            'background' !== e.type &&
              ((this.source = e.source),
              (this.sourceLayer = e['source-layer']),
              (this.filter = e.filter)),
            t && t.layout && (this._unevaluatedLayout = new Ld(t.layout)),
            t && t.paint)
          ) {
            this._transitionablePaint = new Cd(t.paint);
            for (const t in e.paint) this.setPaintProperty(t, e.paint[t], { validate: !1 });
            for (const t in e.layout) this.setLayoutProperty(t, e.layout[t], { validate: !1 });
            this._transitioningPaint = this._transitionablePaint.untransitioned();
          }
          ('3d-model' !== e.type && '3d-tiles' !== e.type && 'extrusion' !== e.type) ||
            ((this.lightingModel = Z(e.lightingModel, b_.NONE)),
            (this.phongLightConfig = e.phongLightConfig),
            (this.clippingPlanes = e.clippingPlanes)),
            ('circle' === e.type ||
              'line' === e.type ||
              'fill' === e.type ||
              'extrusion' === e.type ||
              'heatmap' === e.type ||
              'sprite' === e.type ||
              ('symbol' === e.type && e.classificationType === n_.FORCE_VECTOR_OVER_MODEL)) &&
              (this.classificationType = e.classificationType);
        }
      }
      getLayoutProperty(e) {
        return 'visibility' === e ? this.visibility : this._unevaluatedLayout.getValue(e);
      }
      setLayoutProperty(e, t, i) {
        (null != t && this._validate(cg, `layers.${this.id}.layout.${e}`, e, t, i)) ||
          ('visibility' !== e
            ? this._unevaluatedLayout.setValue(e, t)
            : (this.visibility = 'none' === t ? t : 'visible'));
      }
      getPaintProperty(e) {
        return me(e, hg)
          ? this._transitionablePaint.getTransition(e.slice(0, -11))
          : this._transitionablePaint.getValue(e);
      }
      setPaintProperty(e, t, i) {
        if (null != t && this._validate(lg, `layers.${this.id}.paint.${e}`, e, t, i)) return !1;
        if (me(e, hg))
          return this._transitionablePaint.setTransition(e.slice(0, -11), t || void 0), !1;
        {
          const i = this._transitionablePaint._values[e],
            n = i.value.isDataDriven(),
            r = i.value;
          this._transitionablePaint.setValue(e, t), this._handleSpecialPaintPropertyUpdate(e);
          const o = this._transitionablePaint._values[e].value,
            a = o.isDataDriven(),
            s = me(e, 'pattern') || 'line-dasharray' === e;
          return a || n || s || this._handleOverridablePaintPropertyUpdate(e, r, o);
        }
      }
      _handleSpecialPaintPropertyUpdate(e) {}
      _handleOverridablePaintPropertyUpdate(e, t, i) {
        return t.value !== i.value;
      }
      isHidden(e, t) {
        return this.minzoom > t || this.maxzoom <= e || 'none' === this.visibility;
      }
      isHiddenByMapZoom(e) {
        return (
          !!(this.minzoom && e < this.minzoom) ||
          !!(this.maxzoom && e >= this.maxzoom) ||
          'none' === this.visibility
        );
      }
      updateTransitions(e) {
        this._transitioningPaint = this._transitionablePaint.transitioned(
          e,
          this._transitioningPaint,
        );
      }
      hasTransition() {
        return this._transitioningPaint.hasTransition();
      }
      recalculate(e, t) {
        this._unevaluatedLayout &&
          (this.layout = this._unevaluatedLayout.possiblyEvaluate(e, void 0, t)),
          (this.paint = this._transitioningPaint.possiblyEvaluate(e, void 0, t));
      }
      serialize() {
        const e = {
          id: this.id,
          type: this.type,
          source: this.source,
          'source-layer': this.sourceLayer,
          metadata: this.metadata,
          minzoom: this.minzoom,
          maxzoom: this.maxzoom,
          filter: this.filter,
          _original_style: this._original_style,
          layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
          paint: this._transitionablePaint && this._transitionablePaint.serialize(),
          enableQuery: this.enableQuery,
          vectorRenderInSpace: this.vectorRenderInSpace,
          classificationType: this.classificationType,
        };
        return (
          'none' === this.visibility &&
            ((e.layout = e.layout || {}), (e.layout.visibility = 'none')),
          ge(
            e,
            (e, t) =>
              !(
                void 0 === e ||
                ('layout' === t && !Object.keys(e).length) ||
                ('paint' === t && !Object.keys(e).length)
              ),
          )
        );
      }
      _validate(e, t, i, n, r) {
        return (
          (!r || !1 !== r.validate) &&
          ug(
            this,
            e.call(sg, {
              key: t,
              layerType: this.type,
              objectKey: i,
              value: n,
              styleSpec: pm,
              style: { glyphs: !0, sprite: !0 },
            }),
          )
        );
      }
      hasOffscreenPass() {
        return !1;
      }
      resize() {}
      isStateDependent() {
        for (const e in this.paint._values) {
          const t = this.paint.get(e);
          if (
            t instanceof Rd &&
            Pr(t.property.specification) &&
            ('source' === t.value.kind || 'composite' === t.value.kind) &&
            t.value.isStateDependent
          )
            return !0;
        }
        return !1;
      }
      clearPick() {}
    }
    var pg = {
        paint: new Vd({
          'background-color': new Od(pm.paint_background['background-color']),
          'background-pattern': new zd(pm.paint_background['background-pattern']),
          'background-pattern-fixed': new Od(pm.paint_background['background-pattern-fixed']),
          'background-opacity': new Od(pm.paint_background['background-opacity']),
          'background-terrain-analysis': new Dd(pm.paint_background['background-terrain-analysis']),
        }),
      },
      fg = {
        paint: new Vd({
          'raster-opacity': new Od(pm.paint_raster['raster-opacity']),
          'raster-hue-rotate': new Od(pm.paint_raster['raster-hue-rotate']),
          'raster-brightness-min': new Od(pm.paint_raster['raster-brightness-min']),
          'raster-brightness-max': new Od(pm.paint_raster['raster-brightness-max']),
          'raster-saturation': new Od(pm.paint_raster['raster-saturation']),
          'raster-contrast': new Od(pm.paint_raster['raster-contrast']),
          'raster-resampling': new Od(pm.paint_raster['raster-resampling']),
          'raster-fade-duration': new Od(pm.paint_raster['raster-fade-duration']),
        }),
      };
    class mg {
      constructor() {}
      static setPhongLightUniform(e) {
        const { material: t, phongLightConfig: i } = e,
          n = Object.assign(
            {
              Ambient: pm.phongLightConfig.Ambient.default,
              Diffuse: pm.phongLightConfig.Diffuse.default,
              SpecularColor: pm.phongLightConfig.SpecularColor.default,
              Shininess: pm.phongLightConfig.Shininess.default,
            },
            i,
          ),
          { Ambient: r, Diffuse: o, SpecularColor: a, Shininess: s } = n;
        t._uniforms.set('u_LightMaterial', {
          Ambient: () => new Pt(r, r, r),
          Diffuse: () => new Pt(o, o, o),
          SpecularColor: () => new Pt(a, a, a),
          Shininess: () => s,
        });
      }
    }
    class _g extends Wp {
      constructor(e) {
        super(e),
          (this.frame = void 0),
          (this._texType = Z(e.texType, void 0)),
          (this._flowOptions = void 0);
      }
      update(e, t, i = {}) {
        super.update(e, t, i);
      }
      #E(e) {
        this._uniforms.set('u_TexOffsetScale', () => {
          const t = new Ge(0, 0, 1, 1);
          return (
            e && e.texCoordOffset && e.texCoordOffset[0] && (t.x = e.texCoordOffset[0]),
            e && e.texCoordOffset && e.texCoordOffset[1] && (t.y = e.texCoordOffset[1]),
            e && e.texCoordRepeat && e.texCoordRepeat[0] && (t.z = e.texCoordRepeat[0]),
            e && e.texCoordRepeat && e.texCoordRepeat[1] && (t.w = e.texCoordRepeat[1]),
            t
          );
        }),
          this._uniforms.set('u_TexRotate', () => {
            const t = new Pt(0.5, 0.5, 0);
            return (
              e && e.texCoordCenter && e.texCoordCenter[0] && (t.x = e.texCoordCenter[0]),
              e && e.texCoordCenter && e.texCoordCenter[1] && (t.y = e.texCoordCenter[1]),
              e && e.texCoordRotation && (t.z = e.texCoordRotation * Me.TRANSFORM.DEG_TO_RAD),
              t
            );
          });
      }
      flowTexture(e) {
        e.speed || (e.speed = 1),
          e.rotation || (e.rotation = 0),
          e.direction || (e.direction = 'right'),
          e.texRepeat || (e.repeat = [0, 0]),
          e.speed > 10 && (e.speed = 10),
          e.speed < 1 && (e.speed = 1);
        const t = 50 / e.speed,
          i = new Ge(0, 0, 1, 1),
          n = Date.now(),
          r = this;
        (r._flowOptions = e),
          (function o() {
            if (Date.now() - n >= t) {
              switch ((i.x > 1 && (i.x = i.x - 1), i.y > 1 && (i.y = i.y - 1), e.direction)) {
                case 'right':
                  i.x = i.x - 1 / 60 + 1;
                  break;
                case 'left':
                default:
                  i.x += 1 / 60;
                  break;
                case 'up':
                  i.y = i.y - 1 / 60 + 1;
                  break;
                case 'down':
                  i.y += 1 / 60;
              }
              r.#E({
                texCoordCenter: [0.5, 0.5],
                texCoordRotation: e.rotation,
                texCoordOffset: [i.x, i.y],
                texCoordRepeat: e.texRepeat,
              });
            }
            r.frame && J.cancelAnimationFrame(r.frame), (r.frame = J.requestAnimationFrame(o));
          })();
      }
      updateTexture(e, t) {
        let i;
        switch (e) {
          case 'Color':
            i = _g.fromType('Color', {
              color: t.baseColor,
              opacity: t.opacity,
              lightingModel: t.lightingModel,
              doubleSided: t.doubleSided,
            });
            break;
          case 'Texture':
            i = _g.fromType('Texture', {
              baseColorTexture: t.baseColorTexture,
              opacity: t.opacity,
              lightingModel: t.lightingModel,
              doubleSided: t.doubleSided,
            });
        }
        return i;
      }
      updateProperty(e) {
        if (e.color) {
          const t = ai.parse(e.color);
          this._uniforms.set('u_Color', () => Ge.fromColor(t, !1));
        }
        e.baseColorTexture &&
          (this._uniforms.set('u_BaseColorSampler', () =>
            _g.bindTextureSampler(e.baseColorTexture),
          ),
          _g.buildDefines(this, e)),
          e.opacity && this._uniforms.set('u_Opacity', () => e.opacity),
          this.#E(e);
      }
      static buildDefines(e, t = {}) {
        const i = {};
        (i.PHONG_LIGHT = t.phongLight), (i.HAS_BASECOLORMAP = t.hasBaseColorMap), (e.defines = i);
      }
      get texType() {
        return this._texType;
      }
      set texType(e) {
        this._texType = e;
      }
      static fromType(e, t) {
        const i = _g.getPresetMaterial(e, t),
          n = new _g({
            renderState: t.renderState ? t.renderState : i.renderState,
            defines: t.defines,
            type: 'StandardMaterial',
            texType: e,
            baseColorTexture: i.baseColorTexture,
            color: i.color,
            doubleSided: i.doubleSided,
            opacity: i.opacity,
            lightingModel: i.lightingModel,
          });
        _g.buildDefines(n, i.microDefineOptions), mg.setPhongLightUniform({ material: n });
        for (const e in i.uniforms) n._uniforms.set(`u_${e}`, i.uniforms[e]);
        return n.#E(null), n;
      }
      static bindTextureSampler(e) {
        return (
          (e.sampler = {
            minificationFilter: e.minFilter || Ll.LINEAR_MIPMAP_NEAREST,
            magnificationFilter: e.magFilter || Ll.LINEAR,
            wrapS: e.wrapS || Ll.REPEAT,
            wrapT: e.wrapT || Ll.REPEAT,
          }),
          e
        );
      }
      static getPresetMaterial(e, t) {
        const i = Z(t?.lightingModel, b_.PHONG),
          n = {
            renderState: Wp.getDefaultRenderState(),
            videoOptions: {},
            uniforms: {},
            microDefineOptions: {
              phongLight: i === b_.PHONG,
              hasBaseColorMap: Z(!!t.baseColorTexture, !1),
            },
            color: void 0,
            opacity: void 0,
          };
        (n.renderState.polygonOffset = { enabled: !0, factor: 1, units: 1 }),
          (n.renderState.cull.enabled = Z(!t.doubleSided, !0));
        const r = Z(t?.opacity, 1),
          o = ai.parse(Z(t?.color, new ai(1, 0, 0, 1)));
        switch (
          ((n.color = o),
          (n.doubleSided = Z(t.doubleSided, !1)),
          (n.opacity = r),
          (n.lightingModel = i),
          (n.baseColorTexture = t.baseColorTexture),
          e)
        ) {
          case 'Color':
            n.uniforms = { Color: () => Ge.fromColor(o, !1), Opacity: () => r };
            break;
          case 'Texture':
            n.uniforms = {
              BaseColorSampler: () => _g.bindTextureSampler(t.baseColorTexture),
              Color: () => new Ge(o.r, o.g, o.b, o.a),
              Opacity: () => r,
            };
            break;
          default:
            throw new Error(`material with type '${e}' does not exist.`);
        }
        return n;
      }
      serialize() {
        const e = {
          type: 'StandardMaterial',
          texTYpe: this._texType,
          opacity: this._opacity,
          doubleSided: this._doubleSided,
          lightingModel: this._lightingModel,
        };
        return (
          'Color' === this._texType
            ? (e.color = ai.pack(this._color, new Array(4)))
            : 'Texture' === this._texType && (e.texUrl = this._baseColorTexture.texUrl),
          t(this._flowOptions) && (e.flowOptions = this._flowOptions),
          e
        );
      }
      destroy() {
        return super.destroy(), J.cancelAnimationFrame(this.frame), Vc(this);
      }
    }
    const gg = Gt(
        [
          { name: 'a_POSITION', components: 3, type: 'Float32' },
          { name: 'a_ST', components: 2, type: 'Float32' },
        ],
        4,
      ),
      { members: yg } = gg;
    var xg = wg,
      vg = wg;
    function wg(e, t, i) {
      i = i || 2;
      var n,
        r,
        o,
        a,
        s,
        l,
        c,
        u = t && t.length,
        h = u ? t[0] * i : e.length,
        d = Tg(e, 0, h, i, !0),
        p = [];
      if (!d || d.next === d.prev) return p;
      if (
        (u &&
          (d = (function (e, t, i, n) {
            var r,
              o,
              a,
              s = [];
            for (r = 0, o = t.length; r < o; r++)
              (a = Tg(e, t[r] * n, r < o - 1 ? t[r + 1] * n : e.length, n, !1)) === a.next &&
                (a.steiner = !0),
                s.push(Ng(a));
            for (s.sort(Mg), r = 0; r < s.length; r++) i = Ig(s[r], i);
            return i;
          })(e, t, d, i)),
        e.length > 80 * i)
      ) {
        (n = o = e[0]), (r = a = e[1]);
        for (var f = i; f < h; f += i)
          (s = e[f]) < n && (n = s),
            (l = e[f + 1]) < r && (r = l),
            s > o && (o = s),
            l > a && (a = l);
        c = 0 !== (c = Math.max(o - n, a - r)) ? 32767 / c : 0;
      }
      return Sg(d, p, i, n, r, c, 0), p;
    }
    function Tg(e, t, i, n, r) {
      var o, a;
      if (r === Xg(e, t, i, n) > 0) for (o = t; o < i; o += n) a = Hg(o, e[o], e[o + 1], a);
      else for (o = i - n; o >= t; o -= n) a = Hg(o, e[o], e[o + 1], a);
      return a && zg(a, a.next) && (Yg(a), (a = a.next)), a;
    }
    function bg(e, t) {
      if (!e) return e;
      t || (t = e);
      var i,
        n = e;
      do {
        if (((i = !1), n.steiner || (!zg(n, n.next) && 0 !== Fg(n.prev, n, n.next)))) n = n.next;
        else {
          if ((Yg(n), (n = t = n.prev) === n.next)) break;
          i = !0;
        }
      } while (i || n !== t);
      return t;
    }
    function Sg(e, t, i, n, r, o, a) {
      if (e) {
        !a &&
          o &&
          (function (e, t, i, n) {
            var r = e;
            do {
              0 === r.z && (r.z = Rg(r.x, r.y, t, i, n)),
                (r.prevZ = r.prev),
                (r.nextZ = r.next),
                (r = r.next);
            } while (r !== e);
            (r.prevZ.nextZ = null),
              (r.prevZ = null),
              (function (e) {
                var t,
                  i,
                  n,
                  r,
                  o,
                  a,
                  s,
                  l,
                  c = 1;
                do {
                  for (i = e, e = null, o = null, a = 0; i; ) {
                    for (a++, n = i, s = 0, t = 0; t < c && (s++, (n = n.nextZ)); t++);
                    for (l = c; s > 0 || (l > 0 && n); )
                      0 !== s && (0 === l || !n || i.z <= n.z)
                        ? ((r = i), (i = i.nextZ), s--)
                        : ((r = n), (n = n.nextZ), l--),
                        o ? (o.nextZ = r) : (e = r),
                        (r.prevZ = o),
                        (o = r);
                    i = n;
                  }
                  (o.nextZ = null), (c *= 2);
                } while (a > 1);
              })(r);
          })(e, n, r, o);
        for (var s, l, c = e; e.prev !== e.next; )
          if (((s = e.prev), (l = e.next), o ? Pg(e, n, r, o) : Ag(e)))
            t.push((s.i / i) | 0),
              t.push((e.i / i) | 0),
              t.push((l.i / i) | 0),
              Yg(e),
              (e = l.next),
              (c = l.next);
          else if ((e = l) === c) {
            a
              ? 1 === a
                ? Sg((e = Eg(bg(e), t, i)), t, i, n, r, o, 2)
                : 2 === a && Cg(e, t, i, n, r, o)
              : Sg(bg(e), t, i, n, r, o, 1);
            break;
          }
      }
    }
    function Ag(e) {
      var t = e.prev,
        i = e,
        n = e.next;
      if (Fg(t, i, n) >= 0) return !1;
      for (
        var r = t.x,
          o = i.x,
          a = n.x,
          s = t.y,
          l = i.y,
          c = n.y,
          u = r < o ? (r < a ? r : a) : o < a ? o : a,
          h = s < l ? (s < c ? s : c) : l < c ? l : c,
          d = r > o ? (r > a ? r : a) : o > a ? o : a,
          p = s > l ? (s > c ? s : c) : l > c ? l : c,
          f = n.next;
        f !== t;

      ) {
        if (
          f.x >= u &&
          f.x <= d &&
          f.y >= h &&
          f.y <= p &&
          Og(r, s, o, l, a, c, f.x, f.y) &&
          Fg(f.prev, f, f.next) >= 0
        )
          return !1;
        f = f.next;
      }
      return !0;
    }
    function Pg(e, t, i, n) {
      var r = e.prev,
        o = e,
        a = e.next;
      if (Fg(r, o, a) >= 0) return !1;
      for (
        var s = r.x,
          l = o.x,
          c = a.x,
          u = r.y,
          h = o.y,
          d = a.y,
          p = s < l ? (s < c ? s : c) : l < c ? l : c,
          f = u < h ? (u < d ? u : d) : h < d ? h : d,
          m = s > l ? (s > c ? s : c) : l > c ? l : c,
          _ = u > h ? (u > d ? u : d) : h > d ? h : d,
          g = Rg(p, f, t, i, n),
          y = Rg(m, _, t, i, n),
          x = e.prevZ,
          v = e.nextZ;
        x && x.z >= g && v && v.z <= y;

      ) {
        if (
          x.x >= p &&
          x.x <= m &&
          x.y >= f &&
          x.y <= _ &&
          x !== r &&
          x !== a &&
          Og(s, u, l, h, c, d, x.x, x.y) &&
          Fg(x.prev, x, x.next) >= 0
        )
          return !1;
        if (
          ((x = x.prevZ),
          v.x >= p &&
            v.x <= m &&
            v.y >= f &&
            v.y <= _ &&
            v !== r &&
            v !== a &&
            Og(s, u, l, h, c, d, v.x, v.y) &&
            Fg(v.prev, v, v.next) >= 0)
        )
          return !1;
        v = v.nextZ;
      }
      for (; x && x.z >= g; ) {
        if (
          x.x >= p &&
          x.x <= m &&
          x.y >= f &&
          x.y <= _ &&
          x !== r &&
          x !== a &&
          Og(s, u, l, h, c, d, x.x, x.y) &&
          Fg(x.prev, x, x.next) >= 0
        )
          return !1;
        x = x.prevZ;
      }
      for (; v && v.z <= y; ) {
        if (
          v.x >= p &&
          v.x <= m &&
          v.y >= f &&
          v.y <= _ &&
          v !== r &&
          v !== a &&
          Og(s, u, l, h, c, d, v.x, v.y) &&
          Fg(v.prev, v, v.next) >= 0
        )
          return !1;
        v = v.nextZ;
      }
      return !0;
    }
    function Eg(e, t, i) {
      var n = e;
      do {
        var r = n.prev,
          o = n.next.next;
        !zg(r, o) &&
          Bg(r, n, n.next, o) &&
          kg(r, o) &&
          kg(o, r) &&
          (t.push((r.i / i) | 0),
          t.push((n.i / i) | 0),
          t.push((o.i / i) | 0),
          Yg(n),
          Yg(n.next),
          (n = e = o)),
          (n = n.next);
      } while (n !== e);
      return bg(n);
    }
    function Cg(e, t, i, n, r, o) {
      var a = e;
      do {
        for (var s = a.next.next; s !== a.prev; ) {
          if (a.i !== s.i && Dg(a, s)) {
            var l = Gg(a, s);
            return (
              (a = bg(a, a.next)),
              (l = bg(l, l.next)),
              Sg(a, t, i, n, r, o, 0),
              void Sg(l, t, i, n, r, o, 0)
            );
          }
          s = s.next;
        }
        a = a.next;
      } while (a !== e);
    }
    function Mg(e, t) {
      return e.x - t.x;
    }
    function Ig(e, t) {
      var i = (function (e, t) {
        var i,
          n = t,
          r = e.x,
          o = e.y,
          a = -1 / 0;
        do {
          if (o <= n.y && o >= n.next.y && n.next.y !== n.y) {
            var s = n.x + ((o - n.y) * (n.next.x - n.x)) / (n.next.y - n.y);
            if (s <= r && s > a && ((a = s), (i = n.x < n.next.x ? n : n.next), s === r)) return i;
          }
          n = n.next;
        } while (n !== t);
        if (!i) return null;
        var l,
          c = i,
          u = i.x,
          h = i.y,
          d = 1 / 0;
        n = i;
        do {
          r >= n.x &&
            n.x >= u &&
            r !== n.x &&
            Og(o < h ? r : a, o, u, h, o < h ? a : r, o, n.x, n.y) &&
            ((l = Math.abs(o - n.y) / (r - n.x)),
            kg(n, e) &&
              (l < d || (l === d && (n.x > i.x || (n.x === i.x && Lg(i, n))))) &&
              ((i = n), (d = l))),
            (n = n.next);
        } while (n !== c);
        return i;
      })(e, t);
      if (!i) return t;
      var n = Gg(i, e);
      return bg(n, n.next), bg(i, i.next);
    }
    function Lg(e, t) {
      return Fg(e.prev, e, t.prev) < 0 && Fg(t.next, e, e.next) < 0;
    }
    function Rg(e, t, i, n, r) {
      return (
        (e =
          1431655765 &
          ((e =
            858993459 &
            ((e = 252645135 & ((e = 16711935 & ((e = ((e - i) * r) | 0) | (e << 8))) | (e << 4))) |
              (e << 2))) |
            (e << 1))) |
        ((t =
          1431655765 &
          ((t =
            858993459 &
            ((t = 252645135 & ((t = 16711935 & ((t = ((t - n) * r) | 0) | (t << 8))) | (t << 4))) |
              (t << 2))) |
            (t << 1))) <<
          1)
      );
    }
    function Ng(e) {
      var t = e,
        i = e;
      do {
        (t.x < i.x || (t.x === i.x && t.y < i.y)) && (i = t), (t = t.next);
      } while (t !== e);
      return i;
    }
    function Og(e, t, i, n, r, o, a, s) {
      return (
        (r - a) * (t - s) >= (e - a) * (o - s) &&
        (e - a) * (n - s) >= (i - a) * (t - s) &&
        (i - a) * (o - s) >= (r - a) * (n - s)
      );
    }
    function Dg(e, t) {
      return (
        e.next.i !== t.i &&
        e.prev.i !== t.i &&
        !(function (e, t) {
          var i = e;
          do {
            if (
              i.i !== e.i &&
              i.next.i !== e.i &&
              i.i !== t.i &&
              i.next.i !== t.i &&
              Bg(i, i.next, e, t)
            )
              return !0;
            i = i.next;
          } while (i !== e);
          return !1;
        })(e, t) &&
        ((kg(e, t) &&
          kg(t, e) &&
          (function (e, t) {
            var i = e,
              n = !1,
              r = (e.x + t.x) / 2,
              o = (e.y + t.y) / 2;
            do {
              i.y > o != i.next.y > o &&
                i.next.y !== i.y &&
                r < ((i.next.x - i.x) * (o - i.y)) / (i.next.y - i.y) + i.x &&
                (n = !n),
                (i = i.next);
            } while (i !== e);
            return n;
          })(e, t) &&
          (Fg(e.prev, e, t.prev) || Fg(e, t.prev, t))) ||
          (zg(e, t) && Fg(e.prev, e, e.next) > 0 && Fg(t.prev, t, t.next) > 0))
      );
    }
    function Fg(e, t, i) {
      return (t.y - e.y) * (i.x - t.x) - (t.x - e.x) * (i.y - t.y);
    }
    function zg(e, t) {
      return e.x === t.x && e.y === t.y;
    }
    function Bg(e, t, i, n) {
      var r = Ug(Fg(e, t, i)),
        o = Ug(Fg(e, t, n)),
        a = Ug(Fg(i, n, e)),
        s = Ug(Fg(i, n, t));
      return (
        (r !== o && a !== s) ||
        !(0 !== r || !Vg(e, i, t)) ||
        !(0 !== o || !Vg(e, n, t)) ||
        !(0 !== a || !Vg(i, e, n)) ||
        !(0 !== s || !Vg(i, t, n))
      );
    }
    function Vg(e, t, i) {
      return (
        t.x <= Math.max(e.x, i.x) &&
        t.x >= Math.min(e.x, i.x) &&
        t.y <= Math.max(e.y, i.y) &&
        t.y >= Math.min(e.y, i.y)
      );
    }
    function Ug(e) {
      return e > 0 ? 1 : e < 0 ? -1 : 0;
    }
    function kg(e, t) {
      return Fg(e.prev, e, e.next) < 0
        ? Fg(e, t, e.next) >= 0 && Fg(e, e.prev, t) >= 0
        : Fg(e, t, e.prev) < 0 || Fg(e, e.next, t) < 0;
    }
    function Gg(e, t) {
      var i = new qg(e.i, e.x, e.y),
        n = new qg(t.i, t.x, t.y),
        r = e.next,
        o = t.prev;
      return (
        (e.next = t),
        (t.prev = e),
        (i.next = r),
        (r.prev = i),
        (n.next = i),
        (i.prev = n),
        (o.next = n),
        (n.prev = o),
        n
      );
    }
    function Hg(e, t, i, n) {
      var r = new qg(e, t, i);
      return (
        n
          ? ((r.next = n.next), (r.prev = n), (n.next.prev = r), (n.next = r))
          : ((r.prev = r), (r.next = r)),
        r
      );
    }
    function Yg(e) {
      (e.next.prev = e.prev),
        (e.prev.next = e.next),
        e.prevZ && (e.prevZ.nextZ = e.nextZ),
        e.nextZ && (e.nextZ.prevZ = e.prevZ);
    }
    function qg(e, t, i) {
      (this.i = e),
        (this.x = t),
        (this.y = i),
        (this.prev = null),
        (this.next = null),
        (this.z = 0),
        (this.prevZ = null),
        (this.nextZ = null),
        (this.steiner = !1);
    }
    function Xg(e, t, i, n) {
      for (var r = 0, o = t, a = i - n; o < i; o += n)
        (r += (e[a] - e[o]) * (e[o + 1] + e[a + 1])), (a = o);
      return r;
    }
    function jg(e, t, i, n, r) {
      Wg(e, t, i || 0, n || e.length - 1, r || Zg);
    }
    function Wg(e, t, i, n, r) {
      for (; n > i; ) {
        if (n - i > 600) {
          var o = n - i + 1,
            a = t - i + 1,
            s = Math.log(o),
            l = 0.5 * Math.exp((2 * s) / 3),
            c = 0.5 * Math.sqrt((s * l * (o - l)) / o) * (a - o / 2 < 0 ? -1 : 1);
          Wg(
            e,
            t,
            Math.max(i, Math.floor(t - (a * l) / o + c)),
            Math.min(n, Math.floor(t + ((o - a) * l) / o + c)),
            r,
          );
        }
        var u = e[t],
          h = i,
          d = n;
        for ($g(e, i, t), r(e[n], u) > 0 && $g(e, i, n); h < d; ) {
          for ($g(e, h, d), h++, d--; r(e[h], u) < 0; ) h++;
          for (; r(e[d], u) > 0; ) d--;
        }
        0 === r(e[i], u) ? $g(e, i, d) : $g(e, ++d, n),
          d <= t && (i = d + 1),
          t <= d && (n = d - 1);
      }
    }
    function $g(e, t, i) {
      var n = e[t];
      (e[t] = e[i]), (e[i] = n);
    }
    function Zg(e, t) {
      return e < t ? -1 : e > t ? 1 : 0;
    }
    function Kg(e, t) {
      const i = e.length;
      if (i <= 1) return [e];
      const n = [];
      let r, o;
      for (let t = 0; t < i; t++) {
        const i = Te(e[t]);
        0 !== i &&
          ((e[t].area = Math.abs(i)),
          void 0 === o && (o = i < 0),
          o === i < 0 ? (r && n.push(r), (r = [e[t]])) : r.push(e[t]));
      }
      if ((r && n.push(r), t > 1))
        for (let e = 0; e < n.length; e++)
          n[e].length <= t || (jg(n[e], t, 1, n[e].length - 1, Qg), (n[e] = n[e].slice(0, t)));
      return n;
    }
    function Qg(e, t) {
      return t.area - e.area;
    }
    function Jg(e, t, i, n, r, o) {
      if (r >= t && o <= i) return e;
      if (r > i || o < t) return null;
      const a = [];
      for (let r = 0; r < e.length; r++) {
        const o = e[r],
          s = o.geometry,
          l = o.type,
          c = o.min[n],
          u = o.max[n];
        if (c >= t && u <= i) {
          a.push(o);
          continue;
        }
        if (c > i || u < t) continue;
        const h =
          'Point' === l ? ey(s, t, i, n) : ty(s, t, i, n, 0 === n ? oy : ay, 'Polygon' === l);
        h.length && a.push(ny(o.tags, l, h, o.id));
      }
      return a.length ? a : null;
    }
    function ey(e, t, i, n) {
      const r = [];
      for (let o = 0; o < e.length; o++) {
        const a = e[o],
          s = a[n];
        s >= t && s <= i && r.push(a);
      }
      return r;
    }
    function ty(e, t, i, n, r, o) {
      const a = [];
      for (let s = 0; s < e.length; s++) {
        let l,
          c,
          u = 0,
          h = 0,
          d = null,
          p = [];
        const f = e[s],
          m = f.area,
          _ = f.dist,
          g = f.outer,
          y = f.length;
        for (c = 0; c < y - 1; c++)
          (l = d || f[c]),
            (d = f[c + 1]),
            (u = h || l[n]),
            (h = d[n]),
            u < t
              ? h > i
                ? (p.push(r(l, d, t), r(l, d, i)), o || (p = iy(a, p, m, _, g)))
                : h >= t && p.push(r(l, d, t))
              : u > i
              ? h < t
                ? (p.push(r(l, d, i), r(l, d, t)), o || (p = iy(a, p, m, _, g)))
                : h <= i && p.push(r(l, d, i))
              : (p.push(l),
                h < t
                  ? (p.push(r(l, d, t)), o || (p = iy(a, p, m, _, g)))
                  : h > i && (p.push(r(l, d, i)), o || (p = iy(a, p, m, _, g))));
        (l = f[y - 1]), (u = l[n]), u >= t && u <= i && p.push(l);
        const x = p[p.length - 1];
        o && x && (p[0][0] !== x[0] || p[0][1] !== x[1]) && p.push(p[0]), iy(a, p, m, _, g);
      }
      return a;
    }
    function iy(e, t, i, n, r) {
      return t.length && ((t.area = i), (t.dist = n), void 0 !== r && (t.outer = r), e.push(t)), [];
    }
    function ny(e, t, i, n) {
      const r = {
        id: n || null,
        type: t,
        geometry: i,
        tags: e || null,
        min: [1 / 0, 1 / 0],
        max: [-1 / 0, -1 / 0],
      };
      return (
        (function (e) {
          const t = e.geometry,
            i = e.min,
            n = e.max;
          if (1 === e.type) ry(i, n, t);
          else for (let e = 0; e < t.length; e++) ry(i, n, t[e]);
        })(r),
        r
      );
    }
    function ry(e, t, i) {
      for (let n, r = 0; r < i.length; r++)
        (n = i[r]),
          (e[0] = Math.min(n[0], e[0])),
          (t[0] = Math.max(n[0], t[0])),
          (e[1] = Math.min(n[1], e[1])),
          (t[1] = Math.max(n[1], t[1]));
    }
    function oy(e, t, i) {
      return [i, ((i - e[0]) * (t[1] - e[1])) / (t[0] - e[0]) + e[1]];
    }
    function ay(e, t, i) {
      return [((i - e[1]) * (t[0] - e[0])) / (t[1] - e[1]) + e[0], i];
    }
    function sy(e, t, i, n, r, o, a) {
      if (!(e > 1)) return a.push(...o);
      {
        const s = Jg(o, t, t + (i - t) / 2, 0, 0, 8192),
          l = Jg(o, t + (i - t) / 2, i, 0, 0, 8192);
        if (s) {
          const o = Jg(s, n, n + (r - n) / 2, 1, 0, 8192),
            l = Jg(s, n + (r - n) / 2, r, 1, 0, 8192);
          o && sy(e - 1, t, t + (i - t) / 2, n, n + (r - n) / 2, o, a),
            l && sy(e - 1, t, t + (i - t) / 2, n + (r - n) / 2, r, l, a);
        }
        if (l) {
          const o = Jg(l, n, n + (r - n) / 2, 1, 0, 8192),
            s = Jg(l, n + (r - n) / 2, r, 1, 0, 8192);
          o && sy(e - 1, t + (i - t) / 2, i, n, n + (r - n) / 2, o, a),
            s && sy(e - 1, t + (i - t) / 2, i, n + (r - n) / 2, r, s, a);
        }
      }
    }
    function ly(e, t, i) {
      if (e && e.length <= 0) return [];
      const n = [];
      n.push(new dy(new te(0, 0), new te(8192, 0))),
        n.push(new dy(new te(8192, 0), new te(8192, 8192))),
        n.push(new dy(new te(8192, 8192), new te(0, 8192))),
        n.push(new dy(new te(0, 8192), new te(0, 0))),
        (t = t || n);
      let r,
        o = [],
        a = [],
        s = e[e.length - 1];
      for (let t = 0; t < e.length; t++) o.push(e[t]);
      for (const e in t) {
        (s = o[o.length - 1]), (r = !cy(s, t[e]));
        for (let i = 0; i < o.length; i++)
          cy(o[i], t[e])
            ? (r && ((r = !1), a.push(hy(s, o[i], t[e].start, t[e].end))), a.push(o[i]))
            : r || ((r = !0), a.push(hy(s, o[i], t[e].start, t[e].end))),
            (s = o[i]);
        o = [];
        for (let e = 0; e < a.length; e++) o.push(a[e]);
        a = [];
      }
      return o.push(i ? o[0] : o[o.length - 1]), o;
    }
    function cy(e, t) {
      return !!e && uy(e, t.start, t.end) >= 0;
    }
    function uy(e, t, i) {
      return (i.x - t.x) * (e.y - t.y) - (i.y - t.y) * (e.x - t.x);
    }
    function hy(e, t, i, n) {
      const r = (uy(e, n, i) * t.x - uy(t, n, i) * e.x) / (uy(e, n, i) - uy(t, n, i)),
        o = (uy(e, n, i) * t.y - uy(t, n, i) * e.y) / (uy(e, n, i) - uy(t, n, i));
      return new te(r, o);
    }
    function dy(e, t) {
      (this.start = e), (this.end = t);
    }
    (wg.deviation = function (e, t, i, n) {
      var r = t && t.length,
        o = Math.abs(Xg(e, 0, r ? t[0] * i : e.length, i));
      if (r)
        for (var a = 0, s = t.length; a < s; a++)
          o -= Math.abs(Xg(e, t[a] * i, a < s - 1 ? t[a + 1] * i : e.length, i));
      var l = 0;
      for (a = 0; a < n.length; a += 3) {
        var c = n[a] * i,
          u = n[a + 1] * i,
          h = n[a + 2] * i;
        l += Math.abs(
          (e[c] - e[h]) * (e[u + 1] - e[c + 1]) - (e[c] - e[u]) * (e[h + 1] - e[c + 1]),
        );
      }
      return 0 === o && 0 === l ? 0 : Math.abs((l - o) / o);
    }),
      (wg.flatten = function (e) {
        for (
          var t = e[0][0].length, i = { vertices: [], holes: [], dimensions: t }, n = 0, r = 0;
          r < e.length;
          r++
        ) {
          for (var o = 0; o < e[r].length; o++)
            for (var a = 0; a < t; a++) i.vertices.push(e[r][o][a]);
          r > 0 && i.holes.push((n += e[r - 1].length));
        }
        return i;
      }),
      (xg.default = vg);
    class py {
      static getMinMaxHeight(e) {
        switch (e.classificationtype) {
          case n_.TERRAIN:
          case n_.MINEMAP_3D_TILE:
          case n_.BOTH:
          case n_.SINGULARIZATION:
          case n_.ALL:
            (e.maximumHeight = 4e4), (e.minimumHeight = -3e3);
            break;
          default:
            (e.maximumHeight = 0), (e.minimumHeight = 0);
        }
      }
      static get3DTileMinMaxHeight() {}
    }
    const fy = {};
    function my(e) {
      let t = 8 - e;
      return t < 0 && (t = 0), e > 4 && e < 7 ? (t += 3) : 7 == e && (t += 4), t;
    }
    (fy.clipTriangleAtAxisAlignedThreshold = function (e, t, i, n, r, o) {
      let a, s, l;
      (o.length = 0),
        t ? ((a = i < e), (s = n < e), (l = r < e)) : ((a = i > e), (s = n > e), (l = r > e));
      const c = a + s + l;
      let u, h, d, p, f, m;
      return (
        1 === c
          ? a
            ? ((u = (e - i) / (n - i)),
              (h = (e - i) / (r - i)),
              o.push(1),
              o.push(2),
              1 !== h && (o.push(-1), o.push(0), o.push(2), o.push(h)),
              1 !== u && (o.push(-1), o.push(0), o.push(1), o.push(u)))
            : s
            ? ((d = (e - n) / (r - n)),
              (p = (e - n) / (i - n)),
              o.push(2),
              o.push(0),
              1 !== p && (o.push(-1), o.push(1), o.push(0), o.push(p)),
              1 !== d && (o.push(-1), o.push(1), o.push(2), o.push(d)))
            : l &&
              ((f = (e - r) / (i - r)),
              (m = (e - r) / (n - r)),
              o.push(0),
              o.push(1),
              1 !== m && (o.push(-1), o.push(2), o.push(1), o.push(m)),
              1 !== f && (o.push(-1), o.push(2), o.push(0), o.push(f)))
          : 2 === c
          ? a || i === e
            ? s || n === e
              ? l ||
                r === e ||
                ((h = (e - i) / (r - i)),
                (d = (e - n) / (r - n)),
                o.push(2),
                o.push(-1),
                o.push(0),
                o.push(2),
                o.push(h),
                o.push(-1),
                o.push(1),
                o.push(2),
                o.push(d))
              : ((m = (e - r) / (n - r)),
                (u = (e - i) / (n - i)),
                o.push(1),
                o.push(-1),
                o.push(2),
                o.push(1),
                o.push(m),
                o.push(-1),
                o.push(0),
                o.push(1),
                o.push(u))
            : ((p = (e - n) / (i - n)),
              (f = (e - r) / (i - r)),
              o.push(0),
              o.push(-1),
              o.push(1),
              o.push(0),
              o.push(p),
              o.push(-1),
              o.push(2),
              o.push(0),
              o.push(f))
          : 3 !== c && (o.push(0), o.push(1), o.push(2)),
        o
      );
    }),
      (fy.computeBarycentricCoordinates = function (e, t, i, n, r, o, a, s, l) {
        const c = i - a,
          u = a - r,
          h = o - s,
          d = n - s,
          p = 1 / (h * c + u * d),
          f = t - s,
          m = e - a,
          _ = (h * m + u * f) * p,
          g = (-d * m + c * f) * p,
          y = 1 - _ - g;
        return l ? ((l.x = _), (l.y = g), (l.z = y), l) : { x: _, y: g, z: y };
      }),
      (fy.computeLineSegmentLineSegmentIntersection = function (e, t, i, n, r, o, a, s, l) {
        const c = (s - o) * (i - e) - (a - r) * (n - t);
        if (0 === c) return;
        const u = ((a - r) * (t - o) - (s - o) * (e - r)) / c,
          h = ((i - e) * (t - o) - (n - t) * (e - r)) / c;
        return u >= 0 && u <= 1 && h >= 0 && h <= 1
          ? ((l.x = e + u * (i - e)), (l.y = t + u * (n - t)), l)
          : void 0;
      }),
      (fy.featureInsect = function (e, t) {
        let i = !1;
        const n = t.filter((t) => t.index != e.index);
        return (
          !!(e.feature && e.feature._feature && e.feature._feature.geometry) &&
          (e.feature._feature.geometry.forEach((e) => {
            for (let t = 0; t < e.length - 1; t++)
              if (fy.geometryInsect(e[t], e[t + 1], n)) return void (i = !0);
          }),
          i)
        );
      }),
      (fy.geometryInsect = function (e, t, i) {
        let n = !1;
        return (
          i.forEach((i) => {
            i.feature._feature.geometry.forEach((i) => {
              for (let r = 0; r < i.length - 1; r++) {
                const o = i[r],
                  a = i[r + 1];
                if (
                  fy.computeLineSegmentLineSegmentIntersection(
                    e[0],
                    e[1],
                    t[0],
                    t[1],
                    o[0],
                    o[1],
                    a[0],
                    a[1],
                    new $e(),
                  )
                )
                  return void (n = !0);
              }
            });
          }),
          n
        );
      });
    const _y = Math.pow(2, 7);
    function gy(e, t, i, n, r, o, a) {
      const s = Ys(t, i, 0, r, o, n, a);
      (e[0] = s[0]), (e[1] = s[1]), (e[2] = s[2]);
    }
    const yy = 500;
    class xy {
      constructor(e) {
        (this.zoom = e.zoom),
          (this.overscaling = e.overscaling),
          (this.layers = e.layers),
          (this.layerIds = this.layers.map((e) => e.id)),
          (this.index = e.index),
          (this.type = tm.FILL),
          (this.layoutVertexArray = new Bo()),
          (this.layoutVertexArray2 = new Bo()),
          (this.indexArray = new ea()),
          (this.indexArray2 = new ia()),
          (this.programConfigurations = new cp(yg, e.layers, e.zoom)),
          (this.segments = new Yh()),
          (this.segments2 = new Yh()),
          (this.projection = e.projection || Ot.MERCATOR),
          (this.vectorRenderInSpace = !1),
          (this.classificationtype = n_.NONE),
          this.layers.forEach((e) => {
            r_(e.classificationType) &&
              ((this.vectorRenderInSpace = !0), (this.classificationtype = e.classificationType));
          }),
          (this.maximumHeight = 0),
          (this.minimumHeight = 0),
          (this.forceUpdateSegment = !1);
      }
      _convertGeometryPointToPolygon(e) {
        const t = [];
        for (let i = 0; i < e.length; i++) {
          const n = [];
          let r = 1 / 0,
            o = 1 / 0,
            a = -1 / 0,
            s = -1 / 0;
          for (let t = 0; t < e[i].length; t++) {
            const l = e[i][t].x,
              c = e[i][t].y;
            n.push([l, c]), r > l && (r = l), a < l && (a = l), o > c && (o = c), s < c && (s = c);
          }
          t.push({ type: 'Polygon', geometry: [n], min: [r, o], max: [a, s] });
        }
        return t;
      }
      _convertPolygonToGeometry(e) {
        const t = [];
        for (let i = 0; i < e.length; i++) {
          const n = e[i].geometry.map((e) => e.map((e) => new te(e[0], e[1])));
          t.push(...n);
        }
        return t;
      }
      populate(e, t, i) {
        const n = this.vectorRenderInSpace;
        this.referencePoint ||
          ((this.x = t.x),
          (this.y = t.y),
          (this.z = t.z),
          (this.zPow = Math.pow(2, this.z)),
          (this.referencePoint = Xs(this.x, this.y, this.z, this.projection)),
          (this.matrix = new Je()),
          (this.matrix[12] = this.referencePoint[0]),
          (this.matrix[13] = this.referencePoint[1]),
          (this.matrix[14] = this.referencePoint[2]),
          py.getMinMaxHeight(this));
        const r = this.layers[0].layout.get('fill-sort-key'),
          o = [];
        for (const { feature: n, id: a, index: s, sourceLayerIndex: l } of e) {
          const e = this.layers[0]._featureFilter.needGeometry,
            c = { type: n.type, id: a, properties: n.properties, geometry: e ? qf(n) : [] };
          if (!this.layers[0]._featureFilter(new fd(this.zoom), c, i)) continue;
          e || (c.geometry = qf(n));
          const u = r ? r.evaluate(c, {}, i, t.availableImages) : void 0;
          o.push({ feature: n, sourceLayerIndex: l, index: s, geometry: c.geometry, sortKey: u });
        }
        r && o.sort((e, t) => e.sortKey - t.sortKey);
        for (const e of o) {
          const { feature: r, index: a, sourceLayerIndex: s, geometry: l } = e,
            c = [];
          this.vectorRenderInSpace && fy.featureInsect(e, o) && (this.forceUpdateSegment = !0);
          const u = [];
          sy(my(this.z), 0, 8192, 0, 8192, this._convertGeometryPointToPolygon(l), u);
          const h = this._convertPolygonToGeometry(u);
          n
            ? this.addExtrusionFeature(r, l, a, c, i, n)
            : this.addGridedFeature(r, l, h, a, i, this.z),
            t.featureIndex.insert(r, l, a, s, this.index),
            (this.forceUpdateSegment = !1);
        }
        if (n) {
          if (!this.baseP) return;
          this.matrix = js(0, this.baseP);
        }
        0 == this.layoutVertexArray2.length && delete this.layoutVertexArray2;
      }
      update(e, t) {
        this.stateDependentLayers.length &&
          this.programConfigurations.updatePaintArrays(e, t, this.stateDependentLayers);
      }
      isEmpty() {
        return 0 === this.layoutVertexArray.length;
      }
      uploadPending() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }
      upload(e) {
        this.uploaded ||
          ((this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, yg)),
          this.layoutVertexArray2 &&
            this.layoutVertexArray2.length > 0 &&
            (this.layoutVertexBuffer2 = e.createVertexBuffer(this.layoutVertexArray2, yg)),
          (this.indexBuffer = e.createIndexBuffer(this.indexArray)),
          (this.indexBuffer2 = e.createIndexBuffer(this.indexArray2))),
          this.programConfigurations.upload(e),
          (this.uploaded = !0);
      }
      destroy() {
        this.layoutVertexBuffer &&
          (this.layoutVertexBuffer.destroy(),
          this.indexBuffer.destroy(),
          this.indexBuffer2.destroy(),
          this.programConfigurations.destroy(),
          this.segments.destroy(),
          this.segments2.destroy());
      }
      calcTDSpacePoint(e) {
        if (Object.is(e.x, NaN) || Object.is(e.y, NaN) || Object.is(e.z, NaN)) return;
        const t = qs(this.x + e.x / 8192, this.y + e.y / 8192, this.zPow, this.projection),
          i = Il.cartographicToCartesian3(new Pt(t[0], t[1], 0));
        return [
          i[0] - this.referencePoint[0],
          i[1] - this.referencePoint[1],
          i[2] - this.referencePoint[2],
        ];
      }
      addFeature(e, t, i, n) {
        for (const e of Kg(t, yy)) {
          let t = 0;
          for (const i of e) t += i.length;
          const i = this.segments.prepareSegment(t, this.layoutVertexArray, this.indexArray),
            n = i.vertexLength,
            r = [],
            o = [];
          for (const t of e) {
            if (0 === t.length) continue;
            t !== e[0] && o.push(r.length / 2);
            const i = this.segments2.prepareSegment(
                t.length,
                this.layoutVertexArray2,
                this.indexArray2,
              ),
              n = i.vertexLength,
              a = this.calcTDSpacePoint(t[0]);
            if (null == a) continue;
            const s = new Pt(a);
            this.layoutVertexArray.emplaceBack(...a, t[0].x, t[0].y, 0, 0),
              this.layoutVertexArray2.emplaceBack(...a, t[0].x, t[0].y, 0, 0),
              this.indexArray2.emplaceBack(n + t.length - 1, n),
              r.push(t[0].x),
              r.push(t[0].y);
            for (let e = 1; e < t.length; e++) {
              const i = this.calcTDSpacePoint(t[e]);
              if (null == i) continue;
              const o = new Pt(i),
                a = Pt.subtract(s, o);
              this.layoutVertexArray.emplaceBack(...i, t[e].x, t[e].y, ...a),
                this.layoutVertexArray2.emplaceBack(...i, t[e].x, t[e].y, ...a),
                this.indexArray2.emplaceBack(n + e - 1, n + e),
                r.push(t[e].x),
                r.push(t[e].y);
            }
            (i.vertexLength += t.length), (i.primitiveLength += t.length);
          }
          const a = xg(r, o);
          for (let e = 0; e < a.length; e += 3)
            this.indexArray.emplaceBack(n + a[e], n + a[e + 1], n + a[e + 2]);
          (i.vertexLength += t), (i.primitiveLength += a.length / 3);
        }
        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, i, {}, n);
      }
      addGridedFeature(e, t, i, n, r, o) {
        const a = 6 * Math.pow(2, Math.max(8 - o, 1));
        for (const e of Kg(i, yy)) {
          let t = 0;
          for (const i of e) t += i.length;
          const i = this.segments.prepareSegment(t, this.layoutVertexArray, this.indexArray),
            n = i.vertexLength,
            r = [],
            o = [];
          for (const t of e) {
            if (0 === t.length) continue;
            t !== e[0] && o.push(r.length / 2);
            const i = this.calcTDSpacePoint(t[0]);
            if (null != i) {
              this.layoutVertexArray.emplaceBack(...i, (t[0].x / 8192) * a, (t[0].y / 8192) * a),
                r.push(t[0].x),
                r.push(t[0].y);
              for (let e = 1; e < t.length; e++) {
                const i = this.calcTDSpacePoint(t[e]);
                null != i &&
                  (this.layoutVertexArray.emplaceBack(
                    ...i,
                    (t[e].x / 8192) * a,
                    (t[e].y / 8192) * a,
                  ),
                  r.push(t[e].x),
                  r.push(t[e].y));
              }
            }
          }
          const s = xg(r, o);
          for (let e = 0; e < s.length; e += 3)
            this.indexArray.emplaceBack(n + s[e], n + s[e + 1], n + s[e + 2]);
          (i.vertexLength += t), (i.primitiveLength += s.length / 3);
        }
        for (const e of Kg(t, yy))
          for (const t of e) {
            if (0 === t.length) continue;
            const e = this.segments2.prepareSegment(
                t.length,
                this.layoutVertexArray2,
                this.indexArray2,
              ),
              i = e.vertexLength,
              n = this.calcTDSpacePoint(t[0]);
            if (null != n) {
              this.layoutVertexArray2.emplaceBack(...n, (t[0].x / 8192) * a, (t[0].y / 8192) * a),
                this.indexArray2.emplaceBack(i + t.length - 1, i);
              for (let e = 1; e < t.length; e++) {
                const n = this.calcTDSpacePoint(t[e]);
                null != n &&
                  (this.layoutVertexArray2.emplaceBack(
                    ...n,
                    (t[e].x / 8192) * a,
                    (t[e].y / 8192) * a,
                  ),
                  this.indexArray2.emplaceBack(i + e - 1, i + e));
              }
              (e.vertexLength += t.length), (e.primitiveLength += t.length);
            }
          }
        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, n, {}, r);
      }
      addExtrusionFeature(e, t, i, n, r, o) {
        for (const i of Kg(t, yy)) {
          let t = 0,
            n = this.segments.prepareSegment(
              4,
              this.layoutVertexArray,
              this.indexArray,
              this.forceUpdateSegment,
            );
          for (let e of i)
            if (0 !== e.length && !Ty(e) && (!by(e) || ((e = ly(e, void 0, o)), e[0]))) {
              t += e.length;
              for (let t = 0; t < e.length; t++) {
                const i = e[t];
                if (t >= 1) {
                  const r = e[t - 1];
                  if (!wy(i, r)) {
                    n.vertexLength + 4 > Yh.MAX_VERTEX_ARRAY_LENGTH &&
                      (n = this.segments.prepareSegment(
                        4,
                        this.layoutVertexArray,
                        this.indexArray,
                      ));
                    const e = Ys(
                      i.x,
                      i.y,
                      this.minimumHeight,
                      this.x,
                      this.y,
                      this.z,
                      this.projection,
                    );
                    this.baseP || (this.baseP = e);
                    const t = Ys(
                        i.x,
                        i.y,
                        this.maximumHeight,
                        this.x,
                        this.y,
                        this.z,
                        this.projection,
                      ),
                      o = Ys(r.x, r.y, this.minimumHeight, this.x, this.y, this.z, this.projection),
                      a = Ys(r.x, r.y, this.maximumHeight, this.x, this.y, this.z, this.projection),
                      s = this.baseP;
                    this.layoutVertexArray.emplaceBack(e[0] - s[0], e[1] - s[1], e[2] - s[2]),
                      this.layoutVertexArray.emplaceBack(t[0] - s[0], t[1] - s[1], t[2] - s[2]),
                      this.layoutVertexArray.emplaceBack(o[0] - s[0], o[1] - s[1], o[2] - s[2]),
                      this.layoutVertexArray.emplaceBack(a[0] - s[0], a[1] - s[1], a[2] - s[2]);
                    const l = n.vertexLength;
                    this.indexArray.emplaceBack(l, l + 2, l + 1),
                      this.indexArray.emplaceBack(l + 1, l + 2, l + 3),
                      (n.vertexLength += 4),
                      (n.primitiveLength += 2);
                  }
                }
              }
            }
          if (
            (n.vertexLength + t > Yh.MAX_VERTEX_ARRAY_LENGTH &&
              (n = this.segments.prepareSegment(t, this.layoutVertexArray, this.indexArray)),
            'Polygon' !== Qf.VectorTileFeature.types[e.type])
          )
            continue;
          const r = this.segments.prepareSegment(4 * t, this.layoutVertexArray, this.indexArray);
          vy(r, this.maximumHeight, o, !0, i, this, t),
            vy(r, this.minimumHeight, o, !1, i, this, t);
        }
        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, i);
      }
    }
    function vy(e, t, i, n, r, o, a) {
      const s = [],
        l = [],
        c = e.vertexLength;
      for (let e = 0; e < r.length; e++) {
        let a = r[e];
        if (0 !== a.length && !Ty(a) && (!by(a) || ((a = ly(a, void 0, i)), a[0]))) {
          e > 0 && a !== r[0] && l.push(s.length / 2);
          for (let e = 0; e < a.length; e++) {
            const i = a[e],
              r = Ys(i.x, i.y, n ? t : o.minimumHeight, o.x, o.y, o.z, o.projection);
            o.baseP || (o.baseP = r),
              o.layoutVertexArray.emplaceBack(
                r[0] - o.baseP[0],
                r[1] - o.baseP[1],
                r[2] - o.baseP[2],
              ),
              s.push(i.x),
              s.push(i.y);
          }
        }
      }
      const u = xg(s, l);
      for (let e = 0; e < u.length; e += 3)
        n
          ? o.indexArray.emplaceBack(c + u[e], c + u[e + 2], c + u[e + 1])
          : o.indexArray.emplaceBack(c + u[e], c + u[e + 1], c + u[e + 2]);
      (e.primitiveLength += u.length / 3), (e.vertexLength += a);
    }
    function wy(e, t) {
      return (e.x === t.x && (e.x < 0 || e.x > Wu)) || (e.y === t.y && (e.y < 0 || e.y > Wu));
    }
    function Ty(e) {
      return (
        e.every((e) => e.x < 0) ||
        e.every((e) => e.x > Wu) ||
        e.every((e) => e.y < 0) ||
        e.every((e) => e.y > Wu)
      );
    }
    function by(e) {
      return !(
        e.every((e) => e.x >= 0) &&
        e.every((e) => e.x <= Wu) &&
        e.every((e) => e.y >= 0) &&
        e.every((e) => e.y <= Wu)
      );
    }
    function Sy(e, t, i) {
      return !!Ry(e, t) || !!My(t, e, i);
    }
    function Ay(e, t, i) {
      for (let n = 0; n < t.length; n++) {
        const r = t[n];
        if (e.length >= 3) for (let t = 0; t < r.length; t++) if (Ry(e, r[t])) return !0;
        if (Py(e, r, i)) return !0;
      }
      return !1;
    }
    function Py(e, t, i) {
      if (e.length > 1) {
        if (Ey(e, t)) return !0;
        for (let n = 0; n < t.length; n++) if (My(t[n], e, i)) return !0;
      }
      for (let n = 0; n < e.length; n++) if (My(e[n], t, i)) return !0;
      return !1;
    }
    function Ey(e, t) {
      if (0 === e.length || 0 === t.length) return !1;
      for (let i = 0; i < e.length - 1; i++) {
        const n = e[i],
          r = e[i + 1];
        for (let e = 0; e < t.length - 1; e++) if (Cy(n, r, t[e], t[e + 1])) return !0;
      }
      return !1;
    }
    function Cy(e, t, i, n) {
      return we(e, i, n) !== we(t, i, n) && we(e, t, i) !== we(e, t, n);
    }
    function My(e, t, i) {
      const n = i * i;
      if (1 === t.length) return e.distSqr(t[0]) < n;
      for (let i = 1; i < t.length; i++) if (Iy(e, t[i - 1], t[i]) < n) return !0;
      return !1;
    }
    function Iy(e, t, i) {
      const n = t.distSqr(i);
      if (0 === n) return e.distSqr(t);
      const r = ((e.x - t.x) * (i.x - t.x) + (e.y - t.y) * (i.y - t.y)) / n;
      return e.distSqr(r < 0 ? t : r > 1 ? i : i.sub(t)._mult(r)._add(t));
    }
    function Ly(e, t) {
      let i,
        n,
        r,
        o = !1;
      for (let a = 0; a < e.length; a++) {
        i = e[a];
        for (let e = 0, a = i.length - 1; e < i.length; a = e++)
          (n = i[e]),
            (r = i[a]),
            n.y > t.y != r.y > t.y &&
              t.x < ((r.x - n.x) * (t.y - n.y)) / (r.y - n.y) + n.x &&
              (o = !o);
      }
      return o;
    }
    function Ry(e, t) {
      let i = !1;
      for (let n = 0, r = e.length - 1; n < e.length; r = n++) {
        const o = e[n],
          a = e[r];
        o.y > t.y != a.y > t.y && t.x < ((a.x - o.x) * (t.y - o.y)) / (a.y - o.y) + o.x && (i = !i);
      }
      return i;
    }
    function Ny(e, t, i) {
      const n = i[0],
        r = i[2];
      if (
        (e.x < n.x && t.x < n.x) ||
        (e.x > r.x && t.x > r.x) ||
        (e.y < n.y && t.y < n.y) ||
        (e.y > r.y && t.y > r.y)
      )
        return !1;
      const o = we(e, t, i[0]);
      return o !== we(e, t, i[1]) || o !== we(e, t, i[2]) || o !== we(e, t, i[3]);
    }
    function Oy(e, t, i) {
      const n = t.paint.get(e).value;
      return 'constant' === n.kind ? n.value : i.programConfigurations.get(t.id).getMaxValue(e);
    }
    function Dy(e, t, i, n, r) {
      if (!t[0] && !t[1]) return e;
      const o = te.convert(t);
      'viewport' === i && o._rotate(-n);
      const a = [];
      for (let t = 0; t < e.length; t++) a.push(e[t].sub(o._mult(r)));
      return a;
    }
    fo('FillBucket', xy, { omit: ['layers'] });
    const Fy = new Vd({
      'fill-sort-key': new Dd(pm.layout_fill['fill-sort-key']),
      dynamic: new Od(pm.layout_fill.dynamic),
    });
    var zy = {
      paint: new Vd({
        'fill-antialias': new Od(pm.paint_fill['fill-antialias']),
        'fill-opacity': new Dd(pm.paint_fill['fill-opacity']),
        'fill-water-texture': new Od(pm.paint_fill['fill-water-texture']),
        'fill-water-mirror-texture': new Od(pm.paint_fill['fill-water-mirror-texture']),
        'fill-water-speed': new Od(pm.paint_fill['fill-water-speed']),
        'fill-water-wave-size': new Od(pm.paint_fill['fill-water-wave-size']),
        'sunlight-color': new Od(pm.paint_fill['sunlight-color']),
        'sunlight-direction': new Od(pm.paint_fill['sunlight-direction']),
        'sky-color': new Od(pm.paint_fill['sky-color']),
        'fill-color': new Dd(pm.paint_fill['fill-color']),
        'fill-outline-color': new Dd(pm.paint_fill['fill-outline-color']),
        'fill-translate': new Dd(pm.paint_fill['fill-translate']),
        'fill-translate-anchor': new Dd(pm.paint_fill['fill-translate-anchor']),
        'fill-pattern': new zd(pm.paint_fill['fill-pattern']),
        'fill-water': new Od(pm.paint_fill['fill-water']),
        'fill-dynamic-speed': new Dd(pm.paint_fill['fill-dynamic-speed']),
        'fill-dynamic-image-url': new zd(pm.paint_fill['fill-dynamic-image-url']),
      }),
      layout: Fy,
    };
    const By = Gt(
        [
          { name: 'a_POSITION', components: 3, type: 'Float32' },
          { name: 'a_NORMAL', components: 1, type: 'Uint8' },
          { name: 'a_data', components: 4, type: 'Uint8' },
          { name: 'a_extra_extrude', components: 2, type: 'Uint8' },
        ],
        4,
      ),
      { members: Vy } = By,
      Uy = Gt([
        { name: 'a_uv_x', components: 1, type: 'Float32' },
        { name: 'a_split_index', components: 1, type: 'Float32' },
      ]),
      { members: ky } = Uy;
    function Gy(e, t, i, n, r) {
      const o = [];
      for (let a = 0; a < e.length; a++) {
        const s = e[a];
        let l;
        for (let e = 0; e < s.length - 1; e++) {
          let a = s[e],
            c = s[e + 1];
          (a.x < t && c.x < t) ||
            (a.x < t
              ? (a = new te(t, a.y + ((t - a.x) / (c.x - a.x)) * (c.y - a.y))._round())
              : c.x < t && (c = new te(t, a.y + ((t - a.x) / (c.x - a.x)) * (c.y - a.y))._round()),
            (a.y < i && c.y < i) ||
              (a.y < i
                ? (a = new te(a.x + ((i - a.y) / (c.y - a.y)) * (c.x - a.x), i)._round())
                : c.y < i &&
                  (c = new te(a.x + ((i - a.y) / (c.y - a.y)) * (c.x - a.x), i)._round()),
              (a.x >= n && c.x >= n) ||
                (a.x >= n
                  ? (a = new te(n, a.y + ((n - a.x) / (c.x - a.x)) * (c.y - a.y))._round())
                  : c.x >= n &&
                    (c = new te(n, a.y + ((n - a.x) / (c.x - a.x)) * (c.y - a.y))._round()),
                (a.y >= r && c.y >= r) ||
                  (a.y >= r
                    ? (a = new te(a.x + ((r - a.y) / (c.y - a.y)) * (c.x - a.x), r)._round())
                    : c.y >= r &&
                      (c = new te(a.x + ((r - a.y) / (c.y - a.y)) * (c.x - a.x), r)._round()),
                  (l && a.equals(l[l.length - 1])) || ((l = [a]), o.push(l)),
                  l.push(c)))));
        }
      }
      return o;
    }
    const Hy = Qf.VectorTileFeature.types,
      Yy = 63,
      qy = Math.cos((Math.PI / 180) * 37.5),
      Xy = 0.5,
      jy = Math.pow(2, 14) / Xy;
    class Wy {
      constructor(e) {
        (this.zoom = e.zoom),
          (this.overscaling = e.overscaling),
          (this.layers = e.layers),
          (this.layerIds = this.layers.map((e) => e.id)),
          (this.index = e.index),
          (this.hasPattern = !1),
          (this.patternFeatures = []),
          (this.lineClipsArray = []),
          (this.gradients = {}),
          (this.vectorRenderInSpace = !1),
          this.layers.forEach((e) => {
            (this.gradients[e.id] = {}),
              (this.classificationtype = e.classificationType),
              r_(e.classificationType) && (this.vectorRenderInSpace = !0);
          }),
          (this.type = tm.LINE),
          (this.layoutVertexArray = new Do()),
          (this.layoutVertexArray2 = new Ho()),
          (this.indexArray = new ea()),
          (this.programConfigurations = new cp(Vy, e.layers, e.zoom)),
          (this.segments = new Yh()),
          (this.maxLineLength = 0),
          (this.projection = e.projection || Ot.MERCATOR),
          (this.stateDependentLayerIds = this.layers
            .filter((e) => e.isStateDependent())
            .map((e) => e.id)),
          (this.tempVertex = []),
          (this.bottomTempVertex = []),
          (this.bottomTempIndice = []),
          (this.maximumHeight = 0),
          (this.minimumHeight = 0),
          (this.forceUpdateSegment = !1);
      }
      _convertGeometryPointToLine(e) {
        const t = [];
        for (let i = 0; i < e.length; i++) {
          const n = [];
          let r = 1 / 0,
            o = 1 / 0,
            a = -1 / 0,
            s = -1 / 0;
          for (let t = 0; t < e[i].length; t++) {
            const l = e[i][t].x,
              c = e[i][t].y;
            n.push([l, c]), r > l && (r = l), a < l && (a = l), o > c && (o = c), s < c && (s = c);
          }
          t.push({ type: 'LineString', geometry: [n], min: [r, o], max: [a, s] });
        }
        return t;
      }
      _convertLineToGeometry(e) {
        const t = [];
        for (let i = 0; i < e.length; i++) {
          const n = e[i].geometry.map((e) => e.map((e) => new te(e[0], e[1])));
          t.push(...n);
        }
        return t;
      }
      populate(e, t, i) {
        this.referencePoint ||
          ((this.x = t.x),
          (this.y = t.y),
          (this.z = t.z),
          (this.zPow = Math.pow(2, this.z)),
          (this.referencePoint = Xs(this.x, this.y, this.z, this.projection)),
          (this.matrix = new Je()),
          (this.matrix[12] = this.referencePoint[0]),
          (this.matrix[13] = this.referencePoint[1]),
          (this.matrix[14] = this.referencePoint[2]),
          py.getMinMaxHeight(this));
        const n = this.layers[0].layout.get('line-sort-key'),
          r = [];
        for (const { feature: t, id: o, index: a, sourceLayerIndex: s } of e) {
          const e = this.layers[0]._featureFilter.needGeometry,
            l = { type: t.type, id: o, properties: t.properties, geometry: e ? qf(t) : [] };
          if (!this.layers[0]._featureFilter(new fd(this.zoom), l, i)) continue;
          e || (l.geometry = qf(t));
          const c = n ? n.evaluate(l, {}, i) : void 0;
          r.push({ feature: t, sourceLayerIndex: s, index: a, sortKey: c });
        }
        n && r.sort((e, t) => e.sortKey - t.sortKey);
        for (const e of r) {
          const { feature: i, index: n, sourceLayerIndex: o } = e;
          this.vectorRenderInSpace && fy.featureInsect(e, r) && (this.forceUpdateSegment = !0);
          const a = qf(i);
          let s = my(this.z);
          this.layers[0].paint._values['line-gradient'] && (s = 1);
          const l = this._convertGeometryPointToLine(a),
            c = [];
          3 === i.type && ((s = 2), (i.polygon2Line = !0)), sy(s, 0, 8192, 0, 8192, l, c);
          const u = this._convertLineToGeometry(c);
          if (this.classificationtype === n_.VECTOR_WITH_HEIGHT) {
            const e = i?.properties?.height?.split(',');
            for (let t = 0; t < u[0].length && e && 0 !== e.length; t++) u[0][t].z = +e[t];
          }
          this.addFeature(i, u, n, new wd(this.z, this.x, this.y), {}),
            (this.forceUpdateSegment = !1),
            t.featureIndex.insert(i, a, n, o, this.index);
        }
        delete this.tempVertex,
          delete this.bottomTempVertex,
          delete this.bottomTempIndice,
          delete this.maximumHeight,
          delete this.minimumHeight,
          delete this.forceUpdateSegment,
          delete this.e1,
          delete this.e2,
          0 == this.layoutVertexArray2.length && delete this.layoutVertexArray2;
      }
      update(e, t) {
        this.stateDependentLayers.length &&
          this.programConfigurations.updatePaintArrays(e, t, this.stateDependentLayers);
      }
      addFeatures(e, t, i) {
        for (const e of this.patternFeatures) this.addFeature(e, e.geometry, e.index, t, i);
      }
      isEmpty() {
        return 0 === this.layoutVertexArray.length;
      }
      uploadPending() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }
      upload(e) {
        this.uploaded ||
          (this.layoutVertexArray2 &&
            0 !== this.layoutVertexArray2.length &&
            (this.layoutVertexBuffer2 = e.createVertexBuffer(this.layoutVertexArray2, ky)),
          (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Vy)),
          (this.indexBuffer = e.createIndexBuffer(this.indexArray))),
          this.programConfigurations.upload(e),
          (this.uploaded = !0);
      }
      destroy() {
        this.layoutVertexBuffer &&
          (this.layoutVertexBuffer.destroy(),
          this.layoutVertexBuffer2 && this.layoutVertexBuffer2.destroy(),
          this.indexBuffer.destroy(),
          this.programConfigurations.destroy(),
          this.segments.destroy());
      }
      lineFeatureClips(e) {
        if (
          e.properties &&
          e.properties.hasOwnProperty('minemap_clip_start') &&
          e.properties.hasOwnProperty('minemap_clip_end')
        )
          return { start: +e.properties.minemap_clip_start, end: +e.properties.minemap_clip_end };
      }
      addFeature(e, t, i, n, r) {
        const o = this.layers[0].layout,
          a = o.get('line-join').evaluate(e, {}),
          s = o.get('line-cap'),
          l = o.get('line-miter-limit'),
          c = o.get('line-round-limit');
        this.lineClips = this.lineFeatureClips(e);
        for (const i of Gy(t, 0, 0, Wu, Wu))
          if (this.vectorRenderInSpace) {
            (this.tempVertex = []),
              (this.bottomTempVertex = []),
              (this.bottomTempIndice = []),
              this.addLine(i, e, a, s, l, c);
            const t = this.segments.prepareSegment(
              4 * (this.tempVertex.length + this.bottomTempVertex.length),
              this.layoutVertexArray,
              this.indexArray,
            );
            this.tempVertex.push(this.tempVertex[0]),
              this.addSide(t),
              this.addBottom(t),
              (this.tempVertex = []),
              (this.bottomTempIndice = []),
              (this.bottomTempVertex = []);
          } else this.addLine(i, e, a, s, l, c);
        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, i, r, n);
      }
      addLine(e, t, i, n, r, o) {
        if (
          ((this.distance = 0), (this.scaledDistance = 0), (this.totalDistance = 0), this.lineClips)
        ) {
          this.lineClipsArray.push(this.lineClips);
          for (let t = 0; t < e.length - 1; t++) this.totalDistance += e[t].dist(e[t + 1]);
          this.updateScaledDistance(),
            (this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance));
        }
        let a = 'Polygon' === Hy[t.type];
        t.polygon2Line && (a = !1);
        let s = e.length;
        for (; s >= 2 && e[s - 1].equals(e[s - 2]); ) s--;
        let l = 0;
        for (; l < s - 1 && e[l].equals(e[l + 1]); ) l++;
        if (s < (a ? 3 : 2)) return;
        'bevel' === i && (r = 1.05);
        const c = this.overscaling <= 16 ? (15 * Wu) / (512 * this.overscaling) : 0,
          u = this.segments.prepareSegment(10 * s, this.layoutVertexArray, this.indexArray);
        let h, d, p, f, m;
        (this.e1 = this.e2 = -1), a && ((h = e[s - 2]), (m = e[l].sub(h)._unit()._perp()));
        for (let t = l; t < s; t++) {
          if (((p = t === s - 1 ? (a ? e[l + 1] : void 0) : e[t + 1]), p && e[t].equals(p)))
            continue;
          m && (f = m),
            h && (d = h),
            (h = e[t]),
            (m = p ? p.sub(h)._unit()._perp() : f),
            (f = f || m);
          let _ = f.add(m);
          (0 === _.x && 0 === _.y) || _._unit();
          const g = f.x * m.x + f.y * m.y,
            y = _.x * m.x + _.y * m.y,
            x = 0 !== y ? 1 / y : 1 / 0,
            v = 2 * Math.sqrt(2 - 2 * y),
            w = y < qy && d && p,
            T = f.x * m.y - f.y * m.x > 0;
          if (w && t > l) {
            const e = h.dist(d);
            if (e > 2 * c) {
              const t = h.sub(
                h
                  .sub(d)
                  ._mult(c / e)
                  ._round(),
              );
              this.updateDistance(d, t), this.addCurrentVertex(t, f, 0, 0, u), (d = t);
            }
          }
          const b = d && p;
          let S = b ? i : a ? 'butt' : n;
          if (
            (b && 'round' === S && (x < o ? (S = 'miter') : x <= 2 && (S = 'fakeround')),
            'miter' === S && x > r && (S = 'bevel'),
            'bevel' === S && (x > 2 && (S = 'flipbevel'), x < r && (S = 'miter')),
            d && this.updateDistance(d, h),
            'miter' === S)
          )
            _._mult(x), this.addCurrentVertex(h, _, 0, 0, u);
          else if ('flipbevel' === S) {
            if (x > 100) _ = m.mult(-1);
            else {
              const e = (x * f.add(m).mag()) / f.sub(m).mag();
              _._perp()._mult(e * (T ? -1 : 1));
            }
            this.addCurrentVertex(h, _, 0, 0, u), this.addCurrentVertex(h, _.mult(-1), 0, 0, u);
          } else if ('bevel' === S || 'fakeround' === S) {
            const e = -Math.sqrt(x * x - 1),
              t = T ? e : 0,
              i = T ? 0 : e;
            if ((d && this.addCurrentVertex(h, f, t, i, u), 'fakeround' === S)) {
              const e = Math.round((180 * v) / Math.PI / 20);
              for (let t = 1; t < e; t++) {
                let i = t / e;
                if (0.5 !== i) {
                  const e = i - 0.5;
                  i +=
                    i *
                    e *
                    (i - 1) *
                    ((1.0904 + g * (g * (3.55645 - 1.43519 * g) - 3.2452)) * e * e +
                      (0.848013 + g * (0.215638 * g - 1.06021)));
                }
                const n = m
                  .sub(f)
                  ._mult(i)
                  ._add(f)
                  ._unit()
                  ._mult(T ? -1 : 1);
                this.addHalfVertex(h, n.x, n.y, !1, T, 0, u, { x: 0, y: 0 });
              }
            }
            p && this.addCurrentVertex(h, m, -t, -i, u);
          } else if ('butt' === S) this.addCurrentVertex(h, _, 0, 0, u);
          else if ('square' === S) {
            const e = d ? 1 : -1;
            this.addCurrentVertex(h, _, e, e, u);
          } else
            'round' === S
              ? (d &&
                  (this.addCurrentVertex(h, f, 0, 0, u), this.addCurrentVertex(h, f, 1, 1, u, !0)),
                p &&
                  (this.addCurrentVertex(h, m, -1, -1, u, !0),
                  this.addCurrentVertex(h, m, 0, 0, u)))
              : 'round-butt' === S &&
                (d &&
                  (this.addCurrentVertex(h, f, 0, 0, u),
                  this.addCurrentVertex(h, f, 0.5, 0.5, u, !0, 0.42, 0.42)),
                p &&
                  (this.addCurrentVertex(h, m, -0.5, -0.5, u, !0, -0.42, -0.42),
                  this.addCurrentVertex(h, m, 0, 0, u)));
          if (w && t < s - 1) {
            const e = h.dist(p);
            if (e > 2 * c) {
              const t = h.add(
                p
                  .sub(h)
                  ._mult(c / e)
                  ._round(),
              );
              this.updateDistance(h, t), this.addCurrentVertex(t, m, 0, 0, u), (h = t);
            }
          }
        }
        return u;
      }
      addBottom(e) {
        const t = e.vertexLength,
          i = this.bottomTempIndice;
        let n = -1;
        for (let e = 0; e < i.length; e++) {
          const t = i[e];
          n =
            n > -1
              ? Math.min(Math.min(Math.min(t.x, t.y), t.z), n)
              : Math.min(Math.min(t.x, t.y), t.z);
        }
        for (let r = 0; r < i.length; r++) {
          const o = i[r];
          this.indexArray.emplaceBack(t + o.x - n, t + o.y - n, t + o.z - n), e.primitiveLength++;
        }
        const r = this.bottomTempVertex;
        for (let t = 0; t < r.length; t++) {
          const i = r[t],
            n = (this.lineClips ? this.scaledDistance * (jy - 1) : this.scaledDistance) * Xy;
          this.layoutVertexArray.emplaceBack(
            i.currentVertex.x,
            i.currentVertex.y,
            i.currentVertex.z,
            (i.round ? 2 : 0) + (i.up ? 1 : 0),
            Math.round(Yy * i.extrudeX) + 128,
            Math.round(Yy * i.extrudeY) + 128,
            (1 + (0 === i.dir ? 0 : i.dir < 0 ? -1 : 1)) | ((63 & n) << 2),
            n >> 6,
            128,
            128,
          ),
            e.vertexLength++;
        }
      }
      addSide(e) {
        if (this.tempVertex.length < 2) return;
        let t = !0;
        for (let i = 0; i < this.tempVertex.length; i++)
          if (0 === i) {
            const e = this.tempVertex[i];
            (t = !t),
              this.addSideVertex(
                e.currentVertex.x,
                e.currentVertex.y,
                e.currentVertex.z,
                e.extrudeX,
                e.extrudeY,
                e.round,
                t,
                e.dir,
              ),
              this.addSideVertex(
                e.currentSpaceVertex.x,
                e.currentSpaceVertex.y,
                e.currentSpaceVertex.z,
                e.extrudeX,
                e.extrudeY,
                e.round,
                t,
                e.dir,
              );
          } else {
            t = !t;
            const n = this.tempVertex[i];
            this.addSideVertex(
              n.currentVertex.x,
              n.currentVertex.y,
              n.currentVertex.z,
              n.extrudeX,
              n.extrudeY,
              n.round,
              t,
              n.dir,
            ),
              this.addSideVertex(
                n.currentSpaceVertex.x,
                n.currentSpaceVertex.y,
                n.currentSpaceVertex.z,
                n.extrudeX,
                n.extrudeY,
                n.round,
                t,
                n.dir,
              );
            const r = e.vertexLength;
            this.indexArray.emplaceBack(r, r + 2, r + 1),
              this.indexArray.emplaceBack(r + 1, r + 2, r + 3),
              (e.vertexLength += 2),
              (e.primitiveLength += 2);
          }
        e.vertexLength += 2;
      }
      addSideVertex(e, t, i, n, r, o, a, s) {
        const l = (this.lineClips ? this.scaledDistance * (jy - 1) : this.scaledDistance) * Xy;
        this.layoutVertexArray.emplaceBack(
          e,
          t,
          i,
          (o ? 2 : 0) + (a ? 1 : 0),
          Math.round(Yy * n) + 128,
          Math.round(Yy * r) + 128,
          (1 + (0 === s ? 0 : s < 0 ? -1 : 1)) | ((63 & l) << 2),
          l >> 6,
          128,
          128,
        );
      }
      calcTDSpacePoint(e, t) {
        if (Object.is(e.x, NaN) || Object.is(e.y, NaN) || Object.is(e.z, NaN)) return;
        const i = qs(this.x + e.x / 8192, this.y + e.y / 8192, this.zPow, this.projection),
          n = Il.cartographicToCartesian3(new Pt([i[0], i[1], t]));
        return new te(
          n[0] - this.referencePoint[0],
          n[1] - this.referencePoint[1],
          n[2] - this.referencePoint[2],
        );
      }
      addCurrentVertex(e, t, i, n, r, o = !1, a = 0, s = 0) {
        const l = t.x + t.y * i,
          c = t.y - t.x * i,
          u = t.y * n - t.x,
          h = -t.y - t.x * n;
        let d = t.mult(0);
        d = t.perp().mult(-a);
        let p = t.mult(0);
        p = t.perp().mult(-s);
        const f = this.calcTDSpacePoint(e, this.minimumHeight);
        if (null != f) {
          if (this.vectorRenderInSpace) {
            const t = this.calcTDSpacePoint(e, this.maximumHeight);
            if (null == t) return;
            this.addHalfVertex(e, l, c, o, !1, i, r, d),
              this.addHalfVertex(e, u, h, o, !0, -n, r, p),
              this.tempVertex.push({
                currentVertex: f,
                currentSpaceVertex: t,
                extrudeX: l,
                extrudeY: c,
                round: o,
                up: !1,
                dir: i,
              }),
              this.tempVertex.unshift({
                currentVertex: f,
                currentSpaceVertex: t,
                extrudeX: u,
                extrudeY: h,
                round: o,
                up: !0,
                dir: -n,
              });
          } else
            this.addHalfVertex(e, l, c, o, !1, i, r, d),
              this.addHalfVertex(e, u, h, o, !0, -n, r, p);
          this.distance > jy / 2 &&
            0 === this.totalDistance &&
            ((this.distance = 0), this.addCurrentVertex(e, t, i, n, r, o));
        }
      }
      addHalfVertex(e, t, i, n, r, o, a, s) {
        const l = this.layers[0].layout.get('line-height-offset')?.value?.value || 0,
          c = this.lineClips ? this.scaledDistance * (jy - 1) : this.scaledDistance,
          u = this.calcTDSpacePoint(e, this.vectorRenderInSpace ? this.maximumHeight : e.z + l);
        if (null == u) return;
        if (this.vectorRenderInSpace) {
          const a = this.calcTDSpacePoint(e, this.minimumHeight);
          if (void 0 === a) return;
          this.bottomTempVertex.push({
            currentVertex: a,
            extrudeX: t,
            extrudeY: i,
            round: n,
            up: r,
            dir: o,
          });
        }
        const h = c * Xy;
        this.layoutVertexArray.emplaceBack(
          u.x,
          u.y,
          u.z,
          (n ? 2 : 0) + (r ? 1 : 0),
          Math.round(Yy * t) + 128,
          Math.round(Yy * i) + 128,
          (1 + (0 === o ? 0 : o < 0 ? -1 : 1)) | ((63 & h) << 2),
          h >> 6,
          Math.round(Yy * s.x) + 128,
          Math.round(Yy * s.y) + 128,
        ),
          this.lineClips &&
            this.layoutVertexArray2.emplaceBack(
              (this.scaledDistance - this.lineClips.start) /
                (this.lineClips.end - this.lineClips.start),
              this.lineClipsArray.length,
            );
        const d = a.vertexLength++;
        this.e1 >= 0 &&
          this.e2 >= 0 &&
          (this.indexArray.emplaceBack(this.e1, d, this.e2),
          a.primitiveLength++,
          this.vectorRenderInSpace && this.bottomTempIndice.push({ x: this.e1, y: this.e2, z: d })),
          r ? (this.e2 = d) : (this.e1 = d);
      }
      updateScaledDistance() {
        this.scaledDistance = this.lineClips
          ? this.lineClips.start +
            ((this.lineClips.end - this.lineClips.start) * this.distance) / this.totalDistance
          : this.distance;
      }
      updateDistance(e, t) {
        (this.distance += e.dist(t)), this.updateScaledDistance();
      }
    }
    fo('LineBucket', Wy, { omit: ['layers', 'patternFeatures'] });
    const $y = new Vd({
      'line-cap': new Od(pm.layout_line['line-cap']),
      'line-join': new Dd(pm.layout_line['line-join']),
      'line-miter-limit': new Od(pm.layout_line['line-miter-limit']),
      'line-round-limit': new Od(pm.layout_line['line-round-limit']),
      'line-sort-key': new Dd(pm.layout_line['line-sort-key']),
      'line-height-offset': new Dd(pm.layout_line['line-height-offset']),
      'border-visibility': new Od(pm.layout_line['border-visibility']),
    });
    var Zy = {
      paint: new Vd({
        'line-opacity': new Dd(pm.paint_line['line-opacity']),
        'line-color': new Dd(pm.paint_line['line-color']),
        'line-translate': new Dd(pm.paint_line['line-translate']),
        'line-translate-anchor': new Dd(pm.paint_line['line-translate-anchor']),
        'line-width': new Dd(pm.paint_line['line-width']),
        'line-border-width': new Dd(pm.paint_line['line-border-width']),
        'line-border-opacity': new Dd(pm.paint_line['line-border-opacity']),
        'line-border-color': new Dd(pm.paint_line['line-border-color']),
        'line-gap-width': new Dd(pm.paint_line['line-gap-width']),
        'line-offset': new Dd(pm.paint_line['line-offset']),
        'line-blur': new Dd(pm.paint_line['line-blur']),
        'line-dasharray': new zd(pm.paint_line['line-dasharray']),
        'line-pattern': new zd(pm.paint_line['line-pattern']),
        'line-gradient': new Bd(pm.paint_line['line-gradient']),
        'half-render': new Od(pm.paint_line['half-render']),
        'line-normal-direction': new Dd(pm.paint_line['line-normal-direction']),
      }),
      layout: $y,
    };
    const Ky = new (class extends Dd {
      possiblyEvaluate(e, t) {
        return (
          (t = new fd(Math.floor(t.zoom), {
            now: t.now,
            fadeDuration: t.fadeDuration,
            zoomHistory: t.zoomHistory,
            transition: t.transition,
          })),
          super.possiblyEvaluate(e, t)
        );
      }
      evaluate(e, t, i, n) {
        return (t = ce({}, t, { zoom: Math.floor(t.zoom) })), super.evaluate(e, t, i, n);
      }
    })(Zy.paint.properties['line-width'].specification);
    Ky.useIntegerZoom = !0;
    class Qy extends dg {
      constructor(e) {
        e &&
          e.layout &&
          'visible' === e.layout['border-visibility'] &&
          e.paint &&
          e.paint['line-gap-width'] &&
          (ve("'line-gap-width' cannot be set when 'border-visibility' is 'visible'"),
          (e.paint['line-gap-width'] = 0)),
          super(e, Zy),
          (this.gradientVersion = 0);
      }
      _handleSpecialPaintPropertyUpdate(e) {
        'line-gradient' === e &&
          ((this.stepInterpolate =
            this._transitionablePaint._values['line-gradient'].value.expression._styleExpression
              .expression instanceof Fn),
          (this.gradientVersion = (this.gradientVersion + 1) % ne));
      }
      gradientExpression() {
        return this._transitionablePaint._values['line-gradient'].value.expression;
      }
      getCrossfadeParameters() {
        return this._crossfadeParameters;
      }
      recalculate(e, t) {
        super.recalculate(e, t),
          e.getCrossfadeParameters && (this._crossfadeParameters = e.getCrossfadeParameters()),
          (this.paint._values['line-floorwidth'] = Ky.possiblyEvaluate(
            this._transitioningPaint._values['line-width'].value,
            e,
          ));
      }
      createBucket(e) {
        return new Wy(e);
      }
      queryRadius(e) {
        const t = e,
          i = Jy(Oy('line-width', this, t), Oy('line-gap-width', this, t)),
          n = Oy('line-offset', this, t);
        return i / 2 + Math.abs(n) + 0;
      }
      queryIntersectsFeature(e, t, i, n, r, o, a, s) {
        const l = Dy(
          e,
          this.paint.get('line-translate'),
          this.paint.get('line-translate-anchor'),
          -o.hpr.heading,
          a,
        );
        let c =
          (a / 2) *
          Jy(
            this.paint.get('line-width').evaluate(t, i),
            this.paint.get('line-gap-width').evaluate(t, i),
          );
        null != s && null != s.line && (c = Math.max(c, s.line));
        const u = this.paint.get('line-offset').evaluate(t, i);
        return (
          u &&
            (n = (function (e, t) {
              const i = [],
                n = new te(0, 0);
              for (let r = 0; r < e.length; r++) {
                const o = e[r],
                  a = [];
                for (let e = 0; e < o.length; e++) {
                  const i = o[e],
                    r = o[e + 1],
                    s =
                      0 === e
                        ? n
                        : i
                            .sub(o[e - 1])
                            ._unit()
                            ._perp(),
                    l = e === o.length - 1 ? n : r.sub(i)._unit()._perp(),
                    c = s._add(l)._unit();
                  c._mult(1 / (c.x * l.x + c.y * l.y)), a.push(c._mult(t)._add(i));
                }
                i.push(a);
              }
              return i;
            })(n, u * a)),
          Ay(l, n, c)
        );
      }
      hasOffscreenPass() {
        return 0 !== this.paint.get('line-opacity') && 'none' !== this.visibility;
      }
    }
    function Jy(e, t) {
      return t > 0 ? t + 2 * e : e;
    }
    const ex = Gt(
        [
          { name: 'a_POSITION', components: 3, type: 'Float32' },
          { name: 'a_extra', components: 2, type: 'Int16' },
        ],
        4,
      ),
      { members: tx } = ex;
    function ix(e, t, i, n, r, o) {
      e.emplaceBack(t, i, n, r, o);
    }
    class nx {
      constructor(e) {
        (this.zoom = e.zoom),
          (this.overscaling = e.overscaling),
          (this.layers = e.layers),
          (this.layerIds = this.layers.map((e) => e.id)),
          (this.index = e.index),
          (this.type = tm.CIRCLE),
          (this.layoutVertexArray = new ko()),
          (this.indexArray = new ea()),
          (this.segments = new Yh()),
          (this.programConfigurations = new cp(tx, e.layers, e.zoom)),
          (this.projection = e.projection || Ot.MERCATOR);
      }
      populate(e, t, i) {
        const n = this.layers[0],
          r = [];
        let o = null;
        'circle' === n.type && (o = n.layout.get('circle-sort-key')),
          this.referencePoint ||
            ((this.x = t.x),
            (this.y = t.y),
            (this.z = t.z),
            (this.zPow = Math.pow(2, this.z)),
            (this.referencePoint = Xs(this.x, this.y, this.z, this.projection)),
            (this.matrix = new Je()),
            (this.matrix[12] = this.referencePoint[0]),
            (this.matrix[13] = this.referencePoint[1]),
            (this.matrix[14] = this.referencePoint[2]));
        for (const { feature: t, index: n, sourceLayerIndex: a } of e) {
          const e = t.id,
            s = this.layers[0]._featureFilter.needGeometry,
            l = { type: t.type, id: e, properties: t.properties, geometry: s ? qf(t) : [] };
          if (!this.layers[0]._featureFilter(new fd(this.zoom), t, i)) continue;
          s || (l.geometry = qf(t));
          const c = o ? o.evaluate(l, {}, i) : void 0;
          r.push({
            id: e,
            properties: t.properties,
            type: t.type,
            sourceLayerIndex: a,
            index: n,
            geometry: l.geometry,
            patterns: {},
            sortKey: c,
          });
        }
        o && r.sort((e, t) => e.sortKey - t.sortKey);
        for (const n of r) {
          const { geometry: r, index: o, sourceLayerIndex: a } = n,
            s = e[o].feature;
          this.addFeature(n, r, o, i), t.featureIndex.insert(s, r, o, a, this.index);
        }
        (this.x = t.x), (this.y = t.y), (this.z = t.z);
      }
      update(e, t) {
        this.stateDependentLayers.length &&
          this.programConfigurations.updatePaintArrays(e, t, this.stateDependentLayers);
      }
      isEmpty() {
        return 0 === this.layoutVertexArray.length;
      }
      uploadPending() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }
      upload(e) {
        this.uploaded ||
          ((this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, tx)),
          (this.indexBuffer = e.createIndexBuffer(this.indexArray))),
          this.programConfigurations.upload(e),
          (this.uploaded = !0);
      }
      destroy() {
        this.layoutVertexBuffer &&
          (this.layoutVertexBuffer.destroy(),
          this.indexBuffer.destroy(),
          this.programConfigurations.destroy(),
          this.segments.destroy());
      }
      calcTDSpacePoint(e, t) {
        const i = qs(this.x + e / 8192, this.y + t / 8192, this.zPow, this.projection),
          n = Il.cartographicToCartesian3(new Pt(i[0], i[1], 0));
        return [
          n[0] - this.referencePoint[0],
          n[1] - this.referencePoint[1],
          n[2] - this.referencePoint[2],
        ];
      }
      addFeature(e, t, i, n) {
        for (const e of t)
          for (const t of e) {
            const e = t.x,
              i = t.y;
            if (e < 0 || e >= Wu || i < 0 || i >= Wu) continue;
            const n = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray),
              r = n.vertexLength,
              o = this.calcTDSpacePoint(e, i);
            ix(this.layoutVertexArray, ...o, -1, -1),
              ix(this.layoutVertexArray, ...o, 1, -1),
              ix(this.layoutVertexArray, ...o, 1, 1),
              ix(this.layoutVertexArray, ...o, -1, 1),
              this.indexArray.emplaceBack(r, r + 1, r + 2),
              this.indexArray.emplaceBack(r, r + 3, r + 2),
              (n.vertexLength += 4),
              (n.primitiveLength += 2);
          }
        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, i, {}, n);
      }
    }
    fo('CircleBucket', nx, { omit: ['layers'] });
    const rx = new Vd({ 'circle-sort-key': new Dd(pm.layout_circle['circle-sort-key']) });
    var ox = {
      paint: new Vd({
        'circle-radius': new Dd(pm.paint_circle['circle-radius']),
        'circle-color': new Dd(pm.paint_circle['circle-color']),
        'circle-blur': new Dd(pm.paint_circle['circle-blur']),
        'circle-opacity': new Dd(pm.paint_circle['circle-opacity']),
        'circle-translate': new Od(pm.paint_circle['circle-translate']),
        'circle-translate-anchor': new Od(pm.paint_circle['circle-translate-anchor']),
        'circle-pitch-scale': new Od(pm.paint_circle['circle-pitch-scale']),
        'circle-pitch-alignment': new Od(pm.paint_circle['circle-pitch-alignment']),
        'circle-stroke-width': new Dd(pm.paint_circle['circle-stroke-width']),
        'circle-stroke-color': new Dd(pm.paint_circle['circle-stroke-color']),
        'circle-stroke-opacity': new Dd(pm.paint_circle['circle-stroke-opacity']),
      }),
      layout: rx,
    };
    function ax(e, t) {
      const i = new Ge([e.x, e.y, 0, 1]).transform(t);
      return new te(i[0] / i[3], i[1] / i[3]);
    }
    const sx = Gt(
        [
          { name: 'a_pos_vec3', components: 3, type: 'Float32' },
          { name: 'a_extrude', components: 2, type: 'Int8' },
        ],
        4,
      ),
      { members: lx } = sx;
    function cx(e, t, i, n, r, o) {
      e.emplaceBack(t, i, n, r, o);
    }
    class ux {
      constructor(e) {
        (this.zoom = e.zoom),
          (this.overscaling = e.overscaling),
          (this.layers = e.layers),
          (this.layerIds = this.layers.map((e) => e.id)),
          (this.index = e.index),
          (this.type = tm.HEATMAP),
          (this.layoutVertexArray = new Io()),
          (this.indexArray = new ea()),
          (this.segments = new Yh()),
          (this.programConfigurations = new cp(lx, e.layers, e.zoom)),
          (this.projection = e.projection || Ot.MERCATOR);
      }
      populate(e, t, i) {
        const n = [];
        this.referencePoint ||
          ((this.x = t.x),
          (this.y = t.y),
          (this.z = t.z),
          (this.zPow = Math.pow(2, this.z)),
          (this.referencePoint = Xs(this.x, this.y, this.z, this.projection)),
          (this.matrix = new Je()),
          (this.matrix[12] = this.referencePoint[0]),
          (this.matrix[13] = this.referencePoint[1]),
          (this.matrix[14] = this.referencePoint[2]));
        for (const { feature: t, id: r, index: o, sourceLayerIndex: a } of e) {
          const e = this.layers[0]._featureFilter.needGeometry,
            s = { type: t.type, id: r, properties: t.properties, geometry: e ? qf(t) : [] };
          this.layers[0]._featureFilter(new fd(this.zoom), t, i) &&
            (e || (s.geometry = qf(t)),
            n.push({
              id: r,
              properties: t.properties,
              type: t.type,
              sourceLayerIndex: a,
              index: o,
              geometry: s.geometry,
              patterns: {},
            }));
        }
        for (const r of n) {
          const { geometry: n, index: o, sourceLayerIndex: a } = r,
            s = e[o].feature;
          this.addFeature(r, n, o, i), t.featureIndex.insert(s, n, o, a, this.index);
        }
        (this.x = t.x), (this.y = t.y), (this.z = t.z);
      }
      update(e, t) {
        this.stateDependentLayers.length &&
          this.programConfigurations.updatePaintArrays(e, t, this.stateDependentLayers);
      }
      isEmpty() {
        return 0 === this.layoutVertexArray.length;
      }
      uploadPending() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }
      upload(e) {
        this.uploaded ||
          ((this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, lx)),
          (this.indexBuffer = e.createIndexBuffer(this.indexArray))),
          this.programConfigurations.upload(e),
          (this.uploaded = !0);
      }
      destroy() {
        this.layoutVertexBuffer &&
          (this.layoutVertexBuffer.destroy(),
          this.indexBuffer.destroy(),
          this.programConfigurations.destroy(),
          this.segments.destroy());
      }
      calcTDSpacePoint(e, t) {
        const i = qs(this.x + e / 8192, this.y + t / 8192, this.zPow, this.projection),
          n = Il.cartographicToCartesian3(new Pt(i[0], i[1], 0));
        return [
          n[0] - this.referencePoint[0],
          n[1] - this.referencePoint[1],
          n[2] - this.referencePoint[2],
        ];
      }
      addFeature(e, t, i, n) {
        for (const e of t)
          for (const t of e) {
            const e = t.x,
              i = t.y;
            if (e < 0 || e >= Wu || i < 0 || i >= Wu) continue;
            const n = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray),
              r = n.vertexLength,
              o = this.calcTDSpacePoint(e, i);
            cx(this.layoutVertexArray, o[0], o[1], o[2], -1, -1),
              cx(this.layoutVertexArray, o[0], o[1], o[2], 1, -1),
              cx(this.layoutVertexArray, o[0], o[1], o[2], 1, 1),
              cx(this.layoutVertexArray, o[0], o[1], o[2], -1, 1),
              this.indexArray.emplaceBack(r, r + 1, r + 2),
              this.indexArray.emplaceBack(r, r + 3, r + 2),
              (n.vertexLength += 4),
              (n.primitiveLength += 2);
          }
        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, i, {}, n);
      }
    }
    function hx(e, { width: t, height: i }, n, r) {
      if (r) {
        if (r instanceof Uint8ClampedArray) r = new Uint8Array(r.buffer);
        else if (r.length !== t * i * n) throw new RangeError('mismatched image size');
      } else r = new Uint8Array(t * i * n);
      return (e.width = t), (e.height = i), (e.data = r), e;
    }
    function dx(e, { width: t, height: i }, n) {
      if (t === e.width && i === e.height) return;
      const r = hx({}, { width: t, height: i }, n);
      px(
        e,
        r,
        { x: 0, y: 0 },
        { x: 0, y: 0 },
        { width: Math.min(e.width, t), height: Math.min(e.height, i) },
        n,
      ),
        (e.width = t),
        (e.height = i),
        (e.data = r.data);
    }
    function px(e, t, i, n, r, o) {
      if (0 === r.width || 0 === r.height) return t;
      if (
        r.width > e.width ||
        r.height > e.height ||
        i.x > e.width - r.width ||
        i.y > e.height - r.height
      )
        throw new RangeError('out of range source coordinates for image copy');
      if (
        r.width > t.width ||
        r.height > t.height ||
        n.x > t.width - r.width ||
        n.y > t.height - r.height
      )
        throw new RangeError('out of range destination coordinates for image copy');
      const a = e.data,
        s = t.data;
      for (let l = 0; l < r.height; l++) {
        const c = ((i.y + l) * e.width + i.x) * o,
          u = ((n.y + l) * t.width + n.x) * o;
        for (let e = 0; e < r.width * o; e++) s[u + e] = a[c + e];
      }
      return t;
    }
    fo('HeatmapBucket', ux, { omit: ['layers'] });
    class fx {
      constructor(e, t) {
        hx(this, e, 1, t);
      }
      resize(e) {
        dx(this, e, 1);
      }
      clone() {
        return new fx({ width: this.width, height: this.height }, new Uint8Array(this.data));
      }
      static copy(e, t, i, n, r) {
        px(e, t, i, n, r, 1);
      }
    }
    class mx {
      constructor(e, t) {
        hx(this, e, 4, t);
      }
      resize(e) {
        dx(this, e, 4);
      }
      replace(e, t) {
        t
          ? this.data.set(e)
          : (this.data = e instanceof Uint8ClampedArray ? new Uint8Array(e.buffer) : e);
      }
      clone() {
        return new mx({ width: this.width, height: this.height }, new Uint8Array(this.data));
      }
      static copy(e, t, i, n, r) {
        px(e, t, i, n, r, 4);
      }
    }
    fo('AlphaImage', fx), fo('RGBAImage', mx);
    const _x = new Vd({ 'display-mode': new Od(pm.layout_heatmap['display-mode']) });
    var gx = {
      paint: new Vd({
        'heatmap-height': new Od(pm.paint_heatmap['heatmap-height']),
        'heatmap-radius': new Dd(pm.paint_heatmap['heatmap-radius']),
        'heatmap-weight': new Dd(pm.paint_heatmap['heatmap-weight']),
        'heatmap-intensity': new Od(pm.paint_heatmap['heatmap-intensity']),
        'heatmap-color': new Bd(pm.paint_heatmap['heatmap-color']),
        'heatmap-opacity': new Od(pm.paint_heatmap['heatmap-opacity']),
        'heatmap-height-factor': new Dd(pm.paint_heatmap['heatmap-height-factor']),
      }),
      layout: _x,
    };
    function yx(e) {
      const t = {},
        i = e.resolution || 256,
        n = e.clips ? e.clips.length : 1,
        r = e.image || new mx({ width: i, height: n }),
        o = (i, n, o) => {
          t[e.evaluationKey] = o;
          const a = e.expression.evaluate(t);
          (r.data[i + n + 0] = Math.floor(255 * a.r)),
            (r.data[i + n + 1] = Math.floor(255 * a.g)),
            (r.data[i + n + 2] = Math.floor(255 * a.b)),
            (r.data[i + n + 3] = Math.floor(255 * a.a));
        };
      if (e.clips)
        for (let t = 0, r = 0; t < n; ++t, r += 4 * i)
          for (let n = 0, a = 0; n < i; n++, a += 4) {
            const s = n / (i - 1),
              { start: l, end: c } = e.clips[t];
            o(r, a, l * (1 - s) + c * s);
          }
      else for (let e = 0, t = 0; e < i; e++, t += 4) o(0, t, e / (i - 1));
      return r;
    }
    function xx(e, t) {
      return t.replace(/{([^{}]+)}/g, (t, i) => (i in e ? String(e[i]) : ''));
    }
    const vx = Gt(
        [
          { name: 'a_POSITION', components: 3, type: 'Float32' },
          { name: 'a_NORMAL_ED', components: 3, type: 'Float32' },
          { name: 'a_ST', components: 3, type: 'Float32' },
        ],
        4,
      ),
      wx = Gt(
        [
          { name: 'a_ANS_POS_TIME_0', components: 1, type: 'Float32' },
          { name: 'a_ANS_POS_TIME_1', components: 1, type: 'Float32' },
          { name: 'a_ANS_POSITION_TOP_0', components: 3, type: 'Float32' },
          { name: 'a_ANS_POSITION_TOP_1', components: 3, type: 'Float32' },
        ],
        4,
      ),
      Tx = Gt(
        [
          { name: 'a_ANS_COLOR_TIME_0', components: 1, type: 'Float32' },
          { name: 'a_ANS_COLOR_TIME_1', components: 1, type: 'Float32' },
          { name: 'a_ANS_VERTEXCOLOR_0', components: 4, type: 'Uint8' },
          { name: 'a_ANS_VERTEXCOLOR_1', components: 4, type: 'Uint8' },
        ],
        1,
      ),
      { members: bx } = vx,
      Sx = Math.pow(2, 13),
      Ax = [1, 0, 16384];
    function Px(e, t, i, n, r, o, a, s, l, c) {
      e.emplaceBack(t, i, n, r, o, a, s, l, c);
    }
    function Ex(e, t, i, n) {
      e.emplaceBack(t.t0, t.t1, i.x, i.y, i.z, n.x, n.y, n.z);
    }
    class Cx {
      constructor(e, t) {
        (this.featureTriangles = []),
          (this.zoom = e.zoom),
          (this.overscaling = e.overscaling),
          (this.layers = e.layers),
          (this.layerIds = this.layers.map((e) => e.id)),
          (this.index = e.index),
          (this.type = tm.EXTRUSION),
          (this.layoutVertexArray = new Lo()),
          (this.positionAnimationVertexArray = new Ro()),
          (this.colorAnimationVertexArray = new No()),
          (this.indexArray = new ea()),
          (this.programConfigurations = new cp(bx, e.layers, e.zoom)),
          (this.segments = new Yh()),
          (this.projection = e.projection || Ot.MERCATOR),
          (this.enableQuery = t),
          (this._animationFlag = !1);
      }
      populate(e, t, i) {
        (this.x = t.x), (this.y = t.y), (this.z = t.z);
        for (const { feature: t, index: n } of e)
          if (this.layers[0]._featureFilter(new fd(this.zoom), t, i)) {
            const e = qf(t);
            if (Rx(e)) continue;
            const r = [];
            this.addFeature(t, e, n, r, i),
              this.enableQuery &&
                this.featureTriangles.push({
                  feature: t.toGeoJSON(this.x, this.y, this.z),
                  triangles: r,
                });
          }
        this.baseP && (this.matrix = js(0, this.baseP));
      }
      update(e, t) {
        this.stateDependentLayers.length &&
          this.programConfigurations.updatePaintArrays(e, t, this.stateDependentLayers);
      }
      isEmpty() {
        return 0 === this.layoutVertexArray.length;
      }
      uploadPending() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }
      upload(e) {
        this.uploaded ||
          ((this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, bx)),
          (this.indexBuffer = e.createIndexBuffer(this.indexArray)),
          this._animationFlag && this.uploadAnimationBuffers(e)),
          this.programConfigurations.upload(e),
          (this.uploaded = !0);
      }
      uploadAnimationBuffers(e) {
        (this.animationVertexBuffers = {}),
          this.positionAnimationVertexArray.length > 0 &&
            (this.animationVertexBuffers.positionAnimationVertexBuffer = e.createVertexBuffer(
              this.positionAnimationVertexArray,
              wx.members,
            )),
          this.colorAnimationVertexArray.length > 0 &&
            (this.animationVertexBuffers.colorAnimationVertexBuffer = e.createVertexBuffer(
              this.colorAnimationVertexArray,
              Tx.members,
            ));
      }
      destroyAnimationBuffers() {
        if (Object.keys(this?.animationVertexBuffers).length > 0)
          for (const e in this.animationVertexBuffers)
            Object.hasOwnProperty.call(this.animationVertexBuffers, e) &&
              this.animationVertexBuffers[e].destroy();
      }
      destroy() {
        this.layoutVertexBuffer &&
          (this.layoutVertexBuffer.destroy(),
          this.indexBuffer.destroy(),
          this.programConfigurations.destroy(),
          this.segments.destroy(),
          this._animationFlag && this.destroyAnimationBuffers());
      }
      addAnimationEdgeFeature(e, t, i) {
        e: {
          const n = e?.targetValues,
            r = e?.times;
          if (!n || n.length < 2 || !r || r.length < 2) break e;
          this._animationFlag = !0;
          const o = n[0],
            a = n[1],
            s = r[0],
            l = r[1],
            c = Ys(t.x, t.y, o, this.x, this.y, this.z, this.projection),
            u = Ys(i.x, i.y, o, this.x, this.y, this.z, this.projection),
            h = Ys(t.x, t.y, a, this.x, this.y, this.z, this.projection),
            d = Ys(i.x, i.y, a, this.x, this.y, this.z, this.projection);
          Ex(
            this.positionAnimationVertexArray,
            { t0: 0, t1: 0 },
            { x: c[0] - this.baseP[0], y: c[1] - this.baseP[1], z: c[2] - this.baseP[2] },
            { x: c[0] - this.baseP[0], y: c[1] - this.baseP[1], z: c[2] - this.baseP[2] },
          ),
            Ex(
              this.positionAnimationVertexArray,
              { t0: s, t1: l },
              { x: c[0] - this.baseP[0], y: c[1] - this.baseP[1], z: c[2] - this.baseP[2] },
              { x: h[0] - this.baseP[0], y: h[1] - this.baseP[1], z: h[2] - this.baseP[2] },
            ),
            Ex(
              this.positionAnimationVertexArray,
              { t0: 0, t1: 0 },
              { x: u[0] - this.baseP[0], y: u[1] - this.baseP[1], z: u[2] - this.baseP[2] },
              { x: u[0] - this.baseP[0], y: u[1] - this.baseP[1], z: u[2] - this.baseP[2] },
            ),
            Ex(
              this.positionAnimationVertexArray,
              { t0: s, t1: l },
              { x: u[0] - this.baseP[0], y: u[1] - this.baseP[1], z: u[2] - this.baseP[2] },
              { x: d[0] - this.baseP[0], y: d[1] - this.baseP[1], z: d[2] - this.baseP[2] },
            );
        }
      }
      addAnimationTopFeature(e, t) {
        const i = e?.targetValues,
          n = e?.times,
          r = i[1],
          o = n[0],
          a = n[1],
          s = Ys(t.x, t.y, i[0], this.x, this.y, this.z, this.projection),
          l = Ys(t.x, t.y, r, this.x, this.y, this.z, this.projection);
        Ex(
          this.positionAnimationVertexArray,
          { t0: o, t1: a },
          { x: s[0] - this.baseP[0], y: s[1] - this.baseP[1], z: s[2] - this.baseP[2] },
          { x: l[0] - this.baseP[0], y: l[1] - this.baseP[1], z: l[2] - this.baseP[2] },
        );
      }
      addFeature(e, t, i, n, r) {
        let o = 0;
        const a = this.layers[0].paint.get('extrusion-height'),
          s = this.layers[0].paint.get('extrusion-base'),
          l = this.layers[0].paint.get('extrusion-pattern-factor'),
          c = s.evaluate(e, {}, r) || 0;
        o = a.evaluate(e, {}, r) || 0;
        const u = e?.properties?.animations?.positionKeyframeTrack;
        if (u) {
          const e = u?.targetValues,
            t = u?.times;
          (!e || e.length < 2 || !t || t.length < 2) &&
            console.warn(
              `${this.layers[0].id}图层的形变动画缺少形变的关键帧数据，至少要有2个形变数据`,
            );
        }
        for (const i of Kg(t, 500)) {
          let t = 0,
            r = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
          for (const e of i)
            if (0 !== e.length) {
              t += e.length;
              for (let t = 0; t < e.length; t++)
                if (t >= 1) {
                  const i = e[t],
                    a = e[t - 1];
                  if (Ix(i, a)) continue;
                  if (!Mx(i, a)) {
                    r.vertexLength + 4 > Yh.MAX_VERTEX_ARRAY_LENGTH &&
                      (r = this.segments.prepareSegment(
                        4,
                        this.layoutVertexArray,
                        this.indexArray,
                      ));
                    const e = Ys(i.x, i.y, c, this.x, this.y, this.z, this.projection);
                    this.baseP || (this.baseP = e);
                    const t = Ys(i.x, i.y, o, this.x, this.y, this.z, this.projection),
                      s = Ys(a.x, a.y, c, this.x, this.y, this.z, this.projection),
                      d = Ys(a.x, a.y, o, this.x, this.y, this.z, this.projection),
                      p = this.baseP,
                      f = i.sub(a)._perp()._unit();
                    if (l)
                      Px(
                        this.layoutVertexArray,
                        e[0] - p[0],
                        e[1] - p[1],
                        e[2] - p[2],
                        f[0],
                        f[1],
                        f[2],
                        0,
                        0,
                        0,
                      ),
                        Px(
                          this.layoutVertexArray,
                          t[0] - p[0],
                          t[1] - p[1],
                          t[2] - p[2],
                          f[0],
                          f[1],
                          f[2],
                          0,
                          1 * l[1],
                          0,
                        ),
                        Px(
                          this.layoutVertexArray,
                          s[0] - p[0],
                          s[1] - p[1],
                          s[2] - p[2],
                          f[0],
                          f[1],
                          f[2],
                          1 * l[0],
                          0,
                          0,
                        ),
                        Px(
                          this.layoutVertexArray,
                          d[0] - p[0],
                          d[1] - p[1],
                          d[2] - p[2],
                          f[0],
                          f[1],
                          f[2],
                          1 * l[0],
                          1 * l[1],
                          0,
                        );
                    else {
                      const i =
                        ((h = f.y), new Pt(2 * Math.floor(f.x * Sx) + 0, h * Sx * 2, 0 * Sx * 2));
                      Px(
                        this.layoutVertexArray,
                        e[0] - p[0],
                        e[1] - p[1],
                        e[2] - p[2],
                        i.x,
                        i.y,
                        i.z,
                        0,
                        0,
                        0,
                      ),
                        Px(
                          this.layoutVertexArray,
                          t[0] - p[0],
                          t[1] - p[1],
                          t[2] - p[2],
                          i.x,
                          i.y,
                          i.z,
                          0,
                          1,
                          0,
                        ),
                        Px(
                          this.layoutVertexArray,
                          s[0] - p[0],
                          s[1] - p[1],
                          s[2] - p[2],
                          i.x,
                          i.y,
                          i.z,
                          1,
                          0,
                          0,
                        ),
                        Px(
                          this.layoutVertexArray,
                          d[0] - p[0],
                          d[1] - p[1],
                          d[2] - p[2],
                          i.x,
                          i.y,
                          i.z,
                          1,
                          1,
                          0,
                        );
                    }
                    const m = r.vertexLength;
                    this.indexArray.emplaceBack(m, m + 2, m + 1),
                      this.indexArray.emplaceBack(m + 1, m + 2, m + 3),
                      n.push([e, t, s], [t, s, d]),
                      (r.vertexLength += 4),
                      (r.primitiveLength += 2),
                      u && this.addAnimationEdgeFeature(u, i, a);
                  }
                }
            }
          if (
            (r.vertexLength + t > Yh.MAX_VERTEX_ARRAY_LENGTH &&
              (r = this.segments.prepareSegment(t, this.layoutVertexArray, this.indexArray)),
            'Polygon' !== Qf.VectorTileFeature.types[e.type])
          )
            continue;
          const a = [],
            s = [],
            d = r.vertexLength,
            p = [];
          for (const e of i) {
            if (0 === e.length) continue;
            e !== i[0] && s.push(a.length / 2);
            const t = Lx(i);
            for (let i = 0; i < e.length; i++) {
              const n = e[i],
                r = [(n.x - t.minX) / t.maxLength, (n.y - t.minY) / t.maxLength],
                s = Ys(n.x, n.y, o, this.x, this.y, this.z, this.projection);
              p.push(s),
                this.baseP || (this.baseP = s),
                Px(
                  this.layoutVertexArray,
                  s[0] - this.baseP[0],
                  s[1] - this.baseP[1],
                  s[2] - this.baseP[2],
                  Ax[0],
                  Ax[1],
                  Ax[2],
                  r[0],
                  r[1],
                  1,
                ),
                a.push(n.x),
                a.push(n.y),
                u && this.addAnimationTopFeature(u, n);
            }
          }
          const f = xg(a, s);
          for (let e = 0; e < f.length; e += 3)
            this.indexArray.emplaceBack(d + f[e], d + f[e + 2], d + f[e + 1]),
              n.push([p[f[e]], p[f[e + 1]], p[f[e + 2]]]);
          (r.primitiveLength += f.length / 3), (r.vertexLength += t);
        }
        var h;
        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, i, {}, r);
      }
    }
    function Mx(e, t) {
      return (e.x === t.x && (e.x < 0 || e.x > Wu)) || (e.y === t.y && (e.y < 0 || e.y > Wu));
    }
    function Ix(e, t) {
      return (
        (e.x === t.x && (0 === e.x || 8192 === e.x)) || (e.y === t.y && (0 === e.y || 8192 === e.y))
      );
    }
    function Lx(e) {
      let t = 1 / 0,
        i = -1 / 0,
        n = 1 / 0,
        r = -1 / 0;
      for (const o of e)
        for (const e of o)
          t > e.x && (t = e.x), i < e.x && (i = e.x), n > e.y && (n = e.y), r < e.y && (r = e.y);
      let o = i - t < 512 ? 512 : i - t;
      return o < r - n && (o = r - n), { minX: t, maxX: i, minY: n, maxY: r, maxLength: o };
    }
    function Rx(e) {
      for (let t = 0; t < e.length; t++) {
        const i = e[t];
        return (
          i.every((e) => e.x < 0) ||
          i.every((e) => e.x > Wu) ||
          i.every((e) => e.y < 0) ||
          i.every((e) => e.y > Wu)
        );
      }
    }
    fo('SphereExtrusionBucket', Cx, { omit: ['layers'] });
    var Nx = {
      paint: new Vd({
        'extrusion-opacity': new Dd(pm.paint_extrusion['extrusion-opacity']),
        'extrusion-color': new Dd(pm.paint_extrusion['extrusion-color']),
        'extrusion-translate': new Dd(pm.paint_extrusion['extrusion-translate']),
        'extrusion-translate-anchor': new Dd(pm.paint_extrusion['extrusion-translate-anchor']),
        'extrusion-pattern': new zd(pm.paint_extrusion['extrusion-pattern']),
        'extrusion-top-pattern': new zd(pm.paint_extrusion['extrusion-top-pattern']),
        'extrusion-height': new Dd(pm.paint_extrusion['extrusion-height']),
        'extrusion-base': new Dd(pm.paint_extrusion['extrusion-base']),
        'extrusion-pattern-factor': new Od(pm.paint_extrusion['extrusion-pattern-factor']),
        'extrusion-self-bloom': new Od(pm.paint_extrusion['extrusion-self-bloom']),
        'extrusion-bloom-height': new Od(pm.paint_extrusion['extrusion-bloom-height']),
        'extrusion-glow-pure-color-height': new Od(
          pm.paint_extrusion['extrusion-glow-pure-color-height'],
        ),
        'extrusion-glow-width': new Od(pm.paint_extrusion['extrusion-glow-width']),
        'extrusion-glow-speed': new Od(pm.paint_extrusion['extrusion-glow-speed']),
        'extrusion-roughness': new Od(pm.paint_extrusion['extrusion-roughness']),
      }),
    };
    const Ox = Gt(
        [
          { name: 'a_POSITION', components: 3, type: 'Float32' },
          { name: 'a_normal_vec2', components: 2, type: 'Int8' },
          { name: 'a_data', components: 4, type: 'Uint8' },
          { name: 'a_seq', components: 1, type: 'Uint16' },
        ],
        4,
      ),
      Dx = Gt(
        [
          { name: 'a_ANS_POS_TIME', components: 1, type: 'Float32' },
          { name: 'a_ANS_TRIP_TOTAL_TIME', components: 1, type: 'Float32' },
          { name: 'a_ANS_TRIP_LENGTH', components: 1, type: 'Float32' },
        ],
        4,
      ),
      { members: Fx } = Ox,
      zx = Qf.VectorTileFeature.types,
      Bx = Math.cos((Math.PI / 180) * 37.5),
      Vx = Math.pow(2, 14) / 0.5;
    function Ux(e, t, i, n, r, o, a, s) {
      e.emplaceBack(
        t.x,
        t.y,
        t.z,
        n ? 1 : 0,
        r ? 1 : -1,
        Math.round(63 * i.x) + 128,
        Math.round(63 * i.y) + 128,
        (1 + (0 === o ? 0 : o < 0 ? -1 : 1)) | (((0.5 * a) & 63) << 2),
        (0.5 * a) >> 6,
        s,
      );
    }
    function kx(e, t, i, n) {
      e.emplaceBack(t, i, n);
    }
    class Gx {
      constructor(e) {
        (this.zoom = e.zoom),
          (this.overscaling = e.overscaling),
          (this.layers = e.layers),
          (this.layerIds = this.layers.map((e) => e.id)),
          (this.index = e.index),
          (this.type = tm.TRACKING),
          (this.layoutVertexArray = new Vo()),
          (this.tripsAnimationVertexArray = new Uo()),
          (this.indexArray = new ea()),
          (this.programConfigurations = new cp(Fx, e.layers, e.zoom)),
          (this.segments = new Yh()),
          (this.projection = e.projection || Ot.MERCATOR),
          (this._animationFlag = !1);
      }
      populate(e, t, i) {
        this.referencePoint ||
          ((this.x = t.x),
          (this.y = t.y),
          (this.z = t.z),
          (this.zPow = Math.pow(2, this.z)),
          (this.referencePoint = Xs(this.x, this.y, this.z, this.projection)),
          (this.matrix = new Je()),
          (this.matrix[12] = this.referencePoint[0]),
          (this.matrix[13] = this.referencePoint[1]),
          (this.matrix[14] = this.referencePoint[2]));
        for (const { feature: n, index: r, sourceLayerIndex: o } of e)
          if (this.layers[0]._featureFilter(new fd(this.zoom), n, i)) {
            const e = qf(n);
            this.addFeature(n, e, r, i), t.featureIndex.insert(n, e, r, o, this.index);
          }
      }
      update(e, t) {
        this.stateDependentLayers.length &&
          this.programConfigurations.updatePaintArrays(e, t, this.stateDependentLayers);
      }
      isEmpty() {
        return 0 === this.layoutVertexArray.length;
      }
      uploadPending() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }
      upload(e) {
        this.uploaded ||
          ((this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Fx)),
          (this.indexBuffer = e.createIndexBuffer(this.indexArray)),
          this._animationFlag && this.uploadAnimationBuffers(e)),
          this.programConfigurations.upload(e),
          (this.uploaded = !0);
      }
      uploadAnimationBuffers(e) {
        (this.animationVertexBuffers = {}),
          this.tripsAnimationVertexArray.length > 0 &&
            (this.animationVertexBuffers.tripsAnimationVertexBuffer = e.createVertexBuffer(
              this.tripsAnimationVertexArray,
              Dx.members,
            ));
      }
      destroyAnimationBuffers() {
        if (Object.keys(this?.animationVertexBuffers).length > 0)
          for (const e in this.animationVertexBuffers)
            Object.hasOwnProperty.call(this.animationVertexBuffers, e) &&
              this.animationVertexBuffers[e].destroy();
      }
      destroy() {
        this.layoutVertexBuffer &&
          (this.layoutVertexBuffer.destroy(),
          this.indexBuffer.destroy(),
          this.programConfigurations.destroy(),
          this.segments.destroy(),
          this._animationFlag && this.destroyAnimationBuffers());
      }
      addFeature(e, t, i, n) {
        const r = this.layers[0].layout,
          o = r.get('tracking-join').evaluate(e, {}),
          a = r.get('tracking-cap'),
          s = r.get('tracking-miter-limit'),
          l = r.get('tracking-round-limit'),
          c = Number(e.properties.link_seq);
        for (const r of t) this.addLine(r, e, o, a, s, l, i, c, n);
      }
      addLine(e, t, i, n, r, o, a, s, l) {
        const c = t?.properties?.animations?.tripsKeyframeTrack;
        if (c) {
          const t = c?.times;
          t && t.length === e.length
            ? ((c.available = !0), (this._animationFlag = !0))
            : (c.available = !0);
        }
        const u = 'Polygon' === zx[t.type];
        let h = e.length;
        for (; h >= 2 && e[h - 1].equals(e[h - 2]); ) h--;
        let d = 0;
        for (; d < h - 1 && e[d].equals(e[d + 1]); ) d++;
        if (h < (u ? 3 : 2)) return;
        'bevel' === i && (r = 1.05);
        const p = (Wu / (512 * this.overscaling)) * 15,
          f = e[d],
          m = this.segments.prepareSegment(10 * h, this.layoutVertexArray, this.indexArray);
        this.distance = 0;
        const _ = n,
          g = u ? 'butt' : n;
        let y,
          x,
          v,
          w,
          T,
          b,
          S,
          A = !0;
        (this.e1 = this.e2 = this.e3 = -1), u && ((y = e[h - 2]), (T = f.sub(y)._unit()._perp()));
        for (let t = d; t < h; t++) {
          if (((s += 1), (v = u && t === h - 1 ? e[d + 1] : e[t + 1]), v && e[t].equals(v)))
            continue;
          T && (w = T),
            y && (x = y),
            (y = e[t]),
            (T = v ? v.sub(y)._unit()._perp() : w),
            (w = w || T);
          let n = w.add(T);
          (0 === n.x && 0 === n.y) || n._unit();
          const a = n.x * T.x + n.y * T.y,
            l = 0 !== a ? 1 / a : 1 / 0,
            f = a < Bx && x && v;
          if (f && t > d) {
            const e = y.dist(x);
            if (e > 2 * p) {
              const i = y.sub(
                y
                  .sub(x)
                  ._mult(p / e)
                  ._round(),
              );
              (this.distance += i.dist(x)),
                this.addCurrentVertex(i, this.distance, w.mult(1), 0, 0, !1, m, s, {
                  tripsKeyframeTrack: c,
                  timeIndex: t,
                }),
                (x = i);
            }
          }
          const P = x && v;
          let E = P ? i : v ? _ : g;
          if (
            (P && 'round' === E && (l < o ? (E = 'miter') : l <= 2 && (E = 'fakeround')),
            'miter' === E && l > r && (E = 'bevel'),
            'bevel' === E && (l > 2 && (E = 'flipbevel'), l < r && (E = 'miter')),
            x && (this.distance += y.dist(x)),
            'miter' === E)
          )
            n._mult(l),
              this.addCurrentVertex(y, this.distance, n, 0, 0, !1, m, s, {
                tripsKeyframeTrack: c,
                timeIndex: t,
              });
          else if ('flipbevel' === E) {
            if (l > 100) n = T.clone().mult(-1);
            else {
              const e = w.x * T.y - w.y * T.x > 0 ? -1 : 1,
                t = (l * w.add(T).mag()) / w.sub(T).mag();
              n._perp()._mult(t * e);
            }
            this.addCurrentVertex(y, this.distance, n, 0, 0, !1, m, s, {
              tripsKeyframeTrack: c,
              timeIndex: t,
            }),
              this.addCurrentVertex(y, this.distance, n.mult(-1), 0, 0, !1, m, s, {
                tripsKeyframeTrack: c,
                timeIndex: t,
              });
          } else if ('bevel' === E || 'fakeround' === E) {
            const e = w.x * T.y - w.y * T.x > 0,
              i = -Math.sqrt(l * l - 1);
            if (
              (e ? ((S = 0), (b = i)) : ((b = 0), (S = i)),
              A ||
                this.addCurrentVertex(y, this.distance, w, b, S, !1, m, s, {
                  tripsKeyframeTrack: c,
                  timeIndex: t,
                }),
              'fakeround' === E)
            ) {
              const i = Math.floor(8 * (0.5 - (a - 0.5)));
              let r;
              for (let n = 0; n < i; n++)
                (r = T.mult((n + 1) / (i + 1))
                  ._add(w)
                  ._unit()),
                  this.addPieSliceVertex(y, this.distance, r, e, m, s, {
                    tripsKeyframeTrack: c,
                    timeIndex: t,
                  });
              this.addPieSliceVertex(y, this.distance, n, e, m, s, {
                tripsKeyframeTrack: c,
                timeIndex: t,
              });
              for (let n = i - 1; n >= 0; n--)
                (r = w
                  .mult((n + 1) / (i + 1))
                  ._add(T)
                  ._unit()),
                  this.addPieSliceVertex(y, this.distance, r, e, m, s, {
                    tripsKeyframeTrack: c,
                    timeIndex: t,
                  });
            }
            v &&
              this.addCurrentVertex(y, this.distance, T, -b, -S, !1, m, s, {
                tripsKeyframeTrack: c,
                timeIndex: t,
              });
          } else
            'butt' === E
              ? (A ||
                  this.addCurrentVertex(y, this.distance, w, 0, 0, !1, m, s, {
                    tripsKeyframeTrack: c,
                    timeIndex: t,
                  }),
                v &&
                  this.addCurrentVertex(y, this.distance, T, 0, 0, !1, m, s, {
                    tripsKeyframeTrack: c,
                    timeIndex: t,
                  }))
              : 'square' === E
              ? (A ||
                  (this.addCurrentVertex(y, this.distance, w, 1, 1, !1, m, s, {
                    tripsKeyframeTrack: c,
                    timeIndex: t,
                  }),
                  (this.e1 = this.e2 = -1)),
                v &&
                  this.addCurrentVertex(y, this.distance, T, -1, -1, !1, m, s, {
                    tripsKeyframeTrack: c,
                    timeIndex: t,
                  }))
              : 'round' === E &&
                (A ||
                  (this.addCurrentVertex(y, this.distance, w, 0, 0, !1, m, s, {
                    tripsKeyframeTrack: c,
                    timeIndex: t,
                  }),
                  this.addCurrentVertex(y, this.distance, w, 1, 1, !0, m, s, {
                    tripsKeyframeTrack: c,
                    timeIndex: t,
                  }),
                  (this.e1 = this.e2 = -1)),
                v &&
                  (this.addCurrentVertex(y, this.distance, T, -1, -1, !0, m, s, {
                    tripsKeyframeTrack: c,
                    timeIndex: t,
                  }),
                  this.addCurrentVertex(y, this.distance, T, 0, 0, !1, m, s, {
                    tripsKeyframeTrack: c,
                    timeIndex: t,
                  })));
          if (f && t < h - 1) {
            const e = y.dist(v);
            if (e > 2 * p) {
              const i = y.add(
                v
                  .sub(y)
                  ._mult(p / e)
                  ._round(),
              );
              (this.distance += i.dist(y)),
                this.addCurrentVertex(i, this.distance, T.mult(1), 0, 0, !1, m, s, {
                  tripsKeyframeTrack: c,
                  timeIndex: t,
                }),
                (y = i);
            }
          }
          A = !1;
        }
        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, a, {}, l);
      }
      calcTDSpacePoint(e) {
        const t = qs(this.x + e.x / 8192, this.y + e.y / 8192, this.zPow, this.projection),
          i = Il.cartographicToCartesian3(new Pt(t[0], t[1], 0));
        return new te(
          i[0] - this.referencePoint[0],
          i[1] - this.referencePoint[1],
          i[2] - this.referencePoint[2],
        );
      }
      addCurrentVertex(e, t, i, n, r, o, a, s, l) {
        const { tripsKeyframeTrack: c, timeIndex: u } = l;
        let h;
        const d = this.layoutVertexArray,
          p = this.indexArray;
        (h = i.clone()), n && h._sub(i.perp()._mult(n));
        const f = this.calcTDSpacePoint(e);
        if ((Ux(d, f, h, o, !1, n, t, s), c && c.available)) {
          const { times: e, totalTime: t, tripLength: i } = c;
          kx(this.tripsAnimationVertexArray, e[u], t, i);
        }
        if (
          ((this.e3 = a.vertexLength++),
          this.e1 >= 0 &&
            this.e2 >= 0 &&
            (p.emplaceBack(this.e1, this.e2, this.e3), a.primitiveLength++),
          (this.e1 = this.e2),
          (this.e2 = this.e3),
          (h = i.mult(-1)),
          r && h._sub(i.perp()._mult(r)),
          Ux(d, f, h, o, !0, -r, t, s),
          c && c.available)
        ) {
          const { times: e, totalTime: t, tripLength: i } = c;
          kx(this.tripsAnimationVertexArray, e[u], t, i);
        }
        (this.e3 = a.vertexLength++),
          this.e1 >= 0 &&
            this.e2 >= 0 &&
            (p.emplaceBack(this.e1, this.e2, this.e3), a.primitiveLength++),
          (this.e1 = this.e2),
          (this.e2 = this.e3),
          t > Vx / 2 &&
            ((this.distance = 0),
            this.addCurrentVertex(e, this.distance, i, n, r, o, a, s, {
              tripsKeyframeTrack: c,
              timeIndex: u,
            }));
      }
      addPieSliceVertex(e, t, i, n, r, o, a) {
        const { tripsKeyframeTrack: s, timeIndex: l } = a;
        i = i.mult(n ? -1 : 1);
        const c = this.indexArray;
        if (
          (Ux(this.layoutVertexArray, this.calcTDSpacePoint(e), i, !1, n, 0, t, o),
          s && s.available)
        ) {
          const { times: e, totalTime: t, tripLength: i } = s;
          kx(this.tripsAnimationVertexArray, e[l], t, i);
        }
        (this.e3 = r.vertexLength++),
          this.e1 >= 0 &&
            this.e2 >= 0 &&
            (c.emplaceBack(this.e1, this.e2, this.e3), r.primitiveLength++),
          n ? (this.e2 = this.e3) : (this.e1 = this.e3);
      }
    }
    fo('TrackingBucket', Gx, { omit: ['layers'] });
    const Hx = new Vd({
      'tracking-cap': new Od(pm.layout_tracking['tracking-cap']),
      'tracking-join': new Dd(pm.layout_tracking['tracking-join']),
      'tracking-miter-limit': new Od(pm.layout_tracking['tracking-miter-limit']),
      'tracking-round-limit': new Od(pm.layout_tracking['tracking-round-limit']),
      'tracking-sort-key': new Dd(pm.layout_tracking['tracking-sort-key']),
      'tracking-display-mode': new Od(pm.layout_tracking['tracking-display-mode']),
    });
    var Yx = {
      paint: new Vd({
        'tracking-opacity': new Dd(pm.paint_tracking['tracking-opacity']),
        'tracking-color': new Dd(pm.paint_tracking['tracking-color']),
        'tracking-translate': new Od(pm.paint_tracking['tracking-translate']),
        'tracking-translate-anchor': new Od(pm.paint_tracking['tracking-translate-anchor']),
        'tracking-width': new Dd(pm.paint_tracking['tracking-width']),
        'tracking-gap-width': new Dd(pm.paint_tracking['tracking-gap-width']),
        'tracking-offset': new Dd(pm.paint_tracking['tracking-offset']),
        'tracking-blur': new Dd(pm.paint_tracking['tracking-blur']),
        'tracking-type': new Od(pm.paint_tracking['tracking-type']),
        'tracking-run-time': new Od(pm.paint_tracking['tracking-run-time']),
        'tracking-seg-count': new Od(pm.paint_tracking['tracking-seg-count']),
        'tracking-seg-group': new Od(pm.paint_tracking['tracking-seg-group']),
        'tracking-speed': new Od(pm.paint_tracking['tracking-speed']),
        'tracking-delay': new Od(pm.paint_tracking['tracking-delay']),
        'tracking-speed-factor': new Od(pm.paint_tracking['tracking-speed-factor']),
      }),
      layout: Hx,
    };
    const qx = new (class extends Dd {
      possiblyEvaluate(e, t) {
        return (
          (t = new fd(Math.floor(t.zoom), {
            now: t.now,
            fadeDuration: t.fadeDuration,
            zoomHistory: t.zoomHistory,
            transition: t.transition,
          })),
          super.possiblyEvaluate(e, t)
        );
      }
      evaluate(e, t, i, n) {
        return (t = ce({}, t, { zoom: Math.floor(t.zoom) })), super.evaluate(e, t, i, n);
      }
    })(Yx.paint.properties['tracking-width'].specification);
    function Xx(e, t) {
      return t > 0 ? t + 2 * e : e;
    }
    qx.useIntegerZoom = !0;
    var jx = {
        paint: new Vd({ '3d-model-opacity': new Od(pm['paint_3d-model']['3d-model-opacity']) }),
      },
      Wx = {
        paint: new Vd({ 'point-cloud-color': new Dd(pm['paint_3d-tiles']['point-cloud-color']) }),
      };
    const $x = Gt(
        [
          { name: 'a_POSITION', components: 3, type: 'Float32' },
          { name: 'a_normal_vec2', components: 2, type: 'Int8' },
          { name: 'a_data', components: 4, type: 'Uint8' },
          { name: 'a_extra_m', components: 3, type: 'Uint8' },
        ],
        4,
      ),
      { members: Zx } = $x;
    function Kx(e, t, i, n, r) {
      const o = r.patternDependencies;
      for (const a of t) {
        const t = a.paint.get(`${e}-pattern`).value;
        if ('constant' !== t.kind) {
          let e = t.evaluate({ zoom: n - 1 }, i, {}, r.availableImages),
            s = t.evaluate({ zoom: n }, i, {}, r.availableImages),
            l = t.evaluate({ zoom: n + 1 }, i, {}, r.availableImages);
          (e = e && e.name ? e.name : e),
            (s = s && s.name ? s.name : s),
            (l = l && l.name ? l.name : l),
            (o[e] = !0),
            (o[s] = !0),
            (o[l] = !0),
            (i.patterns[a.id] = { min: e, mid: s, max: l });
        }
      }
      return i;
    }
    const Qx = Qf.VectorTileFeature.types,
      Jx = Math.cos((Math.PI / 180) * 37.5),
      ev = Math.pow(2, 14) / 0.5;
    let tv = 0,
      iv = 0,
      nv = 1;
    function rv(e, t, i, n, r, o, a) {
      e.emplaceBack(
        t.x,
        t.y,
        t.z,
        n ? 1 : 0,
        r ? 1 : -1,
        Math.round(63 * i.x) + 128,
        Math.round(63 * i.y) + 128,
        (1 + (0 === o ? 0 : o < 0 ? -1 : 1)) | (((0.5 * a) & 63) << 2),
        (0.5 * a) >> 6,
        255 & tv,
        parseInt(iv),
        parseInt(nv),
      );
    }
    class ov {
      constructor(e) {
        (this.zoom = e.zoom),
          (this.overscaling = e.overscaling),
          (this.layers = e.layers),
          (this.layerIds = this.layers.map((e) => e.id)),
          (this.index = e.index),
          (this.patternFeatures = []),
          (this.type = tm.SPRITE),
          (this.layoutVertexArray = new Oo()),
          (this.indexArray = new ea()),
          (this.programConfigurations = new cp(Zx, e.layers, e.zoom)),
          (this.segments = new Yh()),
          (this.projection = e.projection || Ot.MERCATOR),
          (this.curOpacity = 0),
          (this.curNum = 0),
          (this.curStatus = 1),
          (this._percent = 0);
      }
      populate(e, t, i) {
        this.referencePoint ||
          ((this.x = t.x),
          (this.y = t.y),
          (this.z = t.z),
          (this.zPow = Math.pow(2, this.z)),
          (this.referencePoint = Xs(this.x, this.y, this.z, this.projection)),
          (this.matrix = new Je()),
          (this.matrix[12] = this.referencePoint[0]),
          (this.matrix[13] = this.referencePoint[1]),
          (this.matrix[14] = this.referencePoint[2])),
          (this.hasPattern = (function (e, t, i) {
            const n = i.patternDependencies;
            let r = !1;
            for (const e of t) {
              const t = e.paint.get('sprite-pattern');
              t.isConstant() || (r = !0);
              const i = t.constantOr(null);
              i && ((r = !0), (n[i.to] = !0), (n[i.from] = !0));
            }
            return r;
          })(0, this.layers, t));
        const n = [];
        for (const { feature: t, id: r, index: o, sourceLayerIndex: a } of e) {
          const e = this.layers[0]._featureFilter.needGeometry,
            s = { type: t.type, id: r, properties: t.properties, geometry: e ? qf(t) : [] };
          this.layers[0]._featureFilter(new fd(this.zoom), s, i) &&
            (e || (s.geometry = qf(t)),
            n.push({
              id: r,
              properties: t.properties,
              type: t.type,
              sourceLayerIndex: a,
              index: o,
              geometry: s.geometry,
              patterns: {},
            }));
        }
        for (const r of n) {
          const { geometry: n, index: o, sourceLayerIndex: a } = r;
          if (this.hasPattern) {
            this.imageNeedResize = !0;
            const e = Kx('sprite', this.layers, r, this.zoom, t);
            this.patternFeatures.push(e);
          } else this.addFeature(r, n, o, i, {});
          t.featureIndex.insert(e[o].feature, n, o, a, this.index);
        }
      }
      update(e, t) {
        this.stateDependentLayers.length &&
          this.programConfigurations.updatePaintArrays(e, t, this.stateDependentLayers);
      }
      addFeatures(e, t, i) {
        for (const e of this.patternFeatures) this.addFeature(e, e.geometry, e.index, t, i);
      }
      isEmpty() {
        return 0 === this.layoutVertexArray.length;
      }
      uploadPending() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }
      upload(e) {
        this.uploaded ||
          ((this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Zx)),
          (this.indexBuffer = e.createIndexBuffer(this.indexArray))),
          this.programConfigurations.upload(e),
          (this.uploaded = !0);
      }
      destroy() {
        this.layoutVertexBuffer &&
          (this.layoutVertexBuffer.destroy(),
          this.indexBuffer.destroy(),
          this.programConfigurations.destroy(),
          this.segments.destroy());
      }
      addFeature(e, t, i, n, r) {
        const o = this.layers[0].layout,
          a = o.get('sprite-join').evaluate(e, {}),
          s = o.get('sprite-cap'),
          l = o.get('sprite-miter-limit'),
          c = o.get('sprite-round-limit');
        (iv = e.properties.link_seq ? Number(e.properties.link_seq) : iv),
          (iv %= 10),
          (nv = Number(e.properties.status) || 1);
        for (const r of t) this.addLine(r, e, a, s, l, c, i, n);
        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, i, r, n);
      }
      addLine(e, t, i, n, r, o) {
        const a = 'Polygon' === Qx[t.type];
        let s = e.length;
        for (; s >= 2 && e[s - 1].equals(e[s - 2]); ) s--;
        let l = 0;
        for (; l < s - 1 && e[l].equals(e[l + 1]); ) l++;
        if (s < (a ? 3 : 2)) return;
        'bevel' === i && (r = 1.05);
        const c = (Wu / (512 * this.overscaling)) * 15,
          u = e[l],
          h = this.segments.prepareSegment(10 * s, this.layoutVertexArray, this.indexArray);
        this.distance = 0;
        const d = n,
          p = a ? 'butt' : n;
        let f,
          m,
          _,
          g,
          y,
          x,
          v,
          w = !0;
        (this.e1 = this.e2 = this.e3 = -1), a && ((f = e[s - 2]), (y = u.sub(f)._unit()._perp()));
        for (let t = l; t < s; t++) {
          if (
            ((tv = Math.round((255 / s) * t)),
            (_ = a && t === s - 1 ? e[l + 1] : e[t + 1]),
            _ && e[t].equals(_))
          )
            continue;
          y && (g = y),
            f && (m = f),
            (f = e[t]),
            (y = _ ? _.sub(f)._unit()._perp() : g),
            (g = g || y);
          let n = g.add(y);
          (0 === n.x && 0 === n.y) || n._unit();
          const u = n.x * y.x + n.y * y.y,
            T = 0 !== u ? 1 / u : 1 / 0,
            b = u < Jx && m && _;
          if (b && t > l) {
            const e = f.dist(m);
            if (e > 2 * c) {
              const t = f.sub(
                f
                  .sub(m)
                  ._mult(c / e)
                  ._round(),
              );
              (this.distance += t.dist(m)),
                this.addCurrentVertex(t, this.distance, g.mult(1), 0, 0, !1, h),
                (m = t);
            }
          }
          const S = m && _;
          let A = S ? i : _ ? d : p;
          if (
            (S && 'round' === A && (T < o ? (A = 'miter') : T <= 2 && (A = 'fakeround')),
            'miter' === A && T > r && (A = 'bevel'),
            'bevel' === A && (T > 2 && (A = 'flipbevel'), T < r && (A = 'miter')),
            m && (this.distance += f.dist(m)),
            'miter' === A)
          )
            n._mult(T), this.addCurrentVertex(f, this.distance, n, 0, 0, !1, h);
          else if ('flipbevel' === A) {
            if (T > 100) n = y.clone().mult(-1);
            else {
              const e = g.x * y.y - g.y * y.x > 0 ? -1 : 1,
                t = (T * g.add(y).mag()) / g.sub(y).mag();
              n._perp()._mult(t * e);
            }
            this.addCurrentVertex(f, this.distance, n, 0, 0, !1, h),
              this.addCurrentVertex(f, this.distance, n.mult(-1), 0, 0, !1, h);
          } else if ('bevel' === A || 'fakeround' === A) {
            const e = g.x * y.y - g.y * y.x > 0,
              t = -Math.sqrt(T * T - 1);
            if (
              (e ? ((v = 0), (x = t)) : ((x = 0), (v = t)),
              w || this.addCurrentVertex(f, this.distance, g, x, v, !1, h),
              'fakeround' === A)
            ) {
              const t = Math.floor(8 * (0.5 - (u - 0.5)));
              let i;
              for (let n = 0; n < t; n++)
                (i = y
                  .mult((n + 1) / (t + 1))
                  ._add(g)
                  ._unit()),
                  this.addPieSliceVertex(f, this.distance, i, e, h);
              this.addPieSliceVertex(f, this.distance, n, e, h);
              for (let n = t - 1; n >= 0; n--)
                (i = g
                  .mult((n + 1) / (t + 1))
                  ._add(y)
                  ._unit()),
                  this.addPieSliceVertex(f, this.distance, i, e, h);
            }
            _ && this.addCurrentVertex(f, this.distance, y, -x, -v, !1, h);
          } else
            'butt' === A
              ? (w || this.addCurrentVertex(f, this.distance, g, 0, 0, !1, h),
                _ && this.addCurrentVertex(f, this.distance, y, 0, 0, !1, h))
              : 'square' === A
              ? (w ||
                  (this.addCurrentVertex(f, this.distance, g, 1, 1, !1, h),
                  (this.e1 = this.e2 = -1)),
                _ && this.addCurrentVertex(f, this.distance, y, -1, -1, !1, h))
              : 'round' === A &&
                (w ||
                  (this.addCurrentVertex(f, this.distance, g, 0, 0, !1, h),
                  this.addCurrentVertex(f, this.distance, g, 1, 1, !0, h),
                  (this.e1 = this.e2 = -1)),
                _ &&
                  (this.addCurrentVertex(f, this.distance, y, -1, -1, !0, h),
                  this.addCurrentVertex(f, this.distance, y, 0, 0, !1, h)));
          if (b && t < s - 1) {
            const e = f.dist(_);
            if (e > 2 * c) {
              const t = f.add(
                _.sub(f)
                  ._mult(c / e)
                  ._round(),
              );
              (this.distance += t.dist(f)),
                this.addCurrentVertex(t, this.distance, y.mult(1), 0, 0, !1, h),
                (f = t);
            }
          }
          w = !1;
        }
      }
      calcTDSpacePoint(e) {
        const t = qs(this.x + e.x / 8192, this.y + e.y / 8192, this.zPow, this.projection),
          i = Il.cartographicToCartesian3(new Pt(t[0], t[1], 0));
        return new te(
          i[0] - this.referencePoint[0],
          i[1] - this.referencePoint[1],
          i[2] - this.referencePoint[2],
        );
      }
      addCurrentVertex(e, t, i, n, r, o, a) {
        let s;
        const l = this.layoutVertexArray,
          c = this.indexArray;
        (s = i.clone()), n && s._sub(i.perp()._mult(n));
        const u = this.calcTDSpacePoint(e);
        rv(l, u, s, o, !1, n, t),
          (this.e3 = a.vertexLength++),
          this.e1 >= 0 &&
            this.e2 >= 0 &&
            (c.emplaceBack(this.e1, this.e2, this.e3), a.primitiveLength++),
          (this.e1 = this.e2),
          (this.e2 = this.e3),
          (s = i.mult(-1)),
          r && s._sub(i.perp()._mult(r)),
          rv(l, u, s, o, !0, -r, t),
          (this.e3 = a.vertexLength++),
          this.e1 >= 0 &&
            this.e2 >= 0 &&
            (c.emplaceBack(this.e1, this.e2, this.e3), a.primitiveLength++),
          (this.e1 = this.e2),
          (this.e2 = this.e3),
          t > ev / 2 &&
            ((this.distance = 0), this.addCurrentVertex(e, this.distance, i, n, r, o, a));
      }
      addPieSliceVertex(e, t, i, n, r) {
        i = i.mult(n ? -1 : 1);
        const o = this.indexArray;
        rv(this.layoutVertexArray, this.calcTDSpacePoint(e), i, !1, n, 0, t),
          (this.e3 = r.vertexLength++),
          this.e1 >= 0 &&
            this.e2 >= 0 &&
            (o.emplaceBack(this.e1, this.e2, this.e3), r.primitiveLength++),
          n ? (this.e2 = this.e3) : (this.e1 = this.e3);
      }
    }
    fo('SpriteBucket', ov, { omit: ['layers'] });
    const av = new Vd({
      'sprite-cap': new Od(pm.layout_sprite['sprite-cap']),
      'sprite-join': new Dd(pm.layout_sprite['sprite-join']),
      'sprite-miter-limit': new Od(pm.layout_sprite['sprite-miter-limit']),
      'sprite-round-limit': new Od(pm.layout_sprite['sprite-round-limit']),
      'sprite-sort-key': new Dd(pm.layout_sprite['sprite-sort-key']),
    });
    var sv = {
      paint: new Vd({
        'sprite-opacity': new Dd(pm.paint_sprite['sprite-opacity']),
        'sprite-color': new Dd(pm.paint_sprite['sprite-color']),
        'sprite-translate': new Dd(pm.paint_sprite['sprite-translate']),
        'sprite-translate-anchor': new Dd(pm.paint_sprite['sprite-translate-anchor']),
        'sprite-width': new Dd(pm.paint_sprite['sprite-width']),
        'sprite-gap-width': new Dd(pm.paint_sprite['sprite-gap-width']),
        'sprite-offset': new Dd(pm.paint_sprite['sprite-offset']),
        'sprite-blur': new Dd(pm.paint_sprite['sprite-blur']),
        'sprite-speed-factor': new Dd(pm.paint_sprite['sprite-speed-factor']),
        'sprite-speed': new Dd(pm.paint_sprite['sprite-speed']),
        'sprite-pattern': new Fd(pm.paint_sprite['sprite-pattern']),
        'sprite-move-direction': new Dd(pm.paint_sprite['sprite-move-direction']),
        'sprite-interpolate': new Od(pm.paint_sprite['sprite-interpolate']),
        'sprite-status': new Dd(pm.paint_sprite['sprite-status']),
        'sprite-instatus': new Dd(pm.paint_sprite['sprite-instatus']),
        'sprite-height-offset': new Od(pm.paint_sprite['sprite-height-offset']),
      }),
      layout: av,
    };
    const lv = new (class extends Dd {
      possiblyEvaluate(e, t) {
        return (
          (t = new fd(Math.floor(t.zoom), {
            now: t.now,
            fadeDuration: t.fadeDuration,
            zoomHistory: t.zoomHistory,
            transition: t.transition,
          })),
          super.possiblyEvaluate(e, t)
        );
      }
      evaluate(e, t, i, n) {
        return (t = ce({}, t, { zoom: Math.floor(t.zoom) })), super.evaluate(e, t, i, n);
      }
    })(sv.paint.properties['sprite-width'].specification);
    function cv(e, t) {
      return t > 0 ? t + 2 * e : e;
    }
    lv.useIntegerZoom = !0;
    class uv extends dg {
      constructor(e) {
        super(e, {}),
          (this.id = e.id),
          (this.type = e.type),
          (this.anchor = e.anchor),
          (this.renderingMode = e.renderingMode),
          (this.implementation = e);
      }
      hasOffscreenPass() {
        return (
          void 0 !== this.implementation.prerender || '3d' === this.implementation.renderingMode
        );
      }
      recalculate(e, t) {}
      updateTransitions() {}
      hasTransition() {}
      serialize() {}
      resize() {
        this.viewportFrame && (this.viewportFrame.destroy(), (this.viewportFrame = null));
      }
      onAdd(e) {
        this.implementation.onAdd && this.implementation.onAdd(e, e.painter.context.gl);
      }
      onRemove(e) {
        this.implementation.onRemove && this.implementation.onRemove(e);
      }
    }
    var hv = {
      paint: new Vd({ 'panorama-opacity': new Od(pm.paint_panorama['panorama-opacity']) }),
    };
    const dv = Gt(
        [
          { name: 'a_POSITION', components: 3, type: 'Float32' },
          { name: 'a_NORMAL_ED', components: 3, type: 'Float32' },
          { name: 'a_ST', components: 3, type: 'Float32' },
        ],
        4,
      ),
      { members: pv } = dv;
    function fv(e, t, i, n, r, o, a, s, l, c) {
      e.emplaceBack(t, i, n, r, o, a, s, l, c);
    }
    class mv {
      constructor(e) {
        (this.featureTrangles = []),
          (this.zoom = e.zoom),
          (this.overscaling = e.overscaling),
          (this.layers = e.layers),
          (this.layerIds = this.layers.map((e) => e.id)),
          (this.index = e.index),
          (this.type = tm.HISTOGRAM),
          (this.layoutVertexArray = new Lo()),
          (this.indexArray = new ea()),
          (this.programConfigurations = new cp(pv, e.layers, e.zoom)),
          (this.segments = new Yh()),
          (this.projection = e.projection || Ot.MERCATOR);
      }
      populate(e, t, i) {
        (this.x = t.x), (this.y = t.y), (this.z = t.z);
        for (const { feature: t, index: n } of e)
          if (this.layers[0]._featureFilter(new fd(this.zoom), t, i)) {
            const e = qf(t);
            this.addFeature(t, e, n, [], i);
          }
        this.baseP && (this.matrix = js(0, this.baseP));
      }
      update(e, t) {
        this.stateDependentLayers.length &&
          this.programConfigurations.updatePaintArrays(e, t, this.stateDependentLayers);
      }
      isEmpty() {
        return 0 === this.layoutVertexArray.length;
      }
      uploadPending() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }
      upload(e) {
        this.uploaded ||
          ((this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, pv)),
          (this.indexBuffer = e.createIndexBuffer(this.indexArray))),
          this.programConfigurations.upload(e),
          (this.uploaded = !0);
      }
      destroy() {
        this.layoutVertexBuffer &&
          (this.layoutVertexBuffer.destroy(),
          this.indexBuffer.destroy(),
          this.programConfigurations.destroy(),
          this.segments.destroy());
      }
      addFeature(e, t, i, n, r) {
        let o = 0,
          a = 0;
        const s = this.layers[0].paint.get('histogram-height'),
          l = this.layers[0].paint.get('histogram-base');
        (o = s.evaluate(e, {}, r) || 0),
          (a = l.evaluate(e, {}, r) || 0),
          this.layers[0].layout.get('histogram-max-height-render') && ((o *= 100), (a *= 100));
        for (const e of Kg(t, 500)) {
          let t = 0;
          for (const i of e) t += i.length;
          let i = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
          for (let t of e)
            if (0 !== t.length && !gv(t)) {
              yv(t) && (t = ly(t));
              for (let e = 0; e < t.length; e++) {
                const r = t[e];
                if (e >= 1) {
                  const s = t[e - 1];
                  if (xv(r, s)) continue;
                  if (!_v(r, s)) {
                    i.vertexLength + 4 > Yh.MAX_VERTEX_ARRAY_LENGTH &&
                      (i = this.segments.prepareSegment(
                        4,
                        this.layoutVertexArray,
                        this.indexArray,
                      ));
                    const e = Ys(r.x, r.y, a, this.x, this.y, this.z, this.projection);
                    this.baseP || (this.baseP = e);
                    const t = Ys(r.x, r.y, o, this.x, this.y, this.z, this.projection),
                      l = Ys(s.x, s.y, a, this.x, this.y, this.z, this.projection),
                      c = Ys(s.x, s.y, o, this.x, this.y, this.z, this.projection),
                      u = this.baseP,
                      h = new Pt();
                    h.subVectors(e, t);
                    const d = new Pt();
                    d.subVectors(e, l);
                    const p = h.cross(d);
                    fv(
                      this.layoutVertexArray,
                      e[0] - u[0],
                      e[1] - u[1],
                      e[2] - u[2],
                      p[0],
                      p[1],
                      p[2],
                      0,
                      a / 5,
                      0,
                    ),
                      fv(
                        this.layoutVertexArray,
                        t[0] - u[0],
                        t[1] - u[1],
                        t[2] - u[2],
                        p[0],
                        p[1],
                        p[2],
                        0,
                        o / 5,
                        1,
                      );
                    const f = 20 * new Pt(l).distance(e);
                    fv(
                      this.layoutVertexArray,
                      l[0] - u[0],
                      l[1] - u[1],
                      l[2] - u[2],
                      p[0],
                      p[1],
                      p[2],
                      f,
                      a / 5,
                      0,
                    ),
                      fv(
                        this.layoutVertexArray,
                        c[0] - u[0],
                        c[1] - u[1],
                        c[2] - u[2],
                        p[0],
                        p[1],
                        p[2],
                        f,
                        o / 5,
                        1,
                      );
                    const m = i.vertexLength;
                    this.indexArray.emplaceBack(m, m + 1, m + 2),
                      this.indexArray.emplaceBack(m + 1, m + 2, m + 3),
                      n.push([e, t, l], [t, l, c]),
                      (i.vertexLength += 4),
                      (i.primitiveLength += 2);
                  }
                }
              }
            }
          i.vertexLength + t > Yh.MAX_VERTEX_ARRAY_LENGTH &&
            (i = this.segments.prepareSegment(t, this.layoutVertexArray, this.indexArray));
          const r = [],
            s = [],
            l = i.vertexLength,
            c = [];
          for (const t of e) {
            if (0 === t.length) continue;
            t !== e[0] && s.push(r.length / 2);
            const i = vv(e);
            for (let e = 0; e < t.length; e++) {
              const n = t[e],
                a = [(n.x - i.minX) / i.maxLength, (n.y - i.minY) / i.maxLength],
                s = Ys(
                  n.x,
                  n.y,
                  o + ((this.x % 2) + (this.y % 2)) / 256,
                  this.x,
                  this.y,
                  this.z,
                  this.projection,
                );
              c.push(s),
                this.baseP || (this.baseP = s),
                fv(
                  this.layoutVertexArray,
                  s[0] - this.baseP[0],
                  s[1] - this.baseP[1],
                  s[2] - this.baseP[2],
                  0,
                  8,
                  0,
                  a[0],
                  a[1],
                  1,
                ),
                r.push(n.x),
                r.push(n.y);
            }
          }
          const u = xg(r, s);
          for (let e = 0; e < u.length; e += 3)
            this.indexArray.emplaceBack(l + u[e], l + u[e + 1], l + u[e + 2]),
              n.push([c[u[e]], c[u[e + 1]], c[u[e + 2]]]);
          (i.primitiveLength += u.length / 3), (i.vertexLength += t);
        }
        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, i, {}, r);
      }
    }
    function _v(e, t) {
      return (e.x === t.x && (e.x < 0 || e.x > Wu)) || (e.y === t.y && (e.y < 0 || e.y > Wu));
    }
    function gv(e) {
      return (
        e.every((e) => e.x < 0) ||
        e.every((e) => e.x > Wu) ||
        e.every((e) => e.y < 0) ||
        e.every((e) => e.y > Wu)
      );
    }
    function yv(e) {
      return !(
        e.every((e) => e.x >= 0) &&
        e.every((e) => e.x <= Wu) &&
        e.every((e) => e.y >= 0) &&
        e.every((e) => e.y <= Wu)
      );
    }
    function xv(e, t) {
      return (
        (e.x === t.x && (0 === e.x || 8192 === e.x)) || (e.y === t.y && (0 === e.y || 8192 === e.y))
      );
    }
    function vv(e) {
      let t = 1 / 0,
        i = -1 / 0,
        n = 1 / 0,
        r = -1 / 0;
      for (const o of e)
        for (const e of o)
          t > e.x && (t = e.x), i < e.x && (i = e.x), n > e.y && (n = e.y), r < e.y && (r = e.y);
      let o = i - t < 512 ? 512 : i - t;
      return o < r - n && (o = r - n), { minX: t, maxX: i, minY: n, maxY: r, maxLength: o };
    }
    fo('SphereHistogramBucket', mv, { omit: ['layers'] });
    const wv = new Vd({
      'histogram-max-height-render': new Od(pm.layout_histogram['histogram-max-height-render']),
      'histogram-color-render': new Od(pm.layout_histogram['histogram-color-render']),
    });
    var Tv = {
      paint: new Vd({
        'histogram-opacity': new Od(pm.paint_histogram['histogram-opacity']),
        'histogram-color': new Dd(pm.paint_histogram['histogram-color']),
        'histogram-colors': new Od(pm.paint_histogram['histogram-colors']),
        'histogram-translate': new Od(pm.paint_histogram['histogram-translate']),
        'histogram-translate-anchor': new Od(pm.paint_histogram['histogram-translate-anchor']),
        'histogram-height': new Dd(pm.paint_histogram['histogram-height']),
        'histogram-base': new Dd(pm.paint_histogram['histogram-base']),
        'histogram-vertical-gradient': new Od(pm.paint_histogram['histogram-vertical-gradient']),
        'histogram-dynamic': new Od(pm.paint_histogram['histogram-dynamic']),
        'histogram-heightArr1': new Dd(pm.paint_histogram['histogram-heightArr1']),
        'histogram-heightArr2': new Dd(pm.paint_histogram['histogram-heightArr2']),
        'histogram-heightArr3': new Dd(pm.paint_histogram['histogram-heightArr3']),
        'histogram-speed': new Od(pm.paint_histogram['histogram-speed']),
        'histogram-count': new Od(pm.paint_histogram['histogram-count']),
        'histogram-max-height': new Od(pm.paint_histogram['histogram-max-height']),
        'depth-change': new Od(pm.paint_histogram['depth-change']),
      }),
      layout: wv,
    };
    const bv = new Vd({
      'symtracking-display-mode': new Od(pm.layout_symtracking['symtracking-display-mode']),
      'symtracking-time-segment': new Od(pm.layout_symtracking['symtracking-time-segment']),
      'symtracking-fps': new Od(pm.layout_symtracking['symtracking-fps']),
      'symtracking-sort-key': new Dd(pm.layout_symtracking['symtracking-sort-key']),
      'symtracking-z-order': new Od(pm.layout_symtracking['symtracking-z-order']),
      'compatible-mode': new Od(pm.layout_symtracking['compatible-mode']),
      'symbol-placement': new Od(pm.layout_symtracking['symbol-placement']),
      'symbol-spacing': new Od(pm.layout_symtracking['symbol-spacing']),
      'symbol-avoid-edges': new Od(pm.layout_symtracking['symbol-avoid-edges']),
      'icon-allow-overlap': new Od(pm.layout_symtracking['icon-allow-overlap']),
      'icon-ignore-placement': new Od(pm.layout_symtracking['icon-ignore-placement']),
      'icon-optional': new Od(pm.layout_symtracking['icon-optional']),
      'icon-rotation-alignment': new Od(pm.layout_symtracking['icon-rotation-alignment']),
      'icon-size': new Dd(pm.layout_symtracking['icon-size']),
      'icon-text-fit': new Od(pm.layout_symtracking['icon-text-fit']),
      'icon-text-fit-padding': new Od(pm.layout_symtracking['icon-text-fit-padding']),
      'icon-image': new Dd(pm.layout_symtracking['icon-image']),
      'icon-rotate': new Dd(pm.layout_symtracking['icon-rotate']),
      'icon-padding': new Od(pm.layout_symtracking['icon-padding']),
      'icon-keep-upright': new Od(pm.layout_symtracking['icon-keep-upright']),
      'icon-offset': new Dd(pm.layout_symtracking['icon-offset']),
      'icon-anchor': new Dd(pm.layout_symtracking['icon-anchor']),
      'icon-pitch-alignment': new Od(pm.layout_symtracking['icon-pitch-alignment']),
      'text-pitch-alignment': new Od(pm.layout_symtracking['text-pitch-alignment']),
      'text-rotation-alignment': new Od(pm.layout_symtracking['text-rotation-alignment']),
      'text-field': new Dd(pm.layout_symtracking['text-field']),
      'text-font': new Dd(pm.layout_symtracking['text-font']),
      'text-size': new Dd(pm.layout_symtracking['text-size']),
      'text-max-width': new Dd(pm.layout_symtracking['text-max-width']),
      'text-line-height': new Od(pm.layout_symtracking['text-line-height']),
      'text-letter-spacing': new Dd(pm.layout_symtracking['text-letter-spacing']),
      'text-justify': new Dd(pm.layout_symtracking['text-justify']),
      'text-anchor': new Dd(pm.layout_symtracking['text-anchor']),
      'text-max-angle': new Od(pm.layout_symtracking['text-max-angle']),
      'text-rotate': new Dd(pm.layout_symtracking['text-rotate']),
      'text-padding': new Od(pm.layout_symtracking['text-padding']),
      'text-keep-upright': new Od(pm.layout_symtracking['text-keep-upright']),
      'text-transform': new Dd(pm.layout_symtracking['text-transform']),
      'text-offset': new Dd(pm.layout_symtracking['text-offset']),
      'text-allow-overlap': new Od(pm.layout_symtracking['text-allow-overlap']),
      'text-ignore-placement': new Od(pm.layout_symtracking['text-ignore-placement']),
      'text-optional': new Od(pm.layout_symtracking['text-optional']),
    });
    var Sv = {
      paint: new Vd({
        'icon-opacity': new Dd(pm.paint_symtracking['icon-opacity']),
        'icon-color': new Dd(pm.paint_symtracking['icon-color']),
        'icon-halo-color': new Dd(pm.paint_symtracking['icon-halo-color']),
        'icon-halo-width': new Dd(pm.paint_symtracking['icon-halo-width']),
        'icon-halo-blur': new Dd(pm.paint_symtracking['icon-halo-blur']),
        'icon-translate': new Od(pm.paint_symtracking['icon-translate']),
        'icon-translate-anchor': new Od(pm.paint_symtracking['icon-translate-anchor']),
        'text-opacity': new Dd(pm.paint_symtracking['text-opacity']),
        'text-color': new Dd(pm.paint_symtracking['text-color']),
        'text-halo-color': new Dd(pm.paint_symtracking['text-halo-color']),
        'text-halo-width': new Dd(pm.paint_symtracking['text-halo-width']),
        'text-halo-blur': new Dd(pm.paint_symtracking['text-halo-blur']),
        'text-translate': new Od(pm.paint_symtracking['text-translate']),
        'text-translate-anchor': new Od(pm.paint_symtracking['text-translate-anchor']),
        'symtracking-delay': new Od(pm.paint_symtracking['symtracking-delay']),
      }),
      layout: bv,
    };
    const Av = Gt(
        [
          { name: 'a_POSITION', components: 3, type: 'Float32' },
          { name: 'a_NORMAL', components: 1, type: 'Uint8' },
          { name: 'a_data', components: 4, type: 'Uint8' },
          { name: 'a_seq', components: 1, type: 'Uint16' },
          { name: 'a_info', components: 2, type: 'Uint16' },
        ],
        4,
      ),
      { members: Pv } = Av,
      Ev = Qf.VectorTileFeature.types,
      Cv = Math.cos((Math.PI / 180) * 37.5),
      Mv = Math.pow(2, 14) / 0.5;
    class Iv {
      constructor(e) {
        (this.zoom = e.zoom),
          (this.overscaling = e.overscaling),
          (this.layers = e.layers),
          (this.layerIds = this.layers.map((e) => e.id)),
          (this.index = e.index),
          (this.hasPattern = !1),
          (this.patternFeatures = []),
          (this.gradients = {}),
          this.layers.forEach((e) => {
            this.gradients[e.id] = {};
          }),
          (this.type = tm.DYNAMIC_LINE),
          (this.layoutVertexArray = new zo()),
          (this.indexArray = new ea()),
          (this.programConfigurations = new cp(Pv, e.layers, e.zoom)),
          (this.segments = new Yh()),
          (this.maxLineLength = 0),
          (this.projection = e.projection || Ot.MERCATOR),
          (this.stateDependentLayerIds = this.layers
            .filter((e) => e.isStateDependent())
            .map((e) => e.id)),
          (this.seq = 0),
          (this.total = 0),
          (this.offset = 0);
      }
      _convertGeometryPointToLine(e) {
        const t = [];
        for (let i = 0; i < e.length; i++) {
          const n = [];
          let r = 1 / 0,
            o = 1 / 0,
            a = -1 / 0,
            s = -1 / 0;
          for (let t = 0; t < e[i].length; t++) {
            const l = e[i][t].x,
              c = e[i][t].y;
            n.push([l, c]), r > l && (r = l), a < l && (a = l), o > c && (o = c), s < c && (s = c);
          }
          t.push({ type: 'LineString', geometry: [n], min: [r, o], max: [a, s] });
        }
        return t;
      }
      _convertLineToGeometry(e) {
        const t = [];
        for (let i = 0; i < e.length; i++) {
          const n = e[i].geometry.map((e) => e.map((e) => new te(e[0], e[1])));
          t.push(...n);
        }
        return t;
      }
      populate(e, t, i) {
        this.referencePoint ||
          ((this.x = t.x),
          (this.y = t.y),
          (this.z = t.z),
          (this.zPow = Math.pow(2, this.z)),
          (this.referencePoint = Xs(this.x, this.y, this.z, this.projection)),
          (this.matrix = new Je()),
          (this.matrix[12] = this.referencePoint[0]),
          (this.matrix[13] = this.referencePoint[1]),
          (this.matrix[14] = this.referencePoint[2]));
        for (const { feature: n, index: r, sourceLayerIndex: o } of e)
          if (this.layers[0]._featureFilter(new fd(this.zoom), n, i)) {
            const e = qf(n),
              a = [];
            sy(my(this.z), 0, 8192, 0, 8192, this._convertGeometryPointToLine(e), a);
            const s = this._convertLineToGeometry(a);
            this.addFeature(n, s, r, i, {}), t.featureIndex.insert(n, e, r, o, this.index);
          }
      }
      update(e, t, i) {
        this.stateDependentLayers.length &&
          this.programConfigurations.updatePaintArrays(e, t, this.stateDependentLayers, i);
      }
      addFeatures(e, t, i) {
        for (const e of this.patternFeatures) this.addFeature(e, e.geometry, e.index, t, i);
      }
      isEmpty() {
        return 0 === this.layoutVertexArray.length;
      }
      uploadPending() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }
      upload(e) {
        this.uploaded ||
          ((this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Pv)),
          (this.indexBuffer = e.createIndexBuffer(this.indexArray))),
          this.programConfigurations.upload(e),
          (this.uploaded = !0);
      }
      destroy() {
        this.layoutVertexBuffer &&
          (this.layoutVertexBuffer.destroy(),
          this.indexBuffer.destroy(),
          this.programConfigurations.destroy(),
          this.segments.destroy());
      }
      addFeature(e, t, i, n, r) {
        const o = this.layers[0].layout,
          a = o.get('dynamicLine-join').evaluate(e, {}),
          s = o.get('dynamicLine-cap'),
          l = o.get('dynamicLine-miter-limit'),
          c = o.get('dynamicLine-round-limit');
        (this.seq = e.properties.link_seq),
          (this.total = e.properties.total_link_count),
          (this.offset = e.properties.offset_link_count);
        for (const i of t) this.addLine(i, e, a, s, l, c);
        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, i, r, n);
      }
      addLine(e, t, i, n, r, o) {
        (this.distance = 0), (this.scaledDistance = 0), (this.totalDistance = 0);
        const a = 'Polygon' === Ev[t.type];
        let s = e.length;
        for (; s >= 2 && e[s - 1].equals(e[s - 2]); ) s--;
        let l = 0;
        for (; l < s - 1 && e[l].equals(e[l + 1]); ) l++;
        if (s < (a ? 3 : 2)) return;
        'bevel' === i && (r = 1.05);
        const c = this.overscaling <= 16 ? (15 * Wu) / (512 * this.overscaling) : 0,
          u = this.segments.prepareSegment(10 * s, this.layoutVertexArray, this.indexArray);
        let h, d, p, f, m;
        (this.e1 = this.e2 = -1), a && ((h = e[s - 2]), (m = e[l].sub(h)._unit()._perp()));
        for (let t = l; t < s; t++) {
          if (
            (this.seq++,
            (p = t === s - 1 ? (a ? e[l + 1] : void 0) : e[t + 1]),
            p && e[t].equals(p))
          )
            continue;
          m && (f = m),
            h && (d = h),
            (h = e[t]),
            (m = p ? p.sub(h)._unit()._perp() : f),
            (f = f || m);
          let _ = f.add(m);
          (0 === _.x && 0 === _.y) || _._unit();
          const g = f.x * m.x + f.y * m.y,
            y = _.x * m.x + _.y * m.y,
            x = 0 !== y ? 1 / y : 1 / 0,
            v = 2 * Math.sqrt(2 - 2 * y),
            w = y < Cv && d && p,
            T = f.x * m.y - f.y * m.x > 0;
          if (w && t > l) {
            const e = h.dist(d);
            if (e > 2 * c) {
              const t = h.sub(
                h
                  .sub(d)
                  ._mult(c / e)
                  ._round(),
              );
              this.updateDistance(d, t), this.addCurrentVertex(t, f, 0, 0, u), (d = t);
            }
          }
          const b = d && p;
          let S = b ? i : a ? 'butt' : n;
          if (
            (b && 'round' === S && (x < o ? (S = 'miter') : x <= 2 && (S = 'fakeround')),
            'miter' === S && x > r && (S = 'bevel'),
            'bevel' === S && (x > 2 && (S = 'flipbevel'), x < r && (S = 'miter')),
            d && this.updateDistance(d, h),
            'miter' === S)
          )
            _._mult(x), this.addCurrentVertex(h, _, 0, 0, u);
          else if ('flipbevel' === S) {
            if (x > 100) _ = m.mult(-1);
            else {
              const e = (x * f.add(m).mag()) / f.sub(m).mag();
              _._perp()._mult(e * (T ? -1 : 1));
            }
            this.addCurrentVertex(h, _, 0, 0, u), this.addCurrentVertex(h, _.mult(-1), 0, 0, u);
          } else if ('bevel' === S || 'fakeround' === S) {
            const e = -Math.sqrt(x * x - 1),
              t = T ? e : 0,
              i = T ? 0 : e;
            if ((d && this.addCurrentVertex(h, f, t, i, u), 'fakeround' === S)) {
              const e = Math.round((180 * v) / Math.PI / 20);
              for (let t = 1; t < e; t++) {
                let i = t / e;
                if (0.5 !== i) {
                  const e = i - 0.5;
                  i +=
                    i *
                    e *
                    (i - 1) *
                    ((1.0904 + g * (g * (3.55645 - 1.43519 * g) - 3.2452)) * e * e +
                      (0.848013 + g * (0.215638 * g - 1.06021)));
                }
                const n = m
                  .sub(f)
                  ._mult(i)
                  ._add(f)
                  ._unit()
                  ._mult(T ? -1 : 1);
                this.addHalfVertex(h, n.x, n.y, !1, T, 0, u);
              }
            }
            p && this.addCurrentVertex(h, m, -t, -i, u);
          } else if ('butt' === S) this.addCurrentVertex(h, _, 0, 0, u);
          else if ('square' === S) {
            const e = d ? 1 : -1;
            this.addCurrentVertex(h, _, e, e, u);
          } else
            'round' === S &&
              (d &&
                (this.addCurrentVertex(h, f, 0, 0, u), this.addCurrentVertex(h, f, 1, 1, u, !0)),
              p &&
                (this.addCurrentVertex(h, m, -1, -1, u, !0), this.addCurrentVertex(h, m, 0, 0, u)));
          if (w && t < s - 1) {
            const e = h.dist(p);
            if (e > 2 * c) {
              const t = h.add(
                p
                  .sub(h)
                  ._mult(c / e)
                  ._round(),
              );
              this.updateDistance(h, t), this.addCurrentVertex(t, m, 0, 0, u), (h = t);
            }
          }
        }
      }
      calcTDSpacePoint(e) {
        const t = qs(this.x + e.x / 8192, this.y + e.y / 8192, this.zPow, this.projection),
          i = Il.cartographicToCartesian3(new Pt(t[0], t[1], 0));
        return new te(
          i[0] - this.referencePoint[0],
          i[1] - this.referencePoint[1],
          i[2] - this.referencePoint[2],
        );
      }
      addCurrentVertex(e, t, i, n, r, o = !1) {
        const a = t.y * n - t.x,
          s = -t.y - t.x * n;
        this.addHalfVertex(e, t.x + t.y * i, t.y - t.x * i, o, !1, i, r),
          this.addHalfVertex(e, a, s, o, !0, -n, r),
          this.distance > Mv / 2 &&
            0 === this.totalDistance &&
            ((this.distance = 0), this.addCurrentVertex(e, t, i, n, r, o));
      }
      addHalfVertex(e, t, i, n, r, o, a) {
        const s = this.scaledDistance,
          l = this.calcTDSpacePoint(e),
          c = 0.5 * s;
        this.layoutVertexArray.emplaceBack(
          l.x,
          l.y,
          l.z,
          (n ? 2 : 0) + (r ? 1 : 0),
          Math.round(63 * t) + 128,
          Math.round(63 * i) + 128,
          (1 + (0 === o ? 0 : o < 0 ? -1 : 1)) | ((63 & c) << 2),
          c >> 6,
          this.seq,
          this.total,
          this.offset,
        );
        const u = a.vertexLength++;
        this.e1 >= 0 &&
          this.e2 >= 0 &&
          (this.indexArray.emplaceBack(this.e1, this.e2, u), a.primitiveLength++),
          r ? (this.e2 = u) : (this.e1 = u);
      }
      updateScaledDistance() {
        this.scaledDistance = this.distance;
      }
      updateDistance(e, t) {
        (this.distance += e.dist(t)), this.updateScaledDistance();
      }
    }
    fo('DynamicLineBucket', Iv, { omit: ['layers', 'patternFeatures'] });
    const Lv = new Vd({
      'dynamicLine-cap': new Od(pm.layout_dynamicLine['dynamicLine-cap']),
      'dynamicLine-join': new Dd(pm.layout_dynamicLine['dynamicLine-join']),
      'dynamicLine-miter-limit': new Od(pm.layout_dynamicLine['dynamicLine-miter-limit']),
      'dynamicLine-round-limit': new Od(pm.layout_dynamicLine['dynamicLine-round-limit']),
      'dynamicLine-sort-key': new Dd(pm.layout_dynamicLine['dynamicLine-sort-key']),
    });
    var Rv = {
      paint: new Vd({
        'dynamicLine-opacity': new Dd(pm.paint_dynamicLine['dynamicLine-opacity']),
        'dynamicLine-color': new Dd(pm.paint_dynamicLine['dynamicLine-color']),
        'dynamicLine-width': new Dd(pm.paint_dynamicLine['dynamicLine-width']),
        'dynamicLine-gap-width': new Dd(pm.paint_dynamicLine['dynamicLine-gap-width']),
        'dynamicLine-blur': new Dd(pm.paint_dynamicLine['dynamicLine-blur']),
        'dynamicLine-seg-group': new Od(pm.paint_dynamicLine['dynamicLine-seg-group']),
        'dynamicLine-speed': new Od(pm.paint_dynamicLine['dynamicLine-speed']),
      }),
      layout: Lv,
    };
    const Nv = new (class extends Dd {
      possiblyEvaluate(e, t) {
        return (
          (t = new fd(Math.floor(t.zoom), {
            now: t.now,
            fadeDuration: t.fadeDuration,
            zoomHistory: t.zoomHistory,
            transition: t.transition,
          })),
          super.possiblyEvaluate(e, t)
        );
      }
      evaluate(e, t, i, n) {
        return (t = ce({}, t, { zoom: Math.floor(t.zoom) })), super.evaluate(e, t, i, n);
      }
    })(Rv.paint.properties['dynamicLine-width'].specification);
    function Ov(e, t) {
      return t > 0 ? t + 2 * e : e;
    }
    Nv.useIntegerZoom = !0;
    const Dv = {
      raster: class extends dg {
        constructor(e) {
          super(e, fg),
            (this.maskingEnabled = e.maskingEnabled),
            (this.maskingPolygonHierarchy = e.maskingPolygonHierarchy),
            e['draw-mode'] && (this.drawMode = e['draw-mode']);
        }
        set maskingEnabled(e) {
          this._maskingEnabled = e;
        }
        get maskingEnabled() {
          return this._maskingEnabled;
        }
        set maskingPolygonHierarchy(e) {
          (this._maskingPolygonHierarchy = e),
            this._maskingPolygonPrimitive &&
              (this._maskingPolygonPrimitive.destroy(), (this._maskingPolygonPrimitive = null));
        }
        get maskingPolygonHierarchy() {
          return this._maskingPolygonHierarchy;
        }
        get maskingPolygonPrimitive() {
          return (
            this._maskingPolygonPrimitive ||
              (this.maskingEnabled &&
                this.maskingPolygonHierarchy &&
                ((this.maskingId = 222),
                (this._maskingPolygonPrimitive = (function (e) {
                  const t = new Jh({
                      polygonHierarchy: e.polygonHierarchy,
                      extrudedHeight: e.extrudedHeight,
                      perPositionHeight: e.perPositionHeight,
                      height: e.height,
                      arcType: e.arcType,
                    }),
                    i = _g.fromType('Color', {
                      color: 'rgba(255,0,0,1.0)',
                      opacity: 1,
                      doubleSided: !0,
                      renderState: {
                        colorMask: { red: !1, green: !1, blue: !1, alpha: !1 },
                        depthTest: { enabled: !1, func: Ll.LESS },
                        stencilTest: {
                          enabled: !0,
                          frontFunction: Ll.ALWAYS,
                          frontOperation: { fail: Ll.KEEP, zFail: Ll.KEEP, zPass: Ll.REPLACE },
                          backFunction: Ll.ALWAYS,
                          backOperation: { fail: Ll.KEEP, zFail: Ll.KEEP, zPass: Ll.REPLACE },
                          reference: e.maskingId,
                          mask: 255,
                        },
                        stencilMask: 255,
                      },
                    });
                  return new o_({ geometry: t, material: i });
                })({
                  polygonHierarchy: this.maskingPolygonHierarchy,
                  extrudedHeight: 0,
                  perPositionHeight: !0,
                  color: 'red',
                  maskingId: this.maskingId,
                })))),
            this._maskingPolygonPrimitive
          );
        }
      },
      fill: class extends dg {
        constructor(e) {
          super(e, zy), (this.maskType = !!e.maskType && e.maskType);
        }
        getCrossfadeParameters() {
          return this._crossfadeParameters;
        }
        recalculate(e, t) {
          super.recalculate(e, t),
            (this.paint = this._transitioningPaint.possiblyEvaluate(e)),
            e.getCrossfadeParameters && (this._crossfadeParameters = e.getCrossfadeParameters());
          const i = this.paint._values['fill-outline-color'];
          'constant' === i.value.kind &&
            void 0 === i.value.value &&
            (this.paint._values['fill-outline-color'] = this.paint._values['fill-color']);
        }
        createBucket(e) {
          return new xy(e);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature(e, t, i, n, r, o, a) {
          return (function (e, t) {
            if (1 === e.length) return Ly(t, e[0]);
            for (let i = 0; i < t.length; i++) {
              const n = t[i];
              for (let t = 0; t < n.length; t++) if (Ry(e, n[t])) return !0;
            }
            for (let i = 0; i < e.length; i++) if (Ly(t, e[i])) return !0;
            for (let i = 0; i < t.length; i++) if (Ey(e, t[i])) return !0;
            return !1;
          })(
            Dy(
              e,
              this.paint.get('fill-translate'),
              this.paint.get('fill-translate-anchor'),
              -o.hpr.heading,
              a,
            ),
            n,
          );
        }
        hasOffscreenPass() {
          return 0 !== this.paint.get('fill-opacity') && 'none' !== this.visibility;
        }
      },
      line: Qy,
      circle: class extends dg {
        constructor(e) {
          super(e, ox);
        }
        createBucket(e) {
          return new nx(e);
        }
        queryRadius(e) {
          const t = e;
          return Oy('circle-radius', this, t) + Oy('circle-stroke-width', this, t) + 0;
        }
        queryIntersectsFeature(e, t, i, n, r, o, a, s) {
          const l = Dy(
              e,
              this.paint.get('circle-translate'),
              this.paint.get('circle-translate-anchor'),
              -o.hpr.heading,
              a,
            ),
            c =
              this.paint.get('circle-radius').evaluate(t, i) +
              this.paint.get('circle-stroke-width').evaluate(t, i),
            u = 'map' === this.paint.get('circle-pitch-alignment'),
            h = u
              ? l
              : (function (e, t) {
                  return e.map((e) => ax(e, t));
                })(l, s),
            d = u ? c * a : c;
          for (const e of n)
            for (const t of e) {
              const e = u ? t : ax(t, s);
              let i = d;
              const n = new Ge([t.x, t.y, 0, 1]).transform(s);
              if (
                ('viewport' === this.paint.get('circle-pitch-scale') &&
                'map' === this.paint.get('circle-pitch-alignment')
                  ? (i *= n[3] / o.cameraToCenterDistance)
                  : 'map' === this.paint.get('circle-pitch-scale') &&
                    'viewport' === this.paint.get('circle-pitch-alignment') &&
                    (i *= o.cameraToCenterDistance / n[3]),
                Sy(h, e, i))
              )
                return !0;
            }
          return !1;
        }
      },
      heatmap: class extends dg {
        createBucket(e) {
          return new ux(e);
        }
        constructor(e) {
          super(e, gx), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(e) {
          'heatmap-color' === e && this._updateColorRamp();
        }
        _updateColorRamp() {
          (this.colorRamp = yx({
            expression: this._transitionablePaint._values['heatmap-color'].value.expression,
            evaluationKey: 'heatmapDensity',
            image: this.colorRamp,
          })),
            (this.colorRampChanged = !0),
            (this.colorRampTexture = null);
        }
        resize() {
          this.heatmapFbo && (this.heatmapFbo.destroy(), (this.heatmapFbo = null));
        }
        queryRadius(e) {
          return Oy('heatmap-radius', this, e);
        }
        queryIntersectsFeature() {
          return !1;
        }
        hasOffscreenPass() {
          return 0 !== this.paint.get('heatmap-opacity') && 'none' !== this.visibility;
        }
        getProgramIds() {
          return ['heatmap', 'heatmapTexture'];
        }
      },
      symbol: class extends dg {
        constructor(e) {
          super(e, mm);
        }
        recalculate(e, t) {
          super.recalculate(e, t),
            'auto' === this.layout.get('icon-rotation-alignment') &&
              (this.layout._values['icon-rotation-alignment'] =
                'point' !== this.layout.get('symbol-placement') ? 'map' : 'viewport'),
            'auto' === this.layout.get('text-rotation-alignment') &&
              (this.layout._values['text-rotation-alignment'] =
                'point' !== this.layout.get('symbol-placement') ? 'map' : 'viewport'),
            'auto' === this.layout.get('text-pitch-alignment') &&
              (this.layout._values['text-pitch-alignment'] =
                this.layout.get('text-rotation-alignment')),
            'auto' === this.layout.get('icon-pitch-alignment') &&
              (this.layout._values['icon-pitch-alignment'] =
                this.layout.get('icon-rotation-alignment'));
        }
        getValueAndResolveTokens(e, t, i, n) {
          const r = this.layout.get(e).evaluate(t, {}, i, n),
            o = this._unevaluatedLayout._values[e];
          return o.isDataDriven() || io(o.value) ? r : xx(t.properties, r);
        }
        createBucket(e) {
          return new dm(e);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          return !1;
        }
        hasOffscreenPass() {
          return (
            0 !== this.paint.get('icon-opacity') &&
            0 !== this.paint.get('text-opacity') &&
            'none' !== this.visibility
          );
        }
      },
      extrusion: class extends dg {
        constructor(e) {
          super(e, Nx),
            (this.enableQuery = e.enableQuery || !1),
            e.hasOwnProperty('patternZoomOffset') && (this.patternZoomOffset = e.patternZoomOffset);
        }
        createBucket(e) {
          return new Cx(e, this.enableQuery);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          return !1;
        }
        hasOffscreenPass() {
          return 0 !== this.paint.get('extrusion-opacity') && 'none' !== this.visibility;
        }
        resize() {
          this.viewportFrame && (this.viewportFrame.destroy(), (this.viewportFrame = null));
        }
      },
      histogram: class extends dg {
        constructor(e) {
          super(e, Tv);
        }
        createBucket(e) {
          return new mv(e);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature(e, t, i, n, r, o, a) {
          return (
            Dy(
              e,
              this.paint.get('histogram-translate'),
              this.paint.get('histogram-translate-anchor'),
              -o.hpr.heading,
              a,
            ),
            !1
          );
        }
        hasOffscreenPass() {
          return 0 !== this.paint.get('histogram-opacity') && 'none' !== this.visibility;
        }
        resize() {
          this.viewportFrame && (this.viewportFrame.destroy(), (this.viewportFrame = null));
        }
      },
      sprite: class extends dg {
        constructor(e) {
          e &&
            e.layout &&
            'visible' === e.layout['border-visibility'] &&
            e.paint &&
            e.paint['sprite-gap-width'] &&
            (ve("'sprite-gap-width' cannot be set when 'border-visibility' is 'visible'"),
            (e.paint['sprite-gap-width'] = 0)),
            super(e, sv),
            (this.gradientVersion = 0);
        }
        _handleSpecialPaintPropertyUpdate(e) {
          'sprite-gradient' === e &&
            ((this.stepInterpolate =
              this._transitionablePaint._values['sprite-gradient'].value.expression._styleExpression
                .expression instanceof Fn),
            (this.gradientVersion = (this.gradientVersion + 1) % ne));
        }
        gradientExpression() {
          return this._transitionablePaint._values['sprite-gradient'].value.expression;
        }
        getCrossfadeParameters() {
          return this._crossfadeParameters;
        }
        recalculate(e, t) {
          super.recalculate(e, t),
            e.getCrossfadeParameters && (this._crossfadeParameters = e.getCrossfadeParameters()),
            (this.paint._values['sprite-floorwidth'] = lv.possiblyEvaluate(
              this._transitioningPaint._values['sprite-width'].value,
              e,
            ));
        }
        createBucket(e) {
          return new ov(e);
        }
        queryRadius(e) {
          const t = e,
            i = cv(Oy('sprite-width', this, t), Oy('sprite-gap-width', this, t)),
            n = Oy('sprite-offset', this, t);
          return i / 2 + Math.abs(n) + 0;
        }
        queryIntersectsFeature(e, t, i, n, r, o, a) {
          const s = Dy(
              e,
              this.paint.get('sprite-translate'),
              this.paint.get('sprite-translate-anchor'),
              -o.hpr.heading,
              a,
            ),
            l =
              (a / 2) *
              cv(
                this.paint.get('sprite-width').evaluate(t, i),
                this.paint.get('sprite-gap-width').evaluate(t, i),
              ),
            c = Math.max(l, 500),
            u = this.paint.get('sprite-offset').evaluate(t, i);
          return (
            u &&
              (n = (function (e, t) {
                const i = [],
                  n = new te(0, 0);
                for (let r = 0; r < e.length; r++) {
                  const o = e[r],
                    a = [];
                  for (let e = 0; e < o.length; e++) {
                    const i = o[e],
                      r = o[e + 1],
                      s =
                        0 === e
                          ? n
                          : i
                              .sub(o[e - 1])
                              ._unit()
                              ._perp(),
                      l = e === o.length - 1 ? n : r.sub(i)._unit()._perp(),
                      c = s._add(l)._unit();
                    c._mult(1 / (c.x * l.x + c.y * l.y)), a.push(c._mult(t)._add(i));
                  }
                  i.push(a);
                }
                return i;
              })(n, u * a)),
            Ay(s, n, c)
          );
        }
        hasOffscreenPass() {
          return 0 !== this.paint.get('sprite-opacity') && 'none' !== this.visibility;
        }
      },
      background: class extends dg {
        constructor(e) {
          super(e, pg), (this.showDepth = e['show-depth'] || !1);
        }
      },
      tracking: class extends dg {
        constructor(e) {
          super(e, Yx);
        }
        recalculate(e, t) {
          super.recalculate(e, t),
            e.getCrossfadeParameters && (this._crossfadeParameters = e.getCrossfadeParameters()),
            (this.paint._values['tracking-floorwidth'] = qx.possiblyEvaluate(
              this._transitioningPaint._values['tracking-width'].value,
              e,
            ));
        }
        getCrossfadeParameters() {
          return this._crossfadeParameters;
        }
        createBucket(e) {
          return new Gx(e);
        }
        queryRadius(e) {
          const t = e,
            i = Xx(Oy('tracking-width', this, t), Oy('tracking-gap-width', this, t)),
            n = Oy('tracking-offset', this, t);
          return i / 2 + Math.abs(n) + 0;
        }
        queryIntersectsFeature(e, t, i, n, r, o, a) {
          const s = Dy(
              e,
              this.paint.get('tracking-translate'),
              this.paint.get('tracking-translate-anchor'),
              -o.hpr.heading,
              a,
            ),
            l =
              (a / 2) *
              Xx(
                this.paint.get('tracking-width').evaluate(t, i),
                this.paint.get('tracking-gap-width').evaluate(t, i),
              ),
            c = this.paint.get('tracking-offset').evaluate(t, i);
          return (
            c &&
              (n = (function (e, t) {
                const i = [],
                  n = new te(0, 0);
                for (let r = 0; r < e.length; r++) {
                  const o = e[r],
                    a = [];
                  for (let e = 0; e < o.length; e++) {
                    const i = o[e],
                      r = o[e + 1],
                      s =
                        0 === e
                          ? n
                          : i
                              .sub(o[e - 1])
                              ._unit()
                              ._perp(),
                      l = e === o.length - 1 ? n : r.sub(i)._unit()._perp(),
                      c = s._add(l)._unit();
                    c._mult(1 / (c.x * l.x + c.y * l.y)), a.push(c._mult(t)._add(i));
                  }
                  i.push(a);
                }
                return i;
              })(n, c * a)),
            Ay(s, n, l)
          );
        }
      },
      '3d-model': class extends dg {
        constructor(e) {
          super(e, jx),
            (this.baseMatrixCalculated = !1),
            (this.respectiveTransformation = !1),
            (this.identityMatrix = !0),
            (this.matrix = []),
            (this.nodes = []),
            (this.meshes = []),
            (this.primitives = []),
            (this.lightExposure = e.lightExposure ? e.lightExposure : 1);
        }
      },
      '3d-tiles': class extends dg {
        constructor(e) {
          super(e, Wx);
        }
      },
      panorama: class extends dg {
        constructor(e) {
          super(e, hv);
        }
      },
      symtracking: class extends dg {
        constructor(e) {
          super(e, Sv);
        }
        recalculate(e, t) {
          super.recalculate(e, t),
            'auto' === this.layout.get('icon-rotation-alignment') &&
              (this.layout._values['icon-rotation-alignment'] =
                'point' !== this.layout.get('symbol-placement') ? 'map' : 'viewport'),
            'auto' === this.layout.get('text-rotation-alignment') &&
              (this.layout._values['text-rotation-alignment'] =
                'point' !== this.layout.get('symbol-placement') ? 'map' : 'viewport'),
            'auto' === this.layout.get('text-pitch-alignment') &&
              (this.layout._values['text-pitch-alignment'] =
                this.layout.get('text-rotation-alignment')),
            'auto' === this.layout.get('icon-pitch-alignment') &&
              (this.layout._values['icon-pitch-alignment'] =
                this.layout.get('icon-rotation-alignment'));
        }
        getValueAndResolveTokens(e, t) {
          const i = this.layout.get(e).evaluate(t, {}),
            n = this._unevaluatedLayout._values[e];
          return n.isDataDriven() || io(n.value) ? i : xx(t.properties, i);
        }
        createBucket(e) {
          return new Pm(e);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          return !1;
        }
        hasOffscreenPass() {
          return (
            0 !== this.paint.get('icon-opacity') &&
            0 !== this.paint.get('text-opacity') &&
            'none' !== this.visibility
          );
        }
      },
      dynamicLine: class extends dg {
        constructor(e) {
          super(e, Rv);
        }
        recalculate(e, t) {
          super.recalculate(e, t),
            (this.paint._values['dynamicLine-floorwidth'] = Nv.possiblyEvaluate(
              this._transitioningPaint._values['dynamicLine-width'].value,
              e,
            ));
        }
        createBucket(e) {
          return new Iv(e);
        }
        queryRadius(e) {
          const t = e;
          return Ov(Oy('dynamicLine-width', this, t), Oy('dynamicLine-gap-width', this, t)) / 2;
        }
        queryIntersectsFeature(e, t, i, n, r, o, a) {
          return Ay(
            [],
            n,
            (a / 2) *
              Ov(
                this.paint.get('dynamicLine-width').evaluate(t, i),
                this.paint.get('dynamicLine-gap-width').evaluate(t, i),
              ),
          );
        }
        isTileClipped() {
          return !0;
        }
      },
    };
    function Fv(e) {
      let t = 0,
        i = 0;
      for (const n of e) (t += n.w * n.h), (i = Math.max(i, n.w));
      e.sort((e, t) => t.h - e.h);
      const n = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(t / 0.95)), i), h: 1 / 0 }];
      let r = 0,
        o = 0;
      for (const t of e)
        for (let e = n.length - 1; e >= 0; e--) {
          const i = n[e];
          if (!(t.w > i.w || t.h > i.h)) {
            if (
              ((t.x = i.x),
              (t.y = i.y),
              (o = Math.max(o, t.y + t.h)),
              (r = Math.max(r, t.x + t.w)),
              t.w === i.w && t.h === i.h)
            ) {
              const t = n.pop();
              e < n.length && (n[e] = t);
            } else
              t.h === i.h
                ? ((i.x += t.w), (i.w -= t.w))
                : t.w === i.w
                ? ((i.y += t.h), (i.h -= t.h))
                : (n.push({ x: i.x + t.w, y: i.y, w: i.w - t.w, h: t.h }),
                  (i.y += t.h),
                  (i.h -= t.h));
            break;
          }
        }
      return { w: r, h: o, fill: t / (r * o) || 0 };
    }
    class zv {
      constructor(e, { pixelRatio: t, version: i, stretchX: n, stretchY: r, content: o }) {
        (this.paddedRect = e),
          (this.pixelRatio = t),
          (this.stretchX = n),
          (this.stretchY = r),
          (this.content = o),
          (this.version = i);
      }
      get tl() {
        return [this.paddedRect.x + 1, this.paddedRect.y + 1];
      }
      get br() {
        return [
          this.paddedRect.x + this.paddedRect.w - 1,
          this.paddedRect.y + this.paddedRect.h - 1,
        ];
      }
      get tlbr() {
        return this.tl.concat(this.br);
      }
      get displaySize() {
        return [
          (this.paddedRect.w - 2) / this.pixelRatio,
          (this.paddedRect.h - 2) / this.pixelRatio,
        ];
      }
    }
    class Bv {
      constructor(e, t) {
        const i = {},
          n = {};
        this.haveRenderCallbacks = [];
        const r = [];
        this.addImages(e, i, r), this.addImages(t, n, r);
        const { w: o, h: a } = Fv(r),
          s = new mx({ width: o || 1, height: a || 1 });
        for (const t in e) {
          const n = e[t],
            r = i[t].paddedRect;
          mx.copy(n.data, s, { x: 0, y: 0 }, { x: r.x + 1, y: r.y + 1 }, n.data);
        }
        for (const e in t) {
          const i = t[e],
            r = n[e].paddedRect,
            o = r.x + 1,
            a = r.y + 1,
            l = i.data.width,
            c = i.data.height;
          mx.copy(i.data, s, { x: 0, y: 0 }, { x: o, y: a }, i.data),
            mx.copy(i.data, s, { x: 0, y: c - 1 }, { x: o, y: a - 1 }, { width: l, height: 1 }),
            mx.copy(i.data, s, { x: 0, y: 0 }, { x: o, y: a + c }, { width: l, height: 1 }),
            mx.copy(i.data, s, { x: l - 1, y: 0 }, { x: o - 1, y: a }, { width: 1, height: c }),
            mx.copy(i.data, s, { x: 0, y: 0 }, { x: o + l, y: a }, { width: 1, height: c });
        }
        (this.image = s), (this.iconPositions = i), (this.patternPositions = n);
      }
      addImages(e, t, i) {
        for (const n in e) {
          const r = e[n],
            o = { x: 0, y: 0, w: r.data.width + 2, h: r.data.height + 2 };
          i.push(o), (t[n] = new zv(o, r)), r.hasRenderCallback && this.haveRenderCallbacks.push(n);
        }
      }
      patchUpdatedImages(e, t) {
        e.dispatchRenderCallbacks(this.haveRenderCallbacks);
        for (const i in e.updatedImages)
          this.patchUpdatedImage(this.iconPositions[i], e.getImage(i), t),
            this.patchUpdatedImage(this.patternPositions[i], e.getImage(i), t);
      }
      patchUpdatedImage(e, t, i) {
        if (!e || !t) return;
        if (e.version === t.version) return;
        e.version = t.version;
        const [n, r] = e.tl;
        i.update(t.data, void 0, { x: n, y: r });
      }
    }
    fo('ImagePosition', zv), fo('ImageAtlas', Bv);
    /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
    var Vv = function (e, t, i, n, r) {
        var o,
          a,
          s = 8 * r - n - 1,
          l = (1 << s) - 1,
          c = l >> 1,
          u = -7,
          h = i ? r - 1 : 0,
          d = i ? -1 : 1,
          p = e[t + h];
        for (
          h += d, o = p & ((1 << -u) - 1), p >>= -u, u += s;
          u > 0;
          o = 256 * o + e[t + h], h += d, u -= 8
        );
        for (
          a = o & ((1 << -u) - 1), o >>= -u, u += n;
          u > 0;
          a = 256 * a + e[t + h], h += d, u -= 8
        );
        if (0 === o) o = 1 - c;
        else {
          if (o === l) return a ? NaN : (1 / 0) * (p ? -1 : 1);
          (a += Math.pow(2, n)), (o -= c);
        }
        return (p ? -1 : 1) * a * Math.pow(2, o - n);
      },
      Uv = function (e, t, i, n, r, o) {
        var a,
          s,
          l,
          c = 8 * o - r - 1,
          u = (1 << c) - 1,
          h = u >> 1,
          d = 23 === r ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
          p = n ? 0 : o - 1,
          f = n ? 1 : -1,
          m = t < 0 || (0 === t && 1 / t < 0) ? 1 : 0;
        for (
          t = Math.abs(t),
            isNaN(t) || t === 1 / 0
              ? ((s = isNaN(t) ? 1 : 0), (a = u))
              : ((a = Math.floor(Math.log(t) / Math.LN2)),
                t * (l = Math.pow(2, -a)) < 1 && (a--, (l *= 2)),
                (t += a + h >= 1 ? d / l : d * Math.pow(2, 1 - h)) * l >= 2 && (a++, (l /= 2)),
                a + h >= u
                  ? ((s = 0), (a = u))
                  : a + h >= 1
                  ? ((s = (t * l - 1) * Math.pow(2, r)), (a += h))
                  : ((s = t * Math.pow(2, h - 1) * Math.pow(2, r)), (a = 0)));
          r >= 8;
          e[i + p] = 255 & s, p += f, s /= 256, r -= 8
        );
        for (a = (a << r) | s, c += r; c > 0; e[i + p] = 255 & a, p += f, a /= 256, c -= 8);
        e[i + p - f] |= 128 * m;
      },
      kv = Gv;
    function Gv(e) {
      (this.buf = ArrayBuffer.isView && ArrayBuffer.isView(e) ? e : new Uint8Array(e || 0)),
        (this.pos = 0),
        (this.type = 0),
        (this.length = this.buf.length);
    }
    (Gv.Varint = 0), (Gv.Fixed64 = 1), (Gv.Bytes = 2), (Gv.Fixed32 = 5);
    var Hv = 4294967296,
      Yv = 1 / Hv,
      qv = 'undefined' == typeof TextDecoder ? null : new TextDecoder('utf8');
    function Xv(e) {
      return e.type === Gv.Bytes ? e.readVarint() + e.pos : e.pos + 1;
    }
    function jv(e, t, i) {
      return i ? 4294967296 * t + (e >>> 0) : 4294967296 * (t >>> 0) + (e >>> 0);
    }
    function Wv(e, t, i) {
      var n =
        t <= 16383
          ? 1
          : t <= 2097151
          ? 2
          : t <= 268435455
          ? 3
          : Math.floor(Math.log(t) / (7 * Math.LN2));
      i.realloc(n);
      for (var r = i.pos - 1; r >= e; r--) i.buf[r + n] = i.buf[r];
    }
    function $v(e, t) {
      for (var i = 0; i < e.length; i++) t.writeVarint(e[i]);
    }
    function Zv(e, t) {
      for (var i = 0; i < e.length; i++) t.writeSVarint(e[i]);
    }
    function Kv(e, t) {
      for (var i = 0; i < e.length; i++) t.writeFloat(e[i]);
    }
    function Qv(e, t) {
      for (var i = 0; i < e.length; i++) t.writeDouble(e[i]);
    }
    function Jv(e, t) {
      for (var i = 0; i < e.length; i++) t.writeBoolean(e[i]);
    }
    function ew(e, t) {
      for (var i = 0; i < e.length; i++) t.writeFixed32(e[i]);
    }
    function tw(e, t) {
      for (var i = 0; i < e.length; i++) t.writeSFixed32(e[i]);
    }
    function iw(e, t) {
      for (var i = 0; i < e.length; i++) t.writeFixed64(e[i]);
    }
    function nw(e, t) {
      for (var i = 0; i < e.length; i++) t.writeSFixed64(e[i]);
    }
    function rw(e, t) {
      return (e[t] | (e[t + 1] << 8) | (e[t + 2] << 16)) + 16777216 * e[t + 3];
    }
    function ow(e, t, i) {
      (e[i] = t), (e[i + 1] = t >>> 8), (e[i + 2] = t >>> 16), (e[i + 3] = t >>> 24);
    }
    function aw(e, t) {
      return (e[t] | (e[t + 1] << 8) | (e[t + 2] << 16)) + (e[t + 3] << 24);
    }
    Gv.prototype = {
      destroy: function () {
        this.buf = null;
      },
      readFields: function (e, t, i) {
        for (i = i || this.length; this.pos < i; ) {
          var n = this.readVarint(),
            r = n >> 3,
            o = this.pos;
          (this.type = 7 & n), e(r, t, this), this.pos === o && this.skip(n);
        }
        return t;
      },
      readMessage: function (e, t) {
        return this.readFields(e, t, this.readVarint() + this.pos);
      },
      readFixed32: function () {
        var e = rw(this.buf, this.pos);
        return (this.pos += 4), e;
      },
      readSFixed32: function () {
        var e = aw(this.buf, this.pos);
        return (this.pos += 4), e;
      },
      readFixed64: function () {
        var e = rw(this.buf, this.pos) + rw(this.buf, this.pos + 4) * Hv;
        return (this.pos += 8), e;
      },
      readSFixed64: function () {
        var e = rw(this.buf, this.pos) + aw(this.buf, this.pos + 4) * Hv;
        return (this.pos += 8), e;
      },
      readFloat: function () {
        var e = Vv(this.buf, this.pos, !0, 23, 4);
        return (this.pos += 4), e;
      },
      readDouble: function () {
        var e = Vv(this.buf, this.pos, !0, 52, 8);
        return (this.pos += 8), e;
      },
      readVarint: function (e) {
        var t,
          i,
          n = this.buf;
        return (
          (t = 127 & (i = n[this.pos++])),
          i < 128
            ? t
            : ((t |= (127 & (i = n[this.pos++])) << 7),
              i < 128
                ? t
                : ((t |= (127 & (i = n[this.pos++])) << 14),
                  i < 128
                    ? t
                    : ((t |= (127 & (i = n[this.pos++])) << 21),
                      i < 128
                        ? t
                        : (function (e, t, i) {
                            var n,
                              r,
                              o = i.buf;
                            if (((n = (112 & (r = o[i.pos++])) >> 4), r < 128)) return jv(e, n, t);
                            if (((n |= (127 & (r = o[i.pos++])) << 3), r < 128)) return jv(e, n, t);
                            if (((n |= (127 & (r = o[i.pos++])) << 10), r < 128))
                              return jv(e, n, t);
                            if (((n |= (127 & (r = o[i.pos++])) << 17), r < 128))
                              return jv(e, n, t);
                            if (((n |= (127 & (r = o[i.pos++])) << 24), r < 128))
                              return jv(e, n, t);
                            if (((n |= (1 & (r = o[i.pos++])) << 31), r < 128)) return jv(e, n, t);
                            throw new Error('Expected varint not more than 10 bytes');
                          })((t |= (15 & (i = n[this.pos])) << 28), e, this))))
        );
      },
      readVarint64: function () {
        return this.readVarint(!0);
      },
      readSVarint: function () {
        var e = this.readVarint();
        return e % 2 == 1 ? (e + 1) / -2 : e / 2;
      },
      readBoolean: function () {
        return Boolean(this.readVarint());
      },
      readString: function () {
        var e = this.readVarint() + this.pos,
          t = this.pos;
        return (
          (this.pos = e),
          e - t >= 12 && qv
            ? (function (e, t, i) {
                return qv.decode(e.subarray(t, i));
              })(this.buf, t, e)
            : (function (e, t, i) {
                for (var n = '', r = t; r < i; ) {
                  var o,
                    a,
                    s,
                    l = e[r],
                    c = null,
                    u = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1;
                  if (r + u > i) break;
                  1 === u
                    ? l < 128 && (c = l)
                    : 2 === u
                    ? 128 == (192 & (o = e[r + 1])) &&
                      (c = ((31 & l) << 6) | (63 & o)) <= 127 &&
                      (c = null)
                    : 3 === u
                    ? ((a = e[r + 2]),
                      128 == (192 & (o = e[r + 1])) &&
                        128 == (192 & a) &&
                        ((c = ((15 & l) << 12) | ((63 & o) << 6) | (63 & a)) <= 2047 ||
                          (c >= 55296 && c <= 57343)) &&
                        (c = null))
                    : 4 === u &&
                      ((a = e[r + 2]),
                      (s = e[r + 3]),
                      128 == (192 & (o = e[r + 1])) &&
                        128 == (192 & a) &&
                        128 == (192 & s) &&
                        ((c = ((15 & l) << 18) | ((63 & o) << 12) | ((63 & a) << 6) | (63 & s)) <=
                          65535 ||
                          c >= 1114112) &&
                        (c = null)),
                    null === c
                      ? ((c = 65533), (u = 1))
                      : c > 65535 &&
                        ((c -= 65536),
                        (n += String.fromCharCode(((c >>> 10) & 1023) | 55296)),
                        (c = 56320 | (1023 & c))),
                    (n += String.fromCharCode(c)),
                    (r += u);
                }
                return n;
              })(this.buf, t, e)
        );
      },
      readBytes: function () {
        var e = this.readVarint() + this.pos,
          t = this.buf.subarray(this.pos, e);
        return (this.pos = e), t;
      },
      readPackedVarint: function (e, t) {
        if (this.type !== Gv.Bytes) return e.push(this.readVarint(t));
        var i = Xv(this);
        for (e = e || []; this.pos < i; ) e.push(this.readVarint(t));
        return e;
      },
      readPackedSVarint: function (e) {
        if (this.type !== Gv.Bytes) return e.push(this.readSVarint());
        var t = Xv(this);
        for (e = e || []; this.pos < t; ) e.push(this.readSVarint());
        return e;
      },
      readPackedBoolean: function (e) {
        if (this.type !== Gv.Bytes) return e.push(this.readBoolean());
        var t = Xv(this);
        for (e = e || []; this.pos < t; ) e.push(this.readBoolean());
        return e;
      },
      readPackedFloat: function (e) {
        if (this.type !== Gv.Bytes) return e.push(this.readFloat());
        var t = Xv(this);
        for (e = e || []; this.pos < t; ) e.push(this.readFloat());
        return e;
      },
      readPackedDouble: function (e) {
        if (this.type !== Gv.Bytes) return e.push(this.readDouble());
        var t = Xv(this);
        for (e = e || []; this.pos < t; ) e.push(this.readDouble());
        return e;
      },
      readPackedFixed32: function (e) {
        if (this.type !== Gv.Bytes) return e.push(this.readFixed32());
        var t = Xv(this);
        for (e = e || []; this.pos < t; ) e.push(this.readFixed32());
        return e;
      },
      readPackedSFixed32: function (e) {
        if (this.type !== Gv.Bytes) return e.push(this.readSFixed32());
        var t = Xv(this);
        for (e = e || []; this.pos < t; ) e.push(this.readSFixed32());
        return e;
      },
      readPackedFixed64: function (e) {
        if (this.type !== Gv.Bytes) return e.push(this.readFixed64());
        var t = Xv(this);
        for (e = e || []; this.pos < t; ) e.push(this.readFixed64());
        return e;
      },
      readPackedSFixed64: function (e) {
        if (this.type !== Gv.Bytes) return e.push(this.readSFixed64());
        var t = Xv(this);
        for (e = e || []; this.pos < t; ) e.push(this.readSFixed64());
        return e;
      },
      skip: function (e) {
        var t = 7 & e;
        if (t === Gv.Varint) for (; this.buf[this.pos++] > 127; );
        else if (t === Gv.Bytes) this.pos = this.readVarint() + this.pos;
        else if (t === Gv.Fixed32) this.pos += 4;
        else {
          if (t !== Gv.Fixed64) throw new Error('Unimplemented type: ' + t);
          this.pos += 8;
        }
      },
      writeTag: function (e, t) {
        this.writeVarint((e << 3) | t);
      },
      realloc: function (e) {
        for (var t = this.length || 16; t < this.pos + e; ) t *= 2;
        if (t !== this.length) {
          var i = new Uint8Array(t);
          i.set(this.buf), (this.buf = i), (this.length = t);
        }
      },
      finish: function () {
        return (this.length = this.pos), (this.pos = 0), this.buf.subarray(0, this.length);
      },
      writeFixed32: function (e) {
        this.realloc(4), ow(this.buf, e, this.pos), (this.pos += 4);
      },
      writeSFixed32: function (e) {
        this.realloc(4), ow(this.buf, e, this.pos), (this.pos += 4);
      },
      writeFixed64: function (e) {
        this.realloc(8),
          ow(this.buf, -1 & e, this.pos),
          ow(this.buf, Math.floor(e * Yv), this.pos + 4),
          (this.pos += 8);
      },
      writeSFixed64: function (e) {
        this.realloc(8),
          ow(this.buf, -1 & e, this.pos),
          ow(this.buf, Math.floor(e * Yv), this.pos + 4),
          (this.pos += 8);
      },
      writeVarint: function (e) {
        (e = +e || 0) > 268435455 || e < 0
          ? (function (e, t) {
              var i, n;
              if (
                (e >= 0
                  ? ((i = e % 4294967296 | 0), (n = (e / 4294967296) | 0))
                  : ((n = ~(-e / 4294967296)),
                    4294967295 ^ (i = ~(-e % 4294967296))
                      ? (i = (i + 1) | 0)
                      : ((i = 0), (n = (n + 1) | 0))),
                e >= 0x10000000000000000 || e < -0x10000000000000000)
              )
                throw new Error("Given varint doesn't fit into 10 bytes");
              t.realloc(10),
                (function (e, t, i) {
                  (i.buf[i.pos++] = (127 & e) | 128),
                    (e >>>= 7),
                    (i.buf[i.pos++] = (127 & e) | 128),
                    (e >>>= 7),
                    (i.buf[i.pos++] = (127 & e) | 128),
                    (e >>>= 7),
                    (i.buf[i.pos++] = (127 & e) | 128),
                    (i.buf[i.pos] = 127 & (e >>>= 7));
                })(i, 0, t),
                (function (e, t) {
                  var i = (7 & e) << 4;
                  (t.buf[t.pos++] |= i | ((e >>>= 3) ? 128 : 0)),
                    e &&
                      ((t.buf[t.pos++] = (127 & e) | ((e >>>= 7) ? 128 : 0)),
                      e &&
                        ((t.buf[t.pos++] = (127 & e) | ((e >>>= 7) ? 128 : 0)),
                        e &&
                          ((t.buf[t.pos++] = (127 & e) | ((e >>>= 7) ? 128 : 0)),
                          e &&
                            ((t.buf[t.pos++] = (127 & e) | ((e >>>= 7) ? 128 : 0)),
                            e && (t.buf[t.pos++] = 127 & e)))));
                })(n, t);
            })(e, this)
          : (this.realloc(4),
            (this.buf[this.pos++] = (127 & e) | (e > 127 ? 128 : 0)),
            e <= 127 ||
              ((this.buf[this.pos++] = (127 & (e >>>= 7)) | (e > 127 ? 128 : 0)),
              e <= 127 ||
                ((this.buf[this.pos++] = (127 & (e >>>= 7)) | (e > 127 ? 128 : 0)),
                e <= 127 || (this.buf[this.pos++] = (e >>> 7) & 127))));
      },
      writeSVarint: function (e) {
        this.writeVarint(e < 0 ? 2 * -e - 1 : 2 * e);
      },
      writeBoolean: function (e) {
        this.writeVarint(Boolean(e));
      },
      writeString: function (e) {
        (e = String(e)), this.realloc(4 * e.length), this.pos++;
        var t = this.pos;
        this.pos = (function (e, t, i) {
          for (var n, r, o = 0; o < t.length; o++) {
            if ((n = t.charCodeAt(o)) > 55295 && n < 57344) {
              if (!r) {
                n > 56319 || o + 1 === t.length
                  ? ((e[i++] = 239), (e[i++] = 191), (e[i++] = 189))
                  : (r = n);
                continue;
              }
              if (n < 56320) {
                (e[i++] = 239), (e[i++] = 191), (e[i++] = 189), (r = n);
                continue;
              }
              (n = ((r - 55296) << 10) | (n - 56320) | 65536), (r = null);
            } else r && ((e[i++] = 239), (e[i++] = 191), (e[i++] = 189), (r = null));
            n < 128
              ? (e[i++] = n)
              : (n < 2048
                  ? (e[i++] = (n >> 6) | 192)
                  : (n < 65536
                      ? (e[i++] = (n >> 12) | 224)
                      : ((e[i++] = (n >> 18) | 240), (e[i++] = ((n >> 12) & 63) | 128)),
                    (e[i++] = ((n >> 6) & 63) | 128)),
                (e[i++] = (63 & n) | 128));
          }
          return i;
        })(this.buf, e, this.pos);
        var i = this.pos - t;
        i >= 128 && Wv(t, i, this), (this.pos = t - 1), this.writeVarint(i), (this.pos += i);
      },
      writeFloat: function (e) {
        this.realloc(4), Uv(this.buf, e, this.pos, !0, 23, 4), (this.pos += 4);
      },
      writeDouble: function (e) {
        this.realloc(8), Uv(this.buf, e, this.pos, !0, 52, 8), (this.pos += 8);
      },
      writeBytes: function (e) {
        var t = e.length;
        this.writeVarint(t), this.realloc(t);
        for (var i = 0; i < t; i++) this.buf[this.pos++] = e[i];
      },
      writeRawMessage: function (e, t) {
        this.pos++;
        var i = this.pos;
        e(t, this);
        var n = this.pos - i;
        n >= 128 && Wv(i, n, this), (this.pos = i - 1), this.writeVarint(n), (this.pos += n);
      },
      writeMessage: function (e, t, i) {
        this.writeTag(e, Gv.Bytes), this.writeRawMessage(t, i);
      },
      writePackedVarint: function (e, t) {
        t.length && this.writeMessage(e, $v, t);
      },
      writePackedSVarint: function (e, t) {
        t.length && this.writeMessage(e, Zv, t);
      },
      writePackedBoolean: function (e, t) {
        t.length && this.writeMessage(e, Jv, t);
      },
      writePackedFloat: function (e, t) {
        t.length && this.writeMessage(e, Kv, t);
      },
      writePackedDouble: function (e, t) {
        t.length && this.writeMessage(e, Qv, t);
      },
      writePackedFixed32: function (e, t) {
        t.length && this.writeMessage(e, ew, t);
      },
      writePackedSFixed32: function (e, t) {
        t.length && this.writeMessage(e, tw, t);
      },
      writePackedFixed64: function (e, t) {
        t.length && this.writeMessage(e, iw, t);
      },
      writePackedSFixed64: function (e, t) {
        t.length && this.writeMessage(e, nw, t);
      },
      writeBytesField: function (e, t) {
        this.writeTag(e, Gv.Bytes), this.writeBytes(t);
      },
      writeFixed32Field: function (e, t) {
        this.writeTag(e, Gv.Fixed32), this.writeFixed32(t);
      },
      writeSFixed32Field: function (e, t) {
        this.writeTag(e, Gv.Fixed32), this.writeSFixed32(t);
      },
      writeFixed64Field: function (e, t) {
        this.writeTag(e, Gv.Fixed64), this.writeFixed64(t);
      },
      writeSFixed64Field: function (e, t) {
        this.writeTag(e, Gv.Fixed64), this.writeSFixed64(t);
      },
      writeVarintField: function (e, t) {
        this.writeTag(e, Gv.Varint), this.writeVarint(t);
      },
      writeSVarintField: function (e, t) {
        this.writeTag(e, Gv.Varint), this.writeSVarint(t);
      },
      writeStringField: function (e, t) {
        this.writeTag(e, Gv.Bytes), this.writeString(t);
      },
      writeFloatField: function (e, t) {
        this.writeTag(e, Gv.Fixed32), this.writeFloat(t);
      },
      writeDoubleField: function (e, t) {
        this.writeTag(e, Gv.Fixed64), this.writeDouble(t);
      },
      writeBooleanField: function (e, t) {
        this.writeVarintField(e, Boolean(t));
      },
    };
    const sw = 3;
    function lw(e, t, i) {
      1 === e && i.readMessage(cw, t);
    }
    function cw(e, t, i) {
      if (3 === e) {
        const {
          id: e,
          bitmap: n,
          width: r,
          height: o,
          left: a,
          top: s,
          advance: l,
        } = i.readMessage(uw, {});
        t.push({
          id: e,
          bitmap: new fx({ width: r + 2 * sw, height: o + 2 * sw }, n),
          metrics: { width: r, height: o, left: a, top: s, advance: l },
        });
      }
    }
    function uw(e, t, i) {
      1 === e
        ? (t.id = i.readVarint())
        : 2 === e
        ? (t.bitmap = i.readBytes())
        : 3 === e
        ? (t.width = i.readVarint())
        : 4 === e
        ? (t.height = i.readVarint())
        : 5 === e
        ? (t.left = i.readSVarint())
        : 6 === e
        ? (t.top = i.readSVarint())
        : 7 === e && (t.advance = i.readVarint());
    }
    const hw = sw;
    class dw {
      constructor(e) {
        (this._stringToNumber = {}), (this._numberToString = []);
        for (let t = 0; t < e.length; t++) {
          const i = e[t];
          (this._stringToNumber[i] = t), (this._numberToString[t] = i);
        }
      }
      encode(e) {
        return this._stringToNumber[e];
      }
      decode(e) {
        return this._numberToString[e];
      }
    }
    class pw {
      constructor(e, t, i, n) {
        (this.type = 'Feature'),
          (this._vectorTileFeature = e),
          (e._z = t),
          (e._x = i),
          (e._y = n),
          (this.properties = e.properties),
          null != e.id && (this.id = e.id);
      }
      get geometry() {
        return (
          void 0 === this._geometry &&
            (this._geometry = this._vectorTileFeature.toGeoJSON(
              this._vectorTileFeature._x,
              this._vectorTileFeature._y,
              this._vectorTileFeature._z,
            ).geometry),
          this._geometry
        );
      }
      set geometry(e) {
        this._geometry = e;
      }
      toJSON() {
        const e = { geometry: this.geometry };
        for (const t in this) '_geometry' !== t && '_vectorTileFeature' !== t && (e[t] = this[t]);
        return e;
      }
    }
    class fw {
      constructor(e, t, i) {
        (this.tileID = e),
          (this.x = e.canonical.x),
          (this.y = e.canonical.y),
          (this.z = e.canonical.z),
          (this.grid = new Yt(Wu, 16, 0)),
          (this.grid3D = new Yt(Wu, 16, 0)),
          (this.featureIndexArray = new pa()),
          (this.promoteId = t),
          (this.projection = i);
      }
      insert(e, t, i, n, r, o) {
        const a = this.featureIndexArray.length;
        this.featureIndexArray.emplaceBack(i, n, r);
        const s = o ? this.grid3D : this.grid;
        for (let e = 0; e < t.length; e++) {
          const i = t[e],
            n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let e = 0; e < i.length; e++) {
            const t = i[e];
            (n[0] = Math.min(n[0], t.x)),
              (n[1] = Math.min(n[1], t.y)),
              (n[2] = Math.max(n[2], t.x)),
              (n[3] = Math.max(n[3], t.y));
          }
          n[0] < Wu && n[1] < Wu && n[2] >= 0 && n[3] >= 0 && s.insert(a, n[0], n[1], n[2], n[3]);
        }
      }
      loadVTLayers() {
        return (
          this.vtLayers ||
            ((this.vtLayers = new Qf.VectorTile(
              new kv(this.rawTileData),
              null,
              this.projection,
            ).layers),
            (this.sourceLayerCoder = new dw(
              this.vtLayers ? Object.keys(this.vtLayers).sort() : ['_geojsonTileLayer'],
            ))),
          this.vtLayers
        );
      }
      query(e, t, i, n) {
        this.loadVTLayers();
        const r = e.params || {},
          o = Wu / e.tileSize / e.scale,
          a = F_(r.filter),
          s = e.queryGeometry,
          l = e.queryPadding * o,
          c = _w(s),
          u = this.grid.query(c.minX - l, c.minY - l, c.maxX + l, c.maxY + l),
          h = _w(e.cameraQueryGeometry),
          d = this.grid3D.query(h.minX - l, h.minY - l, h.maxX + l, h.maxY + l, (t, i, n, r) =>
            (function (e, t, i, n, r) {
              for (const o of e) if (t <= o.x && i <= o.y && n >= o.x && r >= o.y) return !0;
              const o = [new te(t, i), new te(t, r), new te(n, r), new te(n, i)];
              if (e.length > 2) for (const t of o) if (Ry(e, t)) return !0;
              for (let t = 0; t < e.length - 1; t++) if (Ny(e[t], e[t + 1], o)) return !0;
              return !1;
            })(e.cameraQueryGeometry, t - l, i - l, n + l, r + l),
          );
        for (const e of d) u.push(e);
        u.sort(mw);
        const p = {};
        let f;
        for (let l = 0; l < u.length; l++) {
          const c = u[l];
          if (c === f) continue;
          f = c;
          const h = this.featureIndexArray.get(c);
          let d = null;
          this.loadMatchingFeature(
            p,
            h.bucketIndex,
            h.sourceLayerIndex,
            h.featureIndex,
            a,
            r.layers,
            t,
            i,
            (t, i, r) => (
              d || (d = qf(t)),
              i.queryIntersectsFeature(
                s,
                t,
                r,
                d,
                this.z,
                e.transform,
                o,
                i instanceof Qy ? n : e.posMatrix,
              )
            ),
          );
        }
        return p;
      }
      loadMatchingFeature(e, t, i, n, r, o, a, s, l) {
        const c = this.bucketLayerIDs[t];
        if (
          o &&
          !(function (e, t) {
            for (let i = 0; i < e.length; i++) if (t.indexOf(e[i]) >= 0) return !0;
            return !1;
          })(o, c)
        )
          return;
        const u = this.sourceLayerCoder.decode(i),
          h = this.vtLayers[u].feature(n);
        if (!r(new fd(this.tileID.overscaledZ), h)) return;
        const d = this.getId(h, u);
        for (let t = 0; t < c.length; t++) {
          const i = c[t];
          if (o && o.indexOf(i) < 0) continue;
          const r = a[i];
          if (!r) continue;
          let u = {};
          void 0 !== d && s && (u = s.getState(r.sourceLayer || '_geojsonTileLayer', d));
          const p = !l || l(h, r, u);
          if (!p) continue;
          const f = new pw(h, this.z, this.x, this.y);
          (f.layer = r.serialize()), (f.id = d);
          let m = e[i];
          void 0 === m && (m = e[i] = []),
            m.push({ featureIndex: n, feature: f, intersectionZ: p });
        }
      }
      lookupSymbolFeatures(e, t, i, n, r, o) {
        const a = {};
        this.loadVTLayers();
        const s = F_(n);
        for (const n of e) this.loadMatchingFeature(a, t, i, n, s, r, o);
        return a;
      }
      hasLayer(e) {
        for (const t of this.bucketLayerIDs) for (const i of t) if (e === i) return !0;
        return !1;
      }
      getId(e, t) {
        let i = e.id;
        return (
          this.promoteId &&
            ((i =
              e.properties['string' == typeof this.promoteId ? this.promoteId : this.promoteId[t]]),
            'boolean' == typeof i && (i = Number(i))),
          i
        );
      }
    }
    function mw(e, t) {
      return t - e;
    }
    function _w(e) {
      let t = 1 / 0,
        i = 1 / 0,
        n = -1 / 0,
        r = -1 / 0;
      for (const o of e)
        (t = Math.min(t, o.x)),
          (i = Math.min(i, o.y)),
          (n = Math.max(n, o.x)),
          (r = Math.max(r, o.y));
      return { minX: t, minY: i, maxX: n, maxY: r };
    }
    fo('FeatureIndex', fw, { omit: ['rawTileData', 'sourceLayerCoder'] });
    const gw = function (e, t) {
        if (!e) return !1;
        const i = t.imageManager.getPattern(e.from),
          n = t.imageManager.getPattern(e.to);
        return !i || !n;
      },
      yw = function (e) {
        const { material: t, needFixed: i, needCrossfade: n, painter: r } = e,
          o = new fd(r.style.getNearestTileZoom()).getCrossfadeParameters(),
          a = Math.pow(2, t.tile.tileID.overscaledZ),
          s = (t.tile.tileSize * Math.pow(2, r.transform.tileZoom)) / a,
          l = s * (t.tile.tileID.canonical.x + t.tile.tileID.wrap * a),
          c = s * t.tile.tileID.canonical.y;
        if (t._pattern) {
          const e = r.imageManager.getPattern(t._pattern.from),
            i = r.imageManager.getPattern(t._pattern.to);
          t._uniforms.set('u_pattern_tl_a', () => new $e(e.tl)),
            t._uniforms.set('u_pattern_br_a', () => new $e(e.br)),
            t._uniforms.set('u_pattern_tl_b', () => new $e(i.tl)),
            t._uniforms.set('u_pattern_br_b', () => new $e(i.br)),
            t._uniforms.set('u_pattern_size_a', () => new $e(e.displaySize)),
            t._uniforms.set('u_pattern_size_b', () => new $e(i.displaySize)),
            t._uniforms.set('u_body_tex_rend', () => !0);
        }
        if (t._topPattern) {
          const e = r.imageManager.getPattern(t._topPattern.from),
            i = r.imageManager.getPattern(t._topPattern.to);
          t._uniforms.set('u_top_pattern_tl_a', () => new $e(e.tl)),
            t._uniforms.set('u_top_pattern_br_a', () => new $e(e.br)),
            t._uniforms.set('u_top_pattern_tl_b', () => new $e(i.tl)),
            t._uniforms.set('u_top_pattern_br_b', () => new $e(i.br)),
            t._uniforms.set('u_top_pattern_size_a', () => new $e(e.displaySize)),
            t._uniforms.set('u_top_pattern_size_b', () => new $e(i.displaySize)),
            t._uniforms.set('u_top_tex_rend', () => !0);
        }
        t._uniforms.set(
          'u_BaseColorSampler',
          () => (r.imageManager.bind(r.context), r.imageManager.atlasTexture),
        ),
          t._uniforms.set('u_Opacity', () => 1),
          t._uniforms.set('u_texsize', () => {
            const { width: e, height: t } = r.imageManager.getPixelSize();
            return new $e(e, t);
          }),
          n &&
            (t._uniforms.set('u_mix', () => o.t),
            t._uniforms.set('u_scale_a', () => o.fromScale),
            t._uniforms.set('u_scale_b', () => o.toScale)),
          t._uniforms.set('u_Zoom', i ? () => 1 : () => r.style.getNearestTileZoom()),
          t._uniforms.set(
            'u_tile_units_to_pixels',
            () => 1 / Lf(t.tile, 1, r.style.getNearestTileZoom()),
          ),
          t._uniforms.set('u_pixel_coord_upper', () => new $e(l >> 16, c >> 16)),
          t._uniforms.set('u_pixel_coord_lower', () => new $e(65535 & l, 65535 & c)),
          t._uniforms.set('u_zoom_factor', () =>
            Math.pow(2, 13 - Math.floor(r.style.getNearestTileZoom())),
          );
      },
      xw = new om(),
      vw = new $e();
    class ww {
      constructor(e) {
        (this.textures = {}), (this.requests = {}), (this.source = e || { fire() {} });
      }
      addTexture(e, t, i, n, r) {
        if (this.getTexture(e) || this.requests[e])
          n && (n.state = 'loaded'),
            this.source.fire(new _a('data', { dataType: 'gltf-data-loaded' }));
        else {
          if (t)
            this.requests[e] = vu({ url: t }, (t, n) => {
              if (t) throw new ga(t);
              if (n) {
                const t = new Pu({ context: i, image: n, pixelFormat: Ll.RGBA, useMipmap: !0 });
                t.bind(Ll.LINEAR, Ll.CLAMP_TO_EDGE),
                  (this.textures[e] = t),
                  (this.requests[e] = null),
                  delete this.requests[e];
              }
            });
          else {
            const t = new J.Image(),
              o = J.URL || J.webkitURL;
            t.onload = () => {
              const n = new Pu({ context: i, image: t, pixelFormat: Ll.RGBA, useMipmap: !0 });
              n.bind(Ll.LINEAR, Ll.CLAMP_TO_EDGE),
                (this.textures[e] = n),
                (this.requests[e] = null),
                delete this.requests[e];
            };
            const a = e.slice(e.lastIndexOf('_') + 1),
              s = new J.Blob([new Uint8Array(r)], { type: n.result.gltf.images[a].mimeType });
            t.src = r.length ? o.createObjectURL(s) : Me.SOURCE.TRANSPARENT_PNG_URL;
          }
          n.requestImages++;
        }
      }
      getTexture(e) {
        return this.textures[e];
      }
      removeTexture(e) {
        this.textures[e] &&
          (this.requests[e] &&
            (this.requests[e].cancel(), (this.requests[e] = null), delete this.requests[e]),
          this.textures[e].destroy(),
          (this.textures[e] = null),
          delete this.textures[e]);
      }
      getCanvasData(e) {}
      removeAllTexture() {
        for (const e in this.textures) this.removeTexture(e), this.requests[e].cancel();
      }
    }
    const Tw = new Je(),
      bw = new Ge(),
      Sw = new je(),
      Aw = new Pt(0.2875, -0.4979646071760521, 0.9959292143521045),
      Pw = new Pt();
    class Ew extends Wp {
      constructor(e) {
        super(e),
          (this.isVectorMaterial = !1),
          (this.layer = e.layer),
          (this.tile = e.tile),
          (this._programConfiguration = e.programConfiguration),
          (this._renderState = e.renderState),
          (this._pattern = this.layer.paint.get('extrusion-pattern')),
          (this._topPattern = this.layer.paint.get('extrusion-top-pattern')),
          (this.type = this.getProgramType()),
          (this._error = null),
          (this.animationsInfo = e.animationsInfo || {}),
          (this.bloomingParams = this.layer.paint.get('extrusion-self-bloom')
            ? {
                selfBloom: this.layer.paint.get('extrusion-self-bloom'),
                bloomHeight: this.layer.paint.get('extrusion-bloom-height'),
                bloomSpeed: this.layer.paint.get('extrusion-glow-speed'),
                glowPureColorHeight: this.layer.paint.get('extrusion-glow-pure-color-height'),
                glowWidth: this.layer.paint.get('extrusion-glow-width'),
              }
            : null),
          this.#N(),
          Ew.#I(this, e.painter);
      }
      update(e, t, i) {
        super.update(e, t, i),
          this.updateRenderState(i),
          this.updatePattern(e),
          this.updateBlooming(e),
          this.#O(e, t, i);
      }
      getProgramType() {
        return this._pattern || this._topPattern ? 'sphereExtrusionPattern' : 'sphereExtrusion';
      }
      updatePattern(e) {
        const t = this.layer.paint.get('extrusion-pattern'),
          i = this.layer.paint.get('extrusion-top-pattern');
        let n = !1,
          r = !1;
        t &&
          ((n = !this._pattern || t.from !== this._pattern.from || t.to !== this._pattern.to),
          (this._pattern = t)),
          i &&
            ((r =
              !this._topPattern ||
              i.from !== this._topPattern.from ||
              i.to !== this._topPattern.to),
            (this._topPattern = i)),
          (n || r) && (Ew.#D(this, e), (this.type = this.getProgramType()));
      }
      updateBlooming(e) {
        let t = !1,
          i = null;
        this.layer.paint.get('extrusion-self-bloom') &&
          ((i = {
            selfBloom: this.layer.paint.get('extrusion-self-bloom'),
            bloomHeight: this.layer.paint.get('extrusion-bloom-height'),
            bloomSpeed: this.layer.paint.get('extrusion-glow-speed'),
            glowPureColorHeight: this.layer.paint.get('extrusion-glow-pure-color-height'),
            glowWidth: this.layer.paint.get('extrusion-glow-width'),
          }),
          (this.bloomingParams.bloomHeight === i.bloomHeight &&
            this.bloomingParams.bloomSpeed === i.bloomSpeed &&
            this.bloomingParams.glowPureColorHeight === i.glowPureColorHeight &&
            this.bloomingParams.glowWidth === i.glowWidth) ||
            (t = !0)),
          t && ((this.bloomingParams = i), Ew.#F(this, e));
      }
      static logDifferenceUniform() {}
      static tryDiffkeys(e, t) {
        const i = t;
        for (let t = 0; t < i.length; t++) e.pushMinimumUniform(i[t]);
      }
      static #I(e, t) {
        Ew.#z(e, t), Ew.#D(e, t), Ew.#F(e, t);
      }
      static #B(e, t, i) {
        const n = new ww(null),
          r = i.context,
          o = n.getTexture(e.to);
        return o
          ? (r.activeTexture.set(Me.GL_CONST.MODEL_TEXTURE_UNIT1.VALUE),
            o.bind(Ll.LINEAR, Ll.CLAMP_TO_EDGE),
            t._uniforms.set('u_image_top', () => Me.GL_CONST.MODEL_TEXTURE_UNIT1.INDEX),
            t.pushMinimumUniform('u_image_top'),
            !0)
          : (n.addTexture(e.to, e.to, r, { requestImages: 0 }), !1);
      }
      static #D(e, t) {
        e._pattern && gw(e._pattern, t) && (e._error = !0),
          e._topPattern && gw(e._topPattern, t) && (e._error = !0),
          yw({ material: e, needFixed: !1, needCrossfade: !0, painter: t });
      }
      static #z(e, t) {
        mg.setPhongLightUniform({ material: e, phongLightConfig: e.layer.phongLightConfig }),
          e._uniforms.set(
            'u_lightPos',
            () => (
              Pt.clone(Aw, Pw),
              Sw.identity(),
              Sw.rotate(t.transform.hpr.heading, Sw),
              Pw.transformByMatrix3(Sw)
            ),
          ),
          e._uniforms.set('u_Reflectivity', () => 1),
          e._uniforms.set('u_Shininess', () => 30),
          e._uniforms.set('u_Roughness', () => e.layer.paint.get('extrusion-roughness'));
      }
      static #F(e, t) {
        if (e.bloomingParams && e.bloomingParams.selfBloom) {
          if (e.bloomingParams.height <= 0)
            throw new Error('extrusion-bloom-height cannot be less than zero');
          if (e.bloomingParams.speed <= 0)
            throw new Error('extrusion-glow-fps cannot be less than zero');
          e._uniforms.set('u_Time', () => t._map.timer.counter),
            e._uniforms.set('u_BloomHeight', () => e.bloomingParams.bloomHeight),
            e._uniforms.set(
              'u_BloomSpeed',
              () => (1 / e.bloomingParams.bloomSpeed) * e.bloomingParams.bloomHeight,
            ),
            e._uniforms.set('u_SelfBloom', () => e.bloomingParams.selfBloom),
            e._uniforms.set('u_PureColorHeight', () => e.bloomingParams.glowPureColorHeight),
            e._uniforms.set('u_GlowWidth', () => e.bloomingParams.glowWidth);
        }
      }
      #O(e, t, i) {
        const { animationsInfo: n = {} } = i;
        this._uniforms.set('u_ANS_CurrentTime', () => n.currentClipTime),
          this.pushMinimumUniform('u_ANS_CurrentTime'),
          this.layer.clippingPlanes &&
            this.layer.clippingPlanes.enabled &&
            0 !== this.layer.clippingPlanes.length &&
            (this.layer.clippingPlanes.update(e, t),
            this._uniforms.set(
              'u_model_clippingPlanesEdgeStyle',
              () => (
                bw.set(
                  this.layer.clippingPlanes.edgeColor.r,
                  this.layer.clippingPlanes.edgeColor.g,
                  this.layer.clippingPlanes.edgeColor.b,
                  this.layer.clippingPlanes.edgeWidth,
                ),
                bw
              ),
            ),
            this.pushMinimumUniform('u_model_clippingPlanesEdgeStyle'),
            this._uniforms.set('u_model_clippingPlanes', () => this.layer.clippingPlanes.texture),
            this.pushMinimumUniform('u_model_clippingPlanes'),
            this._uniforms.set('u_model_clippingPlanesMatrix', () => {
              const e = Je.multiply(
                Tw,
                t.camera.matrixWorldInverse,
                this.layer.clippingPlanes.modelMatrix,
              );
              return Je.inverseTranspose(e, e), e;
            }),
            this.pushMinimumUniform('u_model_clippingPlanesMatrix'));
      }
      updateRenderState(e) {
        const { renderStateTag: t, stencilTest: i, enableColorMask: n } = e;
        'first' === t
          ? (this.renderState = {
              depthMask: yp.enableDepthMask,
              depthTest: yp.enableDepthTestWithLEQUAL,
              stencilMask: yp.disableStencilMask,
              stencilTest: yp.disableStencilTest,
              colorMask: n ? yp.enableColorMask : yp.disabledColorMask,
            })
          : 'second' === t &&
            (this.renderState = {
              depthMask: yp.enableDepthMask,
              depthTest: yp.enableDepthTestWithLEQUAL,
              stencilMask: yp.enableStencilMask,
              stencilTest: i,
              colorMask: yp.enableColorMask,
              blending: yp.enableBlending,
            });
      }
      #N() {
        const e = {};
        if (
          this.layer.clippingPlanes &&
          this.layer.clippingPlanes.enabled &&
          0 !== this.layer.clippingPlanes.length
        ) {
          e.HAS_CLIPPING_PLANES = !0;
          const t = T_.getTextureResolution(this.layer.clippingPlanes);
          (e.CLIPPING_PLANES_LENGTH = this.layer.clippingPlanes.length),
            (e.CLIPPING_PLANES_TEXTURE_WIDTH = t.x),
            (e.CLIPPING_PLANES_TEXTURE_HEIGHT = t.y),
            (e.UNION_CLIPPING_REGIONS = !!this.layer.clippingPlanes._unionClippingRegions);
        } else (e.HAS_CLIPPING_PLANES = !1), (e.CLIPPING_PLANES_LENGTH = 0), (e.CLIPPING_PLANES_TEXTURE_WIDTH = 1), (e.CLIPPING_PLANES_TEXTURE_HEIGHT = 1);
        this.defines = e;
      }
      destroy() {
        (this.layer = void 0),
          (this.tile = void 0),
          (this.plotter = void 0),
          (this.type = void 0),
          (this._uniforms = void 0),
          (this._textures = void 0),
          (this._program = void 0),
          (this.defines = void 0),
          (this._programConfiguration = void 0),
          (this._renderState = void 0),
          (this._pattern = void 0),
          (this._topPattern = void 0),
          (this.bloomingParams = void 0);
      }
    }
    const Cw = new om();
    class Mw extends Wp {
      constructor(e) {
        super(e),
          (this.isVectorMaterial = !0),
          (this.layer = e.layer),
          (this.tile = e.tile),
          (this.coord = e.tile.tileID),
          (this.pattern = e.pattern),
          (this.programId = e.programId),
          (this._programConfiguration = e.programConfiguration),
          (this._renderState = e.renderState),
          (this._isShadowVolumeMaterial = e.shadowVolumeMaterial || !1);
        const i = e.painter,
          n = this.layer.paint.get('fill-water');
        this._isWater = 'water' === n;
        const r = this.layer.paint.get('fill-water-texture'),
          o = this.layer.paint.get('fill-water-mirror-texture'),
          a = i.textureResourceManager,
          s = i._map;
        (this._texture = 0 !== r.length ? this.getTextureUseUrl(a, { map: s, texUrl: r }) : null),
          (this._mirrorTexture =
            0 !== r.length ? this.getTextureUseUrl(a, { map: s, texUrl: o }) : null),
          (this._isWater = this._isWater && this._texture && this._mirrorTexture);
        const l = this.layer.paint.get('sunlight-color');
        (this._sunlightColor = new Pt(l.r, l.g, l.b)),
          (this._sunlightDirection = new Pt(this.layer.paint.get('sunlight-direction'))),
          (this._waveSize = 1 / this.layer.paint.get('fill-water-wave-size')),
          (this._waveSpeed = this.layer.paint.get('fill-water-speed'));
        const c = this.layer.paint.get('fill-color').value.value,
          u = this.layer.paint.get('sky-color');
        (this._skyColor = new Pt(u.r, u.g, u.b)),
          (this._waterColor = t(c) && t(c.r) ? new Pt(c.r, c.g, c.b) : new Pt(0, 0, 0.5)),
          (this._alpha = this.layer.paint.get('fill-opacity').value.value),
          (this.type = Mw.getProgramTypeAndCreateUniforms(this, i)),
          this._isWater && this.createUniforms(i);
      }
      getTextureUseUrl(e, t) {
        const i = e.getTextureByName(t.texUrl);
        if (i) return i;
        const n = new Pu(t);
        return t.texUrl && n.load(t.texUrl), e.addTexture(t.texUrl, n), n;
      }
      createUniforms(e) {
        this._uniforms.set('u_Color', () => this._waterColor),
          this._uniforms.set('u_SkyColor', () => this._skyColor),
          this._uniforms.set('u_Opacity', () => this._alpha),
          this._uniforms.set(
            'u_MirrorSampler',
            () => (
              (this._mirrorTexture.sampler = {
                minificationFilter: Ll.LINEAR,
                magnificationFilter: Ll.LINEAR,
                wrapS: Ll.CLAMP_TO_EDGE,
                wrapT: Ll.CLAMP_TO_EDGE,
              }),
              this._mirrorTexture
            ),
          ),
          this._uniforms.set(
            'u_Time',
            () => ((this._time = e._map.time * this._waveSpeed), this._time),
          ),
          this._uniforms.set(
            'u_BaseColorSampler',
            () => (
              (this._texture.sampler = {
                minificationFilter: Ll.LINEAR_MIPMAP_LINEAR,
                magnificationFilter: Ll.LINEAR,
                wrapS: Ll.REPEAT,
                wrapT: Ll.REPEAT,
              }),
              this._texture
            ),
          ),
          this.pushMinimumUniform('u_BaseColorSampler'),
          this._uniforms.set('u_DistortionScale', () => 3.7),
          this._uniforms.set('u_SunColor', () => this._sunlightColor),
          this._uniforms.set('u_SunDirection', () => this._sunlightDirection),
          this._uniforms.set('u_IsWater', () => this._isWater),
          this._uniforms.set('u_WaveSize', () => this._waveSize);
      }
      update(e, t, i = {}) {
        super.update(e, t, i);
        const n = e.tileClippingMask.getMaskIDByCoord(this.coord);
        !this._isShadowVolumeMaterial &&
          e.tileClippingMask.status &&
          ((this._renderState.stencilTest = Se(e.tileClippingMask.useMaskRs.stencilTest)),
          (this._renderState.stencilTest.reference = n));
      }
      destroy() {
        (this.layer = void 0),
          (this.tile = void 0),
          (this.coord = void 0),
          (this.pattern = void 0),
          (this.programId = void 0),
          (this.type = void 0),
          (this._uniforms = void 0),
          (this._textures = void 0),
          (this._program = void 0),
          (this._programConfiguration = void 0),
          (this._renderState = void 0);
      }
      static #D(e, t) {
        gw(e._pattern, t) && (e._error = !0), yw({ material: e, needFixed: !1, needCrossfade: !0 });
      }
      static getProgramTypeAndCreateUniforms(e, t) {
        if (e._isWater) return 'WaterMaterial';
        let i = e.programId;
        if (e.pattern) {
          i = `${e.programId}Pattern`;
          const n = new fd(t.style.getNearestTileZoom()).getCrossfadeParameters(),
            r = t.imageManager.getPattern(e.pattern.from),
            o = t.imageManager.getPattern(e.pattern.to),
            a = Math.pow(2, e.tile.tileID.overscaledZ),
            s = (e.tile.tileSize * Math.pow(2, t.transform.tileZoom)) / a,
            l = s * (e.tile.tileID.canonical.x + e.tile.tileID.wrap * a),
            c = s * e.tile.tileID.canonical.y;
          e._uniforms.set(
            'u_BaseColorSampler',
            () => (t.imageManager.bind(t.context), t.imageManager.atlasTexture),
          ),
            e._uniforms.set('u_Opacity', () => e._alpha),
            e._uniforms.set('u_pattern_tl_a', () => new $e(r.tl)),
            e._uniforms.set('u_pattern_br_a', () => new $e(r.br)),
            e._uniforms.set('u_pattern_tl_b', () => new $e(o.tl)),
            e._uniforms.set('u_pattern_br_b', () => new $e(o.br)),
            e._uniforms.set('u_texsize', () => {
              const { width: e, height: i } = t.imageManager.getPixelSize();
              return new $e(e, i);
            }),
            e._uniforms.set('u_mix', () => n.t),
            e._uniforms.set('u_pattern_size_a', () => new $e(r.displaySize)),
            e._uniforms.set('u_pattern_size_b', () => new $e(o.displaySize)),
            e._uniforms.set('u_scale_a', () => n.fromScale),
            e._uniforms.set('u_scale_b', () => n.toScale),
            e._uniforms.set('u_Zoom', () => t.style.getNearestTileZoom()),
            e._uniforms.set('u_zoom_factor', () =>
              Math.pow(2, 13 - Math.floor(t.style.getNearestTileZoom())),
            ),
            e._uniforms.set(
              'u_tile_units_to_pixels',
              () => 1 / Lf(e.tile, 1, t.style.getNearestTileZoom()),
            ),
            e._uniforms.set('u_pixel_coord_upper', () => new $e(l >> 16, c >> 16)),
            e._uniforms.set('u_pixel_coord_lower', () => new $e(65535 & l, 65535 & c));
        }
        return (
          e._uniforms.set(
            'u_PixelMatrix',
            () => (
              Cw.identity(),
              Cw.scale([1, Math.cos(t.transform.hpr.pitch)]),
              Cw.rotate(-t.transform.hpr.heading),
              Cw
            ),
          ),
          i
        );
      }
    }
    const Iw = new Pt(0.0625, 0.5, 1),
      Lw = new om(),
      Rw = new $e(),
      Nw = new $e();
    class Ow extends Wp {
      constructor(e) {
        super(e),
          (this.isVectorMaterial = !0),
          (this.type = e.type),
          (this.layer = e.layer),
          (this.tile = e.tile),
          (this._renderState = e.renderState),
          (this._defines = e.defines),
          (this._programConfiguration = e.programConfiguration),
          (this.hasPattern = e.hasPattern),
          this.#I(e.painter);
      }
      update(e, t, i = {}) {
        const n = this.layer.paint.get('sprite-pattern');
        let r = !1;
        n.isConstant() || (r = !0),
          n.constantOr(null) && (r = !0),
          Ow.updateLayerProperty(this.layer, r),
          super.update(e, t, i);
      }
      #I(e) {
        this._uniforms.set(
          'u_PixelMatrix',
          () => (
            Lw.identity(),
            Lw.scale([1, Math.cos(e.transform.hpr.pitch)]),
            Lw.rotate(-e.transform.hpr.heading),
            Lw
          ),
        ),
          this._uniforms.set('u_Ratio', () => 1 / Lf(this.tile, 1, e.style.getNearestTileZoom())),
          this.pushMinimumUniform('u_Ratio'),
          this._uniforms.set(
            'u_GlUnitsToPixels',
            () => (Rw.set(e.transform.width / 2, -e.transform.height / 2), Rw),
          ),
          this._uniforms.set('u_count', () => this.layer.count),
          this.pushMinimumUniform('u_count'),
          this._uniforms.set(
            'u_BaseColorSampler',
            () => (
              this.tile.imageAtlasTexture.bind(Ll.LINEAR, Ll.CLAMP_TO_EDGE),
              this.tile.imageAtlasTexture
            ),
          ),
          this.pushMinimumUniform('u_BaseColorSampler'),
          this._uniforms.set(
            'u_texsize',
            () => (
              Nw.set(this.tile.imageAtlasTexture.size[0], this.tile.imageAtlasTexture.size[1]), Nw
            ),
          ),
          this._uniforms.set('u_scale', () => Iw);
      }
      destroy() {
        super.destroy(),
          (this.layer = void 0),
          (this.tile = void 0),
          (this._programConfiguration = void 0);
      }
      static updateLayerProperty(e, t) {
        e.hasOwnProperty('count') || (e.count = 0), e.timestamp || (e.timestamp = Date.now());
        const i = Date.now(),
          n = i - e.timestamp;
        let r = 0;
        (r = t ? n / 1e3 : (n / 1e3) * 60), (e.timestamp = i), (e.count += r);
      }
    }
    const Dw = new $e(),
      Fw = new om(),
      zw = new $e(),
      Bw = new $e(),
      Vw = new $e(),
      Uw = new $e(),
      kw = new $e(),
      Gw = new $e();
    class Hw {
      constructor() {}
      clone(e) {
        return (
          (e.uBuffer = this.uBuffer),
          (e.vBuffer = this.vBuffer),
          (e.heightBuffer = this.heightBuffer),
          (e.normalBuffer = this.normalBuffer),
          (e.index = this.index),
          (e.first = this.first),
          (e.second = this.second),
          (e.ratio = this.ratio),
          e
        );
      }
      initializeIndexed(e, t, i, n, r) {
        (this.uBuffer = e),
          (this.vBuffer = t),
          (this.heightBuffer = i),
          (this.normalBuffer = n),
          (this.index = r),
          (this.first = void 0),
          (this.second = void 0),
          (this.ratio = void 0);
      }
      initializeFromClipResult(e, t, i) {
        let n = t + 1;
        return (
          -1 !== e[t]
            ? i[e[t]].clone(this)
            : ((this.vertexBuffer = void 0),
              (this.index = void 0),
              (this.first = i[e[n]]),
              ++n,
              (this.second = i[e[n]]),
              ++n,
              (this.ratio = e[n]),
              ++n),
          n
        );
      }
      getKey() {
        return this.isIndexed()
          ? `${this.index || 0}`
          : JSON.stringify({
              first: this.first ? this.first.getKey() : '',
              second: this.second ? this.second.getKey() : '',
              ratio: this.ratio || 0,
            });
      }
      isIndexed() {
        return null != this.index;
      }
      getH() {
        return null != this.index
          ? this.heightBuffer[this.index]
          : this.first && this.second
          ? Ws(this.first.getH(), this.second.getH(), this.ratio || 0)
          : 0;
      }
      getU() {
        return null != this.index
          ? this.uBuffer[this.index]
          : this.first && this.second
          ? Ws(this.first.getU(), this.second.getU(), this.ratio || 0)
          : 0;
      }
      getV() {
        return null != this.index
          ? this.vBuffer[this.index]
          : this.first && this.second
          ? Ws(this.first.getV(), this.second.getV(), this.ratio || 0)
          : 0;
      }
    }
    function Yw(e, t) {
      let i;
      i = t ? `a_${e.property}` : `v_${e.property}`;
      let n = '    vec4 color;\n';
      if ('interval' === e.type) {
        let t = new ai(0, 0, 0, 1);
        if ((e.default && (t = ai.parse(e.default)), e.stops)) {
          const r = e.stops.length;
          for (let o = 0; o < r; o += 1) {
            const r = e.stops[o];
            0 === o
              ? ((n += `    if (${i} <= float(${r[0]})) \n`),
                (n += `        { color = vec4(${t.r}, ${t.g}, ${t.b}, ${t.a}); }\n`),
                (t = ai.parse(r[1])))
              : (r[0] <= e.stops[o - 1][0] &&
                  console.error(
                    'Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.',
                  ),
                (n += `    else if (${i} <= float(${r[0]})) \n`),
                (n += `        { color = vec4(${t.r}, ${t.g}, ${t.b}, ${t.a}); }\n`),
                (t = ai.parse(r[1])));
          }
          n += `    else { color = vec4(${t.r}, ${t.g}, ${t.b}, ${t.a}); }\n`;
        } else n += `    color = vec4(${t.r}, ${t.g}, ${t.b}, ${t.a});\n`;
      } else if ('categorical' === e.type) {
        let t = new ai(0, 0, 0, 1);
        if ((e.default && (t = ai.parse(e.default)), e.stops)) {
          let r;
          const o = e.stops.length;
          for (let t = 0; t < o; t += 1) {
            const o = e.stops[t];
            0 === t
              ? ((r = ai.parse(o[1])),
                (n += `    if (${i} == float(${o[0]})) \n`),
                (n += `        { color = vec4(${r.r}, ${r.g}, ${r.b}, ${r.a}); }\n`))
              : (o[0] <= e.stops[t - 1][0] &&
                  console.error(
                    'Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.',
                  ),
                (r = ai.parse(o[1])),
                (n += `    else if (${i} == float(${o[0]})) \n`),
                (n += `        { color = vec4(${r.r}, ${r.g}, ${r.b}, ${r.a}); }\n`));
          }
          n += `    else { color = vec4(${t.r}, ${t.g}, ${t.b}, ${t.a}); }\n`;
        } else n += `    color = vec4(${t.r}, ${t.g}, ${t.b}, ${t.a});\n`;
      } else if ('exponential' === e.type) {
        let t = new ai(0, 0, 0, 1),
          r = 1;
        if ((e.default && (t = ai.parse(e.default)), e.base && (r = e.base), e.stops)) {
          const o = e.stops.length;
          for (let a = 0; a < o; a += 1) {
            const o = e.stops[a];
            if (0 === a)
              (n += `    if (${i} <= float(${o[0]})) \n`),
                (n += `        { color = vec4(${t.r}, ${t.g}, ${t.b}, ${t.a}); }\n`);
            else {
              const s = e.stops[a - 1];
              o[0] <= s[0] &&
                console.error(
                  'Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.',
                );
              const l = ai.parse(s[1]),
                c = ai.parse(o[1]);
              (n += `    else if (${i} <= float(${o[0]})) \n`),
                (n += '        { color = getExponentialInterpColor( \n'),
                (n += `            ${i}, \n`),
                (n += `            float(${r}), \n`),
                (n += `            float(${s[0]}), \n`),
                (n += `            float(${o[0]}), \n`),
                (n += `            vec4(${l.r}, ${l.g}, ${l.b}, ${l.a}), \n`),
                (n += `            vec4(${c.r}, ${c.g}, ${c.b}, ${c.a})); \n`),
                (n += '        }\n'),
                (t = c);
            }
          }
          n += `    else { color = vec4(${t.r}, ${t.g}, ${t.b}, ${t.a}); }\n`;
        } else n += `    color = vec4(${t.r}, ${t.g}, ${t.b}, ${t.a});\n`;
      } else console.error(`Unknown interpolation type ${e.type}`);
      return n;
    }
    class qw {
      constructor(e) {
        (this.uid = (1e3 * Math.random()).toFixed(0)),
          (this.options = e || {}),
          (this.maxParallelRequests = e.maxParallelRequests || 6),
          (this.status = 'preparing'),
          (this.requestingCount = 0),
          (this.ids = []),
          (this.requests = {});
      }
      setMaxParallelRequests(e) {
        this.maxParallelRequests = e;
      }
      run() {
        this.status = 'running';
        let e = this.maxParallelRequests - this.requestingCount;
        e <= 0 && (e = 1);
        for (let t = 0; t < e; t++) this.releaseRequest();
      }
      pauseRequest() {
        this.status = 'pausing';
      }
      restart() {
        this.run();
      }
      checkStatus() {
        0 === this.ids.length && (this.status = 'stopped');
      }
      _nextRequest(e) {
        this.removeRequestById(e),
          this.requestingCount--,
          'pausing' !== this.status && (this.checkStatus(), this.releaseRequest());
      }
      pushRequest(e) {
        return (
          !this.hasRequest(e.id) &&
          (this.ids.push(e.id),
          (this.requests[e.id] = {
            req: null,
            send: !1,
            param: e.param,
            cb: (t, i, n, r, o) => {
              this.requests[e.id] && (e.cb(t, i, n, r, o), this._nextRequest(e.id));
            },
          }),
          !0)
        );
      }
      pushRequests(e) {
        for (let t = 0; t < e.length; t++) this.pushRequest(e[t]);
      }
      releaseRequest() {
        for (let e = 0; e < this.ids.length; e++)
          if (!this.requests[this.ids[e]].send && !this.requests[this.ids[e]].req) {
            this.releaseRequestById(this.ids[e]), this.requestingCount++;
            break;
          }
      }
      releaseRequestById(e) {
        const t = this.requests[e];
        this.requests[e].send ||
          this.requests[e].req ||
          ((t.req = fu(t.param, t.cb)), (t.send = !0));
      }
      releaseRequestByIds(e) {
        for (let t = 0; t < e.length; t++) this.releaseRequestById(e[t]);
      }
      hasRequest(e) {
        return -1 !== this.ids.indexOf(e);
      }
      removeRequestById(e) {
        if (this.hasRequest(e)) {
          const t = this.ids.indexOf(e);
          this.ids.splice(t, 1), this.cancelRequestById(e), delete this.requests[e];
        }
      }
      removeRequests(e) {
        for (let t = 0; t < e.length; t++) this.removeRequestById(e[t]);
      }
      removeAllRequest() {
        for (; this.ids.length > 0; ) this.removeRequestById(this.ids[0]);
      }
      cancelRequestById(e) {
        const t = this.requests[e];
        t.send && t.req && t.req.cancel(), (t.req = null), (t.send = !1);
      }
      cancelRequests(e) {
        for (let t = 0; t < e.length; t++) this.cancelRequestById(e[t]);
      }
      cancelAllRequest() {
        for (let e = 0; e < this.ids.length; e++) this.cancelRequestById(this.ids[e]);
      }
      destroy() {
        this.removeAllRequest(), (this.ids = []), (this.requests = {});
      }
    }
    class Xw extends qw {
      constructor(e) {
        super(e);
      }
      pushRequest(e) {
        return (
          !this.hasRequest(e.id) &&
          (this.ids.push(e.id),
          (this.requests[e.id] = {
            req: null,
            send: !1,
            param: e.param,
            out: {},
            cb: (t, i, n, r) => {
              this.done('image', { err: t, data: i, cacheControl: n, expires: r }, e);
            },
          }),
          !0)
        );
      }
      done(e, { err: t, data: i }, n) {
        const r = this.requests[n.id];
        r &&
          (t && (r.out.err = t),
          (r.out.img =
            i && !this._checkBase64(i)
              ? new J.Blob([new Uint8Array(i)], { type: 'image/png' })
              : null),
          n.cb(r.out.err, r.out),
          this._nextRequest(n.id));
      }
      releaseRequestById(e) {
        const t = this.requests[e];
        this.requests[e].send ||
          this.requests[e].req ||
          ((t.req = fu(t.param, t.cb)),
          t.requestTerrainFlag && (t.terrainRequest = fu(t.terrainParam, t.cb1)),
          (t.send = !0));
      }
      cancelRequestById(e) {
        const t = this.requests[e];
        t.send &&
          t.req &&
          t.req.cancel &&
          (t.req.cancel(), t.requestTerrainFlag && t.terrainRequest && t.terrainRequest.cancel()),
          (t.req = null),
          (t.terrainRequest = null),
          (t.send = !1);
      }
      _checkBase64(e) {
        if (e.byteLength > 200) return !1;
        const t = new Uint8Array(e);
        let i = '';
        for (let e = 0; e < t.length; e++) i += String.fromCharCode(t[e]);
        return -1 !== i.indexOf('data:image') || -1 !== i.indexOf('base64');
      }
    }
    class jw extends qw {
      constructor(e) {
        super(e);
      }
      pushRequest(e) {
        return (
          !this.hasRequest(e.id) &&
          (this.ids.push(e.id),
          (this.requests[e.id] = {
            req: null,
            send: !1,
            param: e.param,
            data: null,
            cb: (t, i, n, r) => {
              this.done('terrain', { err: t, data: i, cacheControl: n, expires: r }, e);
            },
          }),
          !0)
        );
      }
      done(e, { err: t, data: i, cacheControl: n, expires: r }, o) {
        const a = this.requests[o.id];
        a &&
          (t && (a.err = t),
          (a.data = { data: i, cacheControl: n, expires: r }),
          o.cb(a.err, a.data),
          this._nextRequest(o.id));
      }
      releaseRequestById(e) {
        const t = this.requests[e];
        this.requests[e].send ||
          this.requests[e].req ||
          ((t.req = fu(t.param, t.cb)), (t.send = !0));
      }
      cancelRequestById(e) {
        const t = this.requests[e];
        t.send && t.req && t.req.cancel && t.req.cancel(), (t.req = null), (t.send = !1);
      }
    }
    (e.ARCTYPE = Kh),
      (e.Actor = class {
        constructor(e, t, i) {
          (this.target = e),
            (this.parent = t),
            (this.mapId = i),
            (this.callbacks = {}),
            (this.callbackID = 0),
            fe(['receive'], this),
            this.target.addEventListener('message', this.receive, !1);
        }
        send(e, t, i, n) {
          const r = i ? `${this.mapId}:${this.callbackID++}` : null;
          i && (this.callbacks[r] = i);
          const o = [];
          if (
            (this.target.postMessage(
              { targetMapId: n, sourceMapId: this.mapId, type: e, id: String(r), data: go(t, o) },
              o,
            ),
            i)
          )
            return {
              cancel: () =>
                this.target.postMessage({
                  targetMapId: n,
                  sourceMapId: this.mapId,
                  type: '<cancel>',
                  id: String(r),
                }),
            };
        }
        receive(e) {
          const t = e.data,
            i = t.id;
          let n;
          if (t.targetMapId && this.mapId !== t.targetMapId) return;
          const r = (e, t) => {
            delete this.callbacks[i];
            const n = [];
            this.target.postMessage(
              t && t.img && t.img.data && 0 === t.img.data.byteLength
                ? {
                    sourceMapId: this.mapId,
                    type: '<response>',
                    id: String(i),
                    error: go({ message: '图片为空' }),
                    data: null,
                  }
                : {
                    sourceMapId: this.mapId,
                    type: '<response>',
                    id: String(i),
                    error: e ? go(e) : null,
                    data: go(t, n),
                  },
              n,
            );
          };
          if ('<response>' === t.type || '<cancel>' === t.type)
            (n = this.callbacks[t.id]),
              delete this.callbacks[t.id],
              n && t.error ? n(yo(t.error)) : n && n(null, yo(t.data));
          else if (void 0 !== t.id && this.parent[t.type]) {
            this.callbacks[t.id] = null;
            const e = yo(t.data);
            'reloadTile' === t.type && (e.projection = this.parent.projection);
            const i = this.parent[t.type](t.sourceMapId, e, r);
            i && null === this.callbacks[t.id] && (this.callbacks[t.id] = i);
          } else if (void 0 !== t.id && this.parent.getWorkerSource) {
            const e = t.type.split('.'),
              i = yo(t.data);
            this.parent.getWorkerSource(t.sourceMapId, e[0], i.source)[e[1]](i, r);
          } else this.parent[t.type](yo(t.data));
        }
        remove() {
          this.target.removeEventListener('message', this.receive, !1);
        }
      }),
      (e.AlphaImage = fx),
      (e.Anchor = em),
      (e.AnimationPropertyCollection = ju),
      (e.ArcType = Zh),
      (e.AxisAlignedBoundingBox = wc),
      (e.BoundingRectangle = $h),
      (e.BoundingSphere = gc),
      (e.CONSTS = Me),
      (e.Camera = class extends Ta {
        constructor() {
          super(),
            (this.type = 'Camera'),
            (this.isCamera = !0),
            (this.matrixWorldInverse = new Je()),
            (this.matrixWorld = new Je()),
            (this.projectionMatrix = new Je()),
            (this.projectionMatrixInverse = new Je()),
            (this.frustumCrate = null);
        }
        getWorldDirection(e) {
          void 0 === e && (console.warn('MineMap需要有目标target'), (e = new Pt())),
            this.updateMatrixWorld(!0);
          const t = this.matrixWorld.elements;
          return e.set(-t[8], -t[9], -t[10]).normalize();
        }
        updateMatrixWorld(e) {
          super.updateMatrixWorld(e), (this.matrixWorldInverse = this.matrixWorld.clone().invert());
        }
        getVPMatrix() {
          return (
            (this.unmodified && this._vpMatrix) || this.updateMatrixWorld(!0),
            (this._tmpProjectionMatrix &&
              this._tmpMatrixWorldInverse &&
              Je.equalsArray(this.projectionMatrix, this._tmpProjectionMatrix) &&
              Je.equalsArray(this.matrixWorldInverse, this._tmpMatrixWorldInverse)) ||
              ((this._vpMatrix = this.projectionMatrix
                .clone()
                .multiplyRight(this.matrixWorldInverse)),
              (this._tmpProjectionMatrix = this.projectionMatrix.clone()),
              (this._tmpMatrixWorldInverse = this.matrixWorldInverse.clone())),
            this._vpMatrix.clone()
          );
        }
        getViewMatrix() {
          return this.updateMatrixWorld(!0), this.matrixWorldInverse.clone();
        }
        getProjectionMatrix() {
          return this.projectionMatrix.clone();
        }
        setMatrix(e) {
          super.setMatrix(e),
            this.updateMatrixWorld(!0),
            this.updateCullingVolume(),
            (this.unmodified = !1);
        }
        updateCullingVolume() {
          if (!this.frustumCrate) throw new Error({ info: '当前没有正确初始化视锥体盒子对象！' });
          const e = this.position,
            t = new Pt(0, 0, -1).transform(this.matrixWorld),
            i = new Pt(0, 1, 0).transform(this.matrixWorld);
          this.frustumCrate.updateCullingVolume(e, t, i);
        }
        getPickRay(e, i, n) {
          if (!t(e)) throw new Wa('windowPosition is required.');
          t(n) || (n = new Ja());
          const r = this.frustumCrate.frustum;
          return t(r.aspectRatio) && t(r.fov) && t(r.near)
            ? this.#V(this, i, e, n)
            : this.#U(this, i, e, n);
        }
        #V(e, t, i, n) {
          const r = t.clientWidth,
            o = t.clientHeight,
            a = Math.tan(0.5 * e.frustumCrate.frustum.fovy),
            s = e.frustumCrate.frustum.aspectRatio * a,
            l = e.frustumCrate.frustum.near,
            c = (2 / r) * i.x - 1,
            u = (2 / o) * (o - i.y) - 1,
            h = e.position;
          n.origin = h;
          const d = Pt.multiplyByScalar(e.direction, l, es);
          Pt.add(h, d, d);
          const p = Pt.multiplyByScalar(e.right, c * l * s, ts),
            f = Pt.multiplyByScalar(e.up, u * l * a, is),
            m = Pt.add(d, p, n.direction);
          return Pt.add(m, f, m), Pt.subtract(m, h, m), Pt.normalize(m, m), n;
        }
        #U(e, i, n) {
          let r = e.frustum;
          return t(r._offCenterFrustum) && (r = r._offCenterFrustum), n;
        }
      }),
      (e.CanonicalTileID = wd),
      (e.Cartographic = as),
      (e.ClassificationType = n_),
      (e.ClippingPlane = a_),
      (e.ClippingPlaneCollection = T_),
      (e.CollisionBoxArray = oa),
      (e.Color = ai),
      (e.CompressedTextureUtil = Wc),
      (e.ContextLimits = Uc),
      (e.Coordinate = ee),
      (e.CullingVolume = Ra),
      (e.DefaultUp = Sa),
      (e.DepthMaterial = rf),
      (e.DepthPass = lf),
      (e.DeveloperError = Wa),
      (e.DictionaryCoder = dw),
      (e.EXTENT = Wu),
      (e.Ellipsoid = wt),
      (e.EncodedVector3 = ih),
      (e.ErrorEvent = ga),
      (e.Euler = It),
      (e.EvaluationParameters = fd),
      (e.Event = _a),
      (e.Evented = ya),
      (e.Feature = pw),
      (e.FeatureIndex = fw),
      (e.Formatted = Vi),
      (e.Framebuffer = Jp),
      (e.GLYPH_PBF_BORDER = hw),
      (e.GeographicProjection = Rl),
      (e.Geometry = ah),
      (e.GltfTile = kp),
      (e.HeadingPitchRoll = Le),
      (e.INTERSECTION = Aa),
      (e.ImageAtlas = Bv),
      (e.ImagePosition = zv),
      (e.Interpolate = kn),
      (e.IntersectionTests = ds),
      (e.JulianDate = Tl),
      (e.LAYER_LAYOUT_CONSTS = Ie),
      (e.LightingModelType = b_),
      (e.LngLat = Nt),
      (e.LngLatBounds = Lt),
      (e.Material = Wp),
      (e.MathArray = h),
      (e.Matrix = Fe),
      (e.Matrix2 = om),
      (e.Matrix3 = je),
      (e.Matrix4 = Je),
      (e.ModelInstance = qu),
      (e.ModelInstanceCollection = Xu),
      (e.Node = Bp),
      (e.NormalMaterial = hf),
      (e.Object3D = Ta),
      (e.OrientedBoundingBox = Dc),
      (e.OrthographicFrustum = Xa),
      (e.OverscaledTileID = bd),
      (e.Pass = nf),
      (e.PerspectiveOffCenterFrustum = Ba),
      (e.PhongLightSetter = mg),
      (e.PickColorMaterial = uf),
      (e.PixelDatatype = Zc),
      (e.PixelFormat = Qc),
      (e.Plane = Ca),
      (e.PolygonGeometry = Jh),
      (e.PolygonGeometryLibrary = Qh),
      (e.PolygonPipeline = zh),
      (e.PolylineGeometry = If),
      (e.PolylineMaterial = cf),
      (e.PolylinePipeline = ff),
      (e.Primitive = o_),
      (e.ProgramConfiguration = lp),
      (e.ProjectionProxy = Bt),
      (e.ProjectionType = Ot),
      (e.Quaternion = Et),
      (e.RGBAImage = mx),
      (e.Ray = Ja),
      (e.Rectangle = Nl),
      (e.RenderPassConsts = pp),
      (e.RenderState = _p),
      (e.RenderbufferFormat = Zp),
      (e.RequestPerformanceManger = class {
        constructor(e) {
          (this.options = e || {}),
            (this.imageCacheRequests = {}),
            (this.vectorCacheRequests = {}),
            (this.terrainCacheRequests = {});
        }
        getTerrainRequesterById(e) {
          return (
            this.terrainCacheRequests[e] ||
              (this.terrainCacheRequests[e] = new jw({ id: e, maxParallelRequests: 1 })),
            this.terrainCacheRequests[e]
          );
        }
        getImageRequesterById(e) {
          return (
            this.imageCacheRequests[e] ||
              (this.imageCacheRequests[e] = new Xw({ id: e, maxParallelRequests: 1 })),
            this.imageCacheRequests[e]
          );
        }
        getVectorRequesterById(e) {
          return (
            this.vectorCacheRequests[e] ||
              (this.vectorCacheRequests[e] = new qw({ id: e, maxParallelRequests: 1 })),
            this.vectorCacheRequests[e]
          );
        }
        pauseVectorRequest() {
          for (const e in this.vectorCacheRequests) this.vectorCacheRequests[e].pauseRequest();
        }
        restartVectorRequest() {
          for (const e in this.vectorCacheRequests) this.vectorCacheRequests[e].restart();
        }
        removeTerrainRequesterById(e) {
          this.terrainCacheRequests[e] &&
            (this.terrainCacheRequests[e].destroy(), delete this.terrainCacheRequests[e]);
        }
        removeImageRequesterById(e) {
          this.imageCacheRequests[e] &&
            (this.imageCacheRequests[e].destroy(), delete this.imageCacheRequests[e]);
        }
        removeVectorRequesterById(e) {
          this.vectorCacheRequests[e] &&
            (this.vectorCacheRequests[e].destroy(), delete this.vectorCacheRequests[e]);
        }
        removeAll() {
          for (const e in this.terrainCacheRequests) this.removeTerrainRequesterById(e);
          for (const e in this.imageCacheRequests) this.removeImageRequesterById(e);
          for (const e in this.vectorCacheRequests) this.removeVectorRequesterById(e);
        }
        destroy() {
          this.removeAll(),
            (this.imageCacheRequests = null),
            (this.vectorCacheRequests = null),
            (this.terrainCacheRequests = null);
        }
      }),
      (e.ResourceType = uu),
      (e.SHADER_BACKGROUND_COLOR = 'sphereBackground'),
      (e.SHADER_BACKGROUND_PATTERN = 'sphereBackgroundPattern'),
      (e.SHADER_CIRCLE = 'sphereCircle'),
      (e.SHADER_FILL_COLOR = 'sphereFill'),
      (e.SHADER_FILL_OUTLINE_COLOR = 'sphereFillOutline'),
      (e.SHADER_HEATMAP_COLOR = 'sphereHeatmap'),
      (e.SHADER_HISTOGRAM_COLOR = 'sphereHistogram'),
      (e.SHADER_LINE_COLOR = 'sphereLine'),
      (e.SHADER_LINE_GRADIENT = 'sphereLineGradient'),
      (e.SHADER_LINE_PATTERN = 'sphereLinePattern'),
      (e.SHADER_LINE_SDF = 'sphereLineSDF'),
      (e.SHADER_LINE_SPRITE_COLOR = 'sphereSprite'),
      (e.SHADER_LINE_SPRITE_PATTERN = 'sphereSpritePattern'),
      (e.SHADER_LINE_TRACKING_COLOR = 'sphereTracking'),
      (e.SHADER_RASTER = 'sphereRaster'),
      (e.SHADER_SYMBOL_ICON = 'sphereSymbolIcon'),
      (e.SHADER_SYMBOL_SDF = 'sphereSymbolSDF'),
      (e.SHADER_SYMTRACKING_ICON = 'sphereSymtrackingIcon'),
      (e.SHADER_SYMTRACKING_SDF = 'sphereSymtrackingSDF'),
      (e.Sampler = jc),
      (e.SegmentVector = Yh),
      (e.ShaderSource = Fp),
      (e.ShadowsType = Hp),
      (e.SharedTexture = ww),
      (e.SpriteMaterial = Ow),
      (e.StandardMaterial = _g),
      (e.StructArrayLayout11f44 = Co),
      (e.StructArrayLayout21f84 = So),
      (e.StructArrayLayout2ui4 = ia),
      (e.StructArrayLayout3f12 = Go),
      (e.StructArrayLayout3f2f3f32 = bo),
      (e.StructArrayLayout3f3f24 = Mo),
      (e.StructArrayLayout3ui6 = ea),
      (e.StructArrayLayout3ul12 = ta),
      (e.StructArrayLayout4f16 = na),
      (e.StructArrayLayout4i8 = vo),
      (e.StructArrayLayout5f20 = wo),
      (e.SymbolBucket = dm),
      (e.SymbolMaterial = t_),
      (e.TerrainTileParser = class {
        constructor() {
          (this.maxShort = 32767), (this.halfMaxShort = (this.maxShort / 2) | 0);
        }
        getCenterLngLat(e, t, i, n) {
          const r = zt(n),
            o = Math.pow(2, i + 1);
          return r.tileNumberToLngLat([2 * e + 1, 2 * t + 1], 1, o);
        }
        createTerrain(e, t, i, n, r) {
          if (!e || 0 === e.byteLength) return;
          e.buffer && (e = e.buffer);
          const o = zt(r),
            a = Math.pow(2, n),
            s = o.tileNumberToLngLat([t, i], 1, a),
            l = o.tileNumberToLngLat([t + 1, i + 1], 1, a),
            c = Math.abs(l.lng - s.lng),
            u = this.getCenterLngLat(t, i, n, r);
          let h = new wo();
          const d = new ea(),
            p = new ia();
          let f = 0;
          const m = 3 * Float64Array.BYTES_PER_ELEMENT,
            _ = 4 * Float64Array.BYTES_PER_ELEMENT,
            g = 3 * Uint16Array.BYTES_PER_ELEMENT;
          let y = Uint16Array.BYTES_PER_ELEMENT,
            x = 3 * y;
          const v = new DataView(e);
          f += m;
          const w = v.getFloat32(f, !0);
          f += Float32Array.BYTES_PER_ELEMENT;
          const T = v.getFloat32(f, !0);
          f += Float32Array.BYTES_PER_ELEMENT;
          const b = Il.cartographicToCartesian3(new Pt([u.lng, u.lat, w])),
            S = {
              vertex: [
                Il.cartographicToCartesian3(new Pt([s.lng, s.lat, w])),
                Il.cartographicToCartesian3(new Pt([l.lng, s.lat, w])),
                Il.cartographicToCartesian3(new Pt([l.lng, l.lat, w])),
                Il.cartographicToCartesian3(new Pt([s.lng, l.lat, w])),
                Il.cartographicToCartesian3(new Pt([s.lng, s.lat, T])),
                Il.cartographicToCartesian3(new Pt([l.lng, s.lat, T])),
                Il.cartographicToCartesian3(new Pt([l.lng, l.lat, T])),
                Il.cartographicToCartesian3(new Pt([s.lng, l.lat, T])),
              ],
              indices: [
                0, 3, 2, 0, 2, 1, 4, 7, 6, 4, 6, 5, 0, 4, 7, 0, 7, 3, 1, 5, 6, 1, 6, 2, 0, 5, 4, 0,
                1, 5, 3, 6, 2, 3, 7, 6,
              ],
            },
            A = [];
          for (let e = 0; e < S.indices.length; )
            A.push([
              S.vertex[S.indices[e]],
              S.vertex[S.indices[e + 1]],
              S.vertex[S.indices[e + 2]],
            ]),
              (e += 3);
          let P;
          (f += _), (f += m);
          try {
            P = v.getUint32(f, !0);
          } catch (e) {
            return;
          }
          f += Uint32Array.BYTES_PER_ELEMENT;
          const E = new Uint16Array(e, f, 3 * P);
          (f += P * g), P > 65536 && ((y = Uint32Array.BYTES_PER_ELEMENT), (x = 3 * y));
          const C = E.subarray(0, P),
            M = E.subarray(P, 2 * P),
            I = E.subarray(2 * P, 3 * P),
            L = [],
            R = [],
            N = [];
          this.zigZagDeltaDecode({
            uBuffer: C,
            vBuffer: M,
            heightBuffer: I,
            maximumHeight: T,
            minimumHeight: w,
            position: L,
            uv: R,
            hei: N,
            sphereMaskedBoundsArray: h,
            centerLngLat: u,
            deltaLng: c,
            projectionType: r,
            rP: b,
            worldSize: a,
            x: t,
            y: i,
            z: n,
          }),
            f % y != 0 && (f += y - (f % y));
          const O = v.getUint32(f, !0);
          f += Uint32Array.BYTES_PER_ELEMENT;
          const D = new Uint16Array(e, f, 3 * O);
          f += O * x;
          let F = 0;
          const z = D.length;
          for (let e = 0; e < z; ++e) {
            const t = D[e];
            (D[e] = F - t), 0 === t && ++F;
          }
          const B = v.getUint32(f, !0);
          f += Uint32Array.BYTES_PER_ELEMENT;
          let V = new Uint16Array(e, f, B);
          f += B * y;
          const U = v.getUint32(f, !0);
          f += Uint32Array.BYTES_PER_ELEMENT;
          let k = new Uint16Array(e, f, U);
          f += U * y;
          const G = v.getUint32(f, !0);
          f += Uint32Array.BYTES_PER_ELEMENT;
          let H = new Uint16Array(e, f, G);
          f += G * y;
          const Y = v.getUint32(f, !0);
          f += Uint32Array.BYTES_PER_ELEMENT;
          let q = new Uint16Array(e, f, Y);
          f += Y * y;
          const X = [];
          h = this.computeNormal(h, D, b, P, z, X);
          const j = [],
            W = this.genTerrainAnalysisArray(h, b, P, j, N),
            $ = Math.max(0, 2 * (V.length + k.length + H.length + q.length - 4)),
            Z = new Uint16Array(z + 3 * $);
          function K(e, t) {
            return M[e] - M[t];
          }
          function Q(e, t) {
            return C[e] - C[t];
          }
          Z.set(D, 0),
            (V = this.sortIndicesIfNecessary(V, K)),
            (k = this.sortIndicesIfNecessary(k, Q)),
            (H = this.sortIndicesIfNecessary(H, K)),
            (q = this.sortIndicesIfNecessary(q, Q));
          let J = z,
            ee = E.length;
          (J = this.addSkirt(ee, Z, J, V, !0, 3, L, R, N, X, j, h, W, n, b)),
            (ee += 3 * V.length),
            (J = this.addSkirt(ee, Z, J, k, !1, 3, L, R, N, X, j, h, W, n, b)),
            (ee += 3 * k.length),
            (J = this.addSkirt(ee, Z, J, H, !1, 3, L, R, N, X, j, h, W, n, b)),
            (ee += 3 * H.length),
            this.addSkirt(ee, Z, J, q, !0, 3, L, R, N, X, j, h, W, n, b);
          for (let e = 0; e < Z.length; e += 3)
            d.emplaceBack(Z[e], Z[e + 1], Z[e + 2]),
              p.emplaceBack(Z[e], Z[e + 1]),
              p.emplaceBack(Z[e + 1], Z[e + 2]),
              p.emplaceBack(Z[e + 2], Z[e]);
          return {
            sphereMaskedBoundsArray: h,
            sphereIndexArray: d,
            wireframeIndexArray: p,
            rP: b,
            count: L.length,
            minimumHeight: w,
            maximumHeight: T,
            tileBounds: A,
            tileBoundsVertex: S.vertex,
            indices: D,
            skirtIndex: D.length,
            vertexCountWithoutSkirts: P,
            x: t,
            y: i,
            z: n,
            uBuffer: C.slice(0),
            vBuffer: M.slice(0),
            hBuffer: I.slice(0),
            westIndices: V.slice(0),
            southIndices: k.slice(0),
            eastIndices: H.slice(0),
            northIndices: q.slice(0),
            terrainAnalysisArray: W,
          };
        }
        createChildTerrain(e) {
          const t = this.upsampleQuantizedTerrainMesh(e);
          return this.createUpSampleTerrain(t);
        }
        createUpSampleTerrain(e) {
          const t = zt(e.projectionType),
            i = e.x,
            n = e.y,
            r = e.z,
            o = Math.pow(2, r),
            a = t.tileNumberToLngLat([i, n], 1, o),
            s = t.tileNumberToLngLat([i + 1, n + 1], 1, o),
            l = Math.abs(s.lng - a.lng),
            c = this.getCenterLngLat(i, n, r);
          let u = new wo();
          const h = new ea(),
            d = new ia(),
            p = new Uint16Array(e.uBuffer),
            f = new Uint16Array(e.vBuffer),
            m = new Uint16Array(e.heightBuffer),
            _ = [],
            g = [],
            y = [],
            x = e.maximumHeight,
            v = e.minimumHeight,
            w = Il.cartographicToCartesian3(new Pt([c.lng, c.lat, v]));
          this.zigZagUpsampleDeltaDecode({
            uBuffer: p,
            vBuffer: f,
            heightBuffer: m,
            maximumHeight: x,
            minimumHeight: v,
            position: _,
            uv: g,
            hei: y,
            sphereMaskedBoundsArray: u,
            centerLngLat: c,
            deltaLng: l,
            projectionType: e.projectionType,
            rP: w,
            x: i,
            y: n,
            z: r,
            worldSize: o,
          });
          const T = e.indices,
            b = T.length;
          let S = e.westIndices,
            A = e.eastIndices,
            P = e.northIndices,
            E = e.southIndices;
          const C = e.vertexCount,
            M = [];
          u = this.computeNormal(u, T, w, C, b, M);
          const I = [],
            L = this.genTerrainAnalysisArray(u, w, C, I, y),
            R = Math.max(0, 2 * (S.length + E.length + A.length + P.length - 4)),
            N = new Uint16Array(b + 3 * R);
          function O(e, t) {
            return f[e] - f[t];
          }
          function D(e, t) {
            return p[e] - p[t];
          }
          N.set(T, 0),
            (S = this.sortIndicesIfNecessary(S, O)),
            (E = this.sortIndicesIfNecessary(E, D)),
            (A = this.sortIndicesIfNecessary(A, O)),
            (P = this.sortIndicesIfNecessary(P, D));
          let F = b,
            z = 3 * C;
          (F = this.addSkirt(z, N, F, S, !0, 3, _, g, y, M, I, u, L, r, w)),
            (z += 3 * S.length),
            (F = this.addSkirt(z, N, F, E, !1, 3, _, g, y, M, I, u, L, r, w)),
            (z += 3 * E.length),
            (F = this.addSkirt(z, N, F, A, !1, 3, _, g, y, M, I, u, L, r, w)),
            (z += 3 * A.length),
            this.addSkirt(z, N, F, P, !0, 3, _, g, y, M, I, u, L, r, w);
          for (let e = 0; e < N.length; e += 3)
            h.emplaceBack(N[e], N[e + 1], N[e + 2]),
              d.emplaceBack(N[e], N[e + 1]),
              d.emplaceBack(N[e + 1], N[e + 2]),
              d.emplaceBack(N[e + 2], N[e]);
          return {
            sphereMaskedBoundsArray: u,
            sphereIndexArray: h,
            wireframeIndexArray: d,
            count: _.length,
            minimumHeight: v,
            maximumHeight: x,
            x: e.x,
            y: e.y,
            z: e.z,
            uBuffer: p.slice(0),
            vBuffer: f.slice(0),
            hBuffer: m,
            indices: T,
            westIndices: S.slice(0),
            southIndices: E.slice(0),
            northIndices: P.slice(0),
            eastIndices: A.slice(0),
            rP: w,
            skirtIndex: T.length,
            vertexCountWithoutSkirts: C,
            terrainAnalysisArray: L,
          };
        }
        zigZagDecode(e) {
          return (e >> 1) ^ -(1 & e);
        }
        zigZagDeltaDecode(e) {
          const t = zt(e.projectionType),
            i = e.uBuffer.length;
          let n = 0,
            r = 0,
            o = 0;
          const a = (e.maximumHeight - e.minimumHeight) / this.maxShort,
            s = e.deltaLng / this.maxShort;
          for (let l = 0; l < i; ++l) {
            (n += this.zigZagDecode(e.uBuffer[l])),
              (r += this.zigZagDecode(e.vBuffer[l])),
              (o += this.zigZagDecode(e.heightBuffer[l])),
              (e.heightBuffer[l] = o),
              (e.uBuffer[l] = n),
              (e.vBuffer[l] = r),
              (e.position[l] = [
                e.centerLngLat.lng + (n - this.halfMaxShort) * s,
                t.yLat(e.y - r / this.maxShort + 1, e.worldSize),
              ]),
              (e.uv[l] = [n, this.maxShort - r]),
              (e.hei[l] = e.minimumHeight + o * a);
            const i = Il.cartographicToCartesian3(
              new Pt(e.position[l][0], e.position[l][1], e.hei[l]),
            );
            e.sphereMaskedBoundsArray.emplaceBack(
              i[0] - e.rP[0],
              i[1] - e.rP[1],
              i[2] - e.rP[2],
              e.uv[l][0],
              e.uv[l][1],
            );
          }
        }
        addSkirt(e, t, i, n, r, o, a, s, l, c, u, h, d, p, f) {
          let m, _, g;
          r ? ((m = n.length - 1), (_ = -1), (g = -1)) : ((m = 0), (_ = n.length), (g = 1));
          let y = -1,
            x = e / o;
          for (let e = m; e !== _; e += g) {
            const r = n[e];
            (a[x] = a[r]), (s[x] = s[r]), (l[x] = l[r] - 100), (c[x] = c[r]), (u[x] = u[r]);
            const o = Il.cartographicToCartesian3(new Pt([a[x][0], a[x][1], l[x]]));
            h.emplaceBack(
              o[0] - f[0],
              o[1] - f[1],
              o[2] - f[2],
              s[x][0],
              s[x][1],
              c[x][0],
              c[x][1],
              c[x][2],
            ),
              d.emplaceBack(u[x][0], u[x][1], u[x][2], l[x]),
              -1 !== y &&
                ((t[i++] = y),
                (t[i++] = x - 1),
                (t[i++] = r),
                (t[i++] = x - 1),
                (t[i++] = x),
                (t[i++] = r)),
              (y = r),
              ++x;
          }
          return i;
        }
        sortIndicesIfNecessary(e, t) {
          const i = [];
          i.length = e.length;
          let n = !1;
          for (let r = 0, o = e.length; r < o; ++r)
            (i[r] = e[r]), (n = n || (r > 0 && t(e[r - 1], e[r]) > 0));
          return n ? (i.sort(t), new Uint16Array(i)) : e;
        }
        upsampleQuantizedTerrainMesh(e) {
          const t = e.isEastChild,
            i = e.isNorthChild,
            n = t ? this.halfMaxShort : 0,
            r = t ? this.maxShort : this.halfMaxShort,
            o = i ? this.halfMaxShort : 0,
            a = i ? this.maxShort : this.halfMaxShort,
            s = [],
            l = [],
            c = [],
            u = [],
            h = {},
            d = e.indices;
          let p = 0;
          const f = e.vertexCountWithoutSkirts,
            m = e.minimumHeight,
            _ = e.maximumHeight,
            g = new Array(f),
            y = new Array(f),
            x = new Array(f),
            v = e.uBuffer,
            w = e.vBuffer,
            T = e.hBuffer;
          let b, S, A, P, E;
          const C = [],
            M = [];
          for (b = 0, S = 0; b < f; ++b, S += 2)
            (A = v[b]),
              (P = w[b]),
              A < 20 && (A = 0),
              P < 20 && (P = 0),
              this.maxShort - A < 20 && (A = this.maxShort),
              this.maxShort - P < 20 && (P = this.maxShort),
              (g[b] = A),
              (y[b] = P),
              (x[b] = T[b]),
              ((t && A >= this.halfMaxShort) || (!t && A <= this.halfMaxShort)) &&
                ((i && P >= this.halfMaxShort) || (!i && P <= this.halfMaxShort)) &&
                ((h[b] = p), s.push(A), l.push(P), c.push(x[b]), ++p);
          const I = [];
          I.push(new Hw()), I.push(new Hw()), I.push(new Hw());
          const L = [];
          L.push(new Hw()), L.push(new Hw()), L.push(new Hw());
          const R = [];
          let N, O;
          for (
            R.push(new Hw()), R.push(new Hw()), R.push(new Hw()), R.push(new Hw()), b = 0;
            b < d.length;
            b += 3
          ) {
            const e = d[b],
              n = d[b + 1],
              r = d[b + 2],
              o = g[e],
              a = g[n],
              p = g[r];
            I[0].initializeIndexed(g, y, x, null, e),
              I[1].initializeIndexed(g, y, x, null, n),
              I[2].initializeIndexed(g, y, x, null, r);
            const f = fy.clipTriangleAtAxisAlignedThreshold(this.halfMaxShort, t, o, a, p, M);
            (N = 0),
              N >= f.length ||
                ((N = L[0].initializeFromClipResult(f, N, I)),
                N >= f.length ||
                  ((N = L[1].initializeFromClipResult(f, N, I)),
                  N >= f.length ||
                    ((N = L[2].initializeFromClipResult(f, N, I)),
                    (O = fy.clipTriangleAtAxisAlignedThreshold(
                      this.halfMaxShort,
                      i,
                      L[0].getV(),
                      L[1].getV(),
                      L[2].getV(),
                      C,
                    )),
                    this.addClippedPolygon(s, l, c, u, h, O, L, R),
                    N < f.length &&
                      (L[2].clone(L[1]),
                      L[2].initializeFromClipResult(f, N, I),
                      (O = fy.clipTriangleAtAxisAlignedThreshold(
                        this.halfMaxShort,
                        i,
                        L[0].getV(),
                        L[1].getV(),
                        L[2].getV(),
                        C,
                      )),
                      this.addClippedPolygon(s, l, c, u, h, O, L, R)))));
          }
          const D = t ? -this.maxShort : 0,
            F = i ? -this.maxShort : 0,
            z = [],
            B = [],
            V = [],
            U = [];
          let k = Number.MAX_VALUE,
            G = -k;
          for (b = 0; b < s.length; ++b)
            (A = Math.round(s[b])),
              A <= n
                ? (z.push(b), (A = 0))
                : A >= r
                ? (V.push(b), (A = this.maxShort))
                : (A = 2 * A + D),
              (s[b] = A),
              (P = Math.round(l[b])),
              P <= o
                ? (B.push(b), (P = 0))
                : P >= a
                ? (U.push(b), (P = this.maxShort))
                : (P = 2 * P + F),
              (l[b] = P),
              (E = Ws(m, _, c[b] / this.maxShort)),
              E < k && (k = E),
              E > G && (G = E),
              (c[b] = E);
          const H = G - k;
          for (b = 0; b < c.length; ++b) c[b] = (this.maxShort * (c[b] - k)) / H;
          return {
            minimumHeight: k,
            maximumHeight: G,
            westIndices: z,
            southIndices: B,
            eastIndices: V,
            northIndices: U,
            indices: u,
            uBuffer: s,
            vBuffer: l,
            heightBuffer: c,
            vertexCount: s.length,
            x: e.x,
            y: e.y,
            z: e.z,
            rP: e.rP,
            projectionType: e.projectionType,
          };
        }
        zigZagUpsampleDeltaDecode(e) {
          const t = zt(e.projectionType),
            i = e.uBuffer.length;
          let n = 0,
            r = 0,
            o = 0;
          const a = (e.maximumHeight - e.minimumHeight) / this.maxShort,
            s = e.deltaLng / this.maxShort;
          for (let l = 0; l < i; ++l) {
            (n = e.uBuffer[l]),
              (r = e.vBuffer[l]),
              (o = e.heightBuffer[l]),
              (e.position[l] = [
                e.centerLngLat.lng + (n - this.halfMaxShort) * s,
                t.yLat(e.y - r / this.maxShort + 1, e.worldSize),
              ]),
              (e.uv[l] = [n, this.maxShort - r]),
              (e.hei[l] = e.minimumHeight + o * a);
            const i = Il.cartographicToCartesian3(
              new Pt(e.position[l][0], e.position[l][1], e.hei[l]),
            );
            e.sphereMaskedBoundsArray.emplaceBack(
              i[0] - e.rP[0],
              i[1] - e.rP[1],
              i[2] - e.rP[2],
              e.uv[l][0],
              e.uv[l][1],
            );
          }
        }
        addClippedPolygon(e, t, i, n, r, o, a, s) {
          if (0 === o.length) return;
          let l = 0,
            c = 0;
          for (; c < o.length; ) c = s[l++].initializeFromClipResult(o, c, a);
          for (let n = 0; n < l; ++n) {
            const o = s[n];
            if (o.isIndexed())
              (o.newIndex = r[o.index]), (o.uBuffer = e), (o.vBuffer = t), (o.heightBuffer = i);
            else {
              const n = o.getKey();
              if (null != r[n]) o.newIndex = r[n];
              else {
                const a = e.length;
                e.push(o.getU()), t.push(o.getV()), i.push(o.getH()), (o.newIndex = a), (r[n] = a);
              }
            }
          }
          3 === l
            ? (n.push(s[0].newIndex), n.push(s[1].newIndex), n.push(s[2].newIndex))
            : 4 === l &&
              (n.push(s[0].newIndex),
              n.push(s[1].newIndex),
              n.push(s[2].newIndex),
              n.push(s[0].newIndex),
              n.push(s[2].newIndex),
              n.push(s[3].newIndex));
        }
        computeNormal(e, t, i, n, r, o) {
          const a = e.float32,
            s = new Pt(),
            l = new Pt(),
            c = new Pt(),
            u = new Pt(),
            h = new Array(n),
            d = new Array(r / 3),
            p = new Array(r);
          let f;
          for (f = 0; f < n; f++) h[f] = { indexOffset: 0, count: 0, currentCount: 0 };
          let m = 0;
          for (f = 0; f < r; f += 3) {
            const e = t[f],
              i = t[f + 1],
              n = t[f + 2],
              r = 5 * e,
              o = 5 * i,
              s = 5 * n;
            (l.x = a[r]),
              (l.y = a[r + 1]),
              (l.z = a[r + 2]),
              (c.x = a[o]),
              (c.y = a[o + 1]),
              (c.z = a[o + 2]),
              (u.x = a[s]),
              (u.y = a[s + 1]),
              (u.z = a[s + 2]),
              h[e].count++,
              h[i].count++,
              h[n].count++,
              Pt.subtract(c, l, c),
              Pt.subtract(u, l, u);
            const p = Pt.cross(c, u, new Pt()),
              _ = p.len() / 2;
            (d[m] = p.multiplyScalar(_)), m++;
          }
          let _,
            g = 0;
          for (f = 0; f < n; f++) (h[f].indexOffset += g), (g += h[f].count);
          for (m = 0, f = 0; f < r; f += 3) {
            _ = h[t[f]];
            let e = _.indexOffset + _.currentCount;
            (p[e] = m),
              _.currentCount++,
              (_ = h[t[f + 1]]),
              (e = _.indexOffset + _.currentCount),
              (p[e] = m),
              _.currentCount++,
              (_ = h[t[f + 2]]),
              (e = _.indexOffset + _.currentCount),
              (p[e] = m),
              _.currentCount++,
              m++;
          }
          const y = new bo();
          for (f = 0; f < n; f++) {
            const e = 5 * f;
            if (((_ = h[f]), Pt.clone(Pt.ZERO, s), _.count > 0)) {
              for (m = 0; m < _.count; m++) Pt.add(s, d[p[_.indexOffset + m]], s);
              Pt.equalsEpsilon(Pt.ZERO, s, Me.CesiumMath.EPSILON10) &&
                Pt.clone(d[p[_.indexOffset]], s);
            }
            Pt.equalsEpsilon(Pt.ZERO, s, Me.CesiumMath.EPSILON10) && (s.z = 1),
              Pt.normalize(s, s),
              y.emplaceBack(a[e], a[e + 1], a[e + 2], a[e + 3], a[e + 4], s.x, s.y, s.z),
              (o[f] = [s.x, s.y, s.z]);
          }
          return y;
        }
        genTerrainAnalysisArray(e, t, i, n, r) {
          const o = e.float32,
            a = new na();
          let s;
          for (s = 0; s < i; s++) {
            const e = 8 * s,
              i = new Pt(o[e] + t[0], o[e + 1] + t[1], o[e + 2] + t[2]),
              l = Il.DefaultEllipsoid.geodeticSurfaceNormal(i, new Pt());
            a.emplaceBack(l.x, l.y, l.z, r[s]), (n[s] = [l.x, l.y, l.z]);
          }
          return a;
        }
        static genShaderScript(e) {
          let t, i;
          return (
            'slope' === e.property
              ? ((t =
                  '\nattribute vec3 a_NORMAL;\nattribute vec3 a_GEODETIC_NORMAL;\nvarying float v_slope;\n\n#include <a_POSITION3>\n#include <u_ModelViewProjectionMatrix>\n\nvoid main(void) {\n\n\t// 计算gl_Position\n\tgl_Position = u_ModelViewProjectionMatrix * vec4(a_POSITION, 1.0);\n\t// 获取坡度\n\tv_slope = degrees(acos(dot(a_NORMAL, a_GEODETIC_NORMAL)));\n}\n\t\t\t'),
                (i =
                  '\nvarying float v_slope;\n\n#include <fn_getExponentialInterpColor>\n\nvoid main(void) {\n\t\t\t'),
                (i += Yw(e, !1)),
                (i += '\n\tgl_FragColor = color;\n}\n\t\t\t'))
              : 'aspect' === e.property
              ? ((t =
                  '\nattribute vec3 a_NORMAL;\nattribute vec3 a_GEODETIC_NORMAL;\nvarying float v_dot_product;\nvarying float v_determ;\n\n#include <c_define>\n#include <a_POSITION3>\n#include <u_ModelViewProjectionMatrix>\n\nvoid main(void) {\n\n\t// 计算gl_Position\n\tgl_Position = u_ModelViewProjectionMatrix * vec4(a_POSITION, 1.0);\n\t// 计算法线在椭球切面的投影\n\tvec3 projection = normalize(a_NORMAL - dot(a_NORMAL, a_GEODETIC_NORMAL) * a_GEODETIC_NORMAL);\n\t// 计算enu坐标系的东方向\n\tvec3 east = normalize(cross(vec3(0.0, 0.0, 1.0), a_GEODETIC_NORMAL));\n\tv_dot_product = dot(projection, east);\n\t// 判断东方向和法线在椭球切面的投影构成的切面是向球心还是远离球心的\n    v_determ = dot(cross(projection, east), a_GEODETIC_NORMAL);\n}\n\t\t\t'),
                (i =
                  '\nvarying float v_dot_product;\nvarying float v_determ;\n\n#include <fn_getExponentialInterpColor>\n#include <fn_branchFreeTernary>\n\nvoid main(void) {\n\t// 计算夹角\n    float v_aspect = degrees(acos(v_dot_product));\n    v_aspect = branchFreeTernary(v_determ < 0.0, 360.0 - v_aspect, v_aspect);\n    // 将以东方向基准改为以北方向为基准\n    v_aspect += 90.0;\n    v_aspect = branchFreeTernary(v_aspect < 360.0, v_aspect, v_aspect - 360.0);\n\t\t\t'),
                (i += Yw(e, !1)),
                (i += '\n\tgl_FragColor = color;\n}\n\t\t\t'))
              : 'elevation_band' === e.property
              ? ((t =
                  '\nattribute float a_ELEVATION;\nvarying float v_elevation_band;\n\n#include <c_define>\n#include <a_POSITION3>\n#include <u_ModelViewProjectionMatrix>\n#include <fn_branchFreeTernary>\n\nvoid main(void) {\n\n\t// 计算gl_Position\n\tgl_Position = u_ModelViewProjectionMatrix * vec4(a_POSITION, 1.0);\n\n    v_elevation_band = a_ELEVATION;\n}\n\t\t\t'),
                (i =
                  '\nvarying float v_elevation_band;\n\n#include <fn_getExponentialInterpColor>\n\nvoid main(void) {\n\t\t\t'),
                (i += Yw(e, !1)),
                (i += '\n\tgl_FragColor = color;\n}\n\t\t\t'))
              : console.error(`Unknown terrain analysis type ${e.property}`),
            { vs: t, fs: i }
          );
        }
      }),
      (e.Texture = Pu),
      (e.TextureMagnificationFilter = Gc),
      (e.TextureMinificationFilter = Yc),
      (e.TextureWrap = Xc),
      (e.TileBoundingRegion = Ou),
      (e.Transforms = Il),
      (e.V34Pos2V4PosUtil = $s),
      (e.ValidationError = S_),
      (e.Vector = Re),
      (e.Vector2 = $e),
      (e.Vector3 = Pt),
      (e.Vector4 = Ge),
      (e.VectorCircleMaterial = class extends Wp {
        constructor(e) {
          super(e),
            (this.isVectorMaterial = !0),
            (this.layer = e.layer),
            (this.tile = e.tile),
            (this.plotter = e.plotter),
            (this._programConfiguration = e.programConfiguration),
            (this._renderState = e.renderState),
            this.#k(e.painter);
        }
        update(e, t, i = {}) {
          super.update(e, t, i);
        }
        #k(e) {
          this._uniforms.set(
            'u_GlUnitsToPixels',
            () => (vw.set(e.transform.width / 2, e.transform.height / 2), vw),
          ),
            this._uniforms.set(
              'u_PixelMatrix',
              () => (
                xw.identity(),
                xw.scale([1, Math.cos(e.transform.hpr.pitch)]),
                xw.rotate(-e.transform.hpr.heading),
                xw
              ),
            );
        }
        destroy() {
          (this.layer = void 0),
            (this.tile = void 0),
            (this.pattern = void 0),
            (this.plotter = void 0),
            (this.type = void 0),
            (this._uniforms = void 0),
            (this._textures = void 0),
            (this._program = void 0),
            (this._programConfiguration = void 0),
            (this._renderState = void 0),
            (this._pixelMatrix = void 0);
        }
      }),
      (e.VectorExtrusionMaterial = Ew),
      (e.VectorFillMaterial = Mw),
      (e.VectorLayerType = tm),
      (e.VectorLineMaterial = class extends Wp {
        constructor(e) {
          super(e),
            (this.isVectorMaterial = !0),
            (this.layer = e.layer),
            (this.tile = e.tile),
            (this.coord = e.tile.tileID),
            (this.isBorder = e.isBorder),
            (this.sourceMaxZoom = e.sourceMaxZoom),
            (this.bucket = e.bucket),
            (this.lineGradient = e.lineGradient || void 0),
            (this._programConfiguration = e.programConfiguration),
            (this._renderState = e.renderState),
            (this._isShadowVolumeMaterial = e.shadowVolumeMaterial || !1),
            (this.dasharray = this.layer.paint.get('line-dasharray')),
            (this.tileRatio = void 0),
            (this.posA = void 0),
            (this.posB = void 0),
            (this.widthA = void 0),
            (this.widthB = void 0),
            (this.crossfade = void 0),
            (this.imagePosA = void 0),
            (this.imagePosB = void 0),
            (this.image = void 0),
            (this.gradientTexture = void 0),
            this.#I(e.painter);
        }
        update(e, t, i = {}) {
          super.update(e, t, i);
          const n = this.layer.paint.get('line-dasharray')
            ? 'sphereLineSDF'
            : this.layer.paint.get('line-pattern')
            ? 'sphereLinePattern'
            : this.layer.paint.get('line-gradient')
            ? 'sphereLineGradient'
            : 'sphereLine';
          (this.type = n), this.updateDynamicProperty(e), this.#G(e), this.#H(e);
        }
        destroy() {
          (this.layer = void 0),
            (this.tile = void 0),
            (this.coord = void 0),
            (this.drawLine = void 0),
            (this.type = void 0),
            (this._uniforms = void 0),
            (this._textures = void 0),
            (this._program = void 0),
            (this.isBorder = void 0),
            (this.sourceMaxZoom = void 0),
            (this.bucket = void 0),
            (this.lineGradient = void 0),
            (this._programConfiguration = void 0),
            (this.dasharray = void 0),
            (this.tileRatio = void 0),
            (this.posA = void 0),
            (this.posB = void 0),
            (this.widthA = void 0),
            (this.widthB = void 0),
            (this.crossfade = void 0),
            (this.imagePosA = void 0),
            (this.imagePosB = void 0),
            (this.image = void 0),
            (this.gradientTexture = void 0);
        }
        #I(e) {
          this.updateDynamicProperty(e),
            this._uniforms.set(
              'u_GlUnitsToPixels',
              () => (Dw.set(e.transform.width / 2, -e.transform.height / 2), Dw),
            ),
            this._uniforms.set('u_Ratio', () => 1 / Lf(this.tile, 1, e.style.getNearestTileZoom())),
            this.pushMinimumUniform('u_Ratio'),
            this._uniforms.set('u_HalfRender', () => this.layer.paint.get('half-render')),
            this._uniforms.set('u_HasBorder', () => this.isBorder),
            this.pushMinimumUniform('u_HasBorder'),
            this._uniforms.set(
              'u_PixelMatrix',
              () => (
                Fw.identity(),
                Fw.scale([1, Math.cos(e.transform.hpr.pitch)]),
                Fw.rotate(-e.transform.hpr.heading),
                Fw
              ),
            ),
            this.#G(e),
            this.#H(e);
        }
        #G(e) {
          this.lineGradient &&
            ((this.gradientTexture = this.#Y(e)),
            this._uniforms.set(
              'u_BaseColorSampler',
              () => (
                this.gradientTexture.bind(
                  this.layer.stepInterpolate ? Ll.NEAREST : Ll.LINEAR,
                  Ll.CLAMP_TO_EDGE,
                ),
                this.gradientTexture
              ),
            ),
            this.pushMinimumUniform('u_BaseColorSampler'),
            this._uniforms.set('u_image_height', () => this.bucket.lineClipsArray.length),
            this.pushMinimumUniform('u_image_height'));
        }
        #Y(e) {
          const t = this.bucket.gradients[this.layer.id];
          let i = t.texture;
          if (this.layer.gradientVersion !== t.version) {
            let n = 256;
            if (this.layer.stepInterpolate) {
              const t =
                this.coord.canonical.z === this.sourceMaxZoom
                  ? Math.ceil(1 << (e.transform.maxZoom - this.coord.canonical.z))
                  : 1;
              n = se(
                pe((this.bucket.maxLineLength / Wu) * 1024 * t),
                256,
                e.context.maxTextureSize,
              );
            }
            (t.gradient = yx({
              expression: this.layer.gradientExpression(),
              evaluationKey: 'lineProgress',
              resolution: n,
              image: t.gradient || void 0,
              clips: this.bucket.lineClipsArray,
            })),
              t.texture
                ? t.texture.update(t.gradient)
                : (t.texture = new Pu({
                    context: e.context,
                    image: t.gradient,
                    pixelFormat: Qc.RGBA,
                  })),
              (t.version = this.layer.gradientVersion),
              (i = t.texture);
          }
          return i;
        }
        #H(e) {
          this.dasharray
            ? (this._uniforms.set(
                'u_patternscale_a',
                () => (zw.set(this.tileRatio / this.widthA, -this.posA.height / 2), zw),
              ),
              this.pushMinimumUniform('u_patternscale_a'),
              this._uniforms.set(
                'u_patternscale_b',
                () => (Bw.set(this.tileRatio / this.widthB, -this.posB.height / 2), Bw),
              ),
              this.pushMinimumUniform('u_patternscale_b'),
              this._uniforms.set(
                'u_sdfgamma',
                () =>
                  e.lineAtlas.width /
                  (256 * Math.min(this.widthA, this.widthB) * Qu.devicePixelRatio) /
                  2,
              ),
              this.pushMinimumUniform('u_sdfgamma'),
              this._uniforms.set(
                'u_BaseColorSampler',
                () => (e.lineAtlas.bind(e.context), e.lineAtlas),
              ),
              this.pushMinimumUniform('u_BaseColorSampler'),
              this._uniforms.set('u_tex_y_a', () => this.posA.y),
              this.pushMinimumUniform('u_tex_y_a'),
              this._uniforms.set('u_tex_y_b', () => this.posB.y),
              this.pushMinimumUniform('u_tex_y_b'),
              this._uniforms.set('u_mix', () => this.crossfade.t),
              this.pushMinimumUniform('u_mix'))
            : this.image &&
              this.imagePosA &&
              this.imagePosB &&
              (this._uniforms.set(
                'u_pattern_size_a',
                () => (
                  Vw.set(
                    (this.imagePosA.displaySize[0] * this.crossfade.fromScale) / this.tileRatio,
                    this.imagePosA.displaySize[1],
                  ),
                  Vw
                ),
              ),
              this.pushMinimumUniform('u_pattern_size_a'),
              this._uniforms.set(
                'u_pattern_size_b',
                () => (
                  Uw.set(
                    (this.imagePosB.displaySize[0] * this.crossfade.toScale) / this.tileRatio,
                    this.imagePosB.displaySize[1],
                  ),
                  Uw
                ),
              ),
              this.pushMinimumUniform('u_pattern_size_b'),
              this._uniforms.set('u_texsize', () => {
                const { width: t, height: i } = e.imageManager.getPixelSize();
                return kw.set(t, i), kw;
              }),
              this.pushMinimumUniform('u_texsize'),
              this._uniforms.set(
                'u_BaseColorSampler',
                () => (e.imageManager.bind(e.context), e.imageManager.atlasTexture),
              ),
              this.pushMinimumUniform('u_BaseColorSampler'),
              this._uniforms.set(
                'u_pattern_tl_a',
                () => (Gw.set(this.imagePosA.tl[0], this.imagePosA.tl[1]), Gw),
              ),
              this.pushMinimumUniform('u_pattern_tl_a'),
              this._uniforms.set(
                'u_pattern_br_a',
                () => (Gw.set(this.imagePosA.br[0], this.imagePosA.br[1]), Gw),
              ),
              this.pushMinimumUniform('u_pattern_br_a'),
              this._uniforms.set(
                'u_pattern_tl_b',
                () => (Gw.set(this.imagePosB.tl[0], this.imagePosB.tl[1]), Gw),
              ),
              this.pushMinimumUniform('u_pattern_tl_b'),
              this._uniforms.set(
                'u_pattern_br_b',
                () => (Gw.set(this.imagePosB.br[0], this.imagePosB.br[1]), Gw),
              ),
              this.pushMinimumUniform('u_pattern_br_b'),
              this._uniforms.set('u_fade', () => this.crossfade.t),
              this.pushMinimumUniform('u_fade'));
        }
        updateDynamicProperty(e) {
          (this.image = this.layer.paint.get('line-pattern')),
            (this.crossfade = this.layer.getCrossfadeParameters()),
            this.dasharray
              ? ((this.posA = e.lineAtlas.getDash(
                  this.dasharray.from,
                  'round' === this.layer.layout.get('line-cap'),
                )),
                (this.posB = e.lineAtlas.getDash(
                  this.dasharray.to,
                  'round' === this.layer.layout.get('line-cap'),
                )),
                (this.widthA = this.posA.width * this.crossfade.fromScale),
                (this.widthB = this.posB.width * this.crossfade.toScale))
              : this.image &&
                ((this.imagePosA = e.imageManager.getPattern(this.image.from)),
                (this.imagePosB = e.imageManager.getPattern(this.image.to))),
            (this.tileRatio = 1 / Lf(this.tile, 1, e.transform.tileZoom));
        }
      }),
      (e.VertexBuffer = Ru),
      (e.ViewportQuadGeometry = af),
      (e.WGS84_RADIUS_X = et),
      (e.WGS84_RADIUS_Y = tt),
      (e.WGS84_RADIUS_Z = it),
      (e.WebGLComponentCounts = {
        SCALAR: 1,
        VEC2: 2,
        VEC3: 3,
        VEC4: 4,
        MAT2: 4,
        MAT3: 9,
        MAT4: 16,
      }),
      (e.WebGLComponentToShaderVariableType = {
        SCALAR: 'float',
        VEC2: 'vec2',
        VEC3: 'vec3',
        VEC4: 'vec4',
        MAT2: 'mat2',
        MAT3: 'mat3',
        MAT4: 'mat4',
      }),
      (e.WebGLConstants = Ll),
      (e.WebGLSizes = { 5120: 1, 5121: 1, 5122: 2, 5123: 2, 5125: 4, 5124: 4, 5126: 4 }),
      (e.WritingMode = Em),
      (e.ZoomHistory = td),
      (e.addColorDefines = function (e) {
        const t = {};
        if (
          ((t.PROPERTY = e.property),
          (t.INTERPOLATION_TYPE = e.type),
          e.default && (t.DEFAULT_COLOR = ai.parse(e.default)),
          e.stops)
        )
          for (let i = 0; i < e.stops.length; i += 1) {
            const n = e.stops[i];
            (t[`STOP_${i}`] = n[0]), (t[`STOP_COLOR_${i}`] = ai.parse(n[1]));
          }
        return e.base && (t.BASE = e.base), t;
      }),
      (e.allowsLetterSpacing = function (e) {
        for (const t of e) if (!Ri(t.charCodeAt(0))) return !1;
        return !0;
      }),
      (e.allowsVerticalWritingMode = Li),
      (e.arrayInclude = function (e, t) {
        return e.filter((e) => e === t).length > 0;
      }),
      (e.arrayRemoveDuplicates = Wh),
      (e.asyncAll = function (e, t, i) {
        if (!e.length) return i(null, []);
        let n = e.length;
        const r = new Array(e.length);
        let o = null;
        for (let a = 0; a < e.length; a++)
          t(e[a], (e, t) => {
            e && (o = e), (r[a] = t), 0 == --n && i(o, r);
          });
      }),
      (e.bezier = oe),
      (e.bindAll = fe),
      (e.calc3dVectorTileTranslateMatrix = js),
      (e.checkIsDepthSupportDataType = function (e) {
        if (void 0 === e || e === i_.NONE) return !0;
      }),
      (e.checkIsIgnoreClassificationDataType = function (e) {
        if (e === i_.IGNORECLASSIFICATION) return !0;
      }),
      (e.checkIsVectorShadowVolumeDataType = r_),
      (e.clamp = se),
      (e.classifyRings = Kg),
      (e.clipLine = Gy),
      (e.clone = ye),
      (e.combine = dp),
      (e.combineInternalMap = Gp),
      (e.createCommonjsModule = Ju),
      (e.createExpression = no),
      (e.createFilter = F_),
      (e.createLayout = Gt),
      (e.createLayoutGltf = function (e, t = 1) {
        const i = [],
          n = e.map((e) => {
            const t = e.components || 1;
            return (
              i.push(e.name),
              {
                name: e.name,
                type: e.type,
                components: t,
                offset: e.offset || 0,
                byteStride: e.byteStride || 4,
              }
            );
          });
        return (
          i.sort(), { members: n, size: Ht(0, Math.max(0, t)), alignment: t, key: i.join(';') }
        );
      }),
      (e.createLayoutPnts = function (e, t = 1) {
        return {
          members: e.map((e) => ({
            name: e.name,
            type: e.type,
            components: e.components || 1,
            offset: e.offset || 0,
            byteStride: e.byteStride || 4,
            bufferName: e.bufferName,
          })),
          size: Ht(0, Math.max(0, t)),
          alignment: t,
        };
      }),
      (e.createPatternUniforms = yw),
      (e.createStyleLayer = function (e) {
        return 'custom' === e.type ? new uv(e) : new Dv[e.type](e);
      }),
      (e.decodeModel = function (e) {
        const t = lu(e, e ? e.byteLength : 0);
        return t.buffer ? t.buffer : t;
      }),
      (e.deepCopyObj = Se),
      (e.defaultValue = Z),
      (e.defined = t),
      (e.destroyObject = Vc),
      (e.distToSegmentSquared = Iy),
      (e.ease = ae),
      (e.easeCubicInOut = re),
      (e.emitValidationErrors = ug),
      (e.evaluateSizeForFeature = Nf),
      (e.evaluateSizeForZoom = Of),
      (e.evented = ud),
      (e.exported = Qu),
      (e.extend = ce),
      (e.filterObject = ge),
      (e.findStopLessThanOrEqualTo = On),
      (e.fromCartographicToRadians = ct),
      (e.genColorBarScript = Yw),
      (e.getArrayBuffer = fu),
      (e.getCoordinatesCenter = function (e) {
        let t = 1 / 0,
          i = 1 / 0,
          n = -1 / 0,
          r = -1 / 0;
        for (let o = 0; o < e.length; o++)
          (t = Math.min(t, e[o].column)),
            (i = Math.min(i, e[o].row)),
            (n = Math.max(n, e[o].column)),
            (r = Math.max(r, e[o].row));
        const o = Math.max(n - t, r - i),
          a = Math.max(0, Math.floor(-Math.log(o) / Math.LN2));
        return new ee((t + n) / 2, (i + r) / 2, 0).zoomTo(a);
      }),
      (e.getDefaultExportFromCjs = function (e) {
        return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, 'default')
          ? e.default
          : e;
      }),
      (e.getDistanceFromZoom = Gs),
      (e.getImage = vu),
      (e.getJSON = function (e, t) {
        return pu(ce((e = 'string' == typeof e ? { url: e } : e), { type: 'json' }), t);
      }),
      (e.getLabelPlaneMatrix = Um),
      (e.getPickPositionOfSurface = function (e) {
        const t = e.transform.getCameraPos(),
          i = new Ja(t, ks(e.canvasX, e.canvasY, 0.999999, e.transform)),
          n = ds.rayEllipsoid(i, e.ellipsoid ? e.ellipsoid : Il.DefaultEllipsoid);
        if (n) {
          const t = i.origin.clone().add(i.direction.clone().multiplyScalar(n.start));
          return {
            lngLat: Nt.convert(
              Il.cartesian3ToCartographic(t, e.ellipsoid ? e.ellipsoid : Il.DefaultEllipsoid),
            ),
            intersectPoint: t,
          };
        }
        return { lngLat: null, intersectPoint: null };
      }),
      (e.getPointInWorldRay = ks),
      (e.getPrimitives = Vp),
      (e.getProjection = zt),
      (e.getRTLTextPluginStatus = hd),
      (e.getRay = function (e) {
        const t = e.transform.getCameraPos();
        return new Ja(t, ks(e.canvasX, e.canvasY, 0.999999, e.transform));
      }),
      (e.getReferrer = du),
      (e.getSpherePos = Ys),
      (e.getString = function (e, t) {
        return pu(ce((e = 'string' == typeof e ? { url: e } : e), { type: 'string' }), t);
      }),
      (e.getVideo = function (e, t) {
        const i = J.document.createElement('video');
        (i.muted = !0),
          (i.onloadstart = function () {
            t(null, i);
          });
        for (let t = 0; t < e.length; t++) {
          const n = J.document.createElement('source');
          mu(e[t]) || (i.crossOrigin = 'Anonymous'), (n.src = e[t]), i.appendChild(n);
        }
        return { cancel: () => {} };
      }),
      (e.getZoomFromDistance = Hs),
      (e.intersectionMapKeys = function (e, t) {
        let i, n;
        const r = [];
        if (!e || !t) return r;
        for (e.size < t.size ? ((i = e.keys()), (n = t)) : ((i = t.keys()), (n = e)); ; ) {
          const e = i.next();
          if (e.done) break;
          const t = e.value;
          n.has(t) && r.push(t);
        }
        return r;
      }),
      (e.isBoolean = Pe),
      (e.isChar = Ii),
      (e.isNumber = Ae),
      (e.isPatternMissing = gw),
      (e.isPowerOfTwo = function (e) {
        return (Math.log(e) / Math.LN2) % 1 == 0;
      }),
      (e.isUrl = function (e) {
        const t = e.substring(0, 2),
          i = e.substring(0, 1);
        return (
          !!/^http[s]?:\/\/([\w\-\.]+)+[\w-]*([\w\-\.\/\?%&=]+)?$/gi.test(e) ||
          './' == t ||
          '/' == i
        );
      }),
      (e.isWorker = be),
      (e.keysDifference = function (e, t) {
        const i = [];
        for (const n in e) n in t || i.push(n);
        return i;
      }),
      (e.keysDifferenceWithMap = function (e, t) {
        const i = [];
        for (const n in e) t.has(n) || i.push(n);
        return i;
      }),
      (e.layout = qh),
      (e.layout$1 = Xh),
      (e.lazyLoadRTLTextPlugin = function () {
        pd.isLoading() || pd.isLoaded() || 'deferred' !== hd() || dd();
      }),
      (e.lerp = Ws),
      (e.makeRequest = pu),
      (e.mapObject = _e),
      (e.mvt = Qf),
      (e.nextPowerOfTwo = pe),
      (e.number = zn),
      (e.octDecode = function (e, t, i) {
        return (function (e, t, i, n) {
          if ((s_(n), e < 0 || e > i || t < 0 || t > i))
            throw new Error('x and y must be unsigned normalized integers between 0 and 255');
          if (
            ((n.x = p_(e, i)),
            (n.y = p_(t, i)),
            (n.z = 1 - (Math.abs(n.x) + Math.abs(n.y))),
            n.z < 0)
          ) {
            const e = n.x;
            (n.x = (1 - Math.abs(n.y)) * m_(e)), (n.y = (1 - Math.abs(e)) * m_(n.y));
          }
          return n.normalize();
        })(e, t, 255, i);
      }),
      (e.parseCacheControl = function (e) {
        const t = {};
        if (
          (e.replace(
            /(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g,
            (e, i, n, r) => {
              const o = n || r;
              return (t[i] = !o || o.toLowerCase()), '';
            },
          ),
          t['max-age'])
        ) {
          const e = parseInt(t['max-age'], 10);
          isNaN(e) ? delete t['max-age'] : (t['max-age'] = e);
        }
        return t;
      }),
      (e.parseGlyphPBF = function (e) {
        return new kv(e).readFields(lw, []);
      }),
      (e.pbf = kv),
      (e.pick = function (e, t) {
        const i = {};
        for (let n = 0; n < t.length; n++) {
          const r = t[n];
          r in e && (i[r] = e[r]);
        }
        return i;
      }),
      (e.pickColorAttributes = zf),
      (e.pixelsToTileUnits = Lf),
      (e.placeFirstAndLastGlyph = Hm),
      (e.plugin = pd),
      (e.pointGeometry3d = te),
      (e.polygonIntersectsPolygon = function (e, t) {
        for (let i = 0; i < e.length; i++) if (Ry(t, e[i])) return !0;
        for (let i = 0; i < t.length; i++) if (Ry(e, t[i])) return !0;
        return !!Ey(e, t);
      }),
      (e.potpack = Fv),
      (e.project = km),
      (e.properties = mm),
      (e.randomBetween = function (e, t) {
        const i = new Uint32Array(1);
        return J.crypto.getRandomValues(i), (i[0] / 4294967295) * (t - e) + e;
      }),
      (e.readPixel = tf),
      (e.reduceComma = Ip),
      (e.refProperties = [
        'type',
        'source',
        'source-layer',
        'minzoom',
        'maxzoom',
        'filter',
        'layout',
      ]),
      (e.register = fo),
      (e.registerForPluginStateChange = function (e) {
        return e({ pluginStatus: ad, pluginURL: sd }), ud.on('pluginStateChange', e), e;
      }),
      (e.renderStateEnum = yp),
      (e.rgba2Hex = function (e) {
        const t = e
            .replace(/rgba?\(/, '')
            .replace(/\)/, '')
            .replace(/[\s+]/g, '')
            .split(','),
          i = parseFloat(t[3] || 1),
          n = Math.floor(i * parseInt(t[0]) + 255 * (1 - i)),
          r = Math.floor(i * parseInt(t[1]) + 255 * (1 - i)),
          o = Math.floor(i * parseInt(t[2]) + 255 * (1 - i));
        return `#${`0${n.toString(16)}`.slice(-2)}${`0${r.toString(16)}`.slice(-2)}${`0${o.toString(
          16,
        )}`.slice(-2)}`;
      }),
      (e.setRTLTextPlugin = function (e, t, i = !1) {
        if (ad === id || ad === nd || ad === rd)
          throw new Error('setRTLTextPlugin cannot be called multiple times.');
        (sd = Qu.resolveURL(e)), (ad = id), (od = t), cd(), i || dd();
      }),
      (e.shaders = Rp),
      (e.shapeIcon = function (e, t, i) {
        const { horizontalAlign: n, verticalAlign: r } = zm(i),
          o = t[0] - e.displaySize[0] * n,
          a = t[1] - e.displaySize[1] * r;
        return {
          image: e,
          top: a,
          bottom: a + e.displaySize[1],
          left: o,
          right: o + e.displaySize[0],
        };
      }),
      (e.shapeText = function (e, t, i, n, r, o, a, s, l, c, u, h) {
        const d = Cm.fromFeature(e, i);
        u === Em.vertical && d.verticalizePunctuation();
        const p = [],
          f = {
            positionedGlyphs: p,
            text: d,
            top: l[1],
            bottom: l[1],
            left: l[0],
            right: l[0],
            writingMode: u,
          };
        let m;
        if (h && h.properties && h.properties.hasOwnProperty('_wrap')) {
          const e = h.properties._wrap.split(',');
          e.length > 0 && '' !== e[0]
            ? (e.forEach((e, t, i) => {
                i[t] = parseInt(e);
              }),
              (m = Mm(d, e)))
            : (m = Mm(d, []));
        } else {
          const { processBidirectionalText: e, processStyledBidirectionalText: i } = pd;
          if (e && 1 === d.sections.length) {
            m = [];
            const i = e(d.toString(), Fm(d, s, n, t));
            for (const e of i) {
              const t = new Cm();
              (t.text = e), (t.sections = d.sections);
              for (let i = 0; i < e.length; i++) t.sectionIndex.push(0);
              m.push(t);
            }
          } else if (i) {
            m = [];
            const e = i(d.text, d.sectionIndex, Fm(d, s, n, t));
            for (const t of e) {
              const e = new Cm();
              (e.text = t[0]), (e.sectionIndex = t[1]), (e.sections = d.sections), m.push(e);
            }
          } else m = Mm(d, Fm(d, s, n, t));
        }
        return (
          (function (e, t, i, n, r, o, a, s, l) {
            let c = 0,
              u = -17,
              h = 0;
            const d = e.positionedGlyphs,
              p = 'right' === o ? 1 : 'left' === o ? 0 : 0.5;
            for (const e of i) {
              e.trim();
              const i = e.getMaxScale();
              if (!e.length()) {
                u += n;
                continue;
              }
              const r = d.length;
              for (let n = 0; n < e.length(); n++) {
                const r = e.getSection(n),
                  o = e.getCharCode(n),
                  h = 24 * (i - r.scale),
                  p = t[r.fontStack],
                  f = p && p[o];
                f &&
                  (Ni(o) && a !== Em.horizontal
                    ? (d.push({
                        glyph: o,
                        x: c,
                        y: h,
                        vertical: !0,
                        scale: r.scale,
                        fontStack: r.fontStack,
                      }),
                      (c += l * r.scale + s))
                    : (d.push({
                        glyph: o,
                        x: c,
                        y: u + h,
                        vertical: !1,
                        scale: r.scale,
                        fontStack: r.fontStack,
                      }),
                      (c += f.metrics.advance * r.scale + s)));
              }
              d.length !== r && ((h = Math.max(c - s, h)), Bm(d, t, r, d.length - 1, p)),
                (c = 0),
                (u += n * i);
            }
            const { horizontalAlign: f, verticalAlign: m } = zm(r);
            !(function (e, t, i, n, r, o, a) {
              const s = (t - i) * r,
                l = (-n * a + 0.5) * o;
              for (let t = 0; t < e.length; t++) (e[t].x += s), (e[t].y += l);
            })(d, p, f, m, h, n, i.length);
            const _ = u - -17;
            (e.top += -m * _), (e.bottom = e.top + _), (e.left += -f * h), (e.right = e.left + h);
          })(f, t, m, r, o, a, u, s, c),
          !!p.length && ((f.text = f.text.toString()), f)
        );
      }),
      (e.smoothstep = function (e, t, i) {
        return (i = se((i - e) / (t - e), 0, 1)) * i * (3 - 2 * i);
      }),
      (e.spec = pm),
      (e.stencilModeforExtrusion = function (e) {
        e.tileClippingMask.nextStencilID + 1 > 256 &&
          ((e.tileClippingMask.nextStencilID = 1), e.clearStencil());
        const t = e.tileClippingMask.nextStencilID++;
        return {
          enabled: !0,
          frontFunction: Ll.NOTEQUAL,
          backFunction: Ll.NOTEQUAL,
          reference: t,
          mask: 255,
          frontOperation: { fail: Ll.KEEP, zFail: Ll.KEEP, zPass: Ll.REPLACE },
          backOperation: { fail: Ll.KEEP, zFail: Ll.KEEP, zPass: Ll.REPLACE },
        };
      }),
      (e.tileSamplesGrid = function (e, t) {
        const i = new Yh(),
          n = new wo(),
          r = new ea(),
          o = new ia();
        i.prepareSegment(0, n, r);
        const a = Me.TILE.EXTENT,
          s = e.canonical.x,
          l = e.canonical.y;
        let c = _y;
        (c /= Math.pow(2, e.overscaledZ)),
          e.overscaledZ > 4 && e.overscaledZ < 7 ? (c *= 8) : 7 == e.overscaledZ && (c *= 16),
          c < Me.TILE_GRIDSAMPLES_SPLIT.THE_MIN_SAMPLES &&
            (c = Me.TILE_GRIDSAMPLES_SPLIT.THE_MIN_SAMPLES);
        const u = [],
          h = a / c,
          d = e.overscaledZ;
        let p = [];
        for (let e = 0; e < c; e++) {
          const a = i.prepareSegment(4 * (c + 1), n, r);
          gy(u, 0, e * h, d, s, l, t),
            0 === p.length && (p = u.slice(0)),
            n.emplaceBack(u[0] - p[0], u[1] - p[1], u[2] - p[2], 0, e * h * 4),
            gy(u, 0, (e + 1) * h, d, s, l, t),
            n.emplaceBack(u[0] - p[0], u[1] - p[1], u[2] - p[2], 0, (e + 1) * h * 4),
            (a.vertexLength += 2);
          for (let i = 1; i <= c; i++) {
            gy(u, i * h, e * h, d, s, l, t),
              n.emplaceBack(u[0] - p[0], u[1] - p[1], u[2] - p[2], i * h * 4, e * h * 4),
              gy(u, i * h, (e + 1) * h, d, s, l, t),
              n.emplaceBack(u[0] - p[0], u[1] - p[1], u[2] - p[2], i * h * 4, (e + 1) * h * 4);
            const c = a.vertexLength;
            r.emplaceBack(c - 2, c - 1, c),
              r.emplaceBack(c, c - 1, c + 1),
              o.emplaceBack(c - 2, c - 1),
              o.emplaceBack(c - 1, c),
              o.emplaceBack(c, c - 2),
              o.emplaceBack(c, c - 1),
              o.emplaceBack(c - 1, c + 1),
              o.emplaceBack(c + 1, c),
              (a.vertexLength += 2),
              (a.primitiveLength += 2);
          }
        }
        return {
          sphereSegments: i,
          sphereIndexArray: r,
          sphereMaskedBoundsArray: n,
          wireframeIndexArray: o,
          rtc: p,
        };
      }),
      (e.toDegrees = l),
      (e.toRadians = s),
      (e.triggerPluginCompletionEvent = ld),
      (e.uniqueId = he),
      (e.unpackDepth = sf),
      (e.uuid = de),
      (e.validateStyle = sg),
      (e.values = function (e) {
        const t = [];
        for (const i in e) t.push(e[i]);
        return t;
      }),
      (e.warnOnce = ve),
      (e.window = J),
      (e.wrap = le),
      (e.xyTransformMat4 = Zm);
  });

  define(['./shared'], function (t) {
    'use strict';
    function e(t) {
      const i = typeof t;
      if ('number' === i || 'boolean' === i || 'string' === i || null == t)
        return JSON.stringify(t);
      if (Array.isArray(t)) {
        let i = '[';
        for (const o of t) i += `${e(o)},`;
        return `${i}]`;
      }
      const o = Object.keys(t).sort();
      let n = '{';
      for (let i = 0; i < o.length; i++) n += `${JSON.stringify(o[i])}:${e(t[o[i]])},`;
      return `${n}}`;
    }
    function i(i) {
      let o = '';
      for (const n of t.refProperties) o += `/${e(i[n])}`;
      return o;
    }
    class o {
      constructor(t) {
        t && this.replace(t);
      }
      replace(t) {
        (this._layerConfigs = {}), (this._layers = {}), this.update(t, []);
      }
      update(e, o) {
        for (const i of e) {
          this._layerConfigs[i.id] = i;
          const e = (this._layers[i.id] = t.createStyleLayer(i));
          e._featureFilter = t.createFilter(e.filter);
        }
        for (const t of o) delete this._layerConfigs[t], delete this._layers[t];
        this.familiesBySource = {};
        const n = (function (t) {
          const e = {};
          for (let o = 0; o < t.length; o++) {
            const n = i(t[o]);
            let s = e[n];
            s || (s = e[n] = []), s.push(t[o]);
          }
          const o = [];
          for (const t in e) o.push(e[t]);
          return o;
        })(t.values(this._layerConfigs));
        for (const t of n) {
          const e = t.map((t) => this._layers[t.id]),
            i = e[0];
          if ('none' === i.visibility) continue;
          const o = i.source || '';
          let n = this.familiesBySource[o];
          n || (n = this.familiesBySource[o] = {});
          const s = i.sourceLayer || '_geojsonTileLayer';
          let r = n[s];
          r || (r = n[s] = []), r.push(e);
        }
      }
    }
    function n(t, e, i, o, n) {
      if (void 0 === e.segment) return !0;
      let s = e,
        r = e.segment + 1,
        a = 0;
      for (; a > -i / 2; ) {
        if ((r--, r < 0)) return !1;
        (a -= t[r].dist(s)), (s = t[r]);
      }
      (a += t[r].dist(t[r + 1])), r++;
      const l = [];
      let c = 0;
      for (; a < i / 2; ) {
        const e = t[r],
          i = t[r + 1];
        if (!i) return !1;
        let s = t[r - 1].angleTo(e) - e.angleTo(i);
        for (
          s = Math.abs(((s + 3 * Math.PI) % (2 * Math.PI)) - Math.PI),
            l.push({ distance: a, angleDelta: s }),
            c += s;
          a - l[0].distance > o;

        )
          c -= l.shift().angleDelta;
        if (c > n) return !1;
        r++, (a += e.dist(i));
      }
      return !0;
    }
    function s(t) {
      let e = 0;
      for (let i = 0; i < t.length - 1; i++) e += t[i].dist(t[i + 1]);
      return e;
    }
    function r(t, e, i) {
      return t ? 0.6 * e * i : 0;
    }
    function a(t, e) {
      return Math.max(t ? t.right - t.left : 0, e ? e.right - e.left : 0);
    }
    function l(e, i, o, l, c, h) {
      const u = r(o, c, h),
        p = a(o, l);
      let f = 0;
      const d = s(e) / 2;
      for (let o = 0; o < e.length - 1; o++) {
        const s = e[o],
          r = e[o + 1],
          a = s.dist(r);
        if (f + a > d) {
          const l = (d - f) / a,
            c = t.number(s.x, r.x, l),
            h = t.number(s.y, r.y, l),
            g = new t.Anchor(c, h, r.angleTo(s), o);
          if ((g._round(), u && !n(e, g, p, u, i))) return;
          return g;
        }
        f += a;
      }
    }
    function c(t, e, i, o, n, s, l, c, u) {
      const p = r(o, s, l),
        f = a(o, n),
        d = 0 === t[0].x || t[0].x === u || 0 === t[0].y || t[0].y === u;
      return (
        e - f * l < e / 4 && (e = f * l + e / 4),
        h(t, d ? ((e / 2) * c) % e : ((f / 2 + 2 * s) * l * c) % e, e, p, i, f * l, d, !1, u)
      );
    }
    function h(e, i, o, r, a, l, c, u, p) {
      const f = l / 2,
        d = s(e);
      let g = 0,
        m = i - o,
        y = [];
      for (let i = 0; i < e.length - 1; i++) {
        const s = e[i],
          c = e[i + 1],
          h = s.dist(c),
          u = c.angleTo(s);
        for (; m + o < g + h; ) {
          m += o;
          const x = (m - g) / h,
            v = t.number(s.x, c.x, x),
            w = t.number(s.y, c.y, x);
          if (v >= 0 && v < p && w >= 0 && w < p && m - f >= 0 && m + f <= d) {
            const o = new t.Anchor(v, w, u, i);
            o._round(), (r && !n(e, o, l, r, a)) || y.push(o);
          }
        }
        g += h;
      }
      return u || y.length || c || (y = h(e, g / 2, o, r, a, l, c, !0, p)), y;
    }
    class u {
      constructor() {
        (this.opacity = 0), (this.targetOpacity = 0), (this.time = 0);
      }
      clone() {
        const t = new u();
        return (
          (t.opacity = this.opacity),
          (t.targetOpacity = this.targetOpacity),
          (t.time = this.time),
          t
        );
      }
    }
    t.register('OpacityState', u);
    class p {
      constructor(e, i, o, n, s, r, a, l, c, h, u, p) {
        let f = a.top * l - c,
          d = a.bottom * l + c,
          g = a.left * l - c,
          m = a.right * l + c;
        if (((this.boxStartIndex = e.length), h)) {
          let t = d - f;
          const a = m - g;
          t > 0 &&
            ((t = Math.max(10 * l, t)),
            this._addLineCollisionCircles(e, i, o, o.segment, a, t, n, s, r, u));
        } else {
          if (p) {
            const e = new t.pointGeometry3d(g, f),
              i = new t.pointGeometry3d(m, f),
              o = new t.pointGeometry3d(g, d),
              n = new t.pointGeometry3d(m, d),
              s = (p * Math.PI) / 180;
            e._rotate(s),
              i._rotate(s),
              o._rotate(s),
              n._rotate(s),
              (g = Math.min(e.x, i.x, o.x, n.x)),
              (m = Math.max(e.x, i.x, o.x, n.x)),
              (f = Math.min(e.y, i.y, o.y, n.y)),
              (d = Math.max(e.y, i.y, o.y, n.y));
          }
          e.emplaceBack(o.x, o.y, g, f, m, d, n, s, r, 0, 0);
        }
        this.boxEndIndex = e.length;
      }
      _addLineCollisionCircles(t, e, i, o, n, s, r, a, l, c) {
        const h = s / 2,
          u = Math.floor(n / h) || 1,
          p = 1 + (0.4 * Math.log(c)) / Math.LN2,
          f = Math.floor((u * p) / 2),
          d = -s / 2;
        let g = i,
          m = o + 1,
          y = d;
        const x = -n / 2,
          v = x - n / 4;
        do {
          if ((m--, m < 0)) {
            if (y > x) return;
            m = 0;
            break;
          }
          (y -= e[m].dist(g)), (g = e[m]);
        } while (y > v);
        let w = e[m].dist(e[m + 1]);
        for (let i = -f; i < u + f; i++) {
          const o = i * h;
          let c = x + o;
          if ((o < 0 && (c += o), o > n && (c += o - n), c < y)) continue;
          for (; y + w < c; ) {
            if (((y += w), m++, m + 1 >= e.length)) return;
            w = e[m].dist(e[m + 1]);
          }
          const u = c - y,
            p = e[m],
            f = e[m + 1].sub(p)._unit()._mult(u)._add(p)._round(),
            g = Math.abs(c - d) < h ? 0 : 0.8 * (c - d);
          t.emplaceBack(f.x, f.y, -s / 2, -s / 2, s / 2, s / 2, r, a, l, s / 2, g);
        }
      }
    }
    class f {
      constructor(t = [], e = d) {
        if (
          ((this.data = t), (this.length = this.data.length), (this.compare = e), this.length > 0)
        )
          for (let t = (this.length >> 1) - 1; t >= 0; t--) this._down(t);
      }
      push(t) {
        this.data.push(t), this.length++, this._up(this.length - 1);
      }
      pop() {
        if (0 === this.length) return;
        const t = this.data[0],
          e = this.data.pop();
        return this.length--, this.length > 0 && ((this.data[0] = e), this._down(0)), t;
      }
      peek() {
        return this.data[0];
      }
      _up(t) {
        const { data: e, compare: i } = this,
          o = e[t];
        for (; t > 0; ) {
          const n = (t - 1) >> 1,
            s = e[n];
          if (i(o, s) >= 0) break;
          (e[t] = s), (t = n);
        }
        e[t] = o;
      }
      _down(t) {
        const { data: e, compare: i } = this,
          o = this.length >> 1,
          n = e[t];
        for (; t < o; ) {
          let o = 1 + (t << 1),
            s = e[o];
          const r = o + 1;
          if ((r < this.length && i(e[r], s) < 0 && ((o = r), (s = e[r])), i(s, n) >= 0)) break;
          (e[t] = s), (t = o);
        }
        e[t] = n;
      }
    }
    function d(t, e) {
      return t < e ? -1 : t > e ? 1 : 0;
    }
    function g(e, i = 1, o = !1) {
      let n = 1 / 0,
        s = 1 / 0,
        r = -1 / 0,
        a = -1 / 0;
      const l = e[0];
      for (let t = 0; t < l.length; t++) {
        const e = l[t];
        (!t || e.x < n) && (n = e.x),
          (!t || e.y < s) && (s = e.y),
          (!t || e.x > r) && (r = e.x),
          (!t || e.y > a) && (a = e.y);
      }
      const c = Math.min(r - n, a - s);
      let h = c / 2;
      const u = new f([], m);
      if (0 === c) return new t.pointGeometry3d(n, s);
      for (let t = n; t < r; t += c)
        for (let i = s; i < a; i += c) u.push(new y(t + h, i + h, h, e));
      let p = (function (t) {
          let e = 0,
            i = 0,
            o = 0;
          const n = t[0];
          for (let t = 0, s = n.length, r = s - 1; t < s; r = t++) {
            const s = n[t],
              a = n[r],
              l = s.x * a.y - a.x * s.y;
            (i += (s.x + a.x) * l), (o += (s.y + a.y) * l), (e += 3 * l);
          }
          return new y(i / e, o / e, 0, t);
        })(e),
        d = u.length;
      for (; u.length; ) {
        const t = u.pop();
        (t.d > p.d || !p.d) &&
          ((p = t),
          o && console.warn('found best %d after %d probes', Math.round(1e4 * t.d) / 1e4, d)),
          t.max - p.d <= i ||
            ((h = t.h / 2),
            u.push(new y(t.p.x - h, t.p.y - h, h, e)),
            u.push(new y(t.p.x + h, t.p.y - h, h, e)),
            u.push(new y(t.p.x - h, t.p.y + h, h, e)),
            u.push(new y(t.p.x + h, t.p.y + h, h, e)),
            (d += 4));
      }
      return o && (console.warn(`num probes: ${d}`), console.warn(`best distance: ${p.d}`)), p.p;
    }
    function m(t, e) {
      return e.max - t.max;
    }
    function y(e, i, o, n) {
      (this.p = new t.pointGeometry3d(e, i)),
        (this.h = o),
        (this.d = (function (e, i) {
          let o = !1,
            n = 1 / 0;
          for (let s = 0; s < i.length; s++) {
            const r = i[s];
            for (let i = 0, s = r.length, a = s - 1; i < s; a = i++) {
              const s = r[i],
                l = r[a];
              s.y > e.y != l.y > e.y &&
                e.x < ((l.x - s.x) * (e.y - s.y)) / (l.y - s.y) + s.x &&
                (o = !o),
                (n = Math.min(n, t.distToSegmentSquared(e, s, l)));
            }
          }
          return (o ? 1 : -1) * Math.sqrt(n);
        })(this.p, n)),
        (this.max = this.d + this.h * Math.SQRT2);
    }
    function x(e, i, o, n, s, r, a) {
      e.createArrays(),
        (e.symbolInstances = []),
        (e.tilePixelRatio = t.EXTENT / (512 * e.overscaling)),
        (e.compareText = {}),
        (e.iconsNeedLinear = !1);
      const l = e.layers[0].layout,
        c = e.layers[0]._unevaluatedLayout._values,
        h = {};
      if ('composite' === e.textSizeData.functionType) {
        const { min: i, max: o } = e.textSizeData.zoomRange;
        h.compositeTextSizes = [
          c['text-size'].possiblyEvaluate(new t.EvaluationParameters(i), a),
          c['text-size'].possiblyEvaluate(new t.EvaluationParameters(o), a),
        ];
      }
      if ('composite' === e.iconSizeData.functionType) {
        const { min: i, max: o } = e.iconSizeData.zoomRange;
        h.compositeIconSizes = [
          c['icon-size'].possiblyEvaluate(new t.EvaluationParameters(i), a),
          c['icon-size'].possiblyEvaluate(new t.EvaluationParameters(o), a),
        ];
      }
      (h.layoutTextSize = c['text-size'].possiblyEvaluate(
        new t.EvaluationParameters(e.zoom + 1),
        a,
      )),
        (h.layoutIconSize = c['icon-size'].possiblyEvaluate(
          new t.EvaluationParameters(e.zoom + 1),
          a,
        )),
        (h.textMaxSize = c['text-size'].possiblyEvaluate(new t.EvaluationParameters(18)));
      const u = 24,
        p = l.get('text-line-height') * u,
        f = 'map' === l.get('text-rotation-alignment') && 'point' !== l.get('symbol-placement'),
        d = l.get('text-keep-upright');
      for (const r of e.features) {
        const c = l.get('text-font').evaluate(r, {}, a).join(','),
          g = o,
          m = {},
          y = r.text;
        let x,
          w = [0, 0];
        if (y) {
          const e = y instanceof t.Formatted ? y.toString() : y;
          w = l
            .get('text-offset')
            .evaluate(r, {}, a)
            .map((t) => t * u);
          const o = l.get('text-letter-spacing').evaluate(r, {}, a) * u,
            n = t.allowsLetterSpacing(e) ? o : 0,
            s = l.get('text-anchor').evaluate(r, {}, a),
            h = l.get('text-justify').evaluate(r, {}, a),
            g =
              'point' === l.get('symbol-placement')
                ? l.get('text-max-width').evaluate(r, {}, a) * u
                : 0;
          (m.horizontal = t.shapeText(y, i, c, g, p, s, h, n, w, u, t.WritingMode.horizontal, r)),
            t.allowsVerticalWritingMode(e) &&
              f &&
              d &&
              (m.vertical = t.shapeText(y, i, c, g, p, s, h, n, w, u, t.WritingMode.vertical, r));
        }
        let b = !1;
        if (r.icon) {
          const i = n[r.icon];
          i &&
            ((x = t.shapeIcon(
              s[r.icon],
              l.get('icon-offset').evaluate(r, {}, a),
              l.get('icon-anchor').evaluate(r, {}, a),
            )),
            (b = i.sdf),
            void 0 === e.sdfIcons
              ? (e.sdfIcons = i.sdf)
              : e.sdfIcons !== i.sdf &&
                t.warnOnce('Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer'),
            (i.pixelRatio !== e.pixelRatio || 0 !== l.get('icon-rotate').constantOr(1)) &&
              (e.iconsNeedLinear = !0));
        }
        (m.horizontal || x) && v(e, r, m, x, g, h, 0, a);
      }
      r && e.generateCollisionDebugBuffers();
    }
    function v(e, i, o, n, s, r, a, h) {
      const f = r.layoutTextSize.evaluate(i, {}, h),
        d = r.layoutIconSize.evaluate(i, {}, h);
      let m = r.textMaxSize.evaluate(i, {}, h);
      void 0 === m && (m = f);
      const y = e.layers[0].layout,
        x = y.get('text-offset').evaluate(i, {}, h),
        v = y.get('icon-offset').evaluate(i, {}, h),
        S = e.tilePixelRatio * (f / 24),
        M = (e.tilePixelRatio * m) / 24,
        _ = e.tilePixelRatio * d,
        I = e.tilePixelRatio * y.get('symbol-spacing'),
        T = y.get('text-padding') * e.tilePixelRatio,
        P = y.get('icon-padding') * e.tilePixelRatio,
        L = (y.get('text-max-angle') / 180) * Math.PI,
        k = 'map' === y.get('text-rotation-alignment') && 'point' !== y.get('symbol-placement'),
        z = 'map' === y.get('icon-rotation-alignment') && 'point' !== y.get('symbol-placement'),
        O = y.get('symbol-placement'),
        E = I / 2,
        C = (a, l) => {
          l.x < 0 ||
            l.x >= t.EXTENT ||
            l.y < 0 ||
            l.y >= t.EXTENT ||
            e.symbolInstances.push(
              (function (e, i, o, n, s, r, a, l, c, h, f, d, g, m, y, x, v, b, S, M, _, I, T) {
                const P = e.addToLineVertexArray(i, o);
                let L,
                  k,
                  z = 0,
                  O = 0,
                  E = 0;
                const C = n.horizontal ? n.horizontal.text : '',
                  D = [];
                if (n.horizontal) {
                  const s = r.layout.get('text-rotate').evaluate(S, {}, T);
                  (L = new p(a, o, i, l, c, h, n.horizontal, f, d, g, e.overscaling, s)),
                    (O += w(
                      e,
                      i,
                      n.horizontal,
                      r,
                      g,
                      S,
                      m,
                      P,
                      n.vertical ? t.WritingMode.horizontal : t.WritingMode.horizontalOnly,
                      D,
                      M,
                      _,
                      T,
                    )),
                    n.vertical &&
                      (E += w(e, i, n.vertical, r, g, S, m, P, t.WritingMode.vertical, D, M, _, T));
                }
                const R = L ? L.boxStartIndex : e.collisionBoxArray.length,
                  j = L ? L.boxEndIndex : e.collisionBoxArray.length;
                if (s) {
                  const u = (function (e, i, o, n, s, r) {
                      const a = i.image,
                        l = o.layout,
                        c = i.top - 1 / a.pixelRatio,
                        h = i.left - 1 / a.pixelRatio,
                        u = i.bottom + 1 / a.pixelRatio,
                        p = i.right + 1 / a.pixelRatio;
                      let f, d, g, m, y;
                      if ('none' !== l.get('icon-text-fit') && s) {
                        const e = p - h,
                          i = u - c,
                          o = l.get('text-size').evaluate(r, {}) / 24,
                          n = s.left * o,
                          a = s.top * o,
                          y = s.right * o - n,
                          x = s.bottom * o - a,
                          v = l.get('icon-text-fit-padding')[0],
                          w = l.get('icon-text-fit-padding')[1],
                          b = l.get('icon-text-fit-padding')[2],
                          S = l.get('icon-text-fit-padding')[3],
                          M = 'width' === l.get('icon-text-fit') ? 0.5 * (x - i) : 0,
                          _ = 'height' === l.get('icon-text-fit') ? 0.5 * (y - e) : 0,
                          I =
                            'width' === l.get('icon-text-fit') || 'both' === l.get('icon-text-fit')
                              ? y
                              : e,
                          T =
                            'height' === l.get('icon-text-fit') || 'both' === l.get('icon-text-fit')
                              ? x
                              : i;
                        (f = new t.pointGeometry3d(n + _ - S, a + M - v)),
                          (d = new t.pointGeometry3d(n + _ + w + I, a + M - v)),
                          (g = new t.pointGeometry3d(n + _ + w + I, a + M + b + T)),
                          (m = new t.pointGeometry3d(n + _ - S, a + M + b + T));
                      } else
                        (f = new t.pointGeometry3d(h, c)),
                          (d = new t.pointGeometry3d(p, c)),
                          (g = new t.pointGeometry3d(p, u)),
                          (m = new t.pointGeometry3d(h, u));
                      if (
                        ((y =
                          'symtracking' !== o.type ||
                          (o.layout.get('symtracking-display-mode') !==
                            t.LAYER_LAYOUT_CONSTS.SYMTRACKING_DISPLAY_MODE.SEQUENCE &&
                            o.layout.get('symtracking-display-mode') !==
                              t.LAYER_LAYOUT_CONSTS.SYMTRACKING_DISPLAY_MODE.TIMESTAMP)
                            ? 'symtracking' !== o.type || o.layout.get('compatible-mode')
                              ? 'symtracking' === o.type
                                ? (function (t, e) {
                                    const i = t.geometry[0];
                                    return (i.length > 2 &&
                                      (!t.properties.hasOwnProperty('name') ||
                                        -1 === t.properties.name.indexOf('箭头'))) ||
                                      1 === i.length
                                      ? 0
                                      : i[1].angleTo(i[0]) + 0;
                                  })(r)
                                : (o.layout.get('icon-rotate').evaluate(r, {}) * Math.PI) / 180
                              : (r.properties.car_rotate * Math.PI) / 180
                            : (o.layout.get('icon-rotate').evaluate(r, {}) * Math.PI) / 180),
                        y)
                      ) {
                        const t = Math.sin(y),
                          e = Math.cos(y),
                          i = [e, -t, t, e];
                        f._matMult(i), d._matMult(i), m._matMult(i), g._matMult(i);
                      }
                      return [
                        {
                          tl: f,
                          tr: d,
                          bl: m,
                          br: g,
                          tex: a.paddedRect,
                          writingMode: void 0,
                          glyphOffset: [0, 0],
                        },
                      ];
                    })(0, s, r, 0, n.horizontal, S),
                    f = r.layout.get('icon-rotate').evaluate(S, {}, T);
                  (k = new p(a, o, i, l, c, h, s, y, x, !1, e.overscaling, f)), (z = 4 * u.length);
                  const d = e.iconSizeData;
                  let g = null;
                  'source' === d.functionType
                    ? (g = [10 * r.layout.get('icon-size').evaluate(S, {}, T)])
                    : 'composite' === d.functionType &&
                      (g = [
                        10 * _.compositeIconSizes[0].evaluate(S, {}, T),
                        10 * _.compositeIconSizes[1].evaluate(S, {}, T),
                      ]),
                    (e.type != t.VectorLayerType.SYMBOL &&
                      e.type != t.VectorLayerType.SYMTRACKING) ||
                      e.addSymbols(e.icon, u, g, b, v, S, !1, i, P.lineStartIndex, P.lineLength, T);
                }
                const V = k ? k.boxStartIndex : e.collisionBoxArray.length,
                  A = k ? k.boxEndIndex : e.collisionBoxArray.length;
                return (
                  e.glyphOffsetArray.length >= t.SymbolBucket.MAX_GLYPHS &&
                    t.warnOnce(
                      'Too many glyphs being rendered in a tile. See https://github.com/minemap/minemap-gl-js/issues/2907',
                    ),
                  {
                    key: C,
                    textBoxStartIndex: R,
                    textBoxEndIndex: j,
                    iconBoxStartIndex: V,
                    iconBoxEndIndex: A,
                    textOffset: m,
                    iconOffset: b,
                    anchor: i,
                    line: o,
                    featureIndex: l,
                    feature: S,
                    numGlyphVertices: O,
                    numVerticalGlyphVertices: E,
                    numIconVertices: z,
                    textOpacityState: new u(),
                    iconOpacityState: new u(),
                    isDuplicate: !1,
                    placedTextSymbolIndices: D,
                    crossTileID: 0,
                  }
                );
              })(
                e,
                l,
                a,
                o,
                n,
                e.layers[0],
                e.collisionBoxArray,
                i.index,
                i.sourceLayerIndex,
                e.index,
                S,
                T,
                k,
                x,
                _,
                P,
                z,
                v,
                i,
                s,
                r,
                0,
                h,
              ),
            );
        };
      if ('line' === O)
        for (const s of t.clipLine(i.geometry, 0, 0, t.EXTENT, t.EXTENT)) {
          const i = c(s, I, L, o.vertical || o.horizontal, n, 24, M, e.overscaling, t.EXTENT);
          for (const t of i) {
            const i = o.horizontal;
            (i && b(e, i.text, E, t)) || C(s, t);
          }
        }
      else if ('line-center' === O) {
        for (const t of i.geometry)
          if (t.length > 1) {
            const e = l(t, L, o.vertical || o.horizontal, n, 24, M);
            e && C(t, e);
          }
      } else if ('Polygon' === i.type)
        for (const e of t.classifyRings(i.geometry, 0)) {
          const i = g(e, 16);
          C(e[0], new t.Anchor(i.x, i.y, 0));
        }
      else if ('LineString' === i.type)
        for (const e of i.geometry) C(e, new t.Anchor(e[0].x, e[0].y, 0));
      else if ('Point' === i.type)
        for (const e of i.geometry) for (const i of e) C([i], new t.Anchor(i.x, i.y, 0));
    }
    function w(e, i, o, n, s, r, a, l, c, h, u, p, f) {
      const d = (function (e, i, o, n, s, r) {
          const a = (o.layout.get('text-rotate').evaluate(s, {}) * Math.PI) / 180,
            l = o.layout
              .get('text-offset')
              .evaluate(s, {})
              .map((t) => 24 * t),
            c = i.positionedGlyphs,
            h = [];
          for (let e = 0; e < c.length; e++) {
            const o = c[e],
              s = r[o.fontStack],
              u = s && s[o.glyph];
            if (!u) continue;
            const p = u.rect;
            if (!p) continue;
            const f = t.GLYPH_PBF_BORDER + 1,
              d = (u.metrics.advance * o.scale) / 2,
              g = n ? [o.x + d, o.y] : [0, 0],
              m = n ? [0, 0] : [o.x + d + l[0], o.y + l[1]],
              y = (u.metrics.left - f) * o.scale - d + m[0],
              x = (-u.metrics.top - f) * o.scale + m[1],
              v = y + p.w * o.scale,
              w = x + p.h * o.scale,
              b = new t.pointGeometry3d(y, x),
              S = new t.pointGeometry3d(v, x),
              M = new t.pointGeometry3d(y, w),
              _ = new t.pointGeometry3d(v, w);
            if (n && o.vertical) {
              const e = new t.pointGeometry3d(-d, d),
                i = -Math.PI / 2,
                o = new t.pointGeometry3d(5, 0);
              b._rotateAround(i, e)._add(o),
                S._rotateAround(i, e)._add(o),
                M._rotateAround(i, e)._add(o),
                _._rotateAround(i, e)._add(o);
            }
            if (a) {
              const t = Math.sin(a),
                e = Math.cos(a),
                i = [e, -t, t, e];
              b._matMult(i), S._matMult(i), M._matMult(i), _._matMult(i);
            }
            h.push({
              tl: b,
              tr: S,
              bl: M,
              br: _,
              tex: p,
              writingMode: i.writingMode,
              glyphOffset: g,
            });
          }
          return h;
        })(0, o, n, s, r, u),
        g = e.textSizeData;
      let m = null;
      return (
        'source' === g.functionType
          ? (m = [10 * n.layout.get('text-size').evaluate(r, {}, f)])
          : 'composite' === g.functionType &&
            (m = [
              10 * p.compositeTextSizes[0].evaluate(r, {}, f),
              10 * p.compositeTextSizes[1].evaluate(r, {}, f),
            ]),
        (e.type != t.VectorLayerType.SYMBOL && e.type != t.VectorLayerType.SYMTRACKING) ||
          e.addSymbols(e.text, d, m, a, s, r, c, i, l.lineStartIndex, l.lineLength, f),
        h.push(e.text.placedSymbolArray.length - 1),
        4 * d.length
      );
    }
    function b(t, e, i, o) {
      const n = t.compareText;
      if (e in n) {
        const t = n[e];
        for (let e = t.length - 1; e >= 0; e--) if (o.dist(t[e]) < i) return !0;
      } else n[e] = [];
      return n[e].push(o), !1;
    }
    function S(t, e, i) {
      (i = i || {}),
        (this.w = t || 64),
        (this.h = e || 64),
        (this.autoResize = !!i.autoResize),
        (this.shelves = []),
        (this.freebins = []),
        (this.stats = {}),
        (this.bins = {}),
        (this.maxId = 0);
    }
    function M(t, e, i) {
      (this.x = 0), (this.y = t), (this.w = this.free = e), (this.h = i);
    }
    function _(t, e, i, o, n, s, r) {
      (this.id = t),
        (this.x = e),
        (this.y = i),
        (this.w = o),
        (this.h = n),
        (this.maxw = s || o),
        (this.maxh = r || n),
        (this.refcount = 0);
    }
    (S.prototype.pack = function (t, e) {
      (t = [].concat(t)), (e = e || {});
      for (var i, o, n, s = [], r = 0; r < t.length; r++)
        if (((o = t[r].h || t[r].height), (i = t[r].w || t[r].width) && o)) {
          if (!(n = this.packOne(i, o, t[r].id))) continue;
          e.inPlace && ((t[r].x = n.x), (t[r].y = n.y), (t[r].id = n.id)), s.push(n);
        }
      return this.shrink(), s;
    }),
      (S.prototype.packOne = function (t, e, i) {
        var o,
          n,
          s,
          r,
          a,
          l,
          c,
          h,
          u = { freebin: -1, shelf: -1, waste: 1 / 0 },
          p = 0;
        if ('string' == typeof i || 'number' == typeof i) {
          if ((o = this.getBin(i))) return this.ref(o), o;
          'number' == typeof i && (this.maxId = Math.max(i, this.maxId));
        } else i = ++this.maxId;
        for (r = 0; r < this.freebins.length; r++) {
          if (e === (o = this.freebins[r]).maxh && t === o.maxw)
            return this.allocFreebin(r, t, e, i);
          e > o.maxh ||
            t > o.maxw ||
            (e <= o.maxh &&
              t <= o.maxw &&
              (s = o.maxw * o.maxh - t * e) < u.waste &&
              ((u.waste = s), (u.freebin = r)));
        }
        for (r = 0; r < this.shelves.length; r++)
          if (((p += (n = this.shelves[r]).h), !(t > n.free))) {
            if (e === n.h) return this.allocShelf(r, t, e, i);
            e > n.h ||
              (e < n.h &&
                (s = (n.h - e) * t) < u.waste &&
                ((u.freebin = -1), (u.waste = s), (u.shelf = r)));
          }
        return -1 !== u.freebin
          ? this.allocFreebin(u.freebin, t, e, i)
          : -1 !== u.shelf
          ? this.allocShelf(u.shelf, t, e, i)
          : e <= this.h - p && t <= this.w
          ? ((n = new M(p, this.w, e)), this.allocShelf(this.shelves.push(n) - 1, t, e, i))
          : this.autoResize
          ? ((a = l = this.h),
            ((c = h = this.w) <= a || t > c) && (h = 2 * Math.max(t, c)),
            (a < c || e > a) && (l = 2 * Math.max(e, a)),
            this.resize(h, l),
            this.packOne(t, e, i))
          : null;
      }),
      (S.prototype.allocFreebin = function (t, e, i, o) {
        var n = this.freebins.splice(t, 1)[0];
        return (
          (n.id = o), (n.w = e), (n.h = i), (n.refcount = 0), (this.bins[o] = n), this.ref(n), n
        );
      }),
      (S.prototype.allocShelf = function (t, e, i, o) {
        var n = this.shelves[t].alloc(e, i, o);
        return (this.bins[o] = n), this.ref(n), n;
      }),
      (S.prototype.shrink = function () {
        if (this.shelves.length > 0) {
          for (var t = 0, e = 0, i = 0; i < this.shelves.length; i++) {
            var o = this.shelves[i];
            (e += o.h), (t = Math.max(o.w - o.free, t));
          }
          this.resize(t, e);
        }
      }),
      (S.prototype.getBin = function (t) {
        return this.bins[t];
      }),
      (S.prototype.ref = function (t) {
        if (1 == ++t.refcount) {
          var e = t.h;
          this.stats[e] = 1 + (0 | this.stats[e]);
        }
        return t.refcount;
      }),
      (S.prototype.unref = function (t) {
        return 0 === t.refcount
          ? 0
          : (0 == --t.refcount &&
              (this.stats[t.h]--, delete this.bins[t.id], this.freebins.push(t)),
            t.refcount);
      }),
      (S.prototype.clear = function () {
        (this.shelves = []),
          (this.freebins = []),
          (this.stats = {}),
          (this.bins = {}),
          (this.maxId = 0);
      }),
      (S.prototype.resize = function (t, e) {
        (this.w = t), (this.h = e);
        for (var i = 0; i < this.shelves.length; i++) this.shelves[i].resize(t);
        return !0;
      }),
      (M.prototype.alloc = function (t, e, i) {
        if (t > this.free || e > this.h) return null;
        var o = this.x;
        return (this.x += t), (this.free -= t), new _(i, o, this.y, t, e, t, this.h);
      }),
      (M.prototype.resize = function (t) {
        return (this.free += t - this.w), (this.w = t), !0;
      });
    class I {
      constructor(e) {
        const i = new t.AlphaImage({ width: 0, height: 0 }),
          o = {},
          n = new S(0, 0, { autoResize: !0 });
        for (const s in e) {
          const r = e[s],
            a = (o[s] = {});
          for (const e in r) {
            const o = r[+e];
            if (o && 0 !== o.bitmap.width && 0 !== o.bitmap.height) {
              const s = n.packOne(o.bitmap.width + 2, o.bitmap.height + 2);
              i.resize({ width: n.w, height: n.h }),
                t.AlphaImage.copy(
                  o.bitmap,
                  i,
                  { x: 0, y: 0 },
                  { x: s.x + 1, y: s.y + 1 },
                  o.bitmap,
                ),
                (a[e] = { rect: s, metrics: o.metrics });
            }
          }
        }
        n.shrink(), i.resize({ width: n.w, height: n.h }), (this.image = i), (this.positions = o);
      }
    }
    t.register('GlyphAtlas', I);
    class T {
      constructor(e) {
        (this.tileID = new t.OverscaledTileID(
          e.tileID.overscaledZ,
          e.tileID.wrap,
          e.tileID.canonical.z,
          e.tileID.canonical.x,
          e.tileID.canonical.y,
          this.projection,
        )),
          (this.uid = e.uid),
          (this.zoom = e.zoom),
          (this.pixelRatio = e.pixelRatio),
          (this.tileSize = e.tileSize),
          (this.source = e.source),
          (this.overscaling = this.tileID.overscaleFactor()),
          (this.showCollisionBoxes = e.showCollisionBoxes),
          (this.collectResourceTiming = !!e.collectResourceTiming),
          (this.projection = e.projection || t.ProjectionType.MERCATOR),
          (this.promoteId = e.promoteId);
      }
      parse(e, i, o, n, s) {
        (this.status = 'parsing'),
          (this.data = e),
          (this.collisionBoxArray = new t.CollisionBoxArray());
        const r = new t.DictionaryCoder(Object.keys(e.layers).sort()),
          a = new t.FeatureIndex(this.tileID, this.promoteId, this.projection);
        a.bucketLayerIDs = [];
        const l = {},
          c = {
            featureIndex: a,
            iconDependencies: {},
            glyphDependencies: {},
            patternDependencies: {},
            x: this.tileID.canonical.x,
            y: this.tileID.canonical.y,
            z: this.tileID.canonical.z,
            availableImages: o,
          },
          h = i.familiesBySource[this.source];
        for (const i in h) {
          const n = e.layers[i];
          if (!n) continue;
          1 === n.version &&
            t.warnOnce(
              `Vector tile source "${this.source}" layer "${i}" does not use vector tile spec v2 and therefore may have some rendering errors.`,
            );
          const s = r.encode(i),
            u = [];
          for (let t = 0; t < n.length; t++) {
            const e = n.feature(t),
              o = a.getId(e, i);
            (e.id = o), u.push({ feature: e, index: t, sourceLayerIndex: s });
          }
          for (const t of h[i]) {
            const e = t[0];
            (e.minzoom && this.zoom < Math.floor(e.minzoom)) ||
              (e.maxzoom && this.zoom >= e.maxzoom) ||
              ('none' !== e.visibility &&
                (P(t, this.zoom, o),
                (l[e.id] = e.createBucket({
                  index: a.bucketLayerIDs.length,
                  layers: t,
                  zoom: this.zoom,
                  pixelRatio: this.pixelRatio,
                  overscaling: this.overscaling,
                  collisionBoxArray: this.collisionBoxArray,
                  sourceLayerIndex: s,
                  sourceID: this.source,
                  projection: this.projection,
                })).populate(u, c, this.tileID.canonical),
                a.bucketLayerIDs.push(t.map((t) => t.id))));
          }
        }
        let u, p, f, d;
        const g = t.mapObject(c.glyphDependencies, (t) => Object.keys(t).map(Number));
        Object.keys(g).length
          ? n.send('getGlyphs', { uid: this.uid, stacks: g }, (t, e) => {
              u || ((u = t), (p = e), v.call(this));
            })
          : (p = {});
        const m = Object.keys(c.iconDependencies);
        m.length
          ? n.send(
              'getImages',
              { icons: m, source: this.source, tileID: this.tileID, type: 'icons' },
              (t, e) => {
                u || ((u = t), (f = e), v.call(this));
              },
            )
          : (f = {});
        const y = Object.keys(c.patternDependencies);
        function v() {
          if (u) return s(u);
          if (p && f && d) {
            const e = new I(p),
              i = new t.ImageAtlas(f, d);
            for (const n in l) {
              const s = l[n];
              s.type == t.VectorLayerType.SYMBOL || s.type == t.VectorLayerType.SYMTRACKING
                ? (P(s.layers, this.zoom, o),
                  x(
                    s,
                    p,
                    e.positions,
                    f,
                    i.iconPositions,
                    this.showCollisionBoxes,
                    this.tileID.canonical,
                  ))
                : !s.hasPattern ||
                  (s.type != t.VectorLayerType.LINE &&
                    s.type != t.VectorLayerType.SPRITE &&
                    s.type != t.VectorLayerType.FILL) ||
                  (P(s.layers, this.zoom, o),
                  s.addFeatures(c, this.tileID.canonical, i.patternPositions));
            }
            (this.status = 'done'),
              s(null, {
                buckets: t.values(l).filter((t) => !t.isEmpty()),
                featureIndex: a,
                collisionBoxArray: this.collisionBoxArray,
                glyphAtlasImage: e.image,
                imageAtlas: i,
              });
          }
        }
        y.length
          ? n.send(
              'getImages',
              { icons: y, source: this.source, tileID: this.tileID, type: 'patterns' },
              (t, e) => {
                u || ((u = t), (d = e), v.call(this));
              },
            )
          : (d = {}),
          v.call(this);
      }
    }
    function P(e, i, o) {
      const n = new t.EvaluationParameters(i);
      for (const t of e) t.recalculate(n, o);
    }
    const L = t.window.performance;
    function k(t) {
      const e = t ? t.url.toString() : void 0;
      return L.getEntriesByName(e);
    }
    class z {
      constructor(t, e, i, o) {
        (this.actor = t),
          (this.layerIndex = e),
          (this.loadVectorData = this.loadVectorTile),
          (this.loading = {}),
          (this.loaded = {}),
          (this.availableImages = i),
          (this.projection = o);
      }
      registRequestController(t) {
        this.vrc = t;
      }
      loadVectorTile(e, i) {
        return this.vrc.pushRequest({
          id: e.uid,
          param: e.request,
          cb: (o, n, s, r) => {
            if (o) i(o);
            else if (n) {
              const o = new t.mvt.VectorTile(new t.pbf(n), null, e && e.projection);
              i(null, { vectorTile: o, rawData: n, cacheControl: s, expires: r });
            }
          },
        });
      }
      setDataLoaderFunction(t) {
        t && (this.loadVectorData = t);
      }
      loadTile(e, i) {
        const o = e.uid,
          n = e && e.request,
          s = n && n.collectResourceTiming;
        this.loading || (this.loading = {});
        const r = (this.loading[o] = new T(e));
        (r.hasRequest = this.loadVectorData(
          e,
          (e, a) => {
            if ((delete this.loading[o], e || !a)) return i(e);
            const l = a.rawData,
              c = {};
            a.expires && (c.expires = a.expires),
              a.cacheControl && (c.cacheControl = a.cacheControl);
            const h = {};
            if (s) {
              const t = k(n);
              t.length > 0 && (h.resourceTiming = JSON.parse(JSON.stringify(t)));
            }
            (r.vectorTile = a.vectorTile),
              r.parse(a.vectorTile, this.layerIndex, this.availableImages, this.actor, (e, o) => {
                if (e || !o) return i(e);
                i(null, t.extend({ rawTileData: l.slice(0), bbx: a.bbx }, o, c, h));
              }),
              (this.loaded = this.loaded || {}),
              (this.loaded[o] = r);
          },
          this.projection,
        )),
          this.vrc && this.vrc.run();
      }
      reloadTile(t, e) {
        const i = this.loaded,
          o = t.uid,
          n = this;
        if (i && i[o]) {
          const s = i[o];
          s.showCollisionBoxes = t.showCollisionBoxes;
          const r = (t, i) => {
            const o = s.reloadCallback;
            o &&
              (delete s.reloadCallback,
              s.parse(s.vectorTile, n.layerIndex, this.availableImages, n.actor, o)),
              e(t, i);
          };
          'parsing' === s.status
            ? (s.reloadCallback = r)
            : 'done' === s.status &&
              s.parse(s.vectorTile, this.layerIndex, this.availableImages, this.actor, r);
        }
      }
      abortTile(t, e) {
        const i = this.loading,
          o = t.uid;
        i && i[o] && i[o].hasRequest && (this.vrc.removeRequestById(o), delete i[o]), e();
      }
      removeTile(t, e) {
        const i = this.loaded,
          o = t.uid;
        i && i[o] && delete i[o], e();
      }
    }
    var O = function t(e, i) {
      var o,
        n = e && e.type;
      if ('FeatureCollection' === n) for (o = 0; o < e.features.length; o++) t(e.features[o], i);
      else if ('GeometryCollection' === n)
        for (o = 0; o < e.geometries.length; o++) t(e.geometries[o], i);
      else if ('Feature' === n) t(e.geometry, i);
      else if ('Polygon' === n) E(e.coordinates, i);
      else if ('MultiPolygon' === n)
        for (o = 0; o < e.coordinates.length; o++) E(e.coordinates[o], i);
      return e;
    };
    function E(t, e) {
      if (0 !== t.length) {
        C(t[0], e);
        for (var i = 1; i < t.length; i++) C(t[i], !e);
      }
    }
    function C(t, e) {
      for (var i = 0, o = 0, n = 0, s = t.length, r = s - 1; n < s; r = n++) {
        var a = (t[n][0] - t[r][0]) * (t[r][1] + t[n][1]),
          l = i + a;
        (o += Math.abs(i) >= Math.abs(a) ? i - l + a : a - l + i), (i = l);
      }
      i + o >= 0 != !!e && t.reverse();
    }
    const D = t.mvt.VectorTileFeature.prototype.toGeoJSON;
    class R {
      constructor(e, i) {
        (this._feature = e),
          (this.extent = t.EXTENT),
          (this.type = e.type),
          (this.properties = e.tags),
          (this.projObj = t.getProjection(i)),
          'id' in e && !isNaN(e.id) && (this.id = parseInt(e.id, 10));
      }
      loadGeometry() {
        if (1 === this._feature.type) {
          const e = [];
          for (const i of this._feature.geometry) e.push([new t.pointGeometry3d(...i)]);
          return e;
        }
        {
          const e = [];
          for (const i of this._feature.geometry) {
            const o = [];
            for (const e of i) o.push(new t.pointGeometry3d(...e));
            e.push(o);
          }
          return e;
        }
      }
      toGeoJSON(t, e, i) {
        return D.call(this, t, e, i);
      }
    }
    class j {
      constructor(e, i) {
        (this.layers = { _geojsonTileLayer: this }),
          (this.name = '_geojsonTileLayer'),
          (this.extent = t.EXTENT),
          (this.length = e.length),
          (this._features = e),
          (this.projection = i);
      }
      feature(t) {
        return new R(this._features[t], this.projection);
      }
    }
    var V = A;
    function A(t, e) {
      (this.x = t), (this.y = e);
    }
    (A.prototype = {
      clone: function () {
        return new A(this.x, this.y);
      },
      add: function (t) {
        return this.clone()._add(t);
      },
      sub: function (t) {
        return this.clone()._sub(t);
      },
      multByPoint: function (t) {
        return this.clone()._multByPoint(t);
      },
      divByPoint: function (t) {
        return this.clone()._divByPoint(t);
      },
      mult: function (t) {
        return this.clone()._mult(t);
      },
      div: function (t) {
        return this.clone()._div(t);
      },
      rotate: function (t) {
        return this.clone()._rotate(t);
      },
      rotateAround: function (t, e) {
        return this.clone()._rotateAround(t, e);
      },
      matMult: function (t) {
        return this.clone()._matMult(t);
      },
      unit: function () {
        return this.clone()._unit();
      },
      perp: function () {
        return this.clone()._perp();
      },
      round: function () {
        return this.clone()._round();
      },
      mag: function () {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      },
      equals: function (t) {
        return this.x === t.x && this.y === t.y;
      },
      dist: function (t) {
        return Math.sqrt(this.distSqr(t));
      },
      distSqr: function (t) {
        var e = t.x - this.x,
          i = t.y - this.y;
        return e * e + i * i;
      },
      angle: function () {
        return Math.atan2(this.y, this.x);
      },
      angleTo: function (t) {
        return Math.atan2(this.y - t.y, this.x - t.x);
      },
      angleWith: function (t) {
        return this.angleWithSep(t.x, t.y);
      },
      angleWithSep: function (t, e) {
        return Math.atan2(this.x * e - this.y * t, this.x * t + this.y * e);
      },
      _matMult: function (t) {
        var e = t[2] * this.x + t[3] * this.y;
        return (this.x = t[0] * this.x + t[1] * this.y), (this.y = e), this;
      },
      _add: function (t) {
        return (this.x += t.x), (this.y += t.y), this;
      },
      _sub: function (t) {
        return (this.x -= t.x), (this.y -= t.y), this;
      },
      _mult: function (t) {
        return (this.x *= t), (this.y *= t), this;
      },
      _div: function (t) {
        return (this.x /= t), (this.y /= t), this;
      },
      _multByPoint: function (t) {
        return (this.x *= t.x), (this.y *= t.y), this;
      },
      _divByPoint: function (t) {
        return (this.x /= t.x), (this.y /= t.y), this;
      },
      _unit: function () {
        return this._div(this.mag()), this;
      },
      _perp: function () {
        var t = this.y;
        return (this.y = this.x), (this.x = -t), this;
      },
      _rotate: function (t) {
        var e = Math.cos(t),
          i = Math.sin(t),
          o = i * this.x + e * this.y;
        return (this.x = e * this.x - i * this.y), (this.y = o), this;
      },
      _rotateAround: function (t, e) {
        var i = Math.cos(t),
          o = Math.sin(t),
          n = e.y + o * (this.x - e.x) + i * (this.y - e.y);
        return (this.x = e.x + i * (this.x - e.x) - o * (this.y - e.y)), (this.y = n), this;
      },
      _round: function () {
        return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
      },
    }),
      (A.convert = function (t) {
        return t instanceof A ? t : Array.isArray(t) ? new A(t[0], t[1]) : t;
      });
    var G = N;
    function N(t, e, i, o, n) {
      (this.properties = {}),
        (this.extent = i),
        (this.type = 0),
        (this._pbf = t),
        (this._geometry = -1),
        (this._keys = o),
        (this._values = n),
        t.readFields(B, this, e);
    }
    function B(t, e, i) {
      1 == t
        ? (e.id = i.readVarint())
        : 2 == t
        ? (function (t, e) {
            for (var i = t.readVarint() + t.pos; t.pos < i; ) {
              var o = e._keys[t.readVarint()],
                n = e._values[t.readVarint()];
              e.properties[o] = n;
            }
          })(i, e)
        : 3 == t
        ? (e.type = i.readVarint())
        : 4 == t && (e._geometry = i.pos);
    }
    function F(t) {
      for (var e, i, o = 0, n = 0, s = t.length, r = s - 1; n < s; r = n++)
        o += ((i = t[r]).x - (e = t[n]).x) * (e.y + i.y);
      return o;
    }
    (N.types = ['Unknown', 'Point', 'LineString', 'Polygon']),
      (N.prototype.loadGeometry = function () {
        var t = this._pbf;
        t.pos = this._geometry;
        for (var e, i = t.readVarint() + t.pos, o = 1, n = 0, s = 0, r = 0, a = []; t.pos < i; ) {
          if (n <= 0) {
            var l = t.readVarint();
            (o = 7 & l), (n = l >> 3);
          }
          if ((n--, 1 === o || 2 === o))
            (s += t.readSVarint()),
              (r += t.readSVarint()),
              1 === o && (e && a.push(e), (e = [])),
              e.push(new V(s, r));
          else {
            if (7 !== o) throw new Error('unknown command ' + o);
            e && e.push(e[0].clone());
          }
        }
        return e && a.push(e), a;
      }),
      (N.prototype.bbox = function () {
        var t = this._pbf;
        t.pos = this._geometry;
        for (
          var e = t.readVarint() + t.pos,
            i = 1,
            o = 0,
            n = 0,
            s = 0,
            r = 1 / 0,
            a = -1 / 0,
            l = 1 / 0,
            c = -1 / 0;
          t.pos < e;

        ) {
          if (o <= 0) {
            var h = t.readVarint();
            (i = 7 & h), (o = h >> 3);
          }
          if ((o--, 1 === i || 2 === i))
            (n += t.readSVarint()) < r && (r = n),
              n > a && (a = n),
              (s += t.readSVarint()) < l && (l = s),
              s > c && (c = s);
          else if (7 !== i) throw new Error('unknown command ' + i);
        }
        return [r, l, a, c];
      }),
      (N.prototype.toGeoJSON = function (t, e, i) {
        var o,
          n,
          s = this.extent * Math.pow(2, i),
          r = this.extent * t,
          a = this.extent * e,
          l = this.loadGeometry(),
          c = N.types[this.type];
        function h(t) {
          for (var e = 0; e < t.length; e++) {
            var i = t[e];
            t[e] = [
              (360 * (i.x + r)) / s - 180,
              (360 / Math.PI) *
                Math.atan(Math.exp(((180 - (360 * (i.y + a)) / s) * Math.PI) / 180)) -
                90,
            ];
          }
        }
        switch (this.type) {
          case 1:
            var u = [];
            for (o = 0; o < l.length; o++) u[o] = l[o][0];
            h((l = u));
            break;
          case 2:
            for (o = 0; o < l.length; o++) h(l[o]);
            break;
          case 3:
            for (
              l = (function (t) {
                var e = t.length;
                if (e <= 1) return [t];
                for (var i, o, n = [], s = 0; s < e; s++) {
                  var r = F(t[s]);
                  0 !== r &&
                    (void 0 === o && (o = r < 0),
                    o === r < 0 ? (i && n.push(i), (i = [t[s]])) : i.push(t[s]));
                }
                return i && n.push(i), n;
              })(l),
                o = 0;
              o < l.length;
              o++
            )
              for (n = 0; n < l[o].length; n++) h(l[o][n]);
        }
        1 === l.length ? (l = l[0]) : (c = 'Multi' + c);
        var p = {
          type: 'Feature',
          geometry: { type: c, coordinates: l },
          properties: this.properties,
        };
        return 'id' in this && (p.id = this.id), p;
      });
    var q = Y;
    function Y(t, e) {
      (this.version = 1),
        (this.name = null),
        (this.extent = 4096),
        (this.length = 0),
        (this._pbf = t),
        (this._keys = []),
        (this._values = []),
        (this._features = []),
        t.readFields(J, this, e),
        (this.length = this._features.length);
    }
    function J(t, e, i) {
      15 === t
        ? (e.version = i.readVarint())
        : 1 === t
        ? (e.name = i.readString())
        : 5 === t
        ? (e.extent = i.readVarint())
        : 2 === t
        ? e._features.push(i.pos)
        : 3 === t
        ? e._keys.push(i.readString())
        : 4 === t &&
          e._values.push(
            (function (t) {
              for (var e = null, i = t.readVarint() + t.pos; t.pos < i; ) {
                var o = t.readVarint() >> 3;
                e =
                  1 === o
                    ? t.readString()
                    : 2 === o
                    ? t.readFloat()
                    : 3 === o
                    ? t.readDouble()
                    : 4 === o
                    ? t.readVarint64()
                    : 5 === o
                    ? t.readVarint()
                    : 6 === o
                    ? t.readSVarint()
                    : 7 === o
                    ? t.readBoolean()
                    : null;
              }
              return e;
            })(i),
          );
    }
    function X(t, e, i) {
      if (3 === t) {
        var o = new q(i, i.readVarint() + i.pos);
        o.length && (e[o.name] = o);
      }
    }
    Y.prototype.feature = function (t) {
      if (t < 0 || t >= this._features.length) throw new Error('feature index out of bounds');
      this._pbf.pos = this._features[t];
      var e = this._pbf.readVarint() + this._pbf.pos;
      return new G(this._pbf, e, this.extent, this._keys, this._values);
    };
    var Z = {
        VectorTile: function (t, e) {
          this.layers = t.readFields(X, {}, e);
        },
        VectorTileFeature: G,
        VectorTileLayer: q,
      }.VectorTileFeature,
      W = $;
    function $(t, e) {
      (this.options = e || {}), (this.features = t), (this.length = t.length);
    }
    function U(t, e) {
      (this.id = 'number' == typeof t.id ? t.id : void 0),
        (this.type = t.type),
        (this.rawGeometry = 1 === t.type ? [t.geometry] : t.geometry),
        (this.properties = t.tags),
        (this.extent = e || 4096);
    }
    ($.prototype.feature = function (t) {
      return new U(this.features[t], this.options.extent);
    }),
      (U.prototype.loadGeometry = function () {
        var t = this.rawGeometry;
        this.geometry = [];
        for (var e = 0; e < t.length; e++) {
          for (var i = t[e], o = [], n = 0; n < i.length; n++) o.push(new V(i[n][0], i[n][1]));
          this.geometry.push(o);
        }
        return this.geometry;
      }),
      (U.prototype.bbox = function () {
        this.geometry || this.loadGeometry();
        for (
          var t = this.geometry, e = 1 / 0, i = -1 / 0, o = 1 / 0, n = -1 / 0, s = 0;
          s < t.length;
          s++
        )
          for (var r = t[s], a = 0; a < r.length; a++) {
            var l = r[a];
            (e = Math.min(e, l.x)),
              (i = Math.max(i, l.x)),
              (o = Math.min(o, l.y)),
              (n = Math.max(n, l.y));
          }
        return [e, o, i, n];
      }),
      (U.prototype.toGeoJSON = Z.prototype.toGeoJSON);
    var K = Q,
      H = W;
    function Q(e) {
      var i = new t.pbf();
      return (
        (function (t, e) {
          for (var i in t.layers) e.writeMessage(3, tt, t.layers[i]);
        })(e, i),
        i.finish()
      );
    }
    function tt(t, e) {
      var i;
      e.writeVarintField(15, t.version || 1),
        e.writeStringField(1, t.name || ''),
        e.writeVarintField(5, t.extent || 4096);
      var o = { keys: [], values: [], keycache: {}, valuecache: {} };
      for (i = 0; i < t.length; i++) (o.feature = t.feature(i)), e.writeMessage(2, et, o);
      var n = o.keys;
      for (i = 0; i < n.length; i++) e.writeStringField(3, n[i]);
      var s = o.values;
      for (i = 0; i < s.length; i++) e.writeMessage(4, rt, s[i]);
    }
    function et(t, e) {
      var i = t.feature;
      void 0 !== i.id && e.writeVarintField(1, i.id),
        e.writeMessage(2, it, t),
        e.writeVarintField(3, i.type),
        e.writeMessage(4, st, i);
    }
    function it(t, e) {
      var i = t.feature,
        o = t.keys,
        n = t.values,
        s = t.keycache,
        r = t.valuecache;
      for (var a in i.properties) {
        var l = i.properties[a],
          c = s[a];
        if (null !== l) {
          void 0 === c && (o.push(a), (s[a] = c = o.length - 1)), e.writeVarint(c);
          var h = typeof l;
          'string' !== h && 'boolean' !== h && 'number' !== h && (l = JSON.stringify(l));
          var u = h + ':' + l,
            p = r[u];
          void 0 === p && (n.push(l), (r[u] = p = n.length - 1)), e.writeVarint(p);
        }
      }
    }
    function ot(t, e) {
      return (e << 3) + (7 & t);
    }
    function nt(t) {
      return (t << 1) ^ (t >> 31);
    }
    function st(t, e) {
      for (var i = t.loadGeometry(), o = t.type, n = 0, s = 0, r = i.length, a = 0; a < r; a++) {
        var l = i[a],
          c = 1;
        1 === o && (c = l.length), e.writeVarint(ot(1, c));
        for (var h = 3 === o ? l.length - 1 : l.length, u = 0; u < h; u++) {
          1 === u && 1 !== o && e.writeVarint(ot(2, h - 1));
          var p = l[u].x - n,
            f = l[u].y - s;
          e.writeVarint(nt(p)), e.writeVarint(nt(f)), (n += p), (s += f);
        }
        3 === o && e.writeVarint(ot(7, 1));
      }
    }
    function rt(t, e) {
      var i = typeof t;
      'string' === i
        ? e.writeStringField(1, t)
        : 'boolean' === i
        ? e.writeBooleanField(7, t)
        : 'number' === i &&
          (t % 1 != 0
            ? e.writeDoubleField(3, t)
            : t < 0
            ? e.writeSVarintField(6, t)
            : e.writeVarintField(5, t));
    }
    function at(t, e, i, o, n, s) {
      if (n - o <= i) return;
      const r = (o + n) >> 1;
      lt(t, e, r, o, n, s % 2), at(t, e, i, o, r - 1, s + 1), at(t, e, i, r + 1, n, s + 1);
    }
    function lt(t, e, i, o, n, s) {
      for (; n > o; ) {
        if (n - o > 600) {
          const r = n - o + 1,
            a = i - o + 1,
            l = Math.log(r),
            c = 0.5 * Math.exp((2 * l) / 3),
            h = 0.5 * Math.sqrt((l * c * (r - c)) / r) * (a - r / 2 < 0 ? -1 : 1);
          lt(
            t,
            e,
            i,
            Math.max(o, Math.floor(i - (a * c) / r + h)),
            Math.min(n, Math.floor(i + ((r - a) * c) / r + h)),
            s,
          );
        }
        const r = e[2 * i + s];
        let a = o,
          l = n;
        for (ct(t, e, o, i), e[2 * n + s] > r && ct(t, e, o, n); a < l; ) {
          for (ct(t, e, a, l), a++, l--; e[2 * a + s] < r; ) a++;
          for (; e[2 * l + s] > r; ) l--;
        }
        e[2 * o + s] === r ? ct(t, e, o, l) : (l++, ct(t, e, l, n)),
          l <= i && (o = l + 1),
          i <= l && (n = l - 1);
      }
    }
    function ct(t, e, i, o) {
      ht(t, i, o), ht(e, 2 * i, 2 * o), ht(e, 2 * i + 1, 2 * o + 1);
    }
    function ht(t, e, i) {
      const o = t[e];
      (t[e] = t[i]), (t[i] = o);
    }
    function ut(t, e, i, o) {
      const n = t - i,
        s = e - o;
      return n * n + s * s;
    }
    (K.fromVectorTileJs = Q),
      (K.fromGeojsonVt = function (t, e) {
        e = e || {};
        var i = {};
        for (var o in t)
          (i[o] = new W(t[o].features, e)),
            (i[o].name = o),
            (i[o].version = e.version),
            (i[o].extent = e.extent);
        return Q({ layers: i });
      }),
      (K.GeoJSONWrapper = H);
    const pt = (t) => t[0],
      ft = (t) => t[1];
    class dt {
      constructor(t, e = pt, i = ft, o = 64, n = Float64Array) {
        (this.nodeSize = o), (this.points = t);
        const s = t.length < 65536 ? Uint16Array : Uint32Array,
          r = (this.ids = new s(t.length)),
          a = (this.coords = new n(2 * t.length));
        for (let o = 0; o < t.length; o++)
          (r[o] = o), (a[2 * o] = e(t[o])), (a[2 * o + 1] = i(t[o]));
        at(r, a, o, 0, r.length - 1, 0);
      }
      range(t, e, i, o) {
        return (function (t, e, i, o, n, s, r) {
          const a = [0, t.length - 1, 0],
            l = [];
          let c, h;
          for (; a.length; ) {
            const u = a.pop(),
              p = a.pop(),
              f = a.pop();
            if (p - f <= r) {
              for (let r = f; r <= p; r++)
                (c = e[2 * r]),
                  (h = e[2 * r + 1]),
                  c >= i && c <= n && h >= o && h <= s && l.push(t[r]);
              continue;
            }
            const d = Math.floor((f + p) / 2);
            (c = e[2 * d]),
              (h = e[2 * d + 1]),
              c >= i && c <= n && h >= o && h <= s && l.push(t[d]);
            const g = (u + 1) % 2;
            (0 === u ? i <= c : o <= h) && (a.push(f), a.push(d - 1), a.push(g)),
              (0 === u ? n >= c : s >= h) && (a.push(d + 1), a.push(p), a.push(g));
          }
          return l;
        })(this.ids, this.coords, t, e, i, o, this.nodeSize);
      }
      within(t, e, i) {
        return (function (t, e, i, o, n, s) {
          const r = [0, t.length - 1, 0],
            a = [],
            l = n * n;
          for (; r.length; ) {
            const c = r.pop(),
              h = r.pop(),
              u = r.pop();
            if (h - u <= s) {
              for (let n = u; n <= h; n++) ut(e[2 * n], e[2 * n + 1], i, o) <= l && a.push(t[n]);
              continue;
            }
            const p = Math.floor((u + h) / 2),
              f = e[2 * p],
              d = e[2 * p + 1];
            ut(f, d, i, o) <= l && a.push(t[p]);
            const g = (c + 1) % 2;
            (0 === c ? i - n <= f : o - n <= d) && (r.push(u), r.push(p - 1), r.push(g)),
              (0 === c ? i + n >= f : o + n >= d) && (r.push(p + 1), r.push(h), r.push(g));
          }
          return a;
        })(this.ids, this.coords, t, e, i, this.nodeSize);
      }
    }
    const gt = {
        minZoom: 0,
        maxZoom: 16,
        minPoints: 2,
        radius: 40,
        extent: 512,
        nodeSize: 64,
        log: !1,
        generateId: !1,
        reduce: null,
        map: (t) => t,
      },
      mt = Math.fround || ((yt = new Float32Array(1)), (t) => ((yt[0] = +t), yt[0]));
    var yt;
    class xt {
      constructor(e) {
        (this.options = Pt(Object.create(gt), e)),
          (this.trees = new Array(this.options.maxZoom + 1)),
          (this.projection = e && e.projection ? e.projection : 'MERCATOR'),
          (this.projObj = t.getProjection(this.projection));
      }
      createPointCluster(t, e, i) {
        const [o, n] = t.geometry.coordinates;
        return { x: mt(St(o)), y: mt((i ? _t : Mt)(n)), zoom: 1 / 0, index: e, parentId: -1 };
      }
      load(t) {
        const { log: e, minZoom: i, maxZoom: o, nodeSize: n } = this.options;
        e && console.time('total time');
        const s = `prepare ${t.length} points`;
        e && console.time(s), (this.points = t);
        let r = [];
        for (let e = 0; e < t.length; e++)
          t[e].geometry && r.push(this.createPointCluster(t[e], e, this.options.isLatLon));
        (this.trees[o + 1] = new dt(r, Lt, kt, n, Float32Array)), e && console.timeEnd(s);
        for (let t = o; t >= i; t--) {
          const i = +Date.now();
          (r = this._cluster(r, t)),
            (this.trees[t] = new dt(r, Lt, kt, n, Float32Array)),
            e && console.warn('z%d: %d clusters in %dms', t, r.length, +Date.now() - i);
        }
        return e && console.timeEnd('total time'), this;
      }
      getClusters(t, e) {
        let i = ((((t[0] + 180) % 360) + 360) % 360) - 180;
        const o = Math.max(-90, Math.min(90, t[1]));
        let n = 180 === t[2] ? 180 : ((((t[2] + 180) % 360) + 360) % 360) - 180;
        const s = Math.max(-90, Math.min(90, t[3]));
        if (t[2] - t[0] >= 360) (i = -180), (n = 180);
        else if (i > n) {
          const t = this.getClusters([i, o, 180, s], e),
            r = this.getClusters([-180, o, n, s], e);
          return t.concat(r);
        }
        const r = this.trees[this._limitZoom(e)],
          a = r.range(
            St(i),
            (this.options.isLatLon ? _t : Mt)(s),
            St(n),
            (this.options.isLatLon ? _t : Mt)(o),
          ),
          l = [];
        for (const t of a) {
          const e = r.points[t];
          l.push(e.numPoints ? wt(e, this.options.isLatLon) : this.points[e.index]);
        }
        return l;
      }
      getChildren(t) {
        const e = this._getOriginId(t),
          i = this._getOriginZoom(t),
          o = 'No cluster with the specified id.',
          n = this.trees[i];
        if (!n) throw new Error(o);
        const s = n.points[e];
        if (!s) throw new Error(o);
        const r = this.options.radius / (this.options.extent * Math.pow(2, i - 1)),
          a = n.within(s.x, s.y, r),
          l = [];
        for (const e of a) {
          const i = n.points[e];
          i.parentId === t &&
            l.push(i.numPoints ? wt(i, this.options.isLatLon) : this.points[i.index]);
        }
        if (0 === l.length) throw new Error(o);
        return l;
      }
      getLeaves(t, e, i) {
        const o = [];
        return this._appendLeaves(o, t, (e = e || 10), (i = i || 0), 0), o;
      }
      getTile(t, e, i) {
        const o = this.trees[this._limitZoom(t)],
          n = Math.pow(2, t),
          { extent: s, radius: r } = this.options,
          a = r / s,
          l = (i - a) / n,
          c = (i + 1 + a) / n,
          h = { features: [] };
        return (
          this._addTileFeatures(o.range((e - a) / n, l, (e + 1 + a) / n, c), o.points, e, i, n, h),
          0 === e && this._addTileFeatures(o.range(1 - a / n, l, 1, c), o.points, n, i, n, h),
          e === n - 1 && this._addTileFeatures(o.range(0, l, a / n, c), o.points, -1, i, n, h),
          h.features.length ? h : null
        );
      }
      getClusterExpansionZoom(t) {
        let e = this._getOriginZoom(t) - 1;
        for (; e <= this.options.maxZoom; ) {
          const i = this.getChildren(t);
          if ((e++, 1 !== i.length)) break;
          t = i[0].properties.cluster_id;
        }
        return e;
      }
      _appendLeaves(t, e, i, o, n) {
        const s = this.getChildren(e);
        for (const e of s) {
          const s = e.properties;
          if (
            (s && s.cluster
              ? n + s.point_count <= o
                ? (n += s.point_count)
                : (n = this._appendLeaves(t, s.cluster_id, i, o, n))
              : n < o
              ? n++
              : t.push(e),
            t.length === i)
          )
            break;
        }
        return n;
      }
      _addTileFeatures(t, e, i, o, n, s) {
        for (const r of t) {
          const t = e[r],
            a = t.numPoints;
          let l, c, h;
          if (a) (l = bt(t)), (c = t.x), (h = t.y);
          else {
            const e = this.points[t.index];
            (l = e.properties),
              (c = St(e.geometry.coordinates[0])),
              (h = (this.options.isLatLon ? _t : Mt)(e.geometry.coordinates[1]));
          }
          const u = {
            type: 1,
            geometry: [
              [
                Math.round(this.options.extent * (c * n - i)),
                Math.round(this.options.extent * (h * n - o)),
              ],
            ],
            tags: l,
          };
          let p;
          a
            ? (p = t.id)
            : this.options.generateId
            ? (p = t.index)
            : this.points[t.index].id && (p = this.points[t.index].id),
            void 0 !== p && (u.id = p),
            s.features.push(u);
        }
      }
      _limitZoom(t) {
        return Math.max(this.options.minZoom, Math.min(+t, this.options.maxZoom + 1));
      }
      _cluster(t, e) {
        const i = [],
          { radius: o, extent: n, reduce: s, minPoints: r } = this.options,
          a = o / (n * Math.pow(2, e));
        for (let o = 0; o < t.length; o++) {
          const n = t[o];
          if (n.zoom <= e) continue;
          n.zoom = e;
          const l = this.trees[e + 1],
            c = l.within(n.x, n.y, a),
            h = n.numPoints || 1;
          let u = h;
          for (const t of c) {
            const i = l.points[t];
            i.zoom > e && (u += i.numPoints || 1);
          }
          if (u >= r) {
            let t = n.x * h,
              r = n.y * h,
              a = s && h > 1 ? this._map(n, !0) : null;
            const p = (o << 5) + (e + 1) + this.points.length;
            for (const i of c) {
              const o = l.points[i];
              if (o.zoom <= e) continue;
              o.zoom = e;
              const c = o.numPoints || 1;
              (t += o.x * c),
                (r += o.y * c),
                (o.parentId = p),
                s && (a || (a = this._map(n, !0)), s(a, this._map(o)));
            }
            (n.parentId = p), i.push(vt(t / u, r / u, p, u, a));
          } else if ((i.push(n), u > 1))
            for (const t of c) {
              const o = l.points[t];
              o.zoom <= e || ((o.zoom = e), i.push(o));
            }
        }
        return i;
      }
      _getOriginId(t) {
        return (t - this.points.length) >> 5;
      }
      _getOriginZoom(t) {
        return (t - this.points.length) % 32;
      }
      _map(t, e) {
        if (t.numPoints) return e ? Pt({}, t.properties) : t.properties;
        const i = this.points[t.index].properties,
          o = this.options.map(i);
        return e && o === i ? Pt({}, o) : o;
      }
    }
    function vt(t, e, i, o, n) {
      return { x: mt(t), y: mt(e), zoom: 1 / 0, id: i, parentId: -1, numPoints: o, properties: n };
    }
    function wt(t, e) {
      return {
        type: 'Feature',
        id: t.id,
        properties: bt(t),
        geometry: {
          type: 'Point',
          coordinates: [((i = t.x), 360 * (i - 0.5)), (e ? Tt : It)(t.y)],
        },
      };
      var i;
    }
    function bt(t) {
      const e = t.numPoints,
        i = e >= 1e4 ? `${Math.round(e / 1e3)}k` : e >= 1e3 ? Math.round(e / 100) / 10 + 'k' : e;
      return Pt(Pt({}, t.properties), {
        cluster: !0,
        cluster_id: t.id,
        point_count: e,
        point_count_abbreviated: i,
      });
    }
    function St(t) {
      return t / 360 + 0.5;
    }
    function Mt(t) {
      const e = Math.sin((t * Math.PI) / 180),
        i = 0.5 - (0.25 * Math.log((1 + e) / (1 - e))) / Math.PI;
      return i < 0 ? 0 : i > 1 ? 1 : i;
    }
    function _t(t) {
      const e = (90 - t) / 360;
      return e < 0 ? 0 : e > 1 ? 1 : e;
    }
    function It(t) {
      const e = ((180 - 360 * t) * Math.PI) / 180;
      return (360 * Math.atan(Math.exp(e))) / Math.PI - 90;
    }
    function Tt(t) {
      return 90 - 360 * t;
    }
    function Pt(t, e) {
      for (const i in e) t[i] = e[i];
      return t;
    }
    function Lt(t) {
      return t.x;
    }
    function kt(t) {
      return t.y;
    }
    function zt(t, e, i, o) {
      let n = o;
      const s = (i - e) >> 1;
      let r,
        a = i - e;
      const l = t[e],
        c = t[e + 1],
        h = t[i],
        u = t[i + 1];
      for (let o = e + 3; o < i; o += 3) {
        const e = Ot(t[o], t[o + 1], l, c, h, u);
        if (e > n) (r = o), (n = e);
        else if (e === n) {
          const t = Math.abs(o - s);
          t < a && ((r = o), (a = t));
        }
      }
      n > o && (r - e > 3 && zt(t, e, r, o), (t[r + 2] = n), i - r > 3 && zt(t, r, i, o));
    }
    function Ot(t, e, i, o, n, s) {
      let r = n - i,
        a = s - o;
      if (0 !== r || 0 !== a) {
        const l = ((t - i) * r + (e - o) * a) / (r * r + a * a);
        l > 1 ? ((i = n), (o = s)) : l > 0 && ((i += r * l), (o += a * l));
      }
      return (r = t - i), (a = e - o), r * r + a * a;
    }
    function Et(t, e, i, o) {
      const n = {
        id: null == t ? null : t,
        type: e,
        geometry: i,
        tags: o,
        minX: 1 / 0,
        minY: 1 / 0,
        maxX: -1 / 0,
        maxY: -1 / 0,
      };
      if ('Point' === e || 'MultiPoint' === e || 'LineString' === e) Ct(n, i);
      else if ('Polygon' === e) Ct(n, i[0]);
      else if ('MultiLineString' === e) for (const t of i) Ct(n, t);
      else if ('MultiPolygon' === e) for (const t of i) Ct(n, t[0]);
      return n;
    }
    function Ct(t, e) {
      for (let i = 0; i < e.length; i += 3)
        (t.minX = Math.min(t.minX, e[i])),
          (t.minY = Math.min(t.minY, e[i + 1])),
          (t.maxX = Math.max(t.maxX, e[i])),
          (t.maxY = Math.max(t.maxY, e[i + 1]));
    }
    function Dt(t, e, i, o) {
      if (!e.geometry) return;
      const n = e.geometry.coordinates,
        s = e.geometry.type,
        r = Math.pow(i.tolerance / ((1 << i.maxZoom) * i.extent), 2);
      let a = [],
        l = e.id;
      if (
        (i.promoteId ? (l = e.properties[i.promoteId]) : i.generateId && (l = o || 0),
        'Point' === s)
      )
        Rt(n, a, i.projection);
      else if ('MultiPoint' === s) for (const t of n) Rt(t, a, i.projection);
      else if ('LineString' === s) jt(n, a, r, !1, i.projection);
      else if ('MultiLineString' === s) {
        if (i.lineMetrics) {
          for (const o of n)
            (a = []), jt(o, a, r, !1, i.projection), t.push(Et(l, 'LineString', a, e.properties));
          return;
        }
        Vt(n, a, r, !1, i.projection);
      } else if ('Polygon' === s) Vt(n, a, r, !0, i.projection);
      else {
        if ('MultiPolygon' !== s) {
          if ('GeometryCollection' === s) {
            for (const n of e.geometry.geometries)
              Dt(t, { id: l, geometry: n, properties: e.properties }, i, o);
            return;
          }
          throw new Error('Input data is not a valid GeoJSON object.');
        }
        for (const t of n) {
          const e = [];
          Vt(t, e, r, !0, i.projection), a.push(e);
        }
      }
      t.push(Et(l, s, a, e.properties));
    }
    function Rt(t, e, i) {
      e.push(...At(t, i), 0);
    }
    function jt(t, e, i, o, n) {
      let s,
        r,
        a = 0;
      for (let i = 0; i < t.length; i++) {
        const l = At(t[i], n),
          c = l[0],
          h = l[1];
        e.push(c, h, 0),
          i > 0 &&
            (a += o ? (s * h - c * r) / 2 : Math.sqrt(Math.pow(c - s, 2) + Math.pow(h - r, 2))),
          (s = c),
          (r = h);
      }
      const l = e.length - 3;
      (e[2] = 1),
        zt(e, 0, l, i),
        (e[l + 2] = 1),
        (e.size = Math.abs(a)),
        (e.start = 0),
        (e.end = e.size);
    }
    function Vt(t, e, i, o, n) {
      for (let s = 0; s < t.length; s++) {
        const r = [];
        jt(t[s], r, i, o, n), e.push(r);
      }
    }
    function At(e, i) {
      const o = t.getProjection(i),
        n = o.lngX(e[0], 1);
      let s = o.latY(e[1], 1);
      return (s = s < 0 ? 0 : s > 1 ? 1 : s), [n, s];
    }
    function Gt(t, e, i, o, n, s, r, a) {
      if (((o /= e), s >= (i /= e) && r < o)) return t;
      if (r < i || s >= o) return null;
      const l = [];
      for (const e of t) {
        const t = e.geometry;
        let s = e.type;
        const r = 0 === n ? e.minX : e.minY,
          c = 0 === n ? e.maxX : e.maxY;
        if (r >= i && c < o) {
          l.push(e);
          continue;
        }
        if (c < i || r >= o) continue;
        let h = [];
        if ('Point' === s || 'MultiPoint' === s) Nt(t, h, i, o, n);
        else if ('LineString' === s) Bt(t, h, i, o, n, !1, a.lineMetrics);
        else if ('MultiLineString' === s) qt(t, h, i, o, n, !1);
        else if ('Polygon' === s) qt(t, h, i, o, n, !0);
        else if ('MultiPolygon' === s)
          for (const e of t) {
            const t = [];
            qt(e, t, i, o, n, !0), t.length && h.push(t);
          }
        if (h.length) {
          if (a.lineMetrics && 'LineString' === s) {
            for (const t of h) l.push(Et(e.id, s, t, e.tags));
            continue;
          }
          ('LineString' !== s && 'MultiLineString' !== s) ||
            (1 === h.length ? ((s = 'LineString'), (h = h[0])) : (s = 'MultiLineString')),
            ('Point' !== s && 'MultiPoint' !== s) || (s = 3 === h.length ? 'Point' : 'MultiPoint'),
            l.push(Et(e.id, s, h, e.tags));
        }
      }
      return l.length ? l : null;
    }
    function Nt(t, e, i, o, n) {
      for (let s = 0; s < t.length; s += 3) {
        const r = t[s + n];
        r >= i && r <= o && Yt(e, t[s], t[s + 1], t[s + 2]);
      }
    }
    function Bt(t, e, i, o, n, s, r) {
      let a = Ft(t);
      const l = 0 === n ? Jt : Xt;
      let c,
        h,
        u = t.start;
      for (let p = 0; p < t.length - 3; p += 3) {
        const f = t[p],
          d = t[p + 1],
          g = t[p + 2],
          m = t[p + 3],
          y = t[p + 4],
          x = 0 === n ? f : d,
          v = 0 === n ? m : y;
        let w = !1;
        r && (c = Math.sqrt(Math.pow(f - m, 2) + Math.pow(d - y, 2))),
          x < i
            ? v >= i && ((h = l(a, f, d, m, y, i)), r && (a.start = u + c * h))
            : x > o
            ? v <= o && ((h = l(a, f, d, m, y, o)), r && (a.start = u + c * h))
            : Yt(a, f, d, g),
          v < i && x >= i && ((h = l(a, f, d, m, y, i)), (w = !0)),
          v > o && x <= o && ((h = l(a, f, d, m, y, o)), (w = !0)),
          !s && w && (r && (a.end = u + c * h), e.push(a), (a = Ft(t))),
          r && (u += c);
      }
      let p = t.length - 3;
      const f = t[p],
        d = t[p + 1],
        g = 0 === n ? f : d;
      g >= i && g <= o && Yt(a, f, d, t[p + 2]),
        (p = a.length - 3),
        s && p >= 3 && (a[p] !== a[0] || a[p + 1] !== a[1]) && Yt(a, a[0], a[1], a[2]),
        a.length && e.push(a);
    }
    function Ft(t) {
      const e = [];
      return (e.size = t.size), (e.start = t.start), (e.end = t.end), e;
    }
    function qt(t, e, i, o, n, s) {
      for (const r of t) Bt(r, e, i, o, n, s, !1);
    }
    function Yt(t, e, i, o) {
      t.push(e, i, o);
    }
    function Jt(t, e, i, o, n, s) {
      const r = (s - e) / (o - e);
      return Yt(t, s, i + (n - i) * r, 1), r;
    }
    function Xt(t, e, i, o, n, s) {
      const r = (s - i) / (n - i);
      return Yt(t, e + (o - e) * r, s, 1), r;
    }
    function Zt(t, e) {
      const i = [];
      for (let o = 0; o < t.length; o++) {
        const n = t[o],
          s = n.type;
        let r;
        if ('Point' === s || 'MultiPoint' === s || 'LineString' === s) r = Wt(n.geometry, e);
        else if ('MultiLineString' === s || 'Polygon' === s) {
          r = [];
          for (const t of n.geometry) r.push(Wt(t, e));
        } else if ('MultiPolygon' === s) {
          r = [];
          for (const t of n.geometry) {
            const i = [];
            for (const o of t) i.push(Wt(o, e));
            r.push(i);
          }
        }
        i.push(Et(n.id, s, r, n.tags));
      }
      return i;
    }
    function Wt(t, e) {
      const i = [];
      (i.size = t.size), void 0 !== t.start && ((i.start = t.start), (i.end = t.end));
      for (let o = 0; o < t.length; o += 3) i.push(t[o] + e, t[o + 1], t[o + 2]);
      return i;
    }
    function $t(t, e) {
      if (t.transformed) return t;
      const i = 1 << t.z,
        o = t.x,
        n = t.y;
      for (const s of t.features) {
        const t = s.geometry,
          r = s.type;
        if (((s.geometry = []), 1 === r))
          for (let r = 0; r < t.length; r += 2) s.geometry.push(Ut(t[r], t[r + 1], e, i, o, n));
        else
          for (let r = 0; r < t.length; r++) {
            const a = [];
            for (let s = 0; s < t[r].length; s += 2) a.push(Ut(t[r][s], t[r][s + 1], e, i, o, n));
            s.geometry.push(a);
          }
      }
      return (t.transformed = !0), t;
    }
    function Ut(t, e, i, o, n, s) {
      return [Math.round(i * (t * o - n)), Math.round(i * (e * o - s))];
    }
    function Kt(t, e, i, o, n) {
      const s = e === n.maxZoom ? 0 : n.tolerance / ((1 << e) * n.extent),
        r = {
          features: [],
          numPoints: 0,
          numSimplified: 0,
          numFeatures: t.length,
          source: null,
          x: i,
          y: o,
          z: e,
          transformed: !1,
          minX: 2,
          minY: 1,
          maxX: -1,
          maxY: 0,
        };
      for (const e of t) Ht(r, e, s, n);
      return r;
    }
    function Ht(t, e, i, o) {
      const n = e.geometry,
        s = e.type,
        r = [];
      if (
        ((t.minX = Math.min(t.minX, e.minX)),
        (t.minY = Math.min(t.minY, e.minY)),
        (t.maxX = Math.max(t.maxX, e.maxX)),
        (t.maxY = Math.max(t.maxY, e.maxY)),
        'Point' === s || 'MultiPoint' === s)
      )
        for (let e = 0; e < n.length; e += 3)
          r.push(n[e], n[e + 1]), t.numPoints++, t.numSimplified++;
      else if ('LineString' === s) Qt(r, n, t, i, !1, !1);
      else if ('MultiLineString' === s || 'Polygon' === s)
        for (let e = 0; e < n.length; e++) Qt(r, n[e], t, i, 'Polygon' === s, 0 === e);
      else if ('MultiPolygon' === s)
        for (let e = 0; e < n.length; e++) {
          const o = n[e];
          for (let e = 0; e < o.length; e++) Qt(r, o[e], t, i, !0, 0 === e);
        }
      if (r.length) {
        let i = e.tags || null;
        if ('LineString' === s && o.lineMetrics) {
          i = {};
          for (const t in e.tags) i[t] = e.tags[t];
          (i.minemap_clip_start = n.start / n.size), (i.minemap_clip_end = n.end / n.size);
        }
        const a = {
          geometry: r,
          type:
            'Polygon' === s || 'MultiPolygon' === s
              ? 3
              : 'LineString' === s || 'MultiLineString' === s
              ? 2
              : 1,
          tags: i,
        };
        null !== e.id && (a.id = e.id), t.features.push(a);
      }
    }
    function Qt(t, e, i, o, n, s) {
      const r = o * o;
      if (o > 0 && e.size < (n ? r : o)) return void (i.numPoints += e.length / 3);
      const a = [];
      for (let t = 0; t < e.length; t += 3)
        (0 === o || e[t + 2] > r) && (i.numSimplified++, a.push(e[t], e[t + 1])), i.numPoints++;
      n &&
        (function (t, e) {
          let i = 0;
          for (let e = 0, o = t.length, n = o - 2; e < o; n = e, e += 2)
            i += (t[e] - t[n]) * (t[e + 1] + t[n + 1]);
          if (i > 0 === e)
            for (let e = 0, i = t.length; e < i / 2; e += 2) {
              const o = t[e],
                n = t[e + 1];
              (t[e] = t[i - 2 - e]),
                (t[e + 1] = t[i - 1 - e]),
                (t[i - 2 - e] = o),
                (t[i - 1 - e] = n);
            }
        })(a, s),
        t.push(a);
    }
    const te = {
      maxZoom: 14,
      indexMaxZoom: 5,
      indexMaxPoints: 1e5,
      tolerance: 3,
      extent: 4096,
      buffer: 64,
      lineMetrics: !1,
      promoteId: null,
      generateId: !1,
      debug: 0,
      projection: t.ProjectionType.MERCATOR,
    };
    class ee {
      constructor(t, e) {
        const i = (e = this.options =
          (function (t, e) {
            for (const i in e) t[i] = e[i];
            return t;
          })(Object.create(te), e)).debug;
        if ((i && console.time('preprocess data'), e.maxZoom < 0 || e.maxZoom > 24))
          throw new Error('maxZoom should be in the 0-24 range');
        if (e.promoteId && e.generateId)
          throw new Error('promoteId and generateId cannot be used together.');
        let o = (function (t, e) {
          const i = [];
          if ('FeatureCollection' === t.type)
            for (let o = 0; o < t.features.length; o++) Dt(i, t.features[o], e, o);
          else Dt(i, 'Feature' === t.type ? t : { geometry: t }, e);
          return i;
        })(t, e);
        (this.tiles = {}),
          (this.tileCoords = []),
          i &&
            (console.timeEnd('preprocess data'),
            console.info('index: maxZoom: %d, maxPoints: %d', e.indexMaxZoom, e.indexMaxPoints),
            console.time('generate tiles'),
            (this.stats = {}),
            (this.total = 0)),
          (o = (function (t, e) {
            const i = e.buffer / e.extent;
            let o = t;
            const n = Gt(t, 1, -1 - i, i, 0, -1, 2, e),
              s = Gt(t, 1, 1 - i, 2 + i, 0, -1, 2, e);
            return (
              (n || s) &&
                ((o = Gt(t, 1, -i, 1 + i, 0, -1, 2, e) || []),
                n && (o = Zt(n, 1).concat(o)),
                s && (o = o.concat(Zt(s, -1)))),
              o
            );
          })(o, e)),
          o.length && this.splitTile(o, 0, 0, 0),
          i &&
            (o.length &&
              console.info(
                'features: %d, points: %d',
                this.tiles[0].numFeatures,
                this.tiles[0].numPoints,
              ),
            console.timeEnd('generate tiles'),
            console.info('tiles generated:', this.total, JSON.stringify(this.stats)));
      }
      splitTile(t, e, i, o, n, s, r) {
        const a = [t, e, i, o],
          l = this.options,
          c = l.debug;
        for (; a.length; ) {
          (o = a.pop()), (i = a.pop()), (e = a.pop()), (t = a.pop());
          const h = 1 << e,
            u = ie(e, i, o);
          let p = this.tiles[u];
          if (
            !p &&
            (c > 1 && console.time('creation'),
            (p = this.tiles[u] = Kt(t, e, i, o, l)),
            this.tileCoords.push({ z: e, x: i, y: o }),
            c)
          ) {
            c > 1 &&
              (console.info(
                'tile z%d-%d-%d (features: %d, points: %d, simplified: %d)',
                e,
                i,
                o,
                p.numFeatures,
                p.numPoints,
                p.numSimplified,
              ),
              console.timeEnd('creation'));
            const t = `z${e}`;
            (this.stats[t] = (this.stats[t] || 0) + 1), this.total++;
          }
          if (((p.source = t), null == n)) {
            if (e === l.indexMaxZoom || p.numPoints <= l.indexMaxPoints) continue;
          } else {
            if (e === l.maxZoom || e === n) continue;
            if (null != n) {
              const t = n - e;
              if (i !== s >> t || o !== r >> t) continue;
            }
          }
          if (((p.source = null), 0 === t.length)) continue;
          c > 1 && console.time('clipping');
          const f = (0.5 * l.buffer) / l.extent,
            d = 0.5 - f,
            g = 0.5 + f,
            m = 1 + f;
          let y = null,
            x = null,
            v = null,
            w = null,
            b = Gt(t, h, i - f, i + g, 0, p.minX, p.maxX, l),
            S = Gt(t, h, i + d, i + m, 0, p.minX, p.maxX, l);
          (t = null),
            b &&
              ((y = Gt(b, h, o - f, o + g, 1, p.minY, p.maxY, l)),
              (x = Gt(b, h, o + d, o + m, 1, p.minY, p.maxY, l)),
              (b = null)),
            S &&
              ((v = Gt(S, h, o - f, o + g, 1, p.minY, p.maxY, l)),
              (w = Gt(S, h, o + d, o + m, 1, p.minY, p.maxY, l)),
              (S = null)),
            c > 1 && console.timeEnd('clipping'),
            a.push(y || [], e + 1, 2 * i, 2 * o),
            a.push(x || [], e + 1, 2 * i, 2 * o + 1),
            a.push(v || [], e + 1, 2 * i + 1, 2 * o),
            a.push(w || [], e + 1, 2 * i + 1, 2 * o + 1);
        }
      }
      getTile(t, e, i) {
        (t = +t), (e = +e), (i = +i);
        const o = this.options,
          { extent: n, debug: s } = o;
        if (t < 0 || t > 24) return null;
        const r = 1 << t,
          a = ie(t, (e = (e + r) & (r - 1)), i);
        if (this.tiles[a]) return $t(this.tiles[a], n);
        s > 1 && console.info('drilling down to z%d-%d-%d', t, e, i);
        let l,
          c = t,
          h = e,
          u = i;
        for (; !l && c > 0; ) c--, (h >>= 1), (u >>= 1), (l = this.tiles[ie(c, h, u)]);
        return l && l.source
          ? (s > 1 &&
              (console.info('found parent tile z%d-%d-%d', c, h, u), console.time('drilling down')),
            this.splitTile(l.source, c, h, u, t, e, i),
            s > 1 && console.timeEnd('drilling down'),
            this.tiles[a] ? $t(this.tiles[a], n) : null)
          : null;
      }
    }
    function ie(t, e, i) {
      return 32 * ((1 << t) * i + e) + t;
    }
    function oe(t, e, i) {
      const o = t.tileID.canonical;
      if (!this._geoJSONIndex) return e(null, null);
      const n = this._geoJSONIndex.getTile(o.z, o.x, o.y);
      if (!n) return e(null, null);
      const s = new j(n.features, i);
      let r = K(s);
      (0 === r.byteOffset && r.byteLength === r.buffer.byteLength) || (r = new Uint8Array(r)),
        e(null, { vectorTile: s, rawData: r.buffer });
    }
    class ne extends z {
      constructor(e, i, o, n) {
        super(e, i, o, n),
          this.setDataLoaderFunction(oe),
          (this.projection = n || t.ProjectionType.MERCATOR);
      }
      loadData(t, e) {
        this._pendingCallback && this._pendingCallback(null, { abandoned: !0 }),
          (this._pendingCallback = e),
          (this._pendingLoadDataParams = t),
          this._state && 'Idle' !== this._state
            ? (this._state = 'NeedsLoadData')
            : ((this._state = 'Coalescing'), this._loadData());
      }
      _loadData() {
        if (!this._pendingCallback || !this._pendingLoadDataParams) return;
        const e = this._pendingCallback,
          i = this._pendingLoadDataParams;
        delete this._pendingCallback, delete this._pendingLoadDataParams;
        const o = i && i.request,
          n = o && o.collectResourceTiming;
        this.loadGeoJSON(i, (s, r) => {
          if (s || !r) return e(s);
          if ('object' != typeof r)
            return e(new Error(`Input data given to '${i.source}' is not a valid GeoJSON object.`));
          {
            O(r, !0);
            try {
              if (i.filter) {
                const e = t.createExpression(i.filter, {
                  type: 'boolean',
                  'property-type': 'data-driven',
                  overridable: !1,
                  transition: !1,
                });
                if ('error' === e.result)
                  throw new Error(e.value.map((t) => `${t.key}: ${t.message}`).join(', '));
                const o = r.features.filter((t) => e.value.evaluate({ zoom: 0 }, t));
                r = { type: 'FeatureCollection', features: o };
              }
              (i.geojsonVtOptions.projection = this.projection),
                (this._geoJSONIndex = i.cluster
                  ? new xt(
                      (function ({ superclusterOptions: e, clusterProperties: i }, o) {
                        if (((e.isLatLon = 'LATLON' === o), !i || !e)) return (e.projection = o), e;
                        const n = {},
                          s = {},
                          r = { accumulated: null, zoom: 0 },
                          a = { properties: null },
                          l = Object.keys(i);
                        for (const e of l) {
                          const [o, r] = i[e],
                            a = t.createExpression(r),
                            l = t.createExpression(
                              'string' == typeof o ? [o, ['accumulated'], ['get', e]] : o,
                            );
                          (n[e] = a.value), (s[e] = l.value);
                        }
                        return (
                          (e.map = (t) => {
                            a.properties = t;
                            const e = {};
                            for (const t of l) e[t] = n[t].evaluate(r, a);
                            return e;
                          }),
                          (e.reduce = (t, e) => {
                            a.properties = e;
                            for (const e of l) (r.accumulated = t[e]), (t[e] = s[e].evaluate(r, a));
                          }),
                          (e.projection = o),
                          e
                        );
                      })(i, this.projection),
                    ).load(r.features)
                  : (function (t, e) {
                      return new ee(t, e);
                    })(r, i.geojsonVtOptions));
            } catch (s) {
              return e(s);
            }
            this.loaded = {};
            const a = {};
            if (n) {
              const t = k(o);
              t &&
                ((a.resourceTiming = {}),
                (a.resourceTiming[i.source] = JSON.parse(JSON.stringify(t))));
            }
            e(null, a);
          }
        });
      }
      coalesce() {
        'Coalescing' === this._state
          ? (this._state = 'Idle')
          : 'NeedsLoadData' === this._state && ((this._state = 'Coalescing'), this._loadData());
      }
      reloadTile(t, e) {
        const i = this.loaded;
        return i && i[t.uid] ? super.reloadTile(t, e) : this.loadTile(t, e);
      }
      loadGeoJSON(e, i) {
        if (e.request) t.getJSON(e.request, i);
        else {
          if ('string' != typeof e.data)
            return i(new Error('Input data is not a valid GeoJSON object.'));
          try {
            return i(null, JSON.parse(e.data));
          } catch (t) {
            return i(new Error('Input data is not a valid GeoJSON object.'));
          }
        }
      }
      removeSource(t, e) {
        this._pendingCallback && this._pendingCallback(null, { abandoned: !0 }), e();
      }
      getClusterExpansionZoom(t, e) {
        e(null, this._geoJSONIndex.getClusterExpansionZoom(t.clusterId));
      }
      getClusterChildren(t, e) {
        e(null, this._geoJSONIndex.getChildren(t.clusterId));
      }
      getClusterLeaves(t, e) {
        e(null, this._geoJSONIndex.getLeaves(t.clusterId, t.limit, t.offset));
      }
    }
    class se {
      constructor(t, e, i, o) {
        (this.actor = t),
          (this.loading = {}),
          (this.loaded = {}),
          (this.availableImages = i),
          (this.projection = o);
      }
      registRequestController(t) {
        this.irc = t;
      }
      loadTile(t, e) {
        this._loadData(t, e);
      }
      _loadData(t, e) {
        this.loading[t.uid] = { imgRequest: null, binRequest: null };
        const i = t.uid;
        (this.loading[i] = this.irc.pushRequest({
          id: i,
          param: t.request,
          cb: (t, o) => {
            t && e(t, null), delete this.loading[i], e(null, o);
          },
        })),
          this.irc.run();
      }
      reloadTile(t, e) {
        this._loadData(t, e);
        const i = this.loaded,
          o = t.uid,
          n = this;
        if (i && i[o]) {
          const t = i[o],
            s = (i, o) => {
              const s = t.reloadCallback;
              s && (delete t.reloadCallback, t.parse(t.vectorTile, n.layerIndex, n.actor, s)),
                e(i, o);
            };
          'parsing' === t.status
            ? (t.reloadCallback = s)
            : 'done' === t.status && t.parse(t.vectorTile, this.layerIndex, this.actor, s);
        }
      }
      abortTile(t, e) {
        const i = this.loading,
          o = t.uid;
        i && i[o] && (this.irc.removeRequestById(o), delete i[o]), e();
      }
      removeTile(t, e) {
        const i = this.loaded,
          o = t.uid;
        i && i[o] && delete i[o], e();
      }
    }
    class re {
      constructor(e, i, o, n) {
        (this.actor = e),
          (this.loading = {}),
          (this.loaded = {}),
          (this.terrainTileParser = new t.TerrainTileParser()),
          (this.projection = n);
      }
      registRequestController(t) {
        this.irc = t;
      }
      loadTile(t, e) {
        this._loadData(t, e);
      }
      _loadData(t, e) {
        const i = t.uid;
        (this.loading[i] = this.irc.pushRequest({
          id: i,
          param: t.request,
          cb: (o, n) => {
            o && e(o, null);
            const s = this.terrainTileParser.createTerrain(
              n.data,
              t.tileID.canonical.x,
              t.tileID.canonical.y,
              t.tileID.canonical.z,
              this.projection,
            );
            delete this.loading[i], e(null, s);
          },
        })),
          this.irc.run();
      }
      reloadTile(t, e) {
        this._loadData(t, e);
        const i = this.loaded,
          o = t.uid,
          n = this;
        if (i && i[o]) {
          const t = i[o],
            s = (i, o) => {
              const s = t.reloadCallback;
              s && (delete t.reloadCallback, t.parse(t.vectorTile, n.layerIndex, n.actor, s)),
                e(i, o);
            };
          'parsing' === t.status
            ? (t.reloadCallback = s)
            : 'done' === t.status && t.parse(t.vectorTile, this.layerIndex, this.actor, s);
        }
      }
      abortTile(t, e) {
        const i = this.loading,
          o = t.uid;
        i && i[o] && (this.irc.removeRequestById(o), delete i[o]), e();
      }
      removeTile(t, e) {
        const i = this.loaded,
          o = t.uid;
        i && i[o] && delete i[o], e();
      }
    }
    class ae {
      constructor(e) {
        (this.self = e),
          (this.actor = new t.Actor(e, this)),
          (this.layerIndexes = {}),
          (this.availableImages = {}),
          (this.isSpriteLoaded = {}),
          (this.requestPerformanceManager = new t.RequestPerformanceManger()),
          (this.workerSourceTypes = { vector: z, geojson: ne, raster: se, terrain: re }),
          (this.workerSources = {}),
          (this.self.registerWorkerSource = (t, e) => {
            if (this.workerSourceTypes[t])
              throw new Error(`Worker source with name "${t}" already registered.`);
            this.workerSourceTypes[t] = e;
          }),
          (this.self.registerRTLTextPlugin = (e) => {
            if (t.plugin.isParsed()) throw new Error('RTL text plugin already registered.');
            (t.plugin.applyArabicShaping = e.applyArabicShaping),
              (t.plugin.processBidirectionalText = e.processBidirectionalText),
              (t.plugin.processStyledBidirectionalText = e.processStyledBidirectionalText);
          });
      }
      clearCaches(t, e, i) {
        delete this.layerIndexes[t],
          delete this.availableImages[t],
          delete this.workerSources[t],
          i();
      }
      spriteLoaded(e, i) {
        this.isSpriteLoaded[e] = i;
        for (const o in this.workerSources[e]) {
          const n = this.workerSources[e][o];
          for (const e in n)
            n[e] instanceof z &&
              ((n[e].isSpriteLoaded = i), n[e].fire && n[e].fire(new t.Event('isSpriteLoaded')));
        }
      }
      setImages(t, e, i) {
        this.availableImages[t] = e;
        for (const i in this.workerSources[t]) {
          const o = this.workerSources[t][i];
          for (const t in o) o[t].availableImages = e;
        }
        i();
      }
      setProjection(t, e, i) {
        (this.projection = e.projection), i();
      }
      setReferrer(t, e) {
        this.referrer = e;
      }
      setLayers(t, e, i) {
        this.getLayerIndex(t).replace(e), i();
      }
      updateLayers(t, e, i) {
        this.getLayerIndex(t).update(e.layers, e.removedIds), i();
      }
      loadTile(t, e, i) {
        (e.projection = this.projection), this.getWorkerSource(t, e.type, e.source).loadTile(e, i);
      }
      reloadTile(t, e, i) {
        this.getWorkerSource(t, e.type, e.source).reloadTile(e, i);
      }
      abortTile(t, e, i) {
        this.getWorkerSource(t, e.type, e.source).abortTile(e, i);
      }
      removeTile(t, e, i) {
        this.getWorkerSource(t, e.type, e.source).removeTile(e, i);
      }
      removeSource(t, e, i) {
        if (
          !this.workerSources[t] ||
          !this.workerSources[t][e.type] ||
          !this.workerSources[t][e.type][e.source]
        )
          return;
        const o = this.workerSources[t][e.type][e.source];
        delete this.workerSources[t][e.type][e.source],
          void 0 !== o.removeSource ? o.removeSource(e, i) : i();
      }
      trianglesIntersact(t, e, i) {
        'raster' === e.type && this.getWorkerSource(t, e.type, e.source).trianglesIntersact(e, i);
      }
      loadWorkerSource(t, e, i) {
        try {
          this.self.importScripts(e.url), i();
        } catch (t) {
          i(t.toString());
        }
      }
      syncRTLPluginState(e, i, o) {
        try {
          t.plugin.setState(i);
          const e = t.plugin.getPluginURL();
          if (t.plugin.isLoaded() && !t.plugin.isParsed() && null != e) {
            this.self.importScripts(e);
            const i = t.plugin.isParsed();
            o(i ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${e}`), i);
          }
        } catch (t) {
          o(t.toString());
        }
      }
      getLayerIndex(t) {
        let e = this.layerIndexes[t];
        return e || (e = this.layerIndexes[t] = new o()), e;
      }
      getAvailableImages(t) {
        let e = this.availableImages[t];
        return e || (e = []), e;
      }
      fetchLoadersTilesData(e, i, o) {
        i.json
          ? t.getJSON(i.requestOptions, (t, e) => {
              o(t, e);
            })
          : t.getArrayBuffer(i.requestOptions, (e, i) => {
              i && (i = t.decodeModel(i)), o(e, i);
            });
      }
      loadRegularTile(e, i, o) {
        o(null, t.tileSamplesGrid(i.tileID, this.projection));
      }
      caculateViewdomeRatio(e, i, o) {
        let n = 0,
          s = 0,
          r = 0;
        for (let e = 0; e < i.data.length; e++) {
          const o = i.data[e];
          for (let e = 0; e < o.length; e += 4) {
            const i = t.Vector4.unpack(o, e, new t.Vector4());
            255 === i.w && (255 === i.x ? n++ : 255 === i.y && s++);
          }
        }
        (r = 0 == s && 0 === s ? 0 : s / (n + s)), o(null, r);
      }
      toggleRequestStatus(t, e) {
        e
          ? this.requestPerformanceManager.pauseVectorRequest()
          : this.requestPerformanceManager.restartVectorRequest();
      }
      getWorkerSource(e, i, o) {
        if (
          (this.workerSources[e] || (this.workerSources[e] = {}),
          this.workerSources[e][i] || (this.workerSources[e][i] = {}),
          !this.workerSources[e][i][o])
        ) {
          const n = {
              send: (t, i, o) => {
                this.actor.send(t, i, o, e);
              },
            },
            s = this.projection || t.ProjectionType.MERCATOR;
          (this.workerSources[e][i][o] = new this.workerSourceTypes[i](
            n,
            this.getLayerIndex(e),
            this.getAvailableImages(e),
            s,
            this.isSpriteLoaded[e],
          )),
            'raster' === i
              ? this.workerSources[e][i][o].registRequestController(
                  this.requestPerformanceManager.getImageRequesterById(o),
                )
              : 'vector' === i || 'geojson' === i
              ? this.workerSources[e][i][o].registRequestController(
                  this.requestPerformanceManager.getVectorRequesterById(o),
                )
              : 'terrain' === i &&
                this.workerSources[e][i][o].registRequestController(
                  this.requestPerformanceManager.getTerrainRequesterById(o),
                );
        }
        return this.workerSources[e][i][o];
      }
    }
    return (
      'undefined' != typeof WorkerGlobalScope &&
        'undefined' != typeof self &&
        self instanceof WorkerGlobalScope &&
        (self.worker = new ae(self)),
      ae
    );
  });

  define(['./shared'], function (e) {
    'use strict';
    function t(e, i) {
      if (Array.isArray(e)) {
        if (!Array.isArray(i) || e.length !== i.length) return !1;
        for (let s = 0; s < e.length; s++) if (!t(e[s], i[s])) return !1;
        return !0;
      }
      if ('object' == typeof e && null !== e && null !== i) {
        if ('object' != typeof i) return !1;
        if (Object.keys(e).length !== Object.keys(i).length) return !1;
        for (const s in e) if (!t(e[s], i[s])) return !1;
        return !0;
      }
      return e === i;
    }
    'function' != typeof Object.assign &&
      (Object.assign = function (e) {
        if (null == e) throw new TypeError('Cannot convert undefined or null to object');
        e = Object(e);
        for (let t = 1; t < arguments.length; t++) {
          const i = arguments[t];
          if (null != i)
            for (const t in i) Object.prototype.hasOwnProperty.call(i, t) && (e[t] = i[t]);
        }
        return e;
      });
    class i {
      constructor(t = {}) {
        (t = { near: 1, far: 5e8, xOffset: 0, yOffset: 0, ...t }),
          (this._offCenterFrustum = new e.PerspectiveOffCenterFrustum()),
          (this.fov = t.fov),
          (this._fov = t.fov),
          (this._fovy = t.fovy || 2 * Math.atan(Math.tan(0.5 * this.fov) / t.aspectRatio)),
          (this._sseDenominator = void 0),
          (this.aspectRatio = t.aspectRatio),
          (this._aspectRatio = void 0),
          (this.near = t.near),
          (this._near = this.near),
          (this.far = t.far),
          (this._far = this.far),
          (this.xOffset = t.xOffset),
          (this._xOffset = this.xOffset),
          (this.yOffset = t.yOffset),
          (this._yOffset = this.yOffset);
      }
      clone() {
        return new i({
          aspectRatio: this.aspectRatio,
          fov: this.fov,
          near: this.near,
          far: this.far,
        });
      }
      equals(e) {
        return (
          null != e &&
          e instanceof i &&
          (s(this),
          s(e),
          this.fov === e.fov &&
            this.aspectRatio === e.aspectRatio &&
            this.near === e.near &&
            this.far === e.far &&
            this._offCenterFrustum.equals(e._offCenterFrustum))
        );
      }
      get projectionMatrix() {
        return s(this), this._offCenterFrustum.projectionMatrix;
      }
      get infiniteProjectionMatrix() {
        return s(this), this._offCenterFrustum.infiniteProjectionMatrix;
      }
      get fovy() {
        return s(this), this._fovy;
      }
      get sseDenominator() {
        return s(this), this._sseDenominator;
      }
      computeCullingVolume(e, t, i) {
        return s(this), this._offCenterFrustum.computeCullingVolume(e, t, i);
      }
      setFromMatrix(e) {
        return s(this), this._offCenterFrustum.setFromMatrix(e);
      }
      getPixelDimensions(e, t, i, r) {
        return s(this), this._offCenterFrustum.getPixelDimensions(e, t, i, r);
      }
    }
    function s(e) {
      const t = e._offCenterFrustum;
      (e.fov === e._fov &&
        e.aspectRatio === e._aspectRatio &&
        e.near === e._near &&
        e.far === e._far &&
        e.xOffset === e._xOffset &&
        e.yOffset === e._yOffset) ||
        ((e._aspectRatio = e.aspectRatio),
        (e._fov = e.fov),
        (e._near = e.near),
        (e._far = e.far),
        (e._sseDenominator = 2 * Math.tan(0.5 * e._fovy)),
        (e._xOffset = e.xOffset),
        (e._yOffset = e.yOffset),
        (t.top = e.near * Math.tan(0.5 * e._fovy)),
        (t.bottom = -t.top),
        (t.right = e.aspectRatio * t.top),
        (t.left = -t.right),
        (t.near = e.near),
        (t.far = e.far),
        (t.right += e.xOffset),
        (t.left += e.xOffset),
        (t.top += e.yOffset),
        (t.bottom += e.yOffset));
    }
    class r {
      constructor(e) {
        (this.camerapos = void 0),
          (this.cullingVolume = void 0),
          (this.dir = void 0),
          (this.up = void 0),
          (this.type = e.type),
          this.updateFrustum(e);
      }
      updateFrustum(t) {
        const { width: s, near: r, far: n, fov: o, fovy: a, aspectRatio: l } = t;
        switch (this.type) {
          case 'perspective':
            (this.fov = a),
              (this.frustum = new i({ fov: o, fovy: a, near: r, far: n, aspectRatio: l }));
            break;
          case 'orthographic':
            this.frustum = new e.OrthographicFrustum({ width: s, far: n, near: r, aspectRatio: l });
        }
      }
      updateCullingVolume(t, i, s) {
        (this.camerapos = t),
          (this.dir = new e.Vector3(i).sub(t)),
          (this.up = new e.Vector3(s).sub(t)),
          (this.cullingVolume = this.frustum.computeCullingVolume(t, this.dir, this.up));
      }
    }
    class n extends e.Camera {
      constructor(e, t, i, s) {
        super(),
          (this.type = 'PerspectiveCamera'),
          (this.isPerspectiveCamera = !0),
          (this.fov = void 0 !== e ? e : 60),
          (this.zoom = 1),
          (this.mapZoom = 0),
          (this.near = void 0 !== i ? i : 0.1),
          (this.far = void 0 !== s ? s : 2e3),
          (this.focus = 10),
          (this.aspect = void 0 !== t ? t : 1),
          (this.view = null),
          (this.filmGauge = 35),
          (this.filmOffset = 0),
          this.updateProjectionMatrix();
      }
      updatePerspectiveOptions(e) {
        e.hasOwnProperty('fov') && (this.fov = e.fov),
          e.hasOwnProperty('aspect') && (this.aspect = e.aspect),
          e.hasOwnProperty('near') && (this.near = e.near),
          e.hasOwnProperty('far') && (this.far = e.far),
          this.updateProjectionMatrix();
      }
      setFocalLength(t) {
        const i = (0.5 * this.getFilmHeight()) / t;
        (this.fov = 2 * e.CONSTS.TRANSFORM.RAD_TO_DEG * Math.atan(i)),
          this.updateProjectionMatrix();
      }
      getFocalLength() {
        const t = Math.tan(0.5 * e.CONSTS.TRANSFORM.DEG_TO_RAD * this.fov);
        return (0.5 * this.getFilmHeight()) / t;
      }
      getEffectiveFOV() {
        return (
          2 *
          e.CONSTS.TRANSFORM.RAD_TO_DEG *
          Math.atan(Math.tan(0.5 * e.CONSTS.TRANSFORM.DEG_TO_RAD * this.fov) / this.zoom)
        );
      }
      getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1);
      }
      getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1);
      }
      setViewOffset(e, t, i, s, r, n) {
        (this.aspect = e / t),
          null === this.view &&
            (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1,
            }),
          (this.view.enabled = !0),
          (this.view.fullWidth = e),
          (this.view.fullHeight = t),
          (this.view.offsetX = i),
          (this.view.offsetY = s),
          (this.view.width = r),
          (this.view.height = n),
          this.updateProjectionMatrix();
      }
      clearViewOffset() {
        null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
      }
      updateProjectionMatrix() {
        const t = this.near,
          i = e.CONSTS.TRANSFORM.DEG_TO_RAD * this.fov;
        this.frustumCrate
          ? this.frustumCrate.updateFrustum({
              near: t,
              far: this.far,
              fovy: i,
              fov: 2 * Math.atan(this.aspect * Math.tan(i / 2)),
              aspectRatio: this.aspect,
            })
          : (this.frustumCrate = new r({
              near: t,
              far: this.far,
              fovy: i,
              fov: 2 * Math.atan(this.aspect * Math.tan(i / 2)),
              aspectRatio: this.aspect,
              type: 'perspective',
            })),
          (this.projectionMatrix = this.frustumCrate.frustum.projectionMatrix),
          (this.projectionMatrixInverse = this.projectionMatrix.clone().invert());
      }
      serialize() {
        return {
          type: 'PerspectiveCamera',
          fov: this.fov,
          aspect: this.aspect,
          near: this.near,
          far: this.far,
          matrix: this.matrixWorld,
        };
      }
    }
    class o extends e.Camera {
      constructor(t, i, s, r) {
        super(),
          (this.type = 'OrthographicCamera'),
          (this.isOrthographicCamera = !0),
          (this.zoom = 1),
          (this.view = null),
          (this.aspectRatio = e.defined(i) ? i : 1),
          (this.width = e.defined(t) ? t : 1),
          (this.near = e.defined(s) ? s : 0.1),
          (this.far = e.defined(r) ? r : 2e3),
          (this.viewMatrix = new e.Matrix4()),
          (this.projectMatrix = new e.Matrix4()),
          (this.vpMatrix = new e.Matrix4()),
          (this._painter = null),
          this.updateProjectionMatrix();
      }
      updateOrthographicOptions(e) {
        e.hasOwnProperty('width') && (this.width = e.width),
          e.hasOwnProperty('aspectRatio') && (this.aspectRatio = e.aspectRatio),
          e.hasOwnProperty('near') && (this.near = e.near),
          e.hasOwnProperty('far') && (this.far = e.far),
          this.updateProjectionMatrix();
      }
      setViewOffset(e, t, i, s, r, n) {
        null === this.view &&
          (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1,
          }),
          (this.view.enabled = !0),
          (this.view.fullWidth = e),
          (this.view.fullHeight = t),
          (this.view.offsetX = i),
          (this.view.offsetY = s),
          (this.view.width = r),
          (this.view.height = n),
          this.updateProjectionMatrix();
      }
      clearViewOffset() {
        null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
      }
      updateProjectionMatrix() {
        this.frustumCrate
          ? this.frustumCrate.updateFrustum({
              width: this.width,
              near: this.near,
              far: this.far,
              aspectRatio: this.aspectRatio,
            })
          : (this.frustumCrate = new r({
              width: this.width,
              near: this.near,
              far: this.far,
              aspectRatio: this.aspectRatio,
              type: 'orthographic',
            })),
          (this.projectionMatrix = this.frustumCrate.frustum.projectionMatrix),
          (this.projectionMatrixInverse = this.projectionMatrix.clone().invert());
      }
      update() {
        if (null == this._painter.frameState.camera) return;
        const e = this._painter.frameState.sunLight;
        null != e && (this.initViewMatrix(e), this.updateVPMatrix());
      }
      initViewMatrix(t) {
        const i = this._painter.frameState.camera.frustumCrate.camerapos;
        return (
          (this.lightRight = new e.Vector3()),
          (this.lightUp = new e.Vector3(
            -0.06079590320587158,
            0.17691355105489492,
            0.982346910983324,
          )),
          (this.lightDir = e.Vector3.normalize(
            t.getSunDirectionGlobalWithCache(),
            new e.Vector3(),
          )),
          (this.lightDir = e.Vector3.multiplyByScalar(this.lightDir, -1, this.lightDir)),
          (this.lightPosition = i),
          e.Vector3.cross(this.lightDir, this.lightUp, this.lightRight),
          (this.lightUp = e.Vector3.cross(this.lightRight, this.lightDir, new e.Vector3())),
          e.Vector3.normalize(this.lightUp, this.lightUp),
          e.Vector3.normalize(this.lightRight, this.lightRight),
          e.Matrix4.computeView(
            this.lightPosition,
            this.lightDir,
            this.lightUp,
            this.lightRight,
            this.viewMatrix,
          )
        );
      }
      updateVPMatrix() {
        const t = this.getBoundingBox(this._painter),
          i = t.max,
          s = t.min;
        (this.lightPosition = e.Matrix4.multiplyByVector(
          e.Matrix4.inverse(this.viewMatrix, new e.Matrix4()),
          e.Vector4.fromElements((s.x + i.x) / 2, (s.y + i.y) / 2, -s.z, 1),
          new e.Vector4(),
        )),
          e.Matrix4.computeView(
            this.lightPosition,
            this.lightDir,
            this.lightUp,
            this.lightRight,
            this.viewMatrix,
          ),
          this.updateProjectMatrix(s, i),
          (this.vpMatrix = new e.Matrix4()),
          e.Matrix4.multiply(this.vpMatrix, this.projectMatrix, this.viewMatrix);
      }
      updateProjectMatrix(t, i) {
        const s = 0.5 * (i.x - t.x),
          r = 0.5 * (i.y - t.y),
          n = -s,
          o = s,
          a = -r,
          l = r,
          h = -0.1,
          c = -(i.z - t.z),
          _ = new e.Matrix4();
        (_[0] = 2 / (o - n)),
          (_[5] = 2 / (l - a)),
          (_[10] = 2 / (c - h)),
          (_[12] = -(o + n) / (o - n)),
          (_[13] = -(l + a) / (l - a)),
          (_[14] = -(c + h) / (c - h)),
          (_[15] = 1),
          (this.projectMatrix = _);
      }
      getBoundingBox(t) {
        const i = this.getNearFar(t, this.lightPosition, this.lightDir),
          s = this.getNearFar(t, this.lightPosition, this.lightRight),
          r = this.getNearFar(t, this.lightPosition, this.lightUp);
        return {
          min: e.Vector3.fromElements(s[0], r[0], i[0]),
          max: e.Vector3.fromElements(s[1], r[1], i[1]),
        };
      }
      getNearFar(e, t, i) {
        let s = this.getMaxMin(e.renderGroup.modelTranslucentPrimitiveList, t, i, {
          near: +Number.MAX_VALUE,
          far: -Number.MAX_VALUE,
        });
        return (
          (s = this.getMaxMin(e.renderGroup.modelOpaquePrimitiveList, t, i, s)), [s.near, s.far]
        );
      }
      getMaxMin(e, t, i, s = {}) {
        let r = s.near,
          n = s.far;
        for (let s = 0; s < e.length; s++) {
          const o = e[s];
          if (o.boundingVolume) {
            const e = o.boundingVolume.computePlaneDistances(t, i),
              s = e.stop;
            (r = Math.min(r, e.start)), (n = Math.max(n, s));
          }
        }
        return { near: r, far: n };
      }
      serialize() {
        return {
          type: 'OrthographicCamera',
          width: this.width,
          aspect: this.aspectRatio,
          near: this.near,
          far: this.far,
          matrix: this.matrixWorld,
        };
      }
    }
    var a = Object.freeze({ LOOP_REPEAT: 0, LOOP_ONCE: 1, LOOP_NONE: 2 });
    const l = { NONE: 0, PRECISE: 1, MEDIUM: 2, STABLE: 3 };
    class h {
      constructor(t, i) {
        (this._blender = t),
          (this._clip = i),
          (this.id = e.uniqueId()),
          (this.loop = e.defaultValue(this._clip._loop, a.LOOP_REPEAT)),
          (this._loopCount = 0),
          (this._startTime = null),
          (this.time = 0),
          (this.timeScale = 1),
          (this._effectiveTimeScale = 1),
          (this.weight = 1),
          (this._effectiveWeight = 1),
          (this.paused = !1),
          (this.enabled = !1),
          (this.timeCounter = 0),
          (this.deltaTime = 0),
          (this.sumTime = 0);
      }
      play() {
        return (this.enabled = !0), this._blender._activateAction(this), this;
      }
      stop() {
        return (this.enabled = !1), this._blender._deactivateAction(this), this.reset();
      }
      reset() {
        (this.paused = !1),
          (this.enabled = !0),
          (this.time = 0),
          (this._loopCount = -1),
          (this._startTime = null);
      }
      update(e, t) {
        if (
          ('3d-model' !== this._blender._root.type &&
            '3d-model-instance' !== this._blender._root.type &&
            'Object3D' !== this._blender._root.type) ||
          !this._blender.trackingOptions
        ) {
          const e = this._updateTime(t);
          this._blender._root.animationPropertyCollection.get(
            `${this._clip.id}-${this.id}`,
          ).currentClipTime = e;
        } else
          switch (this._blender.trackingOptions.trackingEffect) {
            case l.STABLE:
              this.stableUpdate(e, t);
              break;
            case l.MEDIUM:
              this.mediumUpdate(e, t);
              break;
            default:
              this.preciseUpdate(e, t);
          }
      }
      stableUpdate(e, t) {
        this.timeCounter < 5
          ? ((this.deltaTime = t), (this.timeCounter += 1), (this.sumTime += t))
          : ((this.deltaTime = this.sumTime / 5), (t = this.deltaTime));
        const i = this._updateTime(t);
        this._blender._root.animationPropertyCollection.get(
          `${this._clip.id}-${this.id}`,
        ).currentClipTime = i;
      }
      mediumUpdate(e, t) {
        t = c(
          (function (e, t, i) {
            const s = [e - 0.0334, e - t, e, e + t, e + 0.0334],
              r = 0.5 * c(s),
              n = [];
            for (const e in s) {
              const t = s[e],
                i = Number(c([r, n[e - 1] || s[s.length - 1], t, t || s[0]]).toFixed(2));
              n.push(i);
            }
            return n;
          })(t, 0.0167),
        );
        const i = this._updateTime(t);
        this._blender._root.animationPropertyCollection.get(
          `${this._clip.id}-${this.id}`,
        ).currentClipTime = i;
      }
      preciseUpdate(e, t) {
        const i = this._updateTime(t);
        this._blender._root.animationPropertyCollection.get(
          `${this._clip.id}-${this.id}`,
        ).currentClipTime = i;
      }
      _updateTime(t) {
        const i = this._clip.duration;
        let s = this.time + t,
          r = this._loopCount;
        if (s >= i)
          switch (this.loop) {
            case a.LOOP_REPEAT:
              {
                const e = Math.floor(s / i);
                (s -= i * e), (r += Math.abs(e)), (this._loopCount = r), (this.time = s);
              }
              break;
            case a.LOOP_ONCE:
              this.time = i;
              break;
            case a.LOOP_NONE:
              this.time = s;
              break;
            default:
              throw new e.DeveloperError(`Invalid animation loop mode: ${this.loop}`);
          }
        else this.time = s;
        return this.time;
      }
      setLoop(e) {
        return (this.loop = e), this;
      }
      destroy() {
        for (const e in this) Object.hasOwnProperty.call(this, e) && (this[e] = null);
      }
    }
    function c(e) {
      return e.reduce((e, t) => e + t, 0) / e.length;
    }
    class _ {
      id = e.uniqueId();
      #e;
      #t;
      #i;
      #s;
      #r;
      constructor(t = 0, i, s, r, n) {
        (this.tracks = i),
          (this.#e = Math.max(t, 0)),
          (this.#t = r),
          (this.#i = n),
          (this.#s = e.defaultValue(s, a.LOOP_REPEAT)),
          (this.#r = !1);
      }
      get duration() {
        return this.#e;
      }
      set duration(e) {
        this.#e = e && 'number' == typeof e && e > 0 ? e : 0;
      }
      get startTime() {
        return this.#t;
      }
      set startTime(e) {
        this.#t = e && 'number' == typeof e && e > 0 ? e : 0;
      }
      get endTime() {
        return this.#i;
      }
      set endTime(e) {
        this.#i = e && 'number' == typeof e && e > 0 ? e : 0;
      }
      get loop() {
        return this.#s;
      }
      set loop(e) {
        e && (this.#s = e);
      }
      get dirty() {
        return this.#r;
      }
      set dirty(e) {
        'boolean' == typeof e && (this.#r = e);
      }
      destroy() {
        e.defined(this.tracks) &&
          this.tracks.length > 0 &&
          this.tracks.forEach((e) => {
            e.destroy();
          });
      }
      updateTracks(e) {
        Array.isArray(e) && e.length > 0 && ((this.tracks = e), (this.dirty = !0));
      }
    }
    const u = {
      getLinearInterpolationPosition: (e, t, i) => [
        (i[0] - t[0]) * e + t[0],
        (i[1] - t[1]) * e + t[1],
        (i[2] - t[2]) * e + t[2],
      ],
      leftBinarySearch(e, t, i, s) {
        const r = Math.floor((i + s) / 2),
          n = e[r];
        return i > s
          ? r
          : n > t
          ? u.leftBinarySearch(e, t, i, r - 1)
          : n < t
          ? u.leftBinarySearch(e, t, r + 1, s)
          : r;
      },
      getWeightAndPoints(e, t, i) {
        const s = u.leftBinarySearch(e, i, 0, e.length - 2),
          r = e[s];
        return {
          weight: Math.min((i - r) / (e[s + 1] - r), 1),
          pointCurrent: t[s],
          pointNext: t[s + 1],
          currentIndex: s,
        };
      },
      getRSModelMatrix(t, i, s) {
        const r = new e.Vector3();
        e.Vector3.subtract(i, t, r), r.normalize();
        const n = e.Transforms.rotationMatrixFromPositionVelocity(t, r),
          o = new e.Matrix4().setFromMatrix3(n),
          a = s.originalRotationScaleMatrix.clone();
        return o.multiplyRight(a), o;
      },
      getRotation(t, i) {
        const s = new e.Vector3();
        e.Vector3.subtract(i, t, s), s.normalize();
        const r = e.Transforms.rotationMatrixFromPositionVelocity(t, s),
          n = new e.Matrix4().setFromMatrix3(r),
          o = e.Transforms.eastNorthUpToFixedFrame(t),
          a = e.Matrix4.inverse(o, new e.Matrix4()),
          l = n.multiplyLeft(a),
          h = new e.Quaternion().fromRotationMatrix4(l.getRotation());
        return e.HeadingPitchRoll.fromQuaternion(h);
      },
      getRotationMatrixFromEuler(t, i) {
        const s = new e.Matrix4(),
          r = i.split('-'),
          n = {
            x: (e, t) => {
              e.rotateX(t);
            },
            y: (e, t) => {
              e.rotateY(t);
            },
            z: (e, t) => {
              e.rotateZ(t);
            },
          };
        for (let e = 0; e < r.length; e++) n[r[e]](s, t[e]);
        return s;
      },
      getRotationFromEuler(t, i) {
        const s = i.split('-');
        let r = 0,
          n = 0,
          o = 0;
        const a = {
          x: (e) => {
            o = e;
          },
          y: (e) => {
            n = -e;
          },
          z: (e) => {
            r = -e;
          },
        };
        for (let e = 0; e < s.length; e++) a[s[e]](t[e]);
        return new e.HeadingPitchRoll(r, n, o);
      },
      arraySubtract(e, t) {
        if (!Array.isArray(e) || !Array.isArray(t))
          throw new Error('arr1 or arr2 type must be Array');
        if (e.length !== t.length)
          throw new Error(" the 'arr1' length must be the same as the 'arr2' length ");
        return e.map((e, i) => e - t[i]);
      },
    };
    function d(
      e,
      t,
      i,
      s,
      {
        units: r = 'm',
        distancePrecision: n = 0,
        formula: o = 'great-circle',
        bearingPrecision: a = 0,
        directionPrecision: l = 2,
      } = {},
    ) {
      if (isNaN(e) || isNaN(i) || isNaN(t) || isNaN(s) || isNaN(a) || isNaN(l))
        throw new Error('Latitude/Longitude parameter is not a number!');
      if (Math.abs(e) > 90 || Math.abs(i) > 90 || Math.abs(t) > 180 || Math.abs(s) > 180)
        throw new Error('Latitude/Longitude parameter exceeding maximal value!');
      if (isNaN(n) || isNaN(a) || n > 15 || a > 15)
        throw new Error("Precision parameter is not a number or exceeds it's maximum value of 15!");
      if (!['m', 'km', 'ft', 'yd', 'mi', 'nm'].includes(r))
        throw new Error('Units parameter type not supported!');
      if (!['great-circle', 'rhumb-line'].includes(o))
        throw new Error('Calculation formula type parameter not supported!');
      const h = 6371009;
      function c(e) {
        return e * (Math.PI / 180);
      }
      Number.prototype.round = function (e = 0) {
        const t = Number(this.valueOf());
        return +`${Math.round(`${t}e+${e}`)}e-${e}`;
      };
      const _ = {},
        u = (function (e, t = 'm') {
          if ('m' === t) return e;
          switch (t) {
            case 'km':
              return 0.001 * e;
            case 'ft':
              return 3.28084 * e;
            case 'yd':
              return 1.0936 * e;
            case 'mi':
              return 621371e-9 * e;
            case 'nm':
              return 539957e-9 * e;
            default:
              return e;
          }
        })(
          'rhumb-line' === o
            ? (function (e, t, i, s) {
                if (e === i && t === s) return 0;
                const r = c(e),
                  n = c(i),
                  o = c(e - i);
                let a = c(t - s);
                const l = Math.log(Math.tan(Math.PI / 4 + n / 2) / Math.tan(Math.PI / 4 + r / 2)),
                  _ = Math.abs(l) > 1e-11 ? o / l : Math.cos(r);
                return (
                  Math.abs(a) > Math.PI && (a = a > 0 ? -(2 * Math.PI - a) : 2 * Math.PI + a),
                  Math.sqrt(o * o + _ * _ * a * a) * h
                );
              })(e, t, i, s)
            : (function (e, t, i, s) {
                if (e === i && t === s) return 0;
                const r = c(e),
                  n = c(i),
                  o = c(e - i),
                  a = c(t - s),
                  l =
                    Math.sin(o / 2) * Math.sin(o / 2) +
                    Math.cos(r) * Math.cos(n) * Math.sin(a / 2) * Math.sin(a / 2),
                  _ = 2 * Math.atan2(Math.sqrt(l), Math.sqrt(1 - l));
                return h * _;
              })(e, t, i, s),
          r,
        ).round(n);
      (_.distance = u), (_.units = r);
      const d = (function (e, t, i, s) {
        const r = c(e),
          n = c(i),
          o = c(s - t),
          a = Math.sin(o) * Math.cos(n),
          l = Math.cos(r) * Math.sin(n) - Math.sin(r) * Math.cos(n) * Math.cos(o);
        return (Math.atan2(a, l) * (180 / Math.PI) + 360) % 360;
      })(e, t, i, s);
      return (
        (_.bearing = d),
        (_.formula = o),
        0 !== l &&
          (_.direction =
            0 == u
              ? ''
              : (function (e, t) {
                  if (isNaN(e) || isNaN(t)) throw new Error('Parameter is not a number!');
                  if (e < 0 || e > 360) throw new Error('Parameter outside of range!');
                  if (t < 1 || t > 3) throw new Error('Parameter outside of range!');
                  const i = [
                    'N',
                    'NNE',
                    'NE',
                    'ENE',
                    'E',
                    'ESE',
                    'SE',
                    'SSE',
                    'S',
                    'SSW',
                    'SW',
                    'WSW',
                    'W',
                    'WNW',
                    'NW',
                    'NNW',
                  ];
                  let s = 4;
                  2 === t && (s = 8), 3 === t && (s = 16);
                  const r = i.length / s;
                  let n = Math.round(e / (360 / s)) * r;
                  return (() => i.length) && (n = 0), i[n];
                })(d, l)),
        _
      );
    }
    const m = { NONE: 0, FREE: 1, FOLLOW: 2, LOCK: 3 };
    function p(e, t) {
      return (
        e.children && e.children.length > 0
          ? e.children.forEach((e) => {
              if (e.children && e.children.length > 0) return p(e, t);
              t.push(e);
            })
          : t.push(e),
        t
      );
    }
    class f {
      get enabled() {
        return this._enabled;
      }
      set enabled(e) {
        this._enabled = e;
      }
      get currentClipTime() {
        return this._currentClipTime;
      }
      set currentClipTime(e) {
        this._currentClipTime = e;
      }
      constructor(e) {
        (this.id = `${e._clip.id}-${e.id}`),
          (this.animationClip = e._clip),
          (this.animationAction = e),
          (this._enabled = e.enabled),
          (this._currentClipTime = 0),
          (this._lastInstancePosition = void 0);
      }
      destroy() {
        (this._enabled = null),
          (this._currentClipTime = null),
          this.animationClip.destroy(),
          e.defined(this.animationAction._blender._root.animationsInfo) &&
            (this.animationAction._blender._root.animationsInfo.enabled = !1);
      }
      updateAnimation(e, t) {
        ('3d-model' !== e.type && '3d-model-instance' !== e.type) || this.updateModelAnimation(e),
          'geojson' === e.type && this.updateGeojsonAnimation(e),
          e._isPrimitive && this.updatePrimitiveAnimation(e, t);
      }
      updateModelAnimation(t) {
        if (!this.enabled) return;
        const i = this.animationClip.tracks,
          s = this.animationClip.dirty;
        for (const r of i) {
          if ('positionKeyframeTrack' === r.type) {
            const i = r.values,
              s = r.times,
              n = this.currentClipTime,
              { weight: o, pointCurrent: a, pointNext: l } = u.getWeightAndPoints(s, i, n),
              h = u.getLinearInterpolationPosition(o, a, l);
            this.animationAction._blender.trackingOptions && this.trackingAnimation(t, h),
              this.animationAction._blender.callback &&
                this.animationAction._blender.callback({
                  modelId: t.id,
                  currentPosition: e.Transforms.cartesian3ToCartographic(h),
                  totalMileage: this.animationAction._blender.trackCalculation.trackLength,
                }),
              (t.position = h),
              t.updateMatrixWorld(!0);
          }
          if ('multiPositionKeyframeTrack' === r.type) {
            const i = r.values,
              n = r.times,
              o = r.eulers || [],
              a = r.translations || [],
              l = r.colors || [],
              h = r.primitiveNames || [],
              c = this.currentClipTime,
              _ = r.trackIds || void 0;
            if ('ready' === t._setInstancePropertiesState && (!t.modelInstanceCollection || s)) {
              this.animationClip.dirty = !1;
              const s = i.map((e) => e[0]),
                n = o.map((e) => u.getRotationFromEuler(e[0], r.rotateOrder));
              (t.type = '3d-model-instance'),
                (t.modelInstanceCollection = new e.ModelInstanceCollection({
                  instances: e.ModelInstanceCollection.generateInstanceModelMatrix({
                    positions: s,
                    rotations: n,
                    instanceNames: _,
                    cartesian: !0,
                  }),
                  type: t.type,
                  rootId: t.id,
                })),
                t.setInstanceProperties(),
                (t.matrixAutoUpdate = !1),
                t.setMatrix(t.originalRotationScaleMatrix),
                t.updateMatrixWorld(!0);
            }
            if (!t.modelInstanceCollection) return;
            for (let s = 0; s < n.length; s++) {
              const _ = n[s],
                d = i[s],
                m = o[s] || [],
                f = a[s] || [],
                g = l[s] || [],
                y = h[s] || [],
                T = t.modelInstanceCollection._instances.get(s);
              if (_[0] > c) {
                T.show = !1;
                continue;
              }
              if (_.length < 2 || d.length < 2) {
                T.show = !1;
                continue;
              }
              T.show = !0;
              const {
                weight: x,
                pointCurrent: v,
                pointNext: b,
                currentIndex: w,
              } = u.getWeightAndPoints(_, d, c);
              let C = u.getLinearInterpolationPosition(x, v, b);
              this.animationAction._blender.trackingOptions &&
                ((T._map = t._map), this.trackingAnimation(T, C)),
                this.animationAction._blender.callback &&
                  this.animationAction._blender.callback({
                    modelId: T.instanceName,
                    currentPosition: e.Transforms.cartesian3ToCartographic(C),
                    totalMileage: this.animationAction._blender.trackCalculation.trackLength,
                  });
              const S = e.Transforms.eastNorthUpToFixedFrame(C);
              if (f.length > 0) {
                const t = u.getLinearInterpolationPosition(x, f[w], f[w + 1]);
                S.translate(e.Vector3.unpack(t)), (C = [S[12], S[13], S[14]]);
              }
              if (((T.position = e.Vector3.unpack(C)), m.length > 0)) {
                const e = r.rotateOrder,
                  t = u.getLinearInterpolationPosition(x, m[w], m[w + 1]),
                  i = u.getRotationFromEuler(t, e);
                T.rotation = i;
              }
              if (g.length > 0 && y.length > 0) {
                const e = p(t, []);
                for (let t = 0; t < e.length; t++)
                  e[t].parent &&
                    e[t].parent.mesh &&
                    e[t].parent.mesh.name === y[w] &&
                    (e[t].color = g[w]);
              }
            }
          }
          if ('trackingKeyframeTrack' === r.type) {
            const i = r.values,
              s = r.times,
              n = this.currentClipTime,
              { weight: o, pointCurrent: a, pointNext: l } = u.getWeightAndPoints(s, i, n);
            if (!e.Vector3.equals(a, l)) {
              const e = u.getRSModelMatrix(a, l, t);
              t.setMatrix(e);
            }
            const h = u.getLinearInterpolationPosition(o, a, l);
            this.animationAction._blender.trackingOptions && this.trackingAnimation(t, h),
              this.animationAction._blender.callback &&
                this.animationAction._blender.callback({
                  modelId: t.id,
                  currentPosition: e.Transforms.cartesian3ToCartographic(h),
                  totalMileage: this.animationAction._blender.trackCalculation.trackLength,
                }),
              (t.position = e.Vector3.unpack(h)),
              t.updateMatrixWorld(!0);
          }
          if ('multiTrackingKeyframeTrack' === r.type) {
            const i = r.values,
              n = r.times,
              o = this.currentClipTime,
              a = r.trackIds || void 0;
            if ('ready' === t._setInstancePropertiesState && (!t.modelInstanceCollection || s)) {
              this.animationClip.dirty = !1;
              const s = i.map((e) => e[0]);
              (t.type = '3d-model-instance'),
                (t.modelInstanceCollection = new e.ModelInstanceCollection({
                  instances: e.ModelInstanceCollection.generateInstanceModelMatrix({
                    positions: s,
                    instanceNames: a,
                    cartesian: !0,
                  }),
                  type: t.type,
                  rootId: t.id,
                })),
                t.setInstanceProperties(),
                (t.matrixAutoUpdate = !1),
                t.setMatrix(t.originalRotationScaleMatrix),
                t.updateMatrixWorld(!0);
            }
            if (!t.modelInstanceCollection) return;
            for (let s = 0; s < n.length; s++) {
              const r = n[s],
                a = i[s],
                l = t.modelInstanceCollection._instances.get(s);
              if (r[0] > o) {
                l.show = !1;
                continue;
              }
              if (r.length < 2 || a.length < 2) {
                l.show = !1;
                continue;
              }
              l.show = !0;
              const { weight: h, pointCurrent: c, pointNext: _ } = u.getWeightAndPoints(r, a, o),
                d = u.getLinearInterpolationPosition(h, c, _);
              this.animationAction._blender.trackingOptions &&
                ((l._map = t._map), this.trackingAnimation(l, d)),
                this.animationAction._blender.callback &&
                  this.animationAction._blender.callback({
                    modelId: l.instanceName,
                    currentPosition: e.Transforms.cartesian3ToCartographic(d),
                    totalMileage: this.animationAction._blender.trackCalculation.trackLength,
                  }),
                e.Vector3.equals(c, _) || (l.rotation = u.getRotation(c, _, t)),
                (l.position = e.Vector3.unpack(d));
            }
          }
        }
      }
      updateGeojsonAnimation(e) {
        (e.animationsInfo = e.animationsInfo || {}),
          (e.animationsInfo.currentClipTime = this.currentClipTime),
          (e.animationsInfo.enabled = this.enabled || !1);
      }
      updatePrimitiveAnimation(t, i) {
        if (!this.enabled) return;
        const s = this.animationClip.tracks,
          r = this.animationClip.dirty;
        for (const n of s) {
          if ('positionKeyframeTrack' === n.type) {
            const i = n.values,
              s = n.times,
              r = n.translations || [],
              o = this.currentClipTime,
              {
                weight: a,
                pointCurrent: l,
                pointNext: h,
                currentIndex: c,
              } = u.getWeightAndPoints(s, i, o);
            if (s.length < 2 || i.length < 2) continue;
            const _ = e.Vector3.unpack(u.getLinearInterpolationPosition(a, l, h)),
              d = e.Transforms.eastNorthUpToFixedFrame(_);
            if (r.length > 0) {
              const t = e.Vector3.unpack(u.getLinearInterpolationPosition(a, r[c], r[c + 1]));
              d.translate(t), e.Matrix4.multiplyByPoint(d, t, _);
            }
            if (((t.position = _), 'BillboardMaterial' === t._material.type)) {
              const i = n.textures[c];
              i
                ? ((t._material.defines = { USE_BILLBOARDTEXTURE: !0 }),
                  (t._material._texture = i),
                  (t.show = !0))
                : ((t._material.defines = { USE_BILLBOARDTEXTURE: !1 }), (t.show = !1)),
                (t._material.position = e.Transforms.cartesian3ToCartographic(_));
            }
            t.updateMatrixWorld(!0);
          }
          if ('trackingKeyframeTrack' === n.type) {
            const i = n.values,
              s = n.times,
              r = this.currentClipTime,
              { weight: o, pointCurrent: a, pointNext: l } = u.getWeightAndPoints(s, i, r);
            if ('BillboardMaterial' !== t._material.type && !e.Vector3.equals(a, l)) {
              const e = u.getRSModelMatrix(a, l, t);
              t.setMatrix(e);
            }
            const h = u.getLinearInterpolationPosition(o, a, l);
            (t.position = h),
              'BillboardMaterial' === t._material.type &&
                (t._material.position = e.Transforms.cartesian3ToCartographic(h)),
              t.updateMatrixWorld(!0);
          }
          if ('multiPositionKeyframeTrack' === n.type) {
            const s = n.values,
              o = n.times,
              a = n.eulers || [],
              l = n.translations || [],
              h = n.colors || [],
              c = this.currentClipTime,
              _ = i.camera.getVPMatrix(),
              d = _.clone().invert();
            if (!t.animationModelInstanceCollection || r) {
              this.animationClip.dirty = !1;
              const i = s[0],
                r = s.map((t) => {
                  const s = new e.Vector3();
                  return e.Vector3.subtract(t[0], i[0], s), s;
                });
              (t.animationModelInstanceCollection = new e.ModelInstanceCollection({
                instances: e.ModelInstanceCollection.generateInstanceObject(r),
              })),
                t.setInstanceProperties(),
                (t.matrixAutoUpdate = !1),
                t.setMatrix(new e.Matrix4()),
                t.updateMatrixWorld(!0);
            }
            if (!t.animationModelInstanceCollection) return;
            t.setMatrix(d), t.updateMatrixWorld(!0);
            for (let r = 0; r < o.length; r++) {
              const d = o[r],
                m = s[r],
                p = a[r] || [],
                f = l[r] || [],
                g = h[r] || [],
                y = t.animationModelInstanceCollection._instances.get(r);
              if (d[0] > c) {
                y.show = !1;
                continue;
              }
              if (d.length < 2 || m.length < 2) {
                y.show = !1;
                continue;
              }
              y.show = !0;
              const {
                  weight: T,
                  pointCurrent: x,
                  pointNext: v,
                  currentIndex: b,
                } = u.getWeightAndPoints(d, m, c),
                w = u.getLinearInterpolationPosition(T, x, v),
                C = e.Transforms.eastNorthUpToFixedFrame(w);
              if ('BillboardMaterial' === t._material.type) {
                if (f.length > 0) {
                  const t = u.getLinearInterpolationPosition(T, f[b], f[b + 1]);
                  C.translate(e.Vector3.unpack(t));
                }
                const s = i.camera.getViewMatrix().clone().multiplyRight(C);
                t.animationModelInstanceCollection.updateInstanceMatrixByIndex(r, s);
              } else {
                if (f.length > 0) {
                  const t = u.getLinearInterpolationPosition(T, f[b], f[b + 1]);
                  C.translate(e.Vector3.unpack(t));
                }
                if (p.length > 0) {
                  const e = n.rotateOrder,
                    t = u.getLinearInterpolationPosition(T, p[b], p[b + 1]),
                    i = u.getRotationMatrixFromEuler(t, e);
                  C.multiplyRight(i);
                }
                C.multiplyRight(t.originalRotationScaleMatrix.clone());
                const i = _.clone().multiplyRight(C);
                t.animationModelInstanceCollection.updateInstanceMatrixByIndex(r, i);
              }
              g.length > 0 && (t.color = g[b]);
            }
          }
          if ('multiTrackingKeyframeTrack' === n.type) {
            const s = n.values,
              o = n.times,
              a = this.currentClipTime,
              l = i.camera.getVPMatrix(),
              h = l.clone().invert();
            if (!t.animationModelInstanceCollection || r) {
              this.animationClip.dirty = !1;
              const i = s[0],
                r = s.map((t) => {
                  const s = new e.Vector3();
                  return e.Vector3.subtract(t[0], i[0], s), s;
                });
              (t.animationModelInstanceCollection = new e.ModelInstanceCollection({
                instances: e.ModelInstanceCollection.generateInstanceObject(r),
              })),
                t.setInstanceProperties(),
                (t.matrixAutoUpdate = !1),
                t.setMatrix(new e.Matrix4()),
                t.updateMatrixWorld(!0);
            }
            if (!t.animationModelInstanceCollection) return;
            t.setMatrix(h), t.updateMatrixWorld(!0);
            for (let r = 0; r < o.length; r++) {
              const n = o[r],
                h = s[r],
                c = t.animationModelInstanceCollection._instances.get(r);
              if (n[0] > a) {
                c.show = !1;
                continue;
              }
              if (n.length < 2 || h.length < 2) {
                c.show = !1;
                continue;
              }
              c.show = !0;
              let _ = new e.Matrix4();
              const { weight: d, pointCurrent: m, pointNext: p } = u.getWeightAndPoints(n, h, a),
                f = u.getLinearInterpolationPosition(d, m, p);
              if ('BillboardMaterial' === t._material.type) {
                _ = e.Transforms.eastNorthUpToFixedFrame(f);
                const s = i.camera.getViewMatrix().clone().multiplyRight(_);
                t.animationModelInstanceCollection.updateInstanceMatrixByIndex(r, s);
              } else {
                e.Vector3.equals(m, p)
                  ? ((_ = e.Transforms.eastNorthUpToFixedFrame(f)),
                    _.multiplyRight(t.originalRotationScaleMatrix.clone()))
                  : (_ = u.getRSModelMatrix(m, p, t)),
                  (_[12] = f[0]),
                  (_[13] = f[1]),
                  (_[14] = f[2]);
                const i = l.clone().multiplyRight(_);
                t.animationModelInstanceCollection.updateInstanceMatrixByIndex(r, i);
              }
            }
          }
        }
      }
      trackingAnimation(t, i) {
        const s = this.animationAction._blender.trackingOptions;
        if (!s) return;
        let r;
        if (
          (t instanceof e.ModelInstance
            ? s.trackingModel === t._instanceName &&
              (r = [t._modelMatrix[12], t._modelMatrix[13], t._modelMatrix[14]])
            : (r = [t.matrixWorld[12], t.matrixWorld[13], t.matrixWorld[14]]),
          !r)
        )
          return (
            t._map.scrollZoom.enable(), t._map.dragRotate.enable(), void t._map.dragPan.enable()
          );
        if (null === s || (s.trackingModel !== t.id && s.trackingModel !== t._instanceName))
          t._map.scrollZoom.enable(), t._map.dragRotate.enable(), t._map.dragPan.enable();
        else {
          let o;
          switch (s.trackingMode) {
            case m.FREE:
              t._map.scrollZoom.enable(), t._map.dragRotate.enable(), t._map.dragPan.enable();
              break;
            case m.FOLLOW:
              if (
                (t._map.scrollZoom.enable(),
                t._map.dragRotate.enable(),
                t._map.dragPan.enable(),
                s.onset)
              ) {
                const n =
                  (s.onset.distance * Math.sin((s.onset.pitch * Math.PI) / 180) * 180) /
                  (6378137 * Math.PI);
                o = s.onset.distance * Math.cos((s.onset.pitch * Math.PI) / 180);
                const a = e.Transforms.cartesian3ToCartographic(r);
                if (i[0] === r[0] && i[1] === r[1] && i[2] === r[2]) break;
                t._map.jumpTo({
                  target: [a[0], a[1] - n, a[2] + o],
                  bearing: e.defined(s.onset.bearing) ? s.onset.bearing : 0,
                  pitch: e.defined(s.onset.pitch) ? s.onset.pitch : 0,
                });
              }
              break;
            case m.LOCK:
              const a = e.Transforms.cartesian3ToCartographic(r),
                l = e.Transforms.cartesian3ToCartographic(i),
                h = d(a[1], a[0], l[1], l[0]).bearing,
                c = Math.asin(
                  (l[2] - a[2]) /
                    e.Vector3.distance(e.Vector3.fromArray(r), e.Vector3.fromArray(i)),
                );
              if (s.onset) {
                const a =
                    ((s.onset.distance * Math.sin((s.onset.pitch * Math.PI) / 180) * 180) /
                      (6378137 * Math.PI)) *
                    Math.cos(g(h)),
                  l =
                    ((s.onset.distance * Math.sin((s.onset.pitch * Math.PI) / 180) * 180) /
                      (6378137 * Math.PI)) *
                    Math.sin(g(h));
                o = s.onset.distance * Math.cos((s.onset.pitch * Math.PI) / 180);
                const _ = e.Transforms.cartesian3ToCartographic(r);
                if (i[0] === r[0] && i[1] === r[1] && i[2] === r[2]) {
                  t._map.scrollZoom.enable(), t._map.dragRotate.enable(), t._map.dragPan.enable();
                  break;
                }
                t._map.scrollZoom.disable(),
                  t._map.dragRotate.disable(),
                  t._map.dragPan.disable(),
                  t._map.jumpTo({
                    target: [_[0] - l, _[1] - a * Math.sin(g(s.onset.pitch)), _[2] + o],
                    bearing: h,
                    pitch: s.onset.pitch + ((n = c), (180 * n) / Math.PI),
                  });
              }
              break;
            default:
              t._map.scrollZoom.enable(), t._map.dragRotate.enable(), t._map.dragPan.enable();
          }
        }
        var n;
      }
    }
    function g(e) {
      return (e * Math.PI) / 180;
    }
    class y {
      constructor(t, i) {
        if (!e.defined(t)) throw new e.DeveloperError('must have root');
        (this._root = t),
          (this.id = t.id),
          (this.time = 0),
          (this._actions = []),
          (this._uuid = e.uuid()),
          (this._play = !1),
          this._setClipAction(e.defaultValue(i, []));
      }
      get actions() {
        return this._actions;
      }
      set actions(e) {
        e instanceof h && this._actions.push(e);
      }
      addClipAction(e) {
        return this._setClipAction([e]);
      }
      _setClipAction(e) {
        const t = [];
        for (let i = 0; i < e.length; i++) {
          const s = e[i];
          if (s instanceof _) {
            const e = new h(this, s);
            this.#n(e), (this.actions = e), t.push(e);
          }
        }
        return t;
      }
      _activateAction(e) {
        this._root.animationPropertyCollection.get(`${e._clip.id}-${e.id}`).enabled = e.enabled;
      }
      _deactivateAction(e) {
        this._root.animationPropertyCollection.get(`${e._clip.id}-${e.id}`).enabled = e.enabled;
      }
      play() {
        (this._play = !0), (this._actions[0].enabled = !0), this._activateAction(this._actions[0]);
      }
      pause() {
        (this._play = !1), (this._actions[0].enabled = !1), this._activateAction(this._actions[0]);
      }
      stop() {
        switch ((this.reset(), this._root.type)) {
          case '3d-model':
          default:
            (this._root.position = e.Transforms.cartographicToCartesian3(
              this._root._options.position,
            )),
              (this._root.rotation = this._root._options.rotation),
              this._root.updateMatrixWorld(!0);
            break;
          case '3d-model-instance':
            this._root.modelInstanceCollection._instances.forEach((e) => {
              e.modelMatrix = e._originalMatrix;
            });
        }
        this.update(0), this.pause();
      }
      reset() {
        (this._actions[0].paused = !1),
          (this._actions[0].enabled = !0),
          (this._actions[0].time = 0),
          (this._actions[0]._loopCount = -1),
          (this._actions[0]._startTime = null),
          this.play();
      }
      update(e) {
        if (!this._play) return;
        const t = (this.time += e);
        this.actions[0].update(t, e);
      }
      #n(t) {
        this._root.animationPropertyCollection =
          this._root.animationPropertyCollection || new e.AnimationPropertyCollection();
        let i = this._root.animationPropertyCollection.get(`${t._clip.id}-${t.id}`);
        i || ((i = new f(t)), this._root.animationPropertyCollection.add(i));
      }
    }
    class T {
      constructor(e, t) {
        if (void 0 === e) throw new Error('minemap.KeyframeTrack: track name is undefined');
        if (void 0 === t || 0 === t.length)
          throw new Error(`minemap.KeyframeTrack: no keyframes in track named ${e}`);
        this.name = e;
      }
      destroy() {
        (this.times = null), (this.values = null);
      }
    }
    class x extends T {
      constructor(e, t, i, s, r, n, o, a) {
        super(e, t),
          (this.type = 'positionKeyframeTrack'),
          (this.times = t),
          (this.values = x.parsePoints(i, 'pos')),
          s && (this.eulers = x.parsePoints(s, 'deg')),
          r && (this.translations = x.parsePoints(r, 'trans')),
          (this.rotateOrder = n || 'x-y-z'),
          o && a
            ? ((this.colors = o), (this.primitiveNames = a))
            : ((this.colors = []), (this.primitiveNames = []));
      }
      static parsePoints(t, i) {
        return 'pos' === i
          ? e.Vector3.fromDegreesArrayHeights(t)
          : 'deg' === i
          ? x.parsePointsDegree(t)
          : 'trans' === i
          ? x.parseTranslations(t)
          : void 0;
      }
      static parsePointsDegree(t) {
        if (t.length % 3 == 0) {
          const i = [];
          for (let s = 0; s < t.length; s += 3) {
            const r = [];
            (r[0] = t[s] * e.CONSTS.TRANSFORM.DEG_TO_RAD),
              (r[1] = t[s + 1] * e.CONSTS.TRANSFORM.DEG_TO_RAD),
              (r[2] = t[s + 2] * e.CONSTS.TRANSFORM.DEG_TO_RAD),
              i.push(r);
          }
          return i;
        }
      }
      static parseTranslations(e) {
        if (e.length % 3 == 0) {
          const t = [];
          for (let i = 0; i < e.length; i += 3) t.push([e[i], e[i + 1], e[i + 2]]);
          return t;
        }
      }
      parseImageInfo(t, i, s) {
        this.textures = [];
        let r,
          n = {};
        for (let o = 0; o < this.times.length; o++) {
          let a = !0;
          const l = {};
          for (const [t, s] of Object.entries(i)) {
            if (0 === o && this.times.length !== s.length)
              throw new e.DeveloperError(
                " the 'imageInfo' length must be the same as the 'values' length ",
              );
            (l[t] = s[o]), n[t] !== l[t] && (a = !1);
          }
          (n = l),
            a ||
              (r = t(l)
                ? new e.Texture({ context: s, image: t(l), pixelFormat: e.WebGLConstants.RGBA })
                : void 0),
            this.textures.push(r);
        }
      }
    }
    class v extends T {
      constructor(e, t, i) {
        super(e, t),
          (this.type = 'trackingKeyframeTrack'),
          (this.times = t),
          (this.values = v.parsePoints(i));
      }
      static parsePoints(t) {
        if (Array.isArray(t)) return e.Vector3.fromDegreesArrayHeights(t);
      }
    }
    class b extends T {
      constructor(t, i, s) {
        if (
          (super(t, i),
          (this.type = 'multiTrackingKeyframeTrack'),
          (this.times = b.validateTimesParameter(i)),
          (this.values = b.parsePoints(s)),
          this.times.length !== this.values.length)
        )
          throw new e.DeveloperError(
            " the 'times' length must be the same as the 'values' length ",
          );
        if (((this.trackIds = arguments[8]), this.trackIds && this.trackIds.length !== i.length))
          throw new e.DeveloperError(
            " the 'trackIds' length must be the same as the 'times' length ",
          );
      }
      static parsePoints(t) {
        const i = [];
        if (!Array.isArray(t))
          throw new e.DeveloperError(" 'values' parameter type must be Array< Array<number> >");
        for (const s of t) {
          if (!Array.isArray(s))
            throw new e.DeveloperError(" 'values' parameter type must be Array< Array<number> >");
          i.push(e.Vector3.fromDegreesArrayHeights(s));
        }
        return i;
      }
      static validateTimesParameter(t) {
        if (!Array.isArray(t))
          throw new e.DeveloperError(" 'times' parameter type must be Array< Array<number> >");
        for (const i of t)
          if (!Array.isArray(i))
            throw new e.DeveloperError(" 'times' parameter type must be Array< Array<number> >");
        return t;
      }
    }
    class w extends T {
      constructor(t, i, s, r, n, o, a, l, h) {
        if (
          (super(t, i),
          (this.type = 'multiPositionKeyframeTrack'),
          (this.times = w.validateTimesParameter(i)),
          (this.values = w.parsePoints(s, 'pos')),
          r && ((this._angles = r), (this.eulers = w.parsePoints(r, 'deg'))),
          n && (this.translations = w.parsePoints(n, 'trans')),
          (this.rotateOrder = o || 'x-y-z'),
          a && l
            ? ((this._colors = a), (this.primitiveNames = l))
            : ((this._colors = []), (this.primitiveNames = [])),
          h && (this.trackIds = h),
          this.times.length !== this.values.length)
        )
          throw new e.DeveloperError(
            " the 'times' length must be the same as the 'values' length ",
          );
        if (r && this.times.length !== this.eulers.length)
          throw new e.DeveloperError(
            " the 'times' length must be the same as the 'angles' length ",
          );
        if (
          this.colors.length !== this.primitiveNames.length &&
          this.colors.length !== this.values.length
        )
          throw new e.DeveloperError(
            " the 'times' length must be the same as the 'colors' length and primitiveNames length",
          );
        if (h && this.trackIds.length !== i.length)
          throw new e.DeveloperError(
            " the 'trackIds' length must be the same as the 'times' length ",
          );
      }
      get colors() {
        return this._colors;
      }
      set colors(e) {
        this._colors = e;
      }
      static parsePoints(t, i) {
        const s = [];
        if (!Array.isArray(t))
          throw new e.DeveloperError(" 'values' parameter type must be Array< Array<number> >");
        for (const r of t) {
          if (!Array.isArray(r))
            throw new e.DeveloperError(" 'values' parameter type must be Array< Array<number> >");
          'pos' === i
            ? s.push(e.Vector3.fromDegreesArrayHeights(r))
            : 'deg' === i
            ? s.push(x.parsePointsDegree(r))
            : 'trans' === i && s.push(x.parseTranslations(r));
        }
        return s;
      }
      static validateTimesParameter(t) {
        if (!Array.isArray(t))
          throw new e.DeveloperError(" 'times' parameter type must be Array< Array<number> >");
        for (const i of t)
          if (!Array.isArray(i))
            throw new e.DeveloperError(" 'times' parameter type must be Array< Array<number> >");
        return t;
      }
    }
    var C = '4.4.8';
    class S extends e.Evented {
      constructor(t, i, s, r) {
        super(),
          (this.id = t),
          (this.type = 'geojson'),
          (this.minzoom = 0),
          (this.maxzoom = 22),
          (this.tileSize = 512),
          (this.isTileClipped = !0),
          (this.reparseOverscaled = !0),
          (this._removed = !1),
          (this.priorityRequest = i.priorityRequest || !1),
          (this.dispatcher = s),
          this.setEventedParent(r),
          (this._data = i.data),
          (this._options = e.extend({}, i)),
          (this._collectResourceTiming = i.collectResourceTiming),
          (this._resourceTiming = []),
          void 0 !== i.maxzoom && (this.maxzoom = i.maxzoom),
          i.type && (this.type = i.type),
          i.attribution && (this.attribution = i.attribution),
          (this.noBox = i.noBox);
        const n = e.EXTENT / this.tileSize;
        (this.promoteId = i.promoteId),
          (this.workerOptions = e.extend(
            {
              source: this.id,
              cluster: i.cluster || !1,
              geojsonVtOptions: {
                buffer: (void 0 !== i.buffer ? i.buffer : 128) * n,
                tolerance: (void 0 !== i.tolerance ? i.tolerance : 0.375) * n,
                extent: e.EXTENT,
                maxZoom: this.maxzoom,
                lineMetrics: i.lineMetrics || !1,
                generateId: i.generateId || !1,
              },
              superclusterOptions: {
                maxZoom: void 0 !== i.clusterMaxZoom ? i.clusterMaxZoom : this.maxzoom - 1,
                minPoints: Math.max(2, i.clusterMinPoints || 2),
                extent: e.EXTENT,
                radius: (void 0 !== i.clusterRadius ? i.clusterRadius : 50) * n,
                log: !1,
                generateId: i.generateId || !1,
              },
              clusterProperties: i.clusterProperties,
              filter: i.filter,
            },
            i.workerOptions,
          )),
          (this._timestamp = Date.now());
      }
      load() {
        this.fire(new e.Event('dataloading', { dataType: 'source' })),
          this._updateWorkerData((t) => {
            if (t) return void this.fire(new e.ErrorEvent(t));
            const i = { dataType: 'source', sourceDataType: 'metadata' };
            this._collectResourceTiming &&
              this._resourceTiming &&
              this._resourceTiming.length > 0 &&
              ((i.resourceTiming = this._resourceTiming), (this._resourceTiming = [])),
              this.fire(new e.Event('data', i));
          });
      }
      onAdd(e) {
        (this.map = e), this.load();
      }
      setData(t) {
        return (
          (this._data = t),
          (this._timestamp = Date.now()),
          this.fire(new e.Event('dataloading', { dataType: 'source' })),
          this._updateWorkerData((t) => {
            if (t) return void this.fire(new e.ErrorEvent(t));
            const i = { dataType: 'source', sourceDataType: 'content' };
            this._collectResourceTiming &&
              this._resourceTiming &&
              this._resourceTiming.length > 0 &&
              ((i.resourceTiming = this._resourceTiming), (this._resourceTiming = [])),
              this.fire(new e.Event('data', i)),
              this._eventedParent && this._eventedParent.reload && this._eventedParent.reload(!0);
          }),
          this
        );
      }
      getClusterExpansionZoom(e, t) {
        return (
          this.dispatcher.send(
            'geojson.getClusterExpansionZoom',
            { clusterId: e, source: this.id },
            t,
            this.workerID,
          ),
          this
        );
      }
      getClusterChildren(e, t) {
        return (
          this.dispatcher.send(
            'geojson.getClusterChildren',
            { clusterId: e, source: this.id },
            t,
            this.workerID,
          ),
          this
        );
      }
      getClusterLeaves(e, t, i, s) {
        return (
          this.dispatcher.send(
            'geojson.getClusterLeaves',
            { source: this.id, clusterId: e, limit: t, offset: i },
            s,
            this.workerID,
          ),
          this
        );
      }
      _updateWorkerData(t) {
        const i = e.extend({}, this.workerOptions),
          s = this._data;
        'string' == typeof s
          ? ((i.request = this.map._transformRequest(
              e.exported.resolveURL(s),
              e.ResourceType.Source,
            )),
            (i.request.collectResourceTiming = this._collectResourceTiming))
          : (i.data = JSON.stringify(s)),
          (this.workerID = this.dispatcher.send(
            `${this.type}.loadData`,
            i,
            (e, s) => {
              this._removed ||
                (s && s.abandoned) ||
                ((this._loaded = !0),
                s &&
                  s.resourceTiming &&
                  s.resourceTiming[this.id] &&
                  (this._resourceTiming = s.resourceTiming[this.id].slice(0)),
                this.dispatcher.send(
                  `${this.type}.coalesce`,
                  { source: i.source },
                  null,
                  this.workerID,
                ),
                t(e));
            },
            this.workerID,
          ));
      }
      loadTile(t, i) {
        const s = void 0 === t.workerID ? 'loadTile' : 'reloadTile';
        t.workerID = this.dispatcher.send(
          s,
          {
            type: this.type,
            uid: t.uid,
            tileID: t.tileID,
            zoom: t.tileID.overscaledZ,
            maxZoom: this.maxzoom,
            tileSize: this.tileSize,
            source: this.id,
            pixelRatio: e.exported.devicePixelRatio,
            showCollisionBoxes: this.map.showCollisionBoxes,
            promoteId: this.promoteId,
          },
          (e, r) => (
            t.unloadVectorData(),
            t.aborted
              ? i(null)
              : e
              ? i(e)
              : (t.loadVectorData(r, this.map.painter, 'reloadTile' === s), i(null))
          ),
          this.workerID,
        );
      }
      abortTile(e) {
        e.aborted = !0;
      }
      unloadTile(e) {
        e.unloadVectorData(),
          this.dispatcher.send(
            'removeTile',
            { uid: e.uid, type: this.type, source: this.id },
            null,
            e.workerID,
          );
      }
      onRemove() {
        (this._removed = !0),
          this.dispatcher.send(
            'removeSource',
            { type: this.type, source: this.id },
            null,
            this.workerID,
          );
      }
      serialize() {
        return e.extend({}, this._options, { type: this.type, data: this._data });
      }
      hasTransition() {
        return !1;
      }
      isEarthSource() {
        return !0;
      }
    }
    class E extends e.Object3D {
      constructor() {
        super(),
          (this._minzoom = 0),
          (this._maxzoom = 24),
          (this._visible = !0),
          (this._loaded = !1),
          (this._fileSize = 1 / 0),
          (this._classificationType = '');
      }
      set minzoom(e) {
        this._minzoom = e;
      }
      get minzoom() {
        return this._minzoom;
      }
      set maxzoom(e) {
        this._maxzoom = e;
      }
      get maxzoom() {
        return this._maxzoom;
      }
      set visible(e) {
        this._visible = e;
      }
      get visible() {
        return this._visible;
      }
      get loaded() {
        return this._loaded;
      }
      get culled() {
        return this._culled;
      }
      get fileSize() {
        return this._fileSize;
      }
      get classificationType() {
        return this._classificationType;
      }
      set classificationType(e) {
        this._classificationType = e;
      }
      get lightingModel() {
        return this._lightingModel;
      }
      set lightingModel(e) {
        this._lightingModel = e;
      }
      get videoMatchOptions() {
        return this._videoMatchOptions;
      }
      set videoMatchOptions(e) {
        this._videoMatchOptions = e;
      }
    }
    function P(e, t) {
      if (!e) throw new Error(t || 'loader assertion failed.');
    }
    const M = {
        self: 'undefined' != typeof self && self,
        window: 'undefined' != typeof window && window,
        global: 'undefined' != typeof global && global,
        document: 'undefined' != typeof document && document,
      },
      A = M.global || M.self || M.window,
      R = 'object' != typeof process || '[object process]' !== String(process) || process.browser,
      I = 'undefined' != typeof process && process.version && process.version.match(/v([0-9]*)/),
      O = (I && parseFloat(I[1])) || 0;
    function L(e, t) {
      if (!e) throw new Error(t || 'loaders.gl assertion failed.');
    }
    const D = {
        self: 'undefined' != typeof self && self,
        window: 'undefined' != typeof window && window,
        global: 'undefined' != typeof global && global,
        document: 'undefined' != typeof document && document,
      },
      B = D.global || D.self || D.window,
      V = 'object' != typeof process || '[object process]' !== String(process) || process.browser,
      N = 'function' == typeof importScripts,
      k = 'undefined' != typeof window && void 0 !== window.orientation,
      F = 'undefined' != typeof process && process.version && process.version.match(/v([0-9]*)/);
    F && parseFloat(F[1]);
    const G = new Map();
    function U(e) {
      L('string' == typeof e, 'worker source');
      const t = new Blob([e], { type: 'application/javascript' });
      return URL.createObjectURL(t);
    }
    function z(e, t = !0, i) {
      const s = i || new Set();
      if (e)
        if (H(e)) s.add(e);
        else if (H(e.buffer)) s.add(e.buffer);
        else if (ArrayBuffer.isView(e));
        else if (t && 'object' == typeof e) for (const i in e) z(e[i], t, s);
      return void 0 === i ? Array.from(s) : [];
    }
    function H(e) {
      return (
        !!e &&
        (e instanceof ArrayBuffer ||
          ('undefined' != typeof MessagePort && e instanceof MessagePort) ||
          ('undefined' != typeof ImageBitmap && e instanceof ImageBitmap) ||
          ('undefined' != typeof OffscreenCanvas && e instanceof OffscreenCanvas))
      );
    }
    const W = (e) => {};
    class j {
      static isSupported() {
        return 'undefined' != typeof Worker;
      }
      constructor(e) {
        const { name: t, source: i, url: s } = e;
        L(i || s),
          (this.name = t),
          (this.source = i),
          (this.url = s),
          (this.onMessage = W),
          (this.onError = (e) => {
            console.log(e);
          }),
          (this.terminated = !1),
          (this.worker = this._createBrowserWorker());
      }
      destroy() {
        (this.onMessage = W), (this.onError = W), this.worker.terminate(), (this.terminated = !0);
      }
      get isRunning() {
        return Boolean(this.onMessage);
      }
      postMessage(e, t) {
        (t = t || z(e)), this.worker.postMessage(e, t);
      }
      _getErrorFromErrorEvent(e) {
        let t = 'Failed to load ';
        return (
          (t += `worker ${this.name}. `),
          e.message && (t += `${e.message} in `),
          e.lineno && (t += `:${e.lineno}:${e.colno}`),
          new Error(t)
        );
      }
      _createBrowserWorker() {
        this._loadableURL = (function ({ source: e, url: t }) {
          L((e && !t) || (!e && t));
          let i = G.get(e || t);
          return (
            i ||
              (t &&
                ((i = (function (e) {
                  return e.startsWith('http')
                    ? U(
                        `try {\n  importScripts('${e}');\n} catch (error) {\n  console.error(error);\n  throw error;\n}`,
                      )
                    : e;
                })(t)),
                G.set(t, i)),
              e && ((i = U(e)), G.set(e, i))),
            L(i),
            i
          );
        })({ source: this.source, url: this.url });
        const e = new Worker(this._loadableURL, { name: this.name });
        return (
          (e.onmessage = (e) => {
            e.data ? this.onMessage(e.data) : this.onError('No data received');
          }),
          (e.onerror = (e) => {
            this.onError(this._getErrorFromErrorEvent(e)), (this.terminated = !0);
          }),
          (e.onmessageerror = (e) => {
            console.error(e);
          }),
          e
        );
      }
    }
    class q {
      constructor(e, t) {
        (this.name = e),
          (this.workerThread = t),
          (this.isRunning = !0),
          (this.result = new Promise((e, t) => {
            (this._resolve = e), (this._reject = t);
          }));
      }
      postMessage(e, t) {
        this.workerThread.postMessage({ source: 'loaders.gl', type: e, payload: t });
      }
      done(e) {
        L(this.isRunning), (this.isRunning = !1), this._resolve(e);
      }
      error(e) {
        L(this.isRunning), (this.isRunning = !1), this._reject(e);
      }
    }
    class X {
      constructor({
        source: e,
        url: t,
        name: i = 'unnamed',
        maxConcurrency: s = 1,
        onMessage: r,
        onDebug: n = () => {},
        reuseWorkers: o = !0,
      }) {
        L(e || t),
          (this.source = e),
          (this.url = t),
          (this.name = i),
          (this.maxConcurrency = s),
          (this.onMessage = r),
          (this.onDebug = n),
          (this.reuseWorkers = o),
          (this.jobQueue = []),
          (this.idleQueue = []),
          (this.count = 0),
          (this.isDestroyed = !1);
      }
      destroy() {
        this.idleQueue.forEach((e) => e.destroy()), (this.isDestroyed = !0);
      }
      async startJob(e, t = (e, t, i) => e.done(i), i = (e, t) => e.error(t)) {
        const s = new Promise((s) => {
          this.jobQueue.push({ name: e, onMessage: t, onError: i, onStart: s });
        });
        return this._startQueuedJob(), s;
      }
      async _startQueuedJob() {
        if (!this.jobQueue.length) return;
        const e = this._getAvailableWorker();
        if (!e) return;
        const t = this.jobQueue.shift();
        if (t) {
          this.onDebug({
            message: 'Starting job',
            jobName: t.name,
            workerThread: e,
            backlog: this.jobQueue.length,
          });
          const i = new q(t.name, e);
          (e.onMessage = (e) => t.onMessage(i, e.type, e.payload)),
            (e.onError = (e) => t.onError(i, e)),
            t.onStart(i);
          try {
            await i.result;
          } finally {
            this.returnWorkerToQueue(e);
          }
        }
      }
      returnWorkerToQueue(e) {
        this.isDestroyed
          ? e.destroy()
          : (this.reuseWorkers ? this.idleQueue.push(e) : (e.destroy(), this.count--),
            this._startQueuedJob());
      }
      _getAvailableWorker() {
        if (this.idleQueue.length > 0) return this.idleQueue.shift() || null;
        if (this.count < this.maxConcurrency) {
          this.count++;
          const e = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;
          return new j({ name: e, source: this.source, url: this.url });
        }
        return null;
      }
    }
    const Z = { maxConcurrency: 3, maxMobileConcurrency: 1, onDebug: () => {}, reuseWorkers: !0 };
    let $ = null;
    class K {
      static isSupported() {
        return j.isSupported();
      }
      static getWorkerFarm(e = {}) {
        return ($ = $ || new K({})), $.setProps(e), $;
      }
      constructor(e) {
        (this.props = { ...Z }), this.setProps(e), (this.workerPools = new Map());
      }
      destroy() {
        this.workerPools.forEach((e) => e.destroy());
      }
      setProps(e) {
        this.props = { ...this.props, ...e };
      }
      getWorkerPool({ name: e, source: t, url: i }) {
        let s = this.workerPools.get(e);
        return (
          s ||
            ((s = new X({
              name: e,
              source: t,
              url: i,
              maxConcurrency: k ? this.props.maxMobileConcurrency : this.props.maxConcurrency,
              onDebug: this.props.onDebug,
              reuseWorkers: this.props.reuseWorkers,
            })),
            this.workerPools.set(e, s)),
          s
        );
      }
    }
    const Y = 'undefined' != typeof __VERSION__ ? __VERSION__ : 'beta';
    function Q(e) {
      const t = e.split('.').map(Number);
      return { major: t[0], minor: t[1] };
    }
    const J = new Map();
    class ee {
      static set onmessage(e) {
        self.onmessage = (t) => {
          if (!te(t)) return;
          const { type: i, payload: s } = t.data;
          e(i, s);
        };
      }
      static addEventListener(e) {
        let t = J.get(e);
        t ||
          (t = (t) => {
            if (!te(t)) return;
            const { type: i, payload: s } = t.data;
            e(i, s);
          }),
          self.addEventListener('message', t);
      }
      static removeEventListener(e) {
        const t = J.get(e);
        J.delete(e), self.removeEventListener('message', t);
      }
      static postMessage(e, t) {
        if (self) {
          const i = { source: 'loaders.gl', type: e, payload: t },
            s = z(t);
          self.postMessage(i, s);
        }
      }
    }
    function te(e) {
      const { type: t, data: i } = e;
      return (
        'message' === t && i && 'string' == typeof i.source && i.source.startsWith('loaders.gl')
      );
    }
    'undefined' == typeof __VERSION__ || __VERSION__;
    const ie = {};
    async function se(e, t = null, i = {}) {
      return (
        t &&
          (e = (function (e, t, i) {
            if (e.startsWith('http')) return e;
            const s = i.modules || {};
            return s[e]
              ? s[e]
              : V
              ? i.CDN
                ? `${i.CDN}/${t}/dist/libs/${e}`
                : N
                ? `../src/libs/${e}`
                : `modules/${t}/src/libs/${e}`
              : `modules/${t}/dist/libs/${e}`;
          })(e, t, i)),
        (ie[e] =
          ie[e] ||
          (async function (e) {
            if (e.endsWith('wasm')) {
              const t = await fetch(e);
              return await t.arrayBuffer();
            }
            if (N) return importScripts(e);
            const t = await fetch(e);
            return (function (e, t) {
              if (N) return eval.call(B, e), null;
              const i = document.createElement('script');
              i.id = t;
              try {
                i.appendChild(document.createTextNode(e));
              } catch (t) {
                i.text = e;
              }
              return document.body.appendChild(i), null;
            })(await t.text(), e);
          })(e)),
        await ie[e]
      );
    }
    'undefined' == typeof __VERSION__ || __VERSION__;
    let re = 0;
    function ne(e, t = {}) {
      return new Promise((i, s) => {
        const r = re++,
          n = (e, t) => {
            if (t.id === r)
              switch (e) {
                case 'done':
                  ee.removeEventListener(n), i(t.result);
                  break;
                case 'error':
                  ee.removeEventListener(n), s(t.error);
              }
          };
        ee.addEventListener(n), ee.postMessage('process', { id: r, input: e, options: t });
      });
    }
    async function oe(e, t, i, s) {
      switch (i) {
        case 'done':
          t.done(s);
          break;
        case 'error':
          t.error(s.error);
          break;
        case 'process':
          const { id: i, input: r, options: n } = s;
          try {
            const s = await e(r, n);
            t.postMessage('done', { id: i, result: s });
          } catch (e) {
            t.postMessage('error', { id: i, error: e.message });
          }
      }
    }
    function ae(e, t, i) {
      if (e.byteLength <= t + i) return '';
      const s = new DataView(e);
      let r = '';
      for (let e = 0; e < i; e++) r += String.fromCharCode(s.getUint8(t + e));
      return r;
    }
    var le = {
      toArrayBuffer: (e) => (Buffer.isBuffer(e) ? new Uint8Array(e).buffer : e),
      toBuffer(e) {
        if (
          (ArrayBuffer.isView(e) && (e = e.buffer),
          'undefined' != typeof Buffer && e instanceof ArrayBuffer)
        ) {
          const t = new Buffer(e.byteLength),
            i = new Uint8Array(e);
          for (let e = 0; e < t.length; ++e) t[e] = i[e];
          return t;
        }
        return P(!1);
      },
    };
    function he(e) {
      if ((le.toArrayBuffer && (e = le.toArrayBuffer(e)), e instanceof ArrayBuffer)) return e;
      if (ArrayBuffer.isView(e)) return e.buffer;
      if ('string' == typeof e) {
        const t = e;
        return new TextEncoder().encode(t).buffer;
      }
      return e && 'object' == typeof e && e._toArrayBuffer ? e._toArrayBuffer() : P(!1);
    }
    function ce(e, t) {
      return P(e >= 0), P(t > 0), (e + (t - 1)) & ~(t - 1);
    }
    function _e(e, t, i) {
      let s;
      if (e instanceof ArrayBuffer) s = new Uint8Array(e);
      else {
        const t = e.byteOffset;
        s = new Uint8Array((e.buffer || e.arrayBuffer).slice(t, t + e.byteLength));
      }
      return t.set(s, i), i + ce(s.byteLength, 4);
    }
    function ue(e) {
      const t = e && e.lastIndexOf('/');
      return t >= 0 ? e.substr(0, t) : '';
    }
    let de = '';
    const me = {};
    function pe(e) {
      return (
        (pe =
          'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
            ? function (e) {
                return typeof e;
              }
            : function (e) {
                return e &&
                  'function' == typeof Symbol &&
                  e.constructor === Symbol &&
                  e !== Symbol.prototype
                  ? 'symbol'
                  : typeof e;
              }),
        pe(e)
      );
    }
    function fe(e, t, i) {
      return (
        (t = (function (e) {
          var t = (function (e, t) {
            if ('object' !== pe(e) || null === e) return e;
            var i = e[Symbol.toPrimitive];
            if (void 0 !== i) {
              var s = i.call(e, 'string');
              if ('object' !== pe(s)) return s;
              throw new TypeError('@@toPrimitive must return a primitive value.');
            }
            return String(e);
          })(e);
          return 'symbol' === pe(t) ? t : String(t);
        })(t)) in e
          ? Object.defineProperty(e, t, {
              value: i,
              enumerable: !0,
              configurable: !0,
              writable: !0,
            })
          : (e[t] = i),
        e
      );
    }
    function ge() {
      let e;
      if ('undefined' != typeof window && window.performance) e = window.performance.now();
      else if ('undefined' != typeof process && process.hrtime) {
        const t = process.hrtime();
        e = 1e3 * t[0] + t[1] / 1e6;
      } else e = Date.now();
      return e;
    }
    class ye {
      constructor(e, t) {
        fe(this, 'name', void 0),
          fe(this, 'type', void 0),
          fe(this, 'sampleSize', 1),
          fe(this, 'time', void 0),
          fe(this, 'count', void 0),
          fe(this, 'samples', void 0),
          fe(this, 'lastTiming', void 0),
          fe(this, 'lastSampleTime', void 0),
          fe(this, 'lastSampleCount', void 0),
          fe(this, '_count', 0),
          fe(this, '_time', 0),
          fe(this, '_samples', 0),
          fe(this, '_startTime', 0),
          fe(this, '_timerPending', !1),
          (this.name = e),
          (this.type = t),
          this.reset();
      }
      setSampleSize(e) {
        return (this.sampleSize = e), this;
      }
      incrementCount() {
        return this.addCount(1), this;
      }
      decrementCount() {
        return this.subtractCount(1), this;
      }
      addCount(e) {
        return (this._count += e), this._samples++, this._checkSampling(), this;
      }
      subtractCount(e) {
        return (this._count -= e), this._samples++, this._checkSampling(), this;
      }
      addTime(e) {
        return (
          (this._time += e), (this.lastTiming = e), this._samples++, this._checkSampling(), this
        );
      }
      timeStart() {
        return (this._startTime = ge()), (this._timerPending = !0), this;
      }
      timeEnd() {
        return this._timerPending
          ? (this.addTime(ge() - this._startTime),
            (this._timerPending = !1),
            this._checkSampling(),
            this)
          : this;
      }
      getSampleAverageCount() {
        return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
      }
      getSampleAverageTime() {
        return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
      }
      getSampleHz() {
        return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;
      }
      getAverageCount() {
        return this.samples > 0 ? this.count / this.samples : 0;
      }
      getAverageTime() {
        return this.samples > 0 ? this.time / this.samples : 0;
      }
      getHz() {
        return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
      }
      reset() {
        return (
          (this.time = 0),
          (this.count = 0),
          (this.samples = 0),
          (this.lastTiming = 0),
          (this.lastSampleTime = 0),
          (this.lastSampleCount = 0),
          (this._count = 0),
          (this._time = 0),
          (this._samples = 0),
          (this._startTime = 0),
          (this._timerPending = !1),
          this
        );
      }
      _checkSampling() {
        this._samples === this.sampleSize &&
          ((this.lastSampleTime = this._time),
          (this.lastSampleCount = this._count),
          (this.count += this._count),
          (this.time += this._time),
          (this.samples += this._samples),
          (this._time = 0),
          (this._count = 0),
          (this._samples = 0));
      }
    }
    class Te {
      constructor(e) {
        fe(this, 'id', void 0),
          fe(this, 'stats', {}),
          (this.id = e.id),
          (this.stats = {}),
          this._initializeStats(e.stats),
          Object.seal(this);
      }
      get(e) {
        return this._getOrCreate({
          name: e,
          type: arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'count',
        });
      }
      get size() {
        return Object.keys(this.stats).length;
      }
      reset() {
        for (const e in this.stats) this.stats[e].reset();
        return this;
      }
      forEach(e) {
        for (const t in this.stats) e(this.stats[t]);
      }
      getTable() {
        const e = {};
        return (
          this.forEach((t) => {
            e[t.name] = {
              time: t.time || 0,
              count: t.count || 0,
              average: t.getAverageTime() || 0,
              hz: t.getHz() || 0,
            };
          }),
          e
        );
      }
      _initializeStats() {
        (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []).forEach((e) =>
          this._getOrCreate(e),
        );
      }
      _getOrCreate(e) {
        if (!e || !e.name) return null;
        const { name: t, type: i } = e;
        return this.stats[t] || (this.stats[t] = e instanceof ye ? e : new ye(t, i)), this.stats[t];
      }
    }
    const xe = { id: 'request-scheduler', throttleRequests: !0, maxRequests: 6 };
    class ve {
      constructor(e = {}) {
        (this.props = { ...xe, ...e }),
          (this.requestQueue = []),
          (this.activeRequestCount = 0),
          (this.requestMap = new Map()),
          (this.stats = new Te({ id: e.id })),
          this.stats.get('Queued Requests'),
          this.stats.get('Active Requests'),
          this.stats.get('Cancelled Requests'),
          this.stats.get('Queued Requests Ever'),
          this.stats.get('Active Requests Ever'),
          (this._deferredUpdate = null);
      }
      scheduleRequest(e, t = () => 0) {
        if (!this.props.throttleRequests) return Promise.resolve({ done: () => {} });
        if (this.requestMap.has(e)) return this.requestMap.get(e);
        const i = { handle: e, getPriority: t },
          s = new Promise((e) => ((i.resolve = e), i));
        return this.requestQueue.push(i), this.requestMap.set(e, s), this._issueNewRequests(), s;
      }
      _issueRequest(e) {
        const { handle: t, resolve: i } = e;
        let s = !1;
        const r = () => {
          s ||
            ((s = !0),
            this.requestMap.delete(t),
            this.activeRequestCount--,
            this._issueNewRequests());
        };
        return this.activeRequestCount++, i ? i({ done: r }) : Promise.resolve({ done: r });
      }
      _issueNewRequests() {
        this._deferredUpdate ||
          (this._deferredUpdate = setTimeout(() => this._issueNewRequestsAsync(), 0));
      }
      _issueNewRequestsAsync() {
        this._deferredUpdate = null;
        const e = Math.max(this.props.maxRequests - this.activeRequestCount, 0);
        if (0 !== e) {
          this._updateAllRequests();
          for (let t = 0; t < e; ++t)
            if (this.requestQueue.length > 0) {
              const e = this.requestQueue.shift();
              this._issueRequest(e);
            }
        }
      }
      _updateAllRequests() {
        const e = this.requestQueue;
        for (let t = 0; t < e.length; ++t) {
          const i = e[t];
          this._updateRequest(i) || (e.splice(t, 1), this.requestMap.delete(i.handle), t--);
        }
        e.sort((e, t) => e.priority - t.priority);
      }
      _updateRequest(e) {
        return (e.priority = e.getPriority(e.handle)), !(e.priority < 0 && (e.resolve(null), 1));
      }
    }
    function be(e) {
      if (!e || !e.POSITION) return null;
      let t = 1 / 0,
        i = 1 / 0,
        s = 1 / 0,
        r = -1 / 0,
        n = -1 / 0,
        o = -1 / 0;
      const a = e.POSITION.value,
        l = a && a.length;
      if (!l) return null;
      for (let e = 0; e < l; e += 3) {
        const l = a[e],
          h = a[e + 1],
          c = a[e + 2];
        (t = l < t ? l : t),
          (i = h < i ? h : i),
          (s = c < s ? c : s),
          (r = l > r ? l : r),
          (n = h > n ? h : n),
          (o = c > o ? c : o);
      }
      return [
        [t, i, s],
        [r, n, o],
      ];
    }
    'undefined' == typeof __VERSION__ || __VERSION__,
      'undefined' == typeof __VERSION__ || __VERSION__;
    const we = 'undefined' != typeof __VERSION__ ? __VERSION__ : '';
    A.loaders = Object.assign(A.loaders || {}, { VERSION: we });
    const Ce = (e) => 'function' == typeof e,
      Se = (e) => null !== e && 'object' == typeof e,
      Ee = (e) => Se(e) && e.constructor === {}.constructor,
      Pe = (e) => e && 'function' == typeof e[Symbol.iterator],
      Me = (e) => e && 'function' == typeof e[Symbol.asyncIterator],
      Ae = (e) =>
        ('undefined' != typeof Response && e instanceof Response) ||
        (e && e.arrayBuffer && e.text && e.json),
      Re = (e) => 'undefined' != typeof Blob && e instanceof Blob,
      Ie = (e) => e && 'object' == typeof e && e.isBuffer,
      Oe = (e) =>
        ((e) =>
          ('undefined' != typeof ReadableStream && e instanceof ReadableStream) ||
          (Se(e) && Ce(e.tee) && Ce(e.cancel) && Ce(e.getReader)))(e) ||
        ((e) => Se(e) && Ce(e.read) && Ce(e.pipe) && ((e) => 'boolean' == typeof e)(e.readable))(e),
      Le = /^data:([-\w.]+\/[-\w.+]+)(;|,)/,
      De = /^([-\w.]+\/[-\w.+]+)/;
    function Be(e) {
      if ('string' != typeof e) return '';
      const t = e.match(Le);
      return t ? t[1] : '';
    }
    const Ve = /\?.*/;
    function Ne(e) {
      if (Ae(e)) {
        const t = (function (e) {
            if ('string' != typeof e) return '';
            const t = e.match(De);
            return t ? t[1] : e;
          })(e.headers.get('content-type')),
          i = Be(e.url);
        return { url: ke(e.url || ''), type: t || i || null };
      }
      return Re(e)
        ? { url: ke(e.name || ''), type: e.type || '' }
        : 'string' == typeof e
        ? { url: ke(e), type: Be(e) }
        : { url: '', type: '' };
    }
    function ke(e) {
      return e.replace(Ve, '');
    }
    async function Fe(e) {
      if (Ae(e)) return e;
      const t = {},
        i = (function (e) {
          return Ae(e)
            ? e.headers['content-length'] || -1
            : Re(e)
            ? e.size
            : 'string' == typeof e
            ? e.length
            : e instanceof ArrayBuffer || ArrayBuffer.isView(e)
            ? e.byteLength
            : -1;
        })(e);
      i >= 0 && (t['content-length'] = String(i));
      const { url: s, type: r } = Ne(e);
      r && (t['content-type'] = r);
      const n = await (async function (e) {
        if ('string' == typeof e) return `data:,${e.slice(0, 5)}`;
        if (e instanceof Blob) {
          const t = e.slice(0, 5);
          return await new Promise((e) => {
            const i = new FileReader();
            (i.onload = (t) => e(t.target && t.target.result)), i.readAsDataURL(t);
          });
        }
        return e instanceof ArrayBuffer
          ? `data:base64,${(function (e) {
              let t = '';
              const i = new Uint8Array(e);
              for (let e = 0; e < i.byteLength; e++) t += String.fromCharCode(i[e]);
              return btoa(t);
            })(e.slice(0, 5))}`
          : null;
      })(e);
      n && (t['x-first-bytes'] = n), 'string' == typeof e && (e = new TextEncoder().encode(e));
      const o = new Response(e, { headers: t });
      return Object.defineProperty(o, 'url', { value: s }), o;
    }
    async function Ge(e) {
      let t = `Failed to fetch resource ${e.url} (${e.status}): `;
      try {
        e.headers.get('Content-Type').includes('application/json')
          ? (t += await e.text())
          : (t += e.statusText);
      } catch (e) {
        return t;
      }
      return t;
    }
    const Ue = 'data:application/octet-stream;base64,';
    async function ze(t, i = {}) {
      if ('string' != typeof t) return await Fe(t);
      const s = i.dispatcher;
      t = (function (e) {
        for (const t in me) e.startsWith(t) && (e = e.replace(t, me[t]));
        return e.startsWith('http://') || e.startsWith('https://') || (e = `${de}${e}`), e;
      })(t);
      let r = { url: (t = e.exported.resolveURL(t)), binary: i.binary, mode: 'no-cors' };
      const n = new e.window.AbortController();
      if ((i.isDestroyed && n.abort(), i.transformRequest)) {
        const o = -1 == t.indexOf(Ue) ? i.transformRequest(t, e.ResourceType.Source) : { url: t },
          a = new e.window.Request(o.url, {
            method: o.method || 'GET',
            body: o.body,
            credentials: o.credentials,
            headers: o.headers,
            referrer: e.getReferrer(),
            signal: n.signal,
          });
        if (
          (i.json && a.headers.set('Accept', 'application/json'),
          !i._abortListMap ||
            i.isDestroyed ||
            i.json ||
            i._abortListMap.set(o.url.split('?')[0], n),
          e.isWorker() || !s)
        ) {
          const e = await fetch(a);
          if (!e.ok && i.throws) throw new Error(await Ge(e));
          return e;
        }
        r = {
          method: o.method || 'GET',
          body: o.body,
          credentials: o.credentials,
          headers: o.headers,
          url: o.url,
          mode: 'no-cors',
        };
      } else if (e.isWorker() || !s) {
        const e = await fetch(t, i);
        if (!e.ok && i.throws) throw new Error(await Ge(e));
        return e;
      }
      const o = new Promise((e, t) => {
        s.send('fetchLoadersTilesData', { requestOptions: r }, (i, s) => {
          i && t(i), e(s);
        });
      });
      return await o;
    }
    class He {
      log() {
        return (e) => {};
      }
      info() {
        return (e) => {};
      }
      warn() {
        return (e) => {};
      }
      error() {
        return (e) => {};
      }
    }
    const We = {
        fetch: null,
        CDN: '',
        worker: !0,
        maxConcurrency: 3,
        maxMobileConcurrency: 1,
        log: new (class {
          constructor() {
            this.console = console;
          }
          log(...e) {
            return this.console.log.bind(this.console, ...e);
          }
          info(...e) {
            return this.console.info.bind(this.console, ...e);
          }
          warn(...e) {
            return this.console.warn.bind(this.console, ...e);
          }
          error(...e) {
            return this.console.error.bind(this.console, ...e);
          }
        })(),
        metadata: !1,
        transforms: [],
        attributeName: null,
        attributeType: null,
        reuseWorkers: !0,
        _workerType: void 0,
      },
      je = {
        dataType: '(no longer used)',
        uri: 'baseUri',
        method: 'fetch.method',
        headers: 'fetch.headers',
        body: 'fetch.body',
        mode: 'fetch.mode',
        credentials: 'fetch.credentials',
        cache: 'fetch.cache',
        redirect: 'fetch.redirect',
        referrer: 'fetch.referrer',
        referrerPolicy: 'fetch.referrerPolicy',
        integrity: 'fetch.integrity',
        keepalive: 'fetch.keepalive',
        signal: 'fetch.signal',
      },
      qe = () => {
        A.loaders = A.loaders || {};
        const { loaders: e } = A;
        return (e._state = e._state || {}), e._state;
      },
      Xe = () => {
        const e = qe();
        return (
          (We.CDN = `${A.minemapCDN}/@mm-loaders.gl`),
          (We.CDN = We.CDN.replace(/\/\//g, '/')),
          (e.globalOptions = e.globalOptions || { ...We }),
          e.globalOptions
        );
      };
    function Ze(e, t) {
      const i = Xe(),
        s = e.fetch || i.fetch,
        r = e.dispatcher;
      return 'function' == typeof s
        ? s
        : Se(s)
        ? (e.transformRequest && (s.transformRequest = e.transformRequest),
          (s.json = e.json),
          (s.dispatcher = r),
          (e) => ze(e, s))
        : t && t.fetch
        ? t.fetch
        : (t) => ze(t, e);
    }
    function $e(e, t, i, s, r, n) {
      for (const i in e) {
        const o = !t && Se(e[i]);
        i in s || ('baseUri' === i && !t) || i in r || o || Ke(i, n);
      }
    }
    function Ke(e, t) {
      const i = e.toLowerCase();
      let s = '';
      for (const r of t)
        for (const t in r.options) {
          if (e === t) return `Did you mean '${r.id}.${t}'?`;
          const n = t.toLowerCase();
          (i.startsWith(n) || n.startsWith(i)) && (s = s || `Did you mean '${r.id}.${t}'?`);
        }
      return s;
    }
    function Ye(e, t) {
      for (const i in t) i in t && (e[i] = Ee(t[i]) && Ee(e[i]) ? { ...e[i], ...t[i] } : t[i]);
    }
    function Qe(e) {
      return Array.isArray(e) && (e = e[0]), !!e && Array.isArray(e.extensions);
    }
    function Je(e) {
      let t;
      return (
        P(e, 'null loader'),
        P(Qe(e), 'invalid loader'),
        Array.isArray(e) &&
          ((t = e[1]), (e = e[0]), (e = { ...e, options: { ...e.options, ...t } })),
        (e.parseTextSync || e.parseText) && (e.text = !0),
        e.text || (e.binary = !0),
        e
      );
    }
    const et = () => {
        const e = qe();
        return (e.loaderRegistry = e.loaderRegistry || []), e.loaderRegistry;
      },
      tt = 1048576;
    async function it(e, t, i) {
      return await new Promise((s, r) => {
        const n = e.slice(t, i),
          o = new FileReader();
        (o.onload = (e) => s(e.target && e.target.result)),
          (o.onerror = (e) => r(e)),
          o.readAsArrayBuffer(n);
      });
    }
    function st(e) {
      if (R || O >= 10) {
        if ('function' == typeof e[Symbol.asyncIterator])
          return (async function* (e) {
            for await (const t of e) yield he(t);
          })(e);
        if ('function' == typeof e.getIterator) return e.getIterator();
      }
      return R
        ? (async function* (e) {
            const t = e.getReader();
            try {
              for (;;) {
                const { done: e, value: i } = await t.read();
                if (e) return;
                yield he(i);
              }
            } catch (e) {
              t.releaseLock();
            }
          })(e)
        : (async function* (e) {
            for (e = await e; ; ) {
              const t = e.read();
              if (null === t) {
                if (e._readableState.ended) return;
                await rt(e);
              } else yield he(t);
            }
          })(e);
    }
    async function rt(e) {
      return new Promise((t) => {
        e.once('readable', t);
      });
    }
    const nt = /\.([^.]+)$/;
    function ot(e, t = [], i = {}, s = {}) {
      if (t && !Array.isArray(t)) return Je(t);
      !(function (e) {
        for (const t of e) Je(t);
      })((t = [...(t || []), ...et()]));
      const { url: r, type: n } = Ne(e);
      let o = (function (e, t) {
        const i = t && t.match(nt),
          s = i && i[1];
        return (
          s &&
          (function (e, t) {
            t = t.toLowerCase();
            for (const i of e) for (const e of i.extensions) if (e.toLowerCase() === t) return i;
            return null;
          })(e, s)
        );
      })(t, r || s.url);
      if (
        ((o =
          o ||
          (function (e, t) {
            for (const i of e) {
              if (i.mimeTypes && i.mimeTypes.includes(t)) return i;
              if (t === `application/x.${i.id}`) return i;
              if (i.mimeTypes && i.mimeTypes.includes('image/crn')) return i;
              if (i.mimeTypes && i.mimeTypes.includes('image/ktx')) return i;
              if (i.mimeTypes && i.mimeTypes.includes('image/ktx2')) return i;
              if (i.mimeTypes && i.mimeTypes.includes('image/basis')) return i;
            }
            return null;
          })(t, n)),
        (o =
          o ||
          (function (e, t) {
            if (!t) return null;
            for (const i of e)
              if ('string' == typeof t) {
                if (lt(t, i)) return i;
              } else if (ArrayBuffer.isView(t)) {
                if (ht(t.buffer, t.byteOffset, i)) return i;
              } else if (t instanceof ArrayBuffer && ht(t, 0, i)) return i;
            return null;
          })(t, e)),
        !o && !i.nothrow)
      )
        throw new Error(at(e));
      return o;
    }
    function at(e) {
      const { url: t, type: i } = Ne(e);
      let s = 'No valid loader found';
      return (
        e &&
          (s += ` data: "${(function (e, t = 5) {
            return 'string' == typeof e
              ? e.slice(0, t)
              : ArrayBuffer.isView(e)
              ? ct(e.buffer, e.byteOffset, t)
              : e instanceof ArrayBuffer
              ? ct(e, 0, t)
              : '';
          })(e)}", contentType: "${i}"`),
        t && (s += ` url: ${t}`),
        s
      );
    }
    function lt(e, t) {
      return t.testText
        ? t.testText(e)
        : (Array.isArray(t.tests) ? t.tests : [t.tests]).some((t) => e.startsWith(t));
    }
    function ht(e, t, i) {
      return (Array.isArray(i.tests) ? i.tests : [i.tests]).some((s) =>
        (function (e, t, i, s) {
          if (s instanceof ArrayBuffer)
            return (function (e, t, i) {
              if (e.byteLength < (i = i || e.byteLength) || t.byteLength < i) return !1;
              const s = new Uint8Array(e),
                r = new Uint8Array(t);
              for (let e = 0; e < s.length; ++e) if (s[e] !== r[e]) return !1;
              return !0;
            })(s, e, s.byteLength);
          switch (typeof s) {
            case 'function':
              return s(e, i);
            case 'string':
              return s === ct(e, t, s.length);
            default:
              return !1;
          }
        })(e, t, i, s),
      );
    }
    function ct(e, t, i) {
      if (e.byteLength < t + i) return '';
      const s = new DataView(e);
      let r = '';
      for (let e = 0; e < i; e++) r += String.fromCharCode(s.getUint8(t + e));
      return r;
    }
    async function _t(e, t, i, s) {
      L(!s || 'string' != typeof s, 'parse no longer accepts final url'),
        !t || Array.isArray(t) || Qe(t) || ((s = i), (i = t), (t = null)),
        (e = await e),
        (i = i || {});
      let { url: r } = Ne(e);
      r || (r = i.url);
      const n = (function (e, t) {
          if (!t && e && !Array.isArray(e)) return e;
          let i;
          if ((e && (i = Array.isArray(e) ? e : [e]), t && t.loaders)) {
            const e = Array.isArray(t.loaders) ? t.loaders : [t.loaders];
            i = i ? [...i, ...e] : e;
          }
          return i && i.length ? i : null;
        })(t, s),
        o = await (async function (e, t = [], i = {}, s = {}) {
          let r = ot(e, t, { ...i, nothrow: !0 }, s);
          if (r) return r;
          if ((Re(e) && (r = ot((e = await it(e, 0, 10)), t, i, s)), !r && !i.nothrow))
            throw new Error(at(e));
          return r;
        })(e, n, i);
      if (!o) return null;
      s = (function (e, t, i = null) {
        return (
          i ||
          ((e = { fetch: Ze(t || {}, e), ...e }), Array.isArray(e.loaders) || (e.loaders = null), e)
        );
      })(
        { url: r, parse: _t, loaders: n },
        (i = (function (e, t, i, s) {
          return (
            (i = i || []),
            (function (e, t, i = console) {
              (We.CDN = A.minemapCDN), $e(e, null, 0, We, je, t);
              for (const i of t)
                $e(
                  (e && e[i.id]) || {},
                  i.id,
                  0,
                  (i.options && i.options[i.id]) || {},
                  (i.defaultOptions && i.defaultOptions[i.id]) || {},
                  t,
                );
            })(e, (i = Array.isArray(i) ? i : [i])),
            (function (e, t, i) {
              const s = { ...(e.options || {}) };
              return (
                (function (e, t) {
                  t && !('baseUri' in e) && (e.baseUri = t);
                })(s, i),
                null === s.log && (s.log = new He()),
                Ye(s, Xe()),
                Ye(s, t),
                s
              );
            })(t, e, s)
          );
        })(i, o, n, r)),
        s,
      );
      const a = await (async function (e, t, i, s) {
        return (
          (function (e, t = Y) {
            L(e, 'no worker provided');
            let i = e.version;
            t && i && ((t = Q(t)), (i = Q(i)));
          })(e),
          (t = await (async function (e, t) {
            const i = e instanceof ArrayBuffer || ArrayBuffer.isView(e);
            if ('string' == typeof e || i)
              return (function (e, t) {
                if (t.text && 'string' == typeof e) return e;
                if (e instanceof ArrayBuffer) {
                  const i = e;
                  return t.text && !t.binary ? new TextDecoder('utf8').decode(i) : i;
                }
                if (ArrayBuffer.isView(e) || Ie(e)) {
                  if (t.text && !t.binary) return new TextDecoder('utf8').decode(e);
                  let i = e.buffer;
                  const s = e.byteLength || e.length;
                  return (
                    (0 === e.byteOffset && s === i.byteLength) ||
                      (i = i.slice(e.byteOffset, e.byteOffset + s)),
                    i
                  );
                }
                return e;
              })(e, t);
            if ((Re(e) && (e = await Fe(e)), Ae(e))) {
              const i = e;
              return (
                await (async function (e) {
                  if (!e.ok) {
                    const t = await (async function (e) {
                      let t = `Failed to fetch resource ${e.url} (${e.status}): `;
                      try {
                        const i = e.headers.get('Content-Type');
                        let s = e.statusText;
                        i.includes('application/json') && (s += ` ${await e.text()}`),
                          (t += s),
                          (t = t.length > 60 ? `${t.slice(60)}...` : t);
                      } catch (e) {}
                      return t;
                    })(e);
                    throw new Error(t);
                  }
                })(i),
                t.binary ? await i.arrayBuffer() : await i.text()
              );
            }
            return (
              Oe(e) &&
                (e = (function (e, t = {}) {
                  return 'string' == typeof e
                    ? (function* (e, t = {}) {
                        const { chunkSize: i = 262144 } = t;
                        let s = 0;
                        const r = new TextEncoder();
                        for (; s < e.length; ) {
                          const t = Math.min(e.length - s, i),
                            n = e.slice(s, s + t);
                          (s += t), yield r.encode(n);
                        }
                      })(e, t)
                    : e instanceof ArrayBuffer
                    ? (function* (e, t = {}) {
                        const { chunkSize: i = 262144 } = t;
                        let s = 0;
                        for (; s < e.byteLength; ) {
                          const t = Math.min(e.byteLength - s, i),
                            r = new ArrayBuffer(t),
                            n = new Uint8Array(e.slice(s, s + t));
                          new Uint8Array(r).set(n), (s += t), yield r;
                        }
                      })(e, t)
                    : Re(e)
                    ? (async function* (e, t = {}) {
                        const i = t.chunkSize || tt;
                        let s = 0;
                        for (; s < e.size; ) {
                          const t = s + i,
                            r = await it(e, s, t);
                          (s = t), yield r;
                        }
                      })(e, t)
                    : Oe(e)
                    ? st(e)
                    : Ae(e)
                    ? st(e.body)
                    : P(!1);
                })(e)),
              Pe(e) || Me(e)
                ? (async function (e) {
                    const t = [],
                      i = [];
                    for await (const s of e) 'string' == typeof s ? i.push(s) : t.push(s);
                    return i.length > 0
                      ? (P(0 === t.length), i.join(''))
                      : (function (...e) {
                          const t = e.map((e) =>
                              e instanceof ArrayBuffer ? new Uint8Array(e) : e,
                            ),
                            i = t.reduce((e, t) => e + t.byteLength, 0),
                            s = new Uint8Array(i);
                          let r = 0;
                          for (const e of t) s.set(e, r), (r += e.byteLength);
                          return s.buffer;
                        })(...t);
                  })(e)
                : e
            );
          })(t, e)),
          e.parseTextSync && 'string' == typeof t
            ? ((i.dataType = 'text'), e.parseTextSync(t, i, s, e))
            : (function (e, t, i, s) {
                return (
                  !!K.isSupported() && !(!e.worker || !i.worker) && (!e.useWorker || e.useWorker(i))
                );
              })(e, 0, i)
            ? await (async function (e, t, i, s, r) {
                const n = e.id,
                  o = (function (e, t) {
                    const i = t || {},
                      s = `${e.id}-worker.js`;
                    let r = (i[e.id] || {}).workerUrl;
                    return (
                      'test' === i._workerType && (r = `modules/${e.module}/dist/${s}`),
                      r ||
                        ((r = `${window.minemapCDN}/@mm-loaders.gl/${e.module}/dist/${s}`),
                        (r = r.replace(/\/\//g, '/'))),
                      L(r),
                      r
                    );
                  })(e, i),
                  a = K.getWorkerFarm(i).getWorkerPool({ name: n, url: o });
                i.fetch && (i.fetch.dispatcher = null),
                  (i.dispatcher = null),
                  (i = JSON.parse(JSON.stringify(i)));
                const l = await a.startJob('process-on-worker', oe.bind(null, r));
                l.postMessage('process', { input: t, options: i });
                const h = await l.result;
                return await h.result;
              })(e, t, i, 0, _t)
            : e.parseText && 'string' == typeof t
            ? await e.parseText(t, i, s, e)
            : e.parse
            ? await e.parse(t, i, s, e)
            : (L(!e.parseSync), L(!1))
        );
      })(o, e, i, s);
      return a;
    }
    async function ut(e, t, i, s, r) {
      Array.isArray(t) || Qe(t) || ((i = t), (t = null));
      const n = Ze(i || {});
      let o = e;
      return (
        'string' == typeof e
          ? (o = await n(e, i))
          : Re(e)
          ? ((o = await n(e)), (e = null))
          : (e = null),
        i && (i.modelFolder = r),
        (i.url = e),
        await _t(o, t, i)
      );
    }
    const dt = 'KHR_binary_glTF',
      mt = 'KHR_draco_mesh_compression',
      pt = 'KHR_lights_punctual',
      ft = 'KHR_materials_unlit',
      gt = 'KHR_techniques_webgl',
      yt = 'undefined' != typeof __VERSION__ ? __VERSION__ : 'latest',
      Tt = 'undefined' != typeof __VERSION__ ? __VERSION__ : 'latest';
    function xt(e, t) {
      if (!e) throw new Error(t);
    }
    const vt = {
        self: 'undefined' != typeof self && self,
        window: 'undefined' != typeof window && window,
        global: 'undefined' != typeof global && global,
        document: 'undefined' != typeof document && document,
      },
      bt = vt.global || vt.self || vt.window,
      wt = 'object' != typeof process || '[object process]' !== String(process) || process.browser,
      Ct = 'undefined' != typeof process && process.version && process.version.match(/v([0-9]*)/);
    Ct && parseFloat(Ct[1]);
    const { _parseImageNode: St } = bt,
      Et = 'undefined' != typeof Image,
      Pt = 'undefined' != typeof ImageBitmap,
      Mt = Boolean(St),
      At = !!wt || Mt,
      Rt = /^data:image\/svg\+xml/,
      It = /\.svg((\?|#).*)?$/;
    function Ot(e) {
      return e && (Rt.test(e) || It.test(e));
    }
    function Lt(e, t) {
      if (Ot(t)) throw new Error('SVG cannot be parsed directly to imagebitmap');
      return new Blob([new Uint8Array(e)]);
    }
    async function Dt(e, t, i) {
      const s = (function (e, t) {
          if (Ot(t)) {
            const t = new TextDecoder().decode(e);
            return `data:image/svg+xml;base64,${btoa(t)}`;
          }
          return Lt(e, t);
        })(e, i),
        r = self.URL || self.webkitURL,
        n = 'string' != typeof s && r.createObjectURL(s);
      try {
        return await (async function (e, t) {
          const i = new Image();
          return (
            (i.src = e),
            t.image && t.image.decode && i.decode
              ? (await i.decode(), i)
              : await new Promise((t, s) => {
                  try {
                    (i.onload = () => t(i)),
                      (i.onerror = (t) => s(new Error(`Could not load image ${e}: ${t}`)));
                  } catch (e) {
                    s(e);
                  }
                })
          );
        })(n || s, t);
      } finally {
        n && r.revokeObjectURL(n);
      }
    }
    const Bt = {};
    let Vt = !0;
    const Nt = !1,
      kt = !0;
    function Ft(e) {
      const t = Gt(e),
        i =
          (function (e) {
            const t = Gt(e);
            return t.byteLength >= 24 && 2303741511 === t.getUint32(0, Nt)
              ? { mimeType: 'image/png', width: t.getUint32(16, Nt), height: t.getUint32(20, Nt) }
              : null;
          })(t) ||
          (function (e) {
            const t = Gt(e);
            if (!(t.byteLength >= 3 && 65496 === t.getUint16(0, Nt) && 255 === t.getUint8(2)))
              return null;
            const { tableMarkers: i, sofMarkers: s } = (function () {
              const e = new Set([65499, 65476, 65484, 65501, 65534]);
              for (let t = 65504; t < 65520; ++t) e.add(t);
              return {
                tableMarkers: e,
                sofMarkers: new Set([
                  65472, 65473, 65474, 65475, 65477, 65478, 65479, 65481, 65482, 65483, 65485,
                  65486, 65487, 65502,
                ]),
              };
            })();
            let r = 2;
            for (; r + 9 < t.byteLength; ) {
              const e = t.getUint16(r, Nt);
              if (s.has(e))
                return {
                  mimeType: 'image/jpeg',
                  height: t.getUint16(r + 5, Nt),
                  width: t.getUint16(r + 7, Nt),
                };
              if (!i.has(e)) return null;
              (r += 2), (r += t.getUint16(r, Nt));
            }
            return null;
          })(t) ||
          (function (e) {
            const t = Gt(e);
            return t.byteLength >= 10 && 1195984440 === t.getUint32(0, Nt)
              ? { mimeType: 'image/gif', width: t.getUint16(6, kt), height: t.getUint16(8, kt) }
              : null;
          })(t) ||
          (function (e) {
            const t = Gt(e);
            return t.byteLength >= 14 &&
              16973 === t.getUint16(0, Nt) &&
              t.getUint32(2, kt) === t.byteLength
              ? { mimeType: 'image/bmp', width: t.getUint32(18, kt), height: t.getUint32(22, kt) }
              : null;
          })(t);
      return i || { mimeType: 'image/webp', width: 256, height: 256 };
    }
    function Gt(e) {
      if (e instanceof DataView) return e;
      if (ArrayBuffer.isView(e)) return new DataView(e.buffer);
      if (e instanceof ArrayBuffer) return new DataView(e);
      throw new Error('toDataView');
    }
    const Ut = {
        name: 'Images',
        id: 'image',
        module: 'images',
        version: Tt,
        mimeTypes: [
          'image/png',
          'image/jpeg',
          'image/gif',
          'image/webp',
          'image/bmp',
          'image/vnd.microsoft.icon',
          'image/svg+xml',
        ],
        extensions: ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'ico', 'svg'],
        parse: async function (e, t, i) {
          const s = ((t = t || {}).image || {}).type || 'auto',
            { url: r } = i || {};
          let n;
          switch (
            (function (e) {
              switch (e) {
                case 'auto':
                case 'data':
                  return (function () {
                    if (Pt) return 'imagebitmap';
                    if (Et) return 'image';
                    if (At) return 'data';
                    throw new Error(
                      "Install '@mm-loaders.gl/polyfills' to parse images under Node.js",
                    );
                  })();
                default:
                  return (
                    (function (e) {
                      switch (e) {
                        case 'auto':
                          return Pt || Et || At;
                        case 'imagebitmap':
                          return Pt;
                        case 'image':
                        case 'html':
                          return Et;
                        case 'data':
                        case 'ndarray':
                          return At;
                        default:
                          throw new Error(
                            `@mm-loaders.gl/images: image ${e} not supported in this environment`,
                          );
                      }
                    })(e),
                    e
                  );
              }
            })(s)
          ) {
            case 'imagebitmap':
              n = await (async function (e, t, i) {
                let s;
                s = Ot(i) ? await Dt(e, t, i) : Lt(e, i);
                const r = t && t.imagebitmap;
                return await (async function (e, t = null) {
                  if (
                    ((!(function (e) {
                      for (const t in e || Bt) return !1;
                      return !0;
                    })(t) &&
                      Vt) ||
                      (t = null),
                    t)
                  )
                    try {
                      return await createImageBitmap(e, t);
                    } catch (e) {
                      Vt = !1;
                    }
                  return await createImageBitmap(e);
                })(s, r);
              })(e, t, r);
              break;
            case 'image':
              n = await Dt(e, t, r);
              break;
            case 'data':
              n = await (function (e, t) {
                const { mimeType: i } = Ft(e) || {},
                  { _parseImageNode: s } = bt;
                return xt(s), s(e, i, t);
              })(e, t);
              break;
            default:
              xt(!1);
          }
          return (
            'data' === s &&
              (n = (function (e) {
                switch (
                  (function (e) {
                    const t = (function (e) {
                      return 'undefined' != typeof ImageBitmap && e instanceof ImageBitmap
                        ? 'imagebitmap'
                        : 'undefined' != typeof Image && e instanceof Image
                        ? 'image'
                        : e && 'object' == typeof e && e.data && e.width && e.height
                        ? 'data'
                        : null;
                    })(e);
                    if (!t) throw new Error('Not an image');
                    return t;
                  })(e)
                ) {
                  case 'data':
                    return e;
                  case 'image':
                  case 'imagebitmap':
                    const t = document.createElement('canvas'),
                      i = t.getContext('2d');
                    if (i)
                      return (
                        (t.width = e.width),
                        (t.height = e.height),
                        i.drawImage(e, 0, 0),
                        i.getImageData(0, 0, e.width, e.height)
                      );
                  default:
                    return xt(!1);
                }
              })(n)),
            n
          );
        },
        tests: [(e) => Boolean(Ft(new DataView(e)))],
        options: { image: { type: 'auto', decode: !0 } },
      },
      zt = 'undefined' != typeof __VERSION__ ? __VERSION__ : 'beta',
      Ht = 'undefined' != typeof __VERSION__ ? __VERSION__ : 'beta';
    let Wt,
      jt,
      qt = '/basis_encoder.wasm',
      Xt = '/basis_encoder.js';
    async function Zt(e) {
      const t = e.modules || {};
      return t.basis
        ? t.basis
        : ((Wt =
            Wt ||
            (async function (e) {
              let t = null,
                i = null;
              return (
                ([t, i] = await Promise.all([
                  await se('basis_transcoder.js', 'textures', e),
                  await se('basis_transcoder.wasm', 'textures', e),
                ])),
                (t = t || globalThis.BASIS),
                await (function (e, t) {
                  const i = {};
                  return (
                    t && (i.wasmBinary = t),
                    new Promise((t) => {
                      e(i).then((e) => {
                        const { BasisFile: i, initializeBasis: s } = e;
                        s(), t({ BasisFile: i });
                      });
                    })
                  );
                })(t, i)
              );
            })(e)),
          await Wt);
    }
    async function $t(e) {
      const t = e.modules || {};
      return t.basisEncoder
        ? t.basisEncoder
        : ((jt =
            jt ||
            (async function (e) {
              let t = null,
                i = null;
              if (e.CDN) (Xt = `${e.CDN}/textures/dist${Xt}`), (qt = `${e.CDN}/textures/dist${qt}`);
              else {
                const e = `https://unpkg.com/@loaders.gl/textures@${Ht}/dist/libs`;
                (Xt = `${e}${Xt}`), (qt = `${e}${qt}`);
              }
              return (
                ([t, i] = await Promise.all([
                  await se(Xt, 'textures', e),
                  await se(qt, 'textures', e),
                ])),
                (t = t || globalThis.BASIS),
                await (function (e, t) {
                  const i = {};
                  return (
                    t && (i.wasmBinary = t),
                    new Promise((t) => {
                      e(i).then((e) => {
                        const {
                          BasisFile: i,
                          KTX2File: s,
                          initializeBasis: r,
                          BasisEncoder: n,
                        } = e;
                        r(), t({ BasisFile: i, KTX2File: s, BasisEncoder: n });
                      });
                    })
                  );
                })(t, i)
              );
            })(e)),
          await jt);
    }
    const Kt = {
        COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,
        COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777,
        COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778,
        COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,
        COMPRESSED_R11_EAC: 37488,
        COMPRESSED_SIGNED_R11_EAC: 37489,
        COMPRESSED_RG11_EAC: 37490,
        COMPRESSED_SIGNED_RG11_EAC: 37491,
        COMPRESSED_RGB8_ETC2: 37492,
        COMPRESSED_RGBA8_ETC2_EAC: 37493,
        COMPRESSED_SRGB8_ETC2: 37494,
        COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 37495,
        COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37496,
        COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37497,
        COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,
        COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,
        COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841,
        COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843,
        COMPRESSED_RGB_ETC1_WEBGL: 36196,
        COMPRESSED_RGB_ATC_WEBGL: 35986,
        COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 35987,
        COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 34798,
        COMPRESSED_RGBA_ASTC_4X4_KHR: 37808,
        COMPRESSED_RGBA_ASTC_5X4_KHR: 37809,
        COMPRESSED_RGBA_ASTC_5X5_KHR: 37810,
        COMPRESSED_RGBA_ASTC_6X5_KHR: 37811,
        COMPRESSED_RGBA_ASTC_6X6_KHR: 37812,
        COMPRESSED_RGBA_ASTC_8X5_KHR: 37813,
        COMPRESSED_RGBA_ASTC_8X6_KHR: 37814,
        COMPRESSED_RGBA_ASTC_8X8_KHR: 37815,
        COMPRESSED_RGBA_ASTC_10X5_KHR: 37816,
        COMPRESSED_RGBA_ASTC_10X6_KHR: 37817,
        COMPRESSED_RGBA_ASTC_10X8_KHR: 37818,
        COMPRESSED_RGBA_ASTC_10X10_KHR: 37819,
        COMPRESSED_RGBA_ASTC_12X10_KHR: 37820,
        COMPRESSED_RGBA_ASTC_12X12_KHR: 37821,
        COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR: 37840,
        COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR: 37841,
        COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR: 37842,
        COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR: 37843,
        COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR: 37844,
        COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR: 37845,
        COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR: 37846,
        COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR: 37847,
        COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR: 37848,
        COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR: 37849,
        COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR: 37850,
        COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR: 37851,
        COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR: 37852,
        COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR: 37853,
        COMPRESSED_RED_RGTC1_EXT: 36283,
        COMPRESSED_SIGNED_RED_RGTC1_EXT: 36284,
        COMPRESSED_RED_GREEN_RGTC2_EXT: 36285,
        COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT: 36286,
        COMPRESSED_SRGB_S3TC_DXT1_EXT: 35916,
        COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: 35917,
        COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: 35918,
        COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: 35919,
      },
      Yt = ['', 'WEBKIT_', 'MOZ_'],
      Qt = {
        WEBGL_compressed_texture_s3tc: 'dxt',
        WEBGL_compressed_texture_s3tc_srgb: 'dxt-srgb',
        WEBGL_compressed_texture_etc1: 'etc1',
        WEBGL_compressed_texture_etc: 'etc2',
        WEBGL_compressed_texture_pvrtc: 'pvrtc',
        WEBGL_compressed_texture_atc: 'atc',
        WEBGL_compressed_texture_astc: 'astc',
        EXT_texture_compression_rgtc: 'rgtc',
      };
    let Jt = null;
    var ei = e.createCommonjsModule(function (e, t) {
        var i, s, r, n, o, a, l, h;
        (t.__esModule = !0),
          (t.KTX2DataFormatChannelUASTC =
            t.KTX2DataFormatChannelETC1S =
            t.KTX2DataFormatFlags =
            t.KTX2DataFormatTransfer =
            t.KTX2DataFormatPrimaries =
            t.KTX2DataFormatModel =
            t.VK_FORMAT_UNDEFINED =
            t.KHR_DF_BLOCKSIZE =
            t.KHR_DF_VERSION =
            t.KHR_DF_VENDORID_KHRONOS =
            t.KTX2DataFormatType =
            t.KTX2SupercompressionScheme =
            t.HEADER_BYTE_LENGTH =
            t.KTX2_ID =
            t.NUL =
            t.KTX_WRITER =
              void 0),
          (t.KTX_WRITER = 'KTX-Parse v0.0.4'),
          (t.NUL = new Uint8Array([0])),
          (t.KTX2_ID = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10]),
          (t.HEADER_BYTE_LENGTH = 68),
          ((i = t.KTX2SupercompressionScheme || (t.KTX2SupercompressionScheme = {}))[(i.NONE = 0)] =
            'NONE'),
          (i[(i.BASISLZ = 1)] = 'BASISLZ'),
          (i[(i.ZSTD = 2)] = 'ZSTD'),
          (i[(i.ZLIB = 3)] = 'ZLIB'),
          ((s = t.KTX2DataFormatType || (t.KTX2DataFormatType = {}))[(s.BASICFORMAT = 0)] =
            'BASICFORMAT'),
          (t.KHR_DF_VENDORID_KHRONOS = 0),
          (t.KHR_DF_VERSION = 2),
          (t.KHR_DF_BLOCKSIZE = 40),
          (t.VK_FORMAT_UNDEFINED = 0),
          ((r = t.KTX2DataFormatModel || (t.KTX2DataFormatModel = {}))[(r.UNSPECIFIED = 0)] =
            'UNSPECIFIED'),
          (r[(r.ETC1S = 163)] = 'ETC1S'),
          (r[(r.UASTC = 166)] = 'UASTC'),
          ((n = t.KTX2DataFormatPrimaries || (t.KTX2DataFormatPrimaries = {}))[
            (n.UNSPECIFIED = 0)
          ] = 'UNSPECIFIED'),
          (n[(n.SRGB = 1)] = 'SRGB'),
          ((o = t.KTX2DataFormatTransfer || (t.KTX2DataFormatTransfer = {}))[(o.UNSPECIFIED = 0)] =
            'UNSPECIFIED'),
          (o[(o.LINEAR = 1)] = 'LINEAR'),
          (o[(o.SRGB = 2)] = 'SRGB'),
          (o[(o.ITU = 3)] = 'ITU'),
          (o[(o.NTSC = 4)] = 'NTSC'),
          (o[(o.SLOG = 5)] = 'SLOG'),
          (o[(o.SLOG2 = 6)] = 'SLOG2'),
          ((a = t.KTX2DataFormatFlags || (t.KTX2DataFormatFlags = {}))[(a.ALPHA_STRAIGHT = 0)] =
            'ALPHA_STRAIGHT'),
          (a[(a.ALPHA_PREMULTIPLIED = 1)] = 'ALPHA_PREMULTIPLIED'),
          ((l = t.KTX2DataFormatChannelETC1S || (t.KTX2DataFormatChannelETC1S = {}))[(l.RGB = 0)] =
            'RGB'),
          (l[(l.RRR = 3)] = 'RRR'),
          (l[(l.GGG = 4)] = 'GGG'),
          (l[(l.AAA = 15)] = 'AAA'),
          ((h = t.KTX2DataFormatChannelUASTC || (t.KTX2DataFormatChannelUASTC = {}))[(h.RGB = 0)] =
            'RGB'),
          (h[(h.RGBA = 3)] = 'RGBA'),
          (h[(h.RRR = 4)] = 'RRR'),
          (h[(h.RRRG = 5)] = 'RRRG');
      }),
      ti = e.createCommonjsModule(function (e, t) {
        (t.__esModule = !0),
          (t.KTX2Container = void 0),
          (t.KTX2Container = function () {
            (this.vkFormat = ei.VK_FORMAT_UNDEFINED),
              (this.typeSize = 1),
              (this.pixelWidth = 0),
              (this.pixelHeight = 0),
              (this.pixelDepth = 0),
              (this.layerCount = 0),
              (this.faceCount = 1),
              (this.supercompressionScheme = ei.KTX2SupercompressionScheme.NONE),
              (this.levels = []),
              (this.dataFormatDescriptor = [
                {
                  vendorId: ei.KHR_DF_VENDORID_KHRONOS,
                  descriptorType: ei.KTX2DataFormatType.BASICFORMAT,
                  versionNumber: ei.KHR_DF_VERSION,
                  descriptorBlockSize: ei.KHR_DF_BLOCKSIZE,
                  colorModel: ei.KTX2DataFormatModel.UNSPECIFIED,
                  colorPrimaries: ei.KTX2DataFormatPrimaries.SRGB,
                  transferFunction: ei.KTX2DataFormatPrimaries.SRGB,
                  flags: ei.KTX2DataFormatFlags.ALPHA_STRAIGHT,
                  texelBlockDimension: { x: 4, y: 4, z: 1, w: 1 },
                  bytesPlane: [],
                  samples: [],
                },
              ]),
              (this.keyValue = {}),
              (this.globalData = null);
          });
      }),
      ii = e.createCommonjsModule(function (e, t) {
        (t.__esModule = !0), (t.BufferReader = void 0);
        var i = (function () {
          function e(e, t, i, s) {
            (this._dataView = new DataView(e.buffer, e.byteOffset + t, i)),
              (this._littleEndian = s),
              (this._offset = 0);
          }
          return (
            (e.prototype._nextUint8 = function () {
              var e = this._dataView.getUint8(this._offset);
              return (this._offset += 1), e;
            }),
            (e.prototype._nextUint16 = function () {
              var e = this._dataView.getUint16(this._offset, this._littleEndian);
              return (this._offset += 2), e;
            }),
            (e.prototype._nextUint32 = function () {
              var e = this._dataView.getUint32(this._offset, this._littleEndian);
              return (this._offset += 4), e;
            }),
            (e.prototype._nextUint64 = function () {
              var e = this._dataView.getUint32(this._offset, this._littleEndian),
                t = this._dataView.getUint32(this._offset + 4, this._littleEndian),
                i = e + Math.pow(2, 32) * t;
              return (this._offset += 8), i;
            }),
            (e.prototype._skip = function (e) {
              return (this._offset += e), this;
            }),
            (e.prototype._scan = function (e, t) {
              void 0 === t && (t = 0);
              for (
                var i = this._offset, s = 0;
                this._dataView.getUint8(this._offset) !== t && s < e;

              )
                s++, this._offset++;
              return (
                s < e && this._offset++,
                new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + i, s)
              );
            }),
            e
          );
        })();
        t.BufferReader = i;
      }),
      si = e.createCommonjsModule(function (e, t) {
        (t.__esModule = !0),
          (t.concat = t.decodeText = t.encodeText = void 0),
          (t.encodeText = function (e) {
            return 'undefined' != typeof TextEncoder ? new TextEncoder().encode(e) : Buffer.from(e);
          }),
          (t.decodeText = function (e) {
            return 'undefined' != typeof TextDecoder
              ? new TextDecoder().decode(e)
              : Buffer.from(e).toString('utf8');
          }),
          (t.concat = function (e) {
            for (var t = 0, i = 0, s = e; i < s.length; i++) t += (l = s[i]).byteLength;
            for (var r = new Uint8Array(t), n = 0, o = 0, a = e; o < a.length; o++) {
              var l = a[o];
              r.set(new Uint8Array(l), n), (n += l.byteLength);
            }
            return r;
          });
      }),
      ri = e.createCommonjsModule(function (e, t) {
        (t.__esModule = !0),
          (t.read = void 0),
          (t.read = function (e) {
            var t = new Uint8Array(e.buffer.slice(e.byteOffset, e.byteOffset + ei.KTX2_ID.length));
            if (
              t[0] !== ei.KTX2_ID[0] ||
              t[1] !== ei.KTX2_ID[1] ||
              t[2] !== ei.KTX2_ID[2] ||
              t[3] !== ei.KTX2_ID[3] ||
              t[4] !== ei.KTX2_ID[4] ||
              t[5] !== ei.KTX2_ID[5] ||
              t[6] !== ei.KTX2_ID[6] ||
              t[7] !== ei.KTX2_ID[7] ||
              t[8] !== ei.KTX2_ID[8] ||
              t[9] !== ei.KTX2_ID[9] ||
              t[10] !== ei.KTX2_ID[10] ||
              t[11] !== ei.KTX2_ID[11]
            )
              throw new Error('Missing KTX 2.0 identifier.');
            var i = new ti.KTX2Container(),
              s = 17 * Uint32Array.BYTES_PER_ELEMENT,
              r = new ii.BufferReader(e, ei.KTX2_ID.length, s, !0);
            (i.vkFormat = r._nextUint32()),
              (i.typeSize = r._nextUint32()),
              (i.pixelWidth = r._nextUint32()),
              (i.pixelHeight = r._nextUint32()),
              (i.pixelDepth = r._nextUint32()),
              (i.layerCount = r._nextUint32()),
              (i.faceCount = r._nextUint32());
            var n = r._nextUint32();
            i.supercompressionScheme = r._nextUint32();
            for (
              var o = r._nextUint32(),
                a = r._nextUint32(),
                l = r._nextUint32(),
                h = r._nextUint32(),
                c = r._nextUint64(),
                _ = r._nextUint64(),
                u = new ii.BufferReader(e, ei.KTX2_ID.length + s, 3 * n * 8, !0),
                d = 0;
              d < n;
              d++
            )
              i.levels.push({
                levelData: new Uint8Array(
                  e.buffer.slice(
                    e.byteOffset + u._nextUint64(),
                    e.byteOffset + u._nextUint64() + u._nextUint64(),
                  ),
                ),
                uncompressedByteLength: u._nextUint64(),
              });
            var m = new ii.BufferReader(e, o, a, !0),
              p = {
                vendorId: m._skip(4)._nextUint16(),
                descriptorType: m._nextUint16(),
                versionNumber: m._nextUint16(),
                descriptorBlockSize: m._nextUint16(),
                colorModel: m._nextUint8(),
                colorPrimaries: m._nextUint8(),
                transferFunction: m._nextUint8(),
                flags: m._nextUint8(),
                texelBlockDimension: {
                  x: m._nextUint8() + 1,
                  y: m._nextUint8() + 1,
                  z: m._nextUint8() + 1,
                  w: m._nextUint8() + 1,
                },
                bytesPlane: [
                  m._nextUint8(),
                  m._nextUint8(),
                  m._nextUint8(),
                  m._nextUint8(),
                  m._nextUint8(),
                  m._nextUint8(),
                  m._nextUint8(),
                  m._nextUint8(),
                ],
                samples: [],
              },
              f = (p.descriptorBlockSize / 4 - 6) / 4;
            for (d = 0; d < f; d++)
              p.samples[d] = {
                bitOffset: m._nextUint16(),
                bitLength: m._nextUint8(),
                channelID: m._nextUint8(),
                samplePosition: [m._nextUint8(), m._nextUint8(), m._nextUint8(), m._nextUint8()],
                sampleLower: m._nextUint32(),
                sampleUpper: m._nextUint32(),
              };
            (i.dataFormatDescriptor.length = 0), i.dataFormatDescriptor.push(p);
            for (var g = new ii.BufferReader(e, l, h, !0); g._offset < h; ) {
              var y = g._nextUint32(),
                T = g._scan(y),
                x = si.decodeText(T),
                v = g._scan(y - T.byteLength);
              (i.keyValue[x] = x.match(/^ktx/i) ? si.decodeText(v) : v),
                y % 4 && g._skip(4 - (y % 4));
            }
            if (_ <= 0) return i;
            var b = new ii.BufferReader(e, c, _, !0),
              w = b._nextUint16(),
              C = b._nextUint16(),
              S = b._nextUint32(),
              E = b._nextUint32(),
              P = b._nextUint32(),
              M = b._nextUint32(),
              A = [];
            for (d = 0; d < n; d++)
              A.push({
                imageFlags: b._nextUint32(),
                rgbSliceByteOffset: b._nextUint32(),
                rgbSliceByteLength: b._nextUint32(),
                alphaSliceByteOffset: b._nextUint32(),
                alphaSliceByteLength: b._nextUint32(),
              });
            var R = c + b._offset,
              I = R + S,
              O = I + E,
              L = O + P,
              D = new Uint8Array(e.buffer.slice(e.byteOffset + R, e.byteOffset + R + S)),
              B = new Uint8Array(e.buffer.slice(e.byteOffset + I, e.byteOffset + I + E)),
              V = new Uint8Array(e.buffer.slice(e.byteOffset + O, e.byteOffset + O + P)),
              N = new Uint8Array(e.buffer.slice(e.byteOffset + L, e.byteOffset + L + M));
            return (
              (i.globalData = {
                endpointCount: w,
                selectorCount: C,
                imageDescs: A,
                endpointsData: D,
                selectorsData: B,
                tablesData: V,
                extendedData: N,
              }),
              i
            );
          });
      }),
      ni = e.createCommonjsModule(function (e, t) {
        var i =
            (this && this.__assign) ||
            function () {
              return (
                (i =
                  Object.assign ||
                  function (e) {
                    for (var t, i = 1, s = arguments.length; i < s; i++)
                      for (var r in (t = arguments[i]))
                        Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
                    return e;
                  }),
                i.apply(this, arguments)
              );
            },
          s =
            (this && this.__spreadArrays) ||
            function () {
              for (var e = 0, t = 0, i = arguments.length; t < i; t++) e += arguments[t].length;
              var s = Array(e),
                r = 0;
              for (t = 0; t < i; t++)
                for (var n = arguments[t], o = 0, a = n.length; o < a; o++, r++) s[r] = n[o];
              return s;
            };
        (t.__esModule = !0), (t.write = void 0);
        var r = { keepWriter: !1 };
        t.write = function (e, t) {
          void 0 === t && (t = {}), (t = i(i({}, r), t));
          var n = new ArrayBuffer(0);
          if (e.globalData) {
            var o = new ArrayBuffer(20 + 5 * e.globalData.imageDescs.length * 4),
              a = new DataView(o);
            a.setUint16(0, e.globalData.endpointCount, !0),
              a.setUint16(2, e.globalData.selectorCount, !0),
              a.setUint32(4, e.globalData.endpointsData.byteLength, !0),
              a.setUint32(8, e.globalData.selectorsData.byteLength, !0),
              a.setUint32(12, e.globalData.tablesData.byteLength, !0),
              a.setUint32(16, e.globalData.extendedData.byteLength, !0);
            for (var l = 0; l < e.globalData.imageDescs.length; l++) {
              var h = e.globalData.imageDescs[l];
              a.setUint32(20 + 5 * l * 4 + 0, h.imageFlags, !0),
                a.setUint32(20 + 5 * l * 4 + 4, h.rgbSliceByteOffset, !0),
                a.setUint32(20 + 5 * l * 4 + 8, h.rgbSliceByteLength, !0),
                a.setUint32(20 + 5 * l * 4 + 12, h.alphaSliceByteOffset, !0),
                a.setUint32(20 + 5 * l * 4 + 16, h.alphaSliceByteLength, !0);
            }
            n = si.concat([
              o,
              e.globalData.endpointsData,
              e.globalData.selectorsData,
              e.globalData.tablesData,
              e.globalData.extendedData,
            ]);
          }
          var c = [],
            _ = e.keyValue;
          for (var u in (t.keepWriter || (_ = i(i({}, e.keyValue), { KTXwriter: ei.KTX_WRITER })),
          _)) {
            var d = _[u],
              m = si.encodeText(u),
              p = 'string' == typeof d ? si.encodeText(d) : d,
              f = m.byteLength + 1 + p.byteLength + 1,
              g = f % 4 ? 4 - (f % 4) : 0;
            c.push(
              si.concat([new Uint32Array([f]), m, ei.NUL, p, ei.NUL, new Uint8Array(g).fill(0)]),
            );
          }
          var y = si.concat(c),
            T = new ArrayBuffer(44),
            x = new DataView(T);
          if (
            1 !== e.dataFormatDescriptor.length ||
            e.dataFormatDescriptor[0].descriptorType !== ei.KTX2DataFormatType.BASICFORMAT
          )
            throw new Error('Only BASICFORMAT Data Format Descriptor output supported.');
          var v = e.dataFormatDescriptor[0];
          for (
            x.setUint32(0, 44, !0),
              x.setUint16(4, v.vendorId, !0),
              x.setUint16(6, v.descriptorType, !0),
              x.setUint16(8, v.versionNumber, !0),
              x.setUint16(10, v.descriptorBlockSize, !0),
              x.setUint8(12, v.colorModel),
              x.setUint8(13, v.colorPrimaries),
              x.setUint8(14, v.transferFunction),
              x.setUint8(15, v.flags),
              x.setUint8(16, v.texelBlockDimension.x - 1),
              x.setUint8(17, v.texelBlockDimension.y - 1),
              x.setUint8(18, v.texelBlockDimension.z - 1),
              x.setUint8(19, v.texelBlockDimension.w - 1),
              l = 0;
            l < 8;
            l++
          )
            x.setUint8(20 + l, v.bytesPlane[l]);
          for (l = 0; l < v.samples.length; l++) {
            var b = v.samples[l],
              w = 28 + 16 * l;
            x.setUint16(w + 0, b.bitOffset, !0),
              x.setUint8(w + 2, b.bitLength),
              x.setUint8(w + 3, b.channelID),
              x.setUint8(w + 4, b.samplePosition[0]),
              x.setUint8(w + 5, b.samplePosition[1]),
              x.setUint8(w + 6, b.samplePosition[2]),
              x.setUint8(w + 7, b.samplePosition[3]),
              x.setUint32(w + 8, b.sampleLower, !0),
              x.setUint32(w + 12, b.sampleUpper, !0);
          }
          var C = ei.KTX2_ID.length + ei.HEADER_BYTE_LENGTH + 3 * e.levels.length * 8,
            S = C + T.byteLength,
            E = S + y.byteLength;
          E % 8 && (E += 8 - (E % 8));
          var P = [],
            M = new DataView(new ArrayBuffer(3 * e.levels.length * 8)),
            A = E + n.byteLength;
          for (l = 0; l < e.levels.length; l++) {
            var R = e.levels[l];
            P.push(R.levelData),
              M.setBigUint64(24 * l + 0, BigInt(A), !0),
              M.setBigUint64(24 * l + 8, BigInt(R.levelData.byteLength), !0),
              M.setBigUint64(24 * l + 16, BigInt(R.uncompressedByteLength), !0),
              (A += R.levelData.byteLength);
          }
          var I = new ArrayBuffer(ei.HEADER_BYTE_LENGTH),
            O = new DataView(I);
          return (
            O.setUint32(0, e.vkFormat, !0),
            O.setUint32(4, e.typeSize, !0),
            O.setUint32(8, e.pixelWidth, !0),
            O.setUint32(12, e.pixelHeight, !0),
            O.setUint32(16, e.pixelDepth, !0),
            O.setUint32(20, e.layerCount, !0),
            O.setUint32(24, e.faceCount, !0),
            O.setUint32(28, e.levels.length, !0),
            O.setUint32(32, e.supercompressionScheme, !0),
            O.setUint32(36, C, !0),
            O.setUint32(40, T.byteLength, !0),
            O.setUint32(44, S, !0),
            O.setUint32(48, y.byteLength, !0),
            O.setBigUint64(52, BigInt(E), !0),
            O.setBigUint64(60, BigInt(n.byteLength), !0),
            new Uint8Array(
              si.concat(
                s(
                  [
                    new Uint8Array(ei.KTX2_ID).buffer,
                    I,
                    M.buffer,
                    T,
                    y,
                    new ArrayBuffer(E - (S + y.byteLength)),
                    n,
                  ],
                  P,
                ),
              ),
            )
          );
        };
      }),
      oi = e.createCommonjsModule(function (e, t) {
        var i =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, i, s) {
                  void 0 === s && (s = i),
                    Object.defineProperty(e, s, {
                      enumerable: !0,
                      get: function () {
                        return t[i];
                      },
                    });
                }
              : function (e, t, i, s) {
                  void 0 === s && (s = i), (e[s] = t[i]);
                }),
          s =
            (this && this.__exportStar) ||
            function (e, t) {
              for (var s in e) 'default' === s || t.hasOwnProperty(s) || i(t, e, s);
            };
        (t.__esModule = !0), s(ti, t), s(ri, t), s(ni, t);
      }),
      ai = e.getDefaultExportFromCjs(oi);
    function li(e, t) {
      const i = new Array(t.mipMapLevels);
      let s = t.width,
        r = t.height,
        n = 0;
      for (let o = 0; o < t.mipMapLevels; ++o) {
        const a = ci(t, s, r, e, o),
          l = hi(e, o, n, a);
        (i[o] = {
          compressed: !0,
          format: t.internalFormat,
          data: l,
          width: s,
          height: r,
          levelSize: a,
        }),
          (s = Math.max(1, s >> 1)),
          (r = Math.max(1, r >> 1)),
          (n += a);
      }
      return i;
    }
    function hi(e, t, i, s) {
      return Array.isArray(e)
        ? e[t].levelData
        : new Uint8Array(e.buffer.slice(e.byteOffset + i, e.byteOffset + i + s));
    }
    function ci(e, t, i, s, r) {
      return Array.isArray(s) ? e.sizeFunction(s[r]) : e.sizeFunction(t, i);
    }
    const _i = {
        131: Kt.COMPRESSED_RGB_S3TC_DXT1_EXT,
        132: Kt.COMPRESSED_SRGB_S3TC_DXT1_EXT,
        133: Kt.COMPRESSED_RGBA_S3TC_DXT1_EXT,
        134: Kt.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
        135: Kt.COMPRESSED_RGBA_S3TC_DXT3_EXT,
        136: Kt.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
        137: Kt.COMPRESSED_RGBA_S3TC_DXT5_EXT,
        138: Kt.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT,
        139: Kt.COMPRESSED_RED_RGTC1_EXT,
        140: Kt.COMPRESSED_SIGNED_RED_RGTC1_EXT,
        141: Kt.COMPRESSED_RED_GREEN_RGTC2_EXT,
        142: Kt.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT,
        147: Kt.COMPRESSED_RGB8_ETC2,
        148: Kt.COMPRESSED_SRGB8_ETC2,
        149: Kt.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
        150: Kt.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
        151: Kt.COMPRESSED_RGBA8_ETC2_EAC,
        152: Kt.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,
        153: Kt.COMPRESSED_R11_EAC,
        154: Kt.COMPRESSED_SIGNED_R11_EAC,
        155: Kt.COMPRESSED_RG11_EAC,
        156: Kt.COMPRESSED_SIGNED_RG11_EAC,
        157: Kt.COMPRESSED_RGBA_ASTC_4x4_KHR,
        158: Kt.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,
        159: Kt.COMPRESSED_RGBA_ASTC_5x4_KHR,
        160: Kt.COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR,
        161: Kt.COMPRESSED_RGBA_ASTC_5x5_KHR,
        162: Kt.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,
        163: Kt.COMPRESSED_RGBA_ASTC_6x5_KHR,
        164: Kt.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,
        165: Kt.COMPRESSED_RGBA_ASTC_6x6_KHR,
        166: Kt.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,
        167: Kt.COMPRESSED_RGBA_ASTC_8x5_KHR,
        168: Kt.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,
        169: Kt.COMPRESSED_RGBA_ASTC_8x6_KHR,
        170: Kt.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,
        171: Kt.COMPRESSED_RGBA_ASTC_8x8_KHR,
        172: Kt.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,
        173: Kt.COMPRESSED_RGBA_ASTC_10x5_KHR,
        174: Kt.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,
        175: Kt.COMPRESSED_RGBA_ASTC_10x6_KHR,
        176: Kt.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,
        177: Kt.COMPRESSED_RGBA_ASTC_10x8_KHR,
        178: Kt.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,
        179: Kt.COMPRESSED_RGBA_ASTC_10x10_KHR,
        180: Kt.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,
        181: Kt.COMPRESSED_RGBA_ASTC_12x10_KHR,
        182: Kt.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,
        183: Kt.COMPRESSED_RGBA_ASTC_12x12_KHR,
        184: Kt.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR,
        1000054e3: Kt.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG,
        1000054001: Kt.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,
        1000066e3: Kt.COMPRESSED_RGBA_ASTC_4x4_KHR,
        1000066001: Kt.COMPRESSED_RGBA_ASTC_5x4_KHR,
        1000066002: Kt.COMPRESSED_RGBA_ASTC_5x5_KHR,
        1000066003: Kt.COMPRESSED_RGBA_ASTC_6x5_KHR,
        1000066004: Kt.COMPRESSED_RGBA_ASTC_6x6_KHR,
        1000066005: Kt.COMPRESSED_RGBA_ASTC_8x5_KHR,
        1000066006: Kt.COMPRESSED_RGBA_ASTC_8x6_KHR,
        1000066007: Kt.COMPRESSED_RGBA_ASTC_8x8_KHR,
        1000066008: Kt.COMPRESSED_RGBA_ASTC_10x5_KHR,
        1000066009: Kt.COMPRESSED_RGBA_ASTC_10x6_KHR,
        1000066010: Kt.COMPRESSED_RGBA_ASTC_10x8_KHR,
        1000066011: Kt.COMPRESSED_RGBA_ASTC_10x10_KHR,
        1000066012: Kt.COMPRESSED_RGBA_ASTC_12x10_KHR,
        1000066013: Kt.COMPRESSED_RGBA_ASTC_12x12_KHR,
      },
      { read: ui } = ai,
      di = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
    function mi(e) {
      const t = new Uint8Array(e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength));
      return !(
        t.byteLength < di.length ||
        t[0] !== di[0] ||
        t[1] !== di[1] ||
        t[2] !== di[2] ||
        t[3] !== di[3] ||
        t[4] !== di[4] ||
        t[5] !== di[5] ||
        t[6] !== di[6] ||
        t[7] !== di[7] ||
        t[8] !== di[8] ||
        t[9] !== di[9] ||
        t[10] !== di[10] ||
        t[11] !== di[11]
      );
    }
    const pi = {
      etc1: { basisFormat: 0, compressed: !0, format: Kt.COMPRESSED_RGB_ETC1_WEBGL },
      etc2: { basisFormat: 1, compressed: !0 },
      bc1: { basisFormat: 2, compressed: !0, format: Kt.COMPRESSED_RGB_S3TC_DXT1_EXT },
      bc3: { basisFormat: 3, compressed: !0, format: Kt.COMPRESSED_RGBA_S3TC_DXT5_EXT },
      bc4: { basisFormat: 4, compressed: !0 },
      bc5: { basisFormat: 5, compressed: !0 },
      'bc7-m6-opaque-only': { basisFormat: 6, compressed: !0 },
      'bc7-m5': { basisFormat: 7, compressed: !0 },
      'pvrtc1-4-rgb': {
        basisFormat: 8,
        compressed: !0,
        format: Kt.COMPRESSED_RGB_PVRTC_4BPPV1_IMG,
      },
      'pvrtc1-4-rgba': {
        basisFormat: 9,
        compressed: !0,
        format: Kt.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,
      },
      'astc-4x4': { basisFormat: 10, compressed: !0, format: Kt.COMPRESSED_RGBA_ASTC_4X4_KHR },
      'atc-rgb': { basisFormat: 11, compressed: !0 },
      'atc-rgba-interpolated-alpha': { basisFormat: 12, compressed: !0 },
      rgba32: { basisFormat: 13, compressed: !1 },
      rgb565: { basisFormat: 14, compressed: !1 },
      bgr565: { basisFormat: 15, compressed: !1 },
      rgba4444: { basisFormat: 16, compressed: !1 },
    };
    function fi(e, t, i) {
      const s = new e(new Uint8Array(t));
      try {
        if (!s.startTranscoding()) throw new Error('Failed to start basis transcoding');
        const e = s.getNumImages(),
          t = [];
        for (let r = 0; r < e; r++) {
          const e = s.getNumLevels(r),
            n = [];
          for (let t = 0; t < e; t++) n.push(gi(s, r, t, i));
          t.push(n);
        }
        return t;
      } finally {
        s.close(), s.delete();
      }
    }
    function gi(e, t, i, s) {
      const r = e.getImageWidth(t, i),
        n = e.getImageHeight(t, i),
        o = e.getHasAlpha(),
        { compressed: a, format: l, basisFormat: h } = xi(s, o),
        c = e.getImageTranscodedSizeInBytes(t, i, h),
        _ = new Uint8Array(c);
      if (!e.transcodeImage(_, t, i, h, 0, 0)) throw new Error('failed to start Basis transcoding');
      return { width: r, height: n, data: _, compressed: a, format: l, hasAlpha: o };
    }
    function yi(e, t, i) {
      const s = new e(new Uint8Array(t));
      try {
        if (!s.startTranscoding()) throw new Error('failed to start KTX2 transcoding');
        const e = s.getLevels(),
          t = [];
        for (let r = 0; r < e; r++) {
          t.push(Ti(s, r, i));
          break;
        }
        return [t];
      } finally {
        s.close(), s.delete();
      }
    }
    function Ti(e, t, i) {
      const { alphaFlag: s, height: r, width: n } = e.getImageLevelInfo(t, 0, 0),
        { compressed: o, format: a, basisFormat: l } = xi(i, s),
        h = e.getImageTranscodedSizeInBytes(t, 0, 0, l),
        c = new Uint8Array(h);
      if (!e.transcodeImage(c, t, 0, 0, l, 0, -1, -1))
        throw new Error('Failed to transcode KTX2 image');
      return { width: n, height: r, data: c, compressed: o, hasAlpha: s, format: a };
    }
    function xi(e, t) {
      let i = e && e.basis && e.basis.format;
      return (
        'auto' === i && (i = vi()),
        'object' == typeof i && (i = t ? i.alpha : i.noAlpha),
        (i = i.toLowerCase()),
        pi[i]
      );
    }
    function vi() {
      const e = (function (e) {
        if (!Jt) {
          (e =
            e ||
            (function () {
              try {
                return document.createElement('canvas').getContext('webgl');
              } catch (e) {
                return null;
              }
            })()),
            (Jt = new Set());
          for (const t of Yt) for (const i in Qt) e && e.getExtension(`${t}${i}`) && Jt.add(Qt[i]);
        }
        return Jt;
      })();
      return e.has('astc')
        ? 'astc-4x4'
        : e.has('dxt')
        ? { alpha: 'bc3', noAlpha: 'bc1' }
        : e.has('pvrtc')
        ? { alpha: 'pvrtc1-4-rgba', noAlpha: 'pvrtc1-4-rgb' }
        : e.has('etc1')
        ? 'etc1'
        : e.has('etc2')
        ? 'etc2'
        : 'rgb565';
    }
    const bi = {
        name: 'Basis',
        id: 'basis',
        module: 'textures',
        version: zt,
        worker: !0,
        extensions: ['basis', 'ktx2'],
        mimeTypes: ['application/octet-stream', 'image/ktx2'],
        tests: ['sB'],
        binary: !0,
        options: {
          basis: {
            format: 'auto',
            libraryPath: 'libs/',
            containerFormat: 'auto',
            module: 'transcoder',
          },
        },
        parse: async function (e, t) {
          if ('auto' === t.basis.containerFormat) {
            if (mi(e)) return yi((await $t(t)).KTX2File, e, t);
            const { BasisFile: i } = await Zt(t);
            return fi(i, e, t);
          }
          if ('encoder' === t.basis.module) {
            const i = await $t(t);
            return 'ktx2' === t.basis.containerFormat
              ? yi(i.KTX2File, e, t)
              : fi(i.BasisFile, e, t);
          }
          {
            const { BasisFile: i } = await Zt(t);
            return fi(i, e, t);
          }
        },
      },
      wi = {
        MAGIC_NUMBER: 542327876,
        HEADER_LENGTH: 31,
        MAGIC_NUMBER_INDEX: 0,
        HEADER_SIZE_INDEX: 1,
        HEADER_FLAGS_INDEX: 2,
        HEADER_HEIGHT_INDEX: 3,
        HEADER_WIDTH_INDEX: 4,
        MIPMAPCOUNT_INDEX: 7,
        HEADER_PF_FLAGS_INDEX: 20,
        HEADER_PF_FOURCC_INDEX: 21,
        DDSD_MIPMAPCOUNT: 131072,
        DDPF_FOURCC: 4,
        PIXEL_FORMATS: {
          DXT1: Kt.COMPRESSED_RGB_S3TC_DXT1_EXT,
          DXT3: Kt.COMPRESSED_RGBA_S3TC_DXT3_EXT,
          DXT5: Kt.COMPRESSED_RGBA_S3TC_DXT5_EXT,
          'ATC ': Kt.COMPRESSED_RGB_ATC_WEBGL,
          ATCA: Kt.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL,
          ATCI: Kt.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL,
        },
        SIZE_FUNCTIONS: { DXT1: Ci, DXT3: Si, DXT5: Si, 'ATC ': Ci, ATCA: Si, ATCI: Si },
      };
    function Ci(e, t) {
      return ((e + 3) >> 2) * ((t + 3) >> 2) * 8;
    }
    function Si(e, t) {
      return ((e + 3) >> 2) * ((t + 3) >> 2) * 16;
    }
    const Ei = {
        0: [Kt.COMPRESSED_RGB_PVRTC_2BPPV1_IMG],
        1: [Kt.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG],
        2: [Kt.COMPRESSED_RGB_PVRTC_4BPPV1_IMG],
        3: [Kt.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG],
        6: [Kt.COMPRESSED_RGB_ETC1_WEBGL],
        7: [Kt.COMPRESSED_RGB_S3TC_DXT1_EXT],
        9: [Kt.COMPRESSED_RGBA_S3TC_DXT3_EXT],
        11: [Kt.COMPRESSED_RGBA_S3TC_DXT5_EXT],
        22: [Kt.COMPRESSED_RGB8_ETC2],
        23: [Kt.COMPRESSED_RGBA8_ETC2_EAC],
        24: [Kt.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2],
        25: [Kt.COMPRESSED_R11_EAC],
        26: [Kt.COMPRESSED_RG11_EAC],
        27: [Kt.COMPRESSED_RGBA_ASTC_4X4_KHR, Kt.COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR],
        28: [Kt.COMPRESSED_RGBA_ASTC_5X4_KHR, Kt.COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR],
        29: [Kt.COMPRESSED_RGBA_ASTC_5X5_KHR, Kt.COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR],
        30: [Kt.COMPRESSED_RGBA_ASTC_6X5_KHR, Kt.COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR],
        31: [Kt.COMPRESSED_RGBA_ASTC_6X6_KHR, Kt.COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR],
        32: [Kt.COMPRESSED_RGBA_ASTC_8X5_KHR, Kt.COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR],
        33: [Kt.COMPRESSED_RGBA_ASTC_8X6_KHR, Kt.COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR],
        34: [Kt.COMPRESSED_RGBA_ASTC_8X8_KHR, Kt.COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR],
        35: [Kt.COMPRESSED_RGBA_ASTC_10X5_KHR, Kt.COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR],
        36: [Kt.COMPRESSED_RGBA_ASTC_10X6_KHR, Kt.COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR],
        37: [Kt.COMPRESSED_RGBA_ASTC_10X8_KHR, Kt.COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR],
        38: [Kt.COMPRESSED_RGBA_ASTC_10X10_KHR, Kt.COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR],
        39: [Kt.COMPRESSED_RGBA_ASTC_12X10_KHR, Kt.COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR],
        40: [Kt.COMPRESSED_RGBA_ASTC_12X12_KHR, Kt.COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR],
      },
      Pi = {
        0: Mi,
        1: Mi,
        2: Ai,
        3: Ai,
        6: Ri,
        7: Ri,
        9: Ii,
        11: Ii,
        22: Ri,
        23: Ii,
        24: Ri,
        25: Ri,
        26: Ii,
        27: Ii,
        28: function (e, t) {
          return Math.floor((e + 4) / 5) * Math.floor((t + 3) / 4) * 16;
        },
        29: function (e, t) {
          return Math.floor((e + 4) / 5) * Math.floor((t + 4) / 5) * 16;
        },
        30: function (e, t) {
          return Math.floor((e + 5) / 6) * Math.floor((t + 4) / 5) * 16;
        },
        31: function (e, t) {
          return Math.floor((e + 5) / 6) * Math.floor((t + 5) / 6) * 16;
        },
        32: function (e, t) {
          return Math.floor((e + 7) / 8) * Math.floor((t + 4) / 5) * 16;
        },
        33: function (e, t) {
          return Math.floor((e + 7) / 8) * Math.floor((t + 5) / 6) * 16;
        },
        34: function (e, t) {
          return Math.floor((e + 7) / 8) * Math.floor((t + 7) / 8) * 16;
        },
        35: function (e, t) {
          return Math.floor((e + 9) / 10) * Math.floor((t + 4) / 5) * 16;
        },
        36: function (e, t) {
          return Math.floor((e + 9) / 10) * Math.floor((t + 5) / 6) * 16;
        },
        37: function (e, t) {
          return Math.floor((e + 9) / 10) * Math.floor((t + 7) / 8) * 16;
        },
        38: function (e, t) {
          return Math.floor((e + 9) / 10) * Math.floor((t + 9) / 10) * 16;
        },
        39: function (e, t) {
          return Math.floor((e + 11) / 12) * Math.floor((t + 9) / 10) * 16;
        },
        40: function (e, t) {
          return Math.floor((e + 11) / 12) * Math.floor((t + 11) / 12) * 16;
        },
      };
    function Mi(e, t) {
      return ((e = Math.max(e, 16)) * (t = Math.max(t, 8))) / 4;
    }
    function Ai(e, t) {
      return ((e = Math.max(e, 8)) * (t = Math.max(t, 8))) / 2;
    }
    function Ri(e, t) {
      return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8;
    }
    function Ii(e, t) {
      return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16;
    }
    const Oi = {
      name: 'Texture Containers',
      id: 'compressed-texture',
      module: 'textures',
      version: zt,
      worker: !0,
      extensions: ['ktx', 'ktx2', 'dds', 'pvr'],
      mimeTypes: ['application/octet-stream', 'image/vnd-ms.dds', 'image/ktx', 'image/ktx2'],
      binary: !0,
      options: { 'compressed-texture': { libraryPath: 'libs/' } },
      parse: async (e, t) =>
        (function (e) {
          if (mi(e))
            return (function (e) {
              const t = new Uint8Array(e),
                i = ui(t),
                s = Math.max(1, i.levels.length);
              return li(i.levels, {
                mipMapLevels: s,
                width: i.pixelWidth,
                height: i.pixelHeight,
                sizeFunction: (e) => e.uncompressedByteLength,
                internalFormat: _i[i.vkFormat],
              });
            })(e);
          if (
            (function (e) {
              return (
                new Uint32Array(e, 0, wi.HEADER_LENGTH)[wi.MAGIC_NUMBER_INDEX] === wi.MAGIC_NUMBER
              );
            })(e)
          )
            return (function (e) {
              const t = new Int32Array(e, 0, wi.HEADER_LENGTH),
                i = t[wi.HEADER_PF_FOURCC_INDEX];
              P(
                Boolean(t[wi.HEADER_PF_FLAGS_INDEX] & wi.DDPF_FOURCC),
                'DDS: Unsupported format, must contain a FourCC code',
              );
              const s =
                ((r = i),
                String.fromCharCode(255 & r, (r >> 8) & 255, (r >> 16) & 255, (r >> 24) & 255));
              var r;
              const n = wi.PIXEL_FORMATS[s],
                o = wi.SIZE_FUNCTIONS[s];
              P(n && o, `DDS: Unknown pixel format ${i}`);
              let a = 1;
              t[wi.HEADER_FLAGS_INDEX] & wi.DDSD_MIPMAPCOUNT &&
                (a = Math.max(1, t[wi.MIPMAPCOUNT_INDEX]));
              const l = t[wi.HEADER_WIDTH_INDEX],
                h = t[wi.HEADER_HEIGHT_INDEX];
              return li(new Uint8Array(e.slice(t[wi.HEADER_SIZE_INDEX] + 4)), {
                mipMapLevels: a,
                width: l,
                height: h,
                sizeFunction: o,
                internalFormat: n,
              });
            })(e);
          if (
            (function (e) {
              const t = new Uint32Array(e, 0, 13)[0];
              return 55727696 === t || 1347834371 === t;
            })(e)
          )
            return (function (e) {
              const t = new Uint32Array(e, 0, 13),
                i = t[2],
                s = Ei[i] || [],
                r = s.length > 1 && t[4] ? s[1] : s[0],
                n = Pi[i],
                o = t[11],
                a = t[7],
                l = t[6];
              return li(new Uint8Array(e.slice(52 + t[12])), {
                mipMapLevels: o,
                width: a,
                height: l,
                sizeFunction: n,
                internalFormat: r,
              });
            })(e);
          throw new Error('Texture container format not recognized');
        })(e),
    };
    !(function () {
      const e = new Uint32Array([305419896]);
      new Uint8Array(e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength));
    })(),
      new Uint8Array([147, 78, 85, 77, 80, 89]);
    const Li = {
      id: 'crunch',
      name: 'Crunch',
      module: 'textures',
      version: zt,
      worker: !0,
      extensions: ['crn'],
      mimeTypes: ['image/crn', 'image/x-crn', 'application/octet-stream'],
      binary: !0,
      options: { crunch: { libraryPath: 'libs/' } },
    };
    let Di;
    const Bi = {};
    (Bi[0] = { pixelFormat: Kt.COMPRESSED_RGB_S3TC_DXT1_EXT, sizeFunction: Ci }),
      (Bi[1] = { pixelFormat: Kt.COMPRESSED_RGBA_S3TC_DXT3_EXT, sizeFunction: Si }),
      (Bi[2] = { pixelFormat: Kt.COMPRESSED_RGBA_S3TC_DXT5_EXT, sizeFunction: Si });
    let Vi = 0,
      Ni = null;
    const ki = {
      ...Li,
      parse: async function (e, t = {}) {
        const i = await (async function (e) {
            const t = e.modules || {};
            return t.crunch
              ? t.crunch
              : (async function (e) {
                  if (Di) return Di;
                  let t = null;
                  return (
                    ([t] = await Promise.all([await se('crunch.js', 'textures', e)])),
                    (t = t || globalThis.LoadCrunchDecoder),
                    (Di = t()),
                    Di
                  );
                })(e);
          })(t),
          s = e.byteLength,
          r = new Uint8Array(e),
          n = i._malloc(s);
        !(function (e, t, i, s) {
          let r;
          const n = i / 4,
            o = s % 4,
            a = new Uint32Array(e.buffer.slice(0, (s - o) / 4)),
            l = new Uint32Array(t.buffer);
          for (r = 0; r < a.length; r++) l[n + r] = a[r];
          for (r = s - o; r < s; r++) t[i + r] = e[r];
        })(r, i.HEAPU8, n, s);
        const o = i._crn_get_dxt_format(n, s);
        P(Boolean(Bi[o]), 'Unsupported format');
        const a = i._crn_get_levels(n, s),
          l = i._crn_get_width(n, s),
          h = i._crn_get_height(n, s),
          c = Bi[o].sizeFunction;
        let _ = 0;
        for (let e = 0; e < a; ++e) _ += c(l >> e, h >> e);
        return (
          Vi < _ && (Ni && i._free(Ni), (Ni = i._malloc(_)), (Vi = _)),
          i._crn_decompress(n, s, Ni, _, 0, a),
          i._free(n),
          li(new Uint8Array(i.HEAPU8.buffer.slice(Ni, Ni + _)), {
            mipMapLevels: a,
            width: l,
            height: h,
            sizeFunction: c,
            internalFormat: Bi[o].pixelFormat,
          })
        );
      },
    };
    var Fi;
    function Gi(e, t) {
      if (!e) throw new Error(t || 'assert failed: gltf');
    }
    function Ui(e, t) {
      if (e.startsWith('data:') || e.startsWith('http:') || e.startsWith('https:')) return e;
      const i = t && t.modelFolder ? t.modelFolder : t.baseUri || t.uri;
      if (!i) throw new Error(`'baseUri' must be provided to resolve relative url ${e}`);
      return t && t.modelFolder
        ? '/' === t.modelFolder.slice(-1)
          ? t.modelFolder + e
          : `${t.modelFolder}/${e}`
        : i.substr(0, i.lastIndexOf('/') + 1) + e;
    }
    function zi(e, t, i) {
      const s = e.bufferViews[i];
      Gi(s);
      const r = t[s.buffer];
      Gi(r);
      const n = (s.byteOffset || 0) + r.byteOffset;
      return r.arrayBuffer.slice(n, n + s.byteLength);
    }
    (Fi = ki),
      'undefined' != typeof self &&
        (ee.onmessage = async (e, t) => {
          if ('process' === e)
            try {
              const { input: e, options: i = {} } = t,
                s = await (async function ({ loader: e, arrayBuffer: t, options: i, context: s }) {
                  let r, n;
                  if (e.parseSync || e.parse) (r = t), (n = e.parseSync || e.parse);
                  else {
                    if (!e.parseTextSync)
                      throw new Error(`Could not load data with ${e.name} loader`);
                    (r = new TextDecoder().decode(t)), (n = e.parseTextSync);
                  }
                  return (
                    (i = {
                      ...i,
                      modules: (e && e.options && e.options.modules) || {},
                      worker: !1,
                    }),
                    await n(r, { ...i }, s, e)
                  );
                })({
                  loader: Fi,
                  arrayBuffer: e,
                  byteOffset: 0,
                  byteLength: 0,
                  options: i,
                  context: { parse: ne },
                });
              ee.postMessage('done', { result: s });
            } catch (e) {
              ee.postMessage('error', { error: e.message });
            }
        });
    const Hi = 'undefined' != typeof __VERSION__ ? __VERSION__ : 'latest',
      Wi = '1.4.1',
      ji = `/draco/versioned/decoders/${Wi}/draco_decoder.js`,
      qi = `/draco/versioned/decoders/${Wi}/draco_wasm_wrapper.js`,
      Xi = `/draco/versioned/decoders/${Wi}/draco_decoder.wasm`;
    let Zi;
    const $i = {
        POSITION: 'POSITION',
        JOINTS_0: 'JOINTS_0',
        WEIGHTS_0: 'WEIGHTS_0',
        NORMAL: 'NORMAL',
        COLOR: 'COLOR',
        TEX_COORD: 'TEXCOORD',
      },
      Ki = {
        1: Int8Array,
        2: Uint8Array,
        3: Int16Array,
        4: Uint16Array,
        5: Int32Array,
        6: Uint32Array,
        9: Float32Array,
      };
    class Yi {
      constructor(e) {
        (this.draco = e), (this.drawMode = 'TRIANGLE'), (this.metadataQuerier = {});
      }
      destroy() {}
      parseSync(e, t = {}) {
        this.metadataQuerier = new this.draco.MetadataQuerier();
        const i = new this.draco.DecoderBuffer();
        i.Init(new Int8Array(e), e.byteLength);
        const s = new this.draco.Decoder(),
          r = {};
        let n, o, a;
        try {
          const e = s.GetEncodedGeometryType(i);
          switch (e) {
            case this.draco.TRIANGULAR_MESH:
              (o = new this.draco.Mesh()),
                (n = s.DecodeBufferToMesh(i, o)),
                (a = {
                  type: 0,
                  faceCount: o.num_faces(),
                  attributeCount: o.num_attributes(),
                  vertexCount: o.num_points(),
                });
              break;
            case this.draco.POINT_CLOUD:
              (o = new this.draco.PointCloud()),
                (n = s.DecodeBufferToPointCloud(i, o)),
                (a = { type: 1, attributeCount: o.num_attributes(), vertexCount: o.num_points() });
              break;
            default:
              throw new Error('Unknown DRACO geometry type.');
          }
          if (!n.ok() || !o.ptr) {
            const e = `DRACO decompression failed: ${n.error_msg()}`;
            throw (o && this.draco.destroy(o), new Error(e));
          }
          (r.loaderData = { header: a }), this._extractDRACOGeometry(s, o, e, r, t);
          const l = this._getGeometryMetadata(s, o);
          r.header = { vertexCount: a.vertexCount, boundingBox: be(r.attributes), metadata: l };
        } finally {
          this.draco.destroy(s),
            this.draco.destroy(i),
            this.draco.destroy(o),
            this.draco.destroy(this.metadataQuerier);
        }
        return r;
      }
      _extractDRACOGeometry(e, t, i, s, r) {
        const n = this._getAttributes(e, t, r);
        if (!n.POSITION) throw new Error('DRACO decompressor: No position attribute found.');
        return (
          i === this.draco.TRIANGULAR_MESH
            ? ((n.indices =
                'TRIANGLE_STRIP' === this.drawMode
                  ? this._getMeshStripIndices(e, t)
                  : this._getMeshFaceIndices(e, t)),
              (s.mode = 'TRIANGLE_STRIP' === this.drawMode ? 5 : 4))
            : (s.mode = 0),
          n.indices && ((s.indices = { value: n.indices, size: 1 }), delete n.indices),
          (s.attributes = n),
          s
        );
      }
      getPositionAttributeMetadata(e) {
        (this.metadata = this.metadata || {}),
          (this.metadata.attributes = this.metadata.attributes || {});
        const t = new this.draco.AttributeQuantizationTransform();
        if (t.InitFromAttribute(e)) {
          (this.metadata.attributes.position.isQuantized = !0),
            (this.metadata.attributes.position.maxRange = t.range()),
            (this.metadata.attributes.position.numQuantizationBits = t.quantization_bits()),
            (this.metadata.attributes.position.minValues = new Float32Array(3));
          for (let e = 0; e < 3; ++e)
            this.metadata.attributes.position.minValues[e] = t.min_value(e);
        }
        this.draco.destroy(t);
      }
      _getAttributes(e, t, i) {
        const s = {},
          r = t.num_points();
        let n = 0,
          o = 0;
        for (let a = 0; a < t.num_attributes(); a++) {
          const l = e.GetAttribute(t, a),
            h = this._getAttributeMetadata(e, t, a),
            c = {
              uniqueId: l.unique_id(),
              attributeType: l.attribute_type(),
              dataType: Ki[l.data_type()],
              size: l.size(),
              numComponents: l.num_components(),
              byteOffset: l.byte_offset(),
              byteStride: l.byte_stride(),
              normalized: l.normalized(),
              metadata: h,
            };
          let _ = this._deduceAttributeName(c, i);
          const { typedArray: u } = this._getAttributeTypedArray(e, t, l, _);
          'COLOR' === _ ? ((_ = `${_}_${n}`), n++) : 'TEXCOORD' === _ && ((_ = `${_}_${o}`), o++),
            (s[_] = { value: u, size: u.length / r, metadata: h });
        }
        return s;
      }
      _getMeshFaceIndices(e, t) {
        const i = 3 * t.num_faces(),
          s = 4 * i,
          r = this.draco._malloc(s);
        e.GetTrianglesUInt32Array(t, s, r);
        const n = new Uint32Array(this.draco.HEAPF32.buffer.slice(r, r + i));
        return this.draco._free(r), n;
      }
      _getMeshStripIndices(e, t) {
        const i = new this.draco.DracoInt32Array();
        e.GetTriangleStripsFromMesh(t, i);
        const s = new Uint32Array(i.size());
        for (let e = 0; e < i.size(); ++e) s[e] = i.GetValue(e);
        return this.draco.destroy(i), s;
      }
      _getAttributeTypedArray(e, t, i, s) {
        if (0 === i.ptr) throw new Error(`DRACO decode bad attribute ${s}`);
        const r = Ki[i.data_type()],
          n = i.num_components(),
          o = t.num_points() * n,
          a = o * r.BYTES_PER_ELEMENT,
          l = this._getDracoDataType(r),
          h = this.draco._malloc(a);
        e.GetAttributeDataArrayForAllPoints(t, i, l, a, h);
        const c = new r(this.draco.HEAPF32.buffer, h, o).slice();
        return this.draco._free(h), { typedArray: c, components: n };
      }
      _getDracoDataType(e) {
        switch (e) {
          case Float32Array:
            return this.draco.DT_FLOAT32;
          case Int8Array:
            return this.draco.DT_INT8;
          case Int16Array:
            return this.draco.DT_INT16;
          case Int32Array:
            return this.draco.DT_INT32;
          case Uint8Array:
            return this.draco.DT_UINT8;
          case Uint16Array:
            return this.draco.DT_UINT16;
          case Uint32Array:
            return this.draco.DT_UINT32;
          default:
            return this.draco.DT_INVALID;
        }
      }
      _deduceAttributeName(e, t) {
        const { extraAttributes: i = {} } = t;
        if (i && 'object' == typeof i)
          for (const [t, s] of Object.entries(i)) if (s === e.uniqueId) return t;
        for (const t in $i) if (e.attributeType === this.draco[t]) return $i[t];
        if (e.metadata) {
          const i = t.attributeNameEntry || 'name';
          if (e.metadata[i]) return e.metadata[i].string;
        }
        return `CUSTOM_ATTRIBUTE_${e.uniqueId}`;
      }
      _getGeometryMetadata(e, t) {
        const i = e.GetMetadata(t);
        return this._queryDracoMetadata(i);
      }
      _getAttributeMetadata(e, t, i) {
        const s = e.GetAttributeMetadata(t, i);
        return this._queryDracoMetadata(s);
      }
      _queryDracoMetadata(e) {
        if (!e || !e.ptr) return {};
        const t = {},
          i = this.metadataQuerier.NumEntries(e),
          s = new this.draco.DracoInt32Array();
        for (let r = 0; r < i; r++) {
          const i = this.metadataQuerier.GetEntryName(e, r);
          this.metadataQuerier.GetIntEntryArray(e, i, s);
          const n = s.size(),
            o = new Int32Array(n);
          for (let e = 0; e < n; e++) o[e] = s.GetValue(e);
          t[i] = {
            int: this.metadataQuerier.GetIntEntry(e, i),
            string: this.metadataQuerier.GetStringEntry(e, i),
            double: this.metadataQuerier.GetDoubleEntry(e, i),
            intArray: o,
          };
        }
        return this.draco.destroy(s), t;
      }
      decode(e, t) {
        return this.parseSync(e, t);
      }
    }
    const Qi = {
        name: 'Draco',
        id: 'draco',
        module: 'draco',
        version: Hi,
        worker: !0,
        extensions: ['drc'],
        mimeTypes: ['application/octet-stream'],
        binary: !0,
        tests: ['DRACO'],
        options: {
          draco: {
            decoderType: 'object' == typeof WebAssembly ? 'wasm' : 'js',
            libraryPath: 'libs/',
            extraAttributes: {},
          },
        },
        parse: async function (e, t, i, s) {
          const { draco: r } = await (async function (e) {
              const t = e.modules || {};
              return (
                (Zi = t.draco3d
                  ? Zi || t.draco3d.createDecoderModule({}).then((e) => ({ draco: e }))
                  : Zi ||
                    (async function (e) {
                      let t, i;
                      'js' === (e.draco && e.draco.decoderType)
                        ? (t = await se(`${ji}`, 'draco', e))
                        : ([t, i] = await Promise.all([
                            await se(`${qi}`, 'draco', e),
                            await se(`${Xi}`, 'draco', e),
                          ])),
                        (t = t || globalThis.DracoDecoderModule);
                      const s = await (function (e, t) {
                        const i = {};
                        return (
                          t && (i.wasmBinary = t),
                          new Promise((t) => {
                            e({ ...i, onModuleLoaded: (e) => t({ draco: e }) });
                          })
                        );
                      })(t, i);
                      return s;
                    })(e)),
                await Zi
              );
            })(t),
            n = new Yi(r);
          try {
            return n.parseSync(e, {
              extraAttributes: (t.draco && t.draco.extraAttributes) || null,
              ...(t.parseOptions || {}),
            });
          } finally {
            n.destroy();
          }
        },
      },
      Ji = ['SCALAR', 'VEC2', 'VEC3', 'VEC4'],
      es = [
        [Int8Array, 5120],
        [Uint8Array, 5121],
        [Int16Array, 5122],
        [Uint16Array, 5123],
        [Uint32Array, 5125],
        [Float32Array, 5126],
        [Float64Array, 5130],
      ],
      ts = new Map(es),
      is = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
      ss = { 5120: 1, 5121: 1, 5122: 2, 5123: 2, 5125: 4, 5126: 4 },
      rs = {
        5120: Int8Array,
        5121: Uint8Array,
        5122: Int16Array,
        5123: Uint16Array,
        5125: Uint32Array,
        5126: Float32Array,
      };
    function ns(e) {
      return Ji[e - 1] || Ji[0];
    }
    function os(e) {
      const t = ts.get(e.constructor);
      if (!t) throw new Error('Illegal typed array');
      return t;
    }
    function as(e, t) {
      const i = rs[e.componentType],
        s = is[e.type],
        r = e.count * s,
        n = e.count * s * ss[e.componentType];
      return Gi(n >= 0 && n <= t.byteLength), { ArrayType: i, length: r, byteLength: n };
    }
    class ls {
      constructor(e) {
        if (e instanceof ls) return e;
        e ||
          (e = {
            json: { asset: { version: '2.0', generator: 'loaders.gl' }, buffers: [] },
            buffers: [],
          }),
          (this.sourceBuffers = []),
          (this.byteLength = 0),
          e.buffers &&
            e.buffers[0] &&
            ((this.byteLength = e.buffers[0].byteLength), (this.sourceBuffers = [e.buffers[0]])),
          (this.gltf = e),
          Gi(this.gltf.json);
      }
      get json() {
        return this.gltf.json;
      }
      getApplicationData(e) {
        return this.json[e];
      }
      getExtraData(e) {
        return (this.json.extras || {})[e];
      }
      getExtension(e) {
        return this.getUsedExtensions().find((t) => t === e)
          ? (this.json.extensions || {})[e] || !0
          : null;
      }
      getRequiredExtension(e) {
        return this.getRequiredExtensions().find((t) => t === e) ? this.getExtension(e) : null;
      }
      getRequiredExtensions() {
        return this.json.extensionsRequired || [];
      }
      getUsedExtensions() {
        return this.json.extensionsUsed || [];
      }
      getObjectExtension(e, t) {
        return (e.extensions || {})[t];
      }
      getScene(e) {
        return this.getObject('scenes', e);
      }
      getNode(e) {
        return this.getObject('nodes', e);
      }
      getSkin(e) {
        return this.getObject('skins', e);
      }
      getMesh(e) {
        return this.getObject('meshes', e);
      }
      getMaterial(e) {
        return this.getObject('materials', e);
      }
      getAccessor(e) {
        return this.getObject('accessors', e);
      }
      getCamera(e) {
        return null;
      }
      getTexture(e) {
        return this.getObject('textures', e);
      }
      getSampler(e) {
        return this.getObject('samplers', e);
      }
      getImage(e) {
        return this.getObject('images', e);
      }
      getBufferView(e) {
        return this.getObject('bufferViews', e);
      }
      getBuffer(e) {
        return this.getObject('buffers', e);
      }
      getObject(e, t) {
        if ('object' == typeof t) return t;
        const i = this.json[e] && this.json[e][t];
        if (!i) throw new Error(`glTF file error: Could not find ${e}[${t}]`);
        return i;
      }
      getTypedArrayForBufferView(e) {
        e = this.getBufferView(e);
        const t = this.gltf.buffers[e.buffer];
        Gi(t);
        const i = (e.byteOffset || 0) + t.byteOffset;
        return new Uint8Array(t.arrayBuffer.slice(i, i + e.byteLength));
      }
      getTypedArrayDataForBufferViewInSimple(e) {
        e = this.getBufferView(e);
        const t = this.gltf.buffers[e.buffer];
        Gi(t);
        const i = (e.byteOffset || 0) + t.byteOffset;
        return t.arrayBuffer.slice(i, i + e.byteLength);
      }
      getTypedArrayForAccessor(e) {
        e = this.getAccessor(e);
        const t = this.getBufferView(e.bufferView),
          i = this.getBuffer(t.buffer).data,
          { ArrayType: s, length: r } = as(e, t);
        return new s(i, t.byteOffset + e.byteOffset, r);
      }
      getTypedArrayForImageData(e) {
        e = this.getAccessor(e);
        const t = this.getBufferView(e.bufferView),
          i = this.getBuffer(t.buffer),
          s = t.byteOffset || 0;
        return new Uint8Array(i.data.slice(s, s + t.byteLength));
      }
      addApplicationData(e, t) {
        return (this.json[e] = t), this;
      }
      addExtraData(e, t) {
        return (this.json.extras = this.json.extras || {}), (this.json.extras[e] = t), this;
      }
      addObjectExtension(e, t, i) {
        return (
          Gi(i),
          (e.extensions = e.extensions || {}),
          (e.extensions[t] = i),
          this.registerUsedExtension(t),
          this
        );
      }
      setObjectExtension(e, t, i) {
        (e.extensions || {})[t] = i;
      }
      removeObjectExtension(e, t) {
        const i = e.extensions || {},
          s = i[t];
        return delete i[t], s;
      }
      addExtension(e, t = {}) {
        return (
          Gi(t),
          (this.json.extensions = this.json.extensions || {}),
          (this.json.extensions[e] = t),
          this.registerUsedExtension(e),
          t
        );
      }
      addRequiredExtension(e, t = {}) {
        return Gi(t), this.addExtension(e, t), this.registerRequiredExtension(e), t;
      }
      registerUsedExtension(e) {
        (this.json.extensionsUsed = this.json.extensionsUsed || []),
          this.json.extensionsUsed.find((t) => t === e) || this.json.extensionsUsed.push(e);
      }
      registerRequiredExtension(e) {
        this.registerUsedExtension(e),
          (this.json.extensionsRequired = this.json.extensionsRequired || []),
          this.json.extensionsRequired.find((t) => t === e) || this.json.extensionsRequired.push(e);
      }
      removeExtension(e) {
        this.json.extensionsRequired &&
          this._removeStringFromArray(this.json.extensionsRequired, e),
          this.json.extensionsUsed && this._removeStringFromArray(this.json.extensionsUsed, e),
          this.json.extensions && delete this.json.extensions[e];
      }
      setDefaultScene(e) {
        this.json.scene = e;
      }
      addScene({ nodeIndices: e }) {
        return (
          (this.json.scenes = this.json.scenes || []),
          this.json.scenes.push({ nodes: e }),
          this.json.scenes.length - 1
        );
      }
      addNode({ meshIndex: e, matrix: t = null }) {
        this.json.nodes = this.json.nodes || [];
        const i = { mesh: e };
        return t && (i.matrix = t), this.json.nodes.push(i), this.json.nodes.length - 1;
      }
      addMesh({ attributes: e, indices: t, material: i, mode: s = 4 }) {
        const r = { primitives: [{ attributes: this._addAttributes(e), mode: s }] };
        if (t) {
          const e = this._addIndices(t);
          r.primitives[0].indices = e;
        }
        return (
          Number.isFinite(i) && (r.primitives[0].material = i),
          (this.json.meshes = this.json.meshes || []),
          this.json.meshes.push(r),
          this.json.meshes.length - 1
        );
      }
      addPointCloud(e) {
        const t = { primitives: [{ attributes: this._addAttributes(e), mode: 0 }] };
        return (
          (this.json.meshes = this.json.meshes || []),
          this.json.meshes.push(t),
          this.json.meshes.length - 1
        );
      }
      addImage(e, t) {
        t =
          t ||
          (function (e) {
            const t = Ft(e);
            return t ? t.mimeType : null;
          })(e);
        const i = { bufferView: this.addBufferView(e), mimeType: t };
        return (
          (this.json.images = this.json.images || []),
          this.json.images.push(i),
          this.json.images.length - 1
        );
      }
      addBufferView(e) {
        const t = e.byteLength;
        Gi(Number.isFinite(t)),
          (this.sourceBuffers = this.sourceBuffers || []),
          this.sourceBuffers.push(e);
        const i = { buffer: 0, byteOffset: this.byteLength, byteLength: t };
        return (
          (this.byteLength += ce(t, 4)),
          (this.json.bufferViews = this.json.bufferViews || []),
          this.json.bufferViews.push(i),
          this.json.bufferViews.length - 1
        );
      }
      addAccessor(e, t) {
        const i = {
          bufferView: e,
          type: ns(t.size),
          componentType: t.componentType,
          count: t.count,
          max: t.max,
          min: t.min,
        };
        return (
          (this.json.accessors = this.json.accessors || []),
          this.json.accessors.push(i),
          this.json.accessors.length - 1
        );
      }
      addBinaryBuffer(e, t = { size: 3 }) {
        const i = this.addBufferView(e);
        let s = { min: t.min, max: t.max };
        (s.min && s.max) || (s = this._getAccessorMinMax(e, t.size));
        const r = {
          size: t.size,
          componentType: os(e),
          count: Math.round(e.length / t.size),
          min: s.min,
          max: s.max,
        };
        return this.addAccessor(i, Object.assign(r, t));
      }
      addTexture({ imageIndex: e }) {
        const t = { source: e };
        return (
          (this.json.textures = this.json.textures || []),
          this.json.textures.push(t),
          this.json.textures.length - 1
        );
      }
      addMaterial(e) {
        return (
          (this.json.materials = this.json.materials || []),
          this.json.materials.push(e),
          this.json.materials.length - 1
        );
      }
      createBinaryChunk() {
        this.gltf.buffers = [];
        const e = this.byteLength,
          t = new ArrayBuffer(e),
          i = new Uint8Array(t),
          s = this.sourceBuffers || [];
        let r = 0;
        for (let e = 0; e < s.length; e++) r = _e(s[e], i, r);
        (this.json.buffers[0] = this.json.buffers[0] || {}),
          (this.json.buffers[0].byteLength = e),
          (this.gltf.binary = t),
          (this.sourceBuffers = [t]);
      }
      _removeStringFromArray(e, t) {
        let i = !0;
        for (; i; ) {
          const s = e.indexOf(t);
          s > -1 ? e.splice(s, 1) : (i = !1);
        }
      }
      _addAttributes(e = {}) {
        const t = {};
        for (const i in e) {
          const s = e[i],
            r = this._getGltfAttributeName(i),
            n = this.addBinaryBuffer(s.value, s);
          t[r] = n;
        }
        return t;
      }
      _addIndices(e) {
        return this.addBinaryBuffer(e, { size: 1 });
      }
      _getGltfAttributeName(e) {
        switch (e.toLowerCase()) {
          case 'position':
          case 'positions':
          case 'vertices':
            return 'POSITION';
          case 'normal':
          case 'normals':
            return 'NORMAL';
          case 'color':
          case 'colors':
            return 'COLOR_0';
          case 'texcoord':
          case 'texcoords':
            return 'TEXCOORD_0';
          default:
            return e;
        }
      }
      _getAccessorMinMax(e, t) {
        const i = { min: null, max: null };
        if (e.length < t) return i;
        (i.min = []), (i.max = []);
        const s = e.subarray(0, t);
        for (const e of s) i.min.push(e), i.max.push(e);
        for (let s = t; s < e.length; s += t)
          for (let r = 0; r < t; r++)
            (i.min[0 + r] = Math.min(i.min[0 + r], e[s + r])),
              (i.max[0 + r] = Math.max(i.max[0 + r], e[s + r]));
        return i;
      }
    }
    function hs(e, t) {
      const {
        buffer: i,
        size: s,
        count: r,
      } = (function (e, t) {
        let i = e,
          s = 1,
          r = 0;
        return (
          e && e.value && ((i = e.value), (s = e.size || 1)),
          i &&
            (ArrayBuffer.isView(i) ||
              (i = (function (e, t, i = !1) {
                return e
                  ? Array.isArray(e)
                    ? new t(e)
                    : !i || e instanceof t
                    ? e
                    : new t(e)
                  : null;
              })(i, Float32Array)),
            (r = i.length / s)),
          { buffer: i, size: s, count: r }
        );
      })(e);
      return {
        value: i,
        size: s,
        bufferView: null,
        byteOffset: 0,
        count: r,
        type: ns(s),
        componentType: os(i),
      };
    }
    async function cs(e, t, i, s) {
      const r = t.getObjectExtension(e, mt);
      let n = t.getTypedArrayDataForBufferViewInSimple(r.bufferView);
      const { parse: o } = s,
        a = { ...i };
      delete a['3d-tiles'];
      const l = await o(n, Qi, a, s);
      (n = null),
        (e.attributes = (function (e) {
          const t = {};
          for (const i in e)
            if ('indices' !== i) {
              const s = hs(e[i]);
              t[i] = s;
            }
          return t;
        })(l.attributes)),
        (e.boundingBox = { min: l.header.boundingBox[0], max: l.header.boundingBox[1] }),
        l.indices && (e.indices = hs(l.indices)),
        (function (e) {
          if (!e.attributes && Object.keys(e.attributes).length > 0)
            throw new Error('Empty glTF primitive detected: Draco decompression failure?');
        })(e);
    }
    function _s(e, t, i = 4, s, r) {
      if (!s.DracoWriter) throw new Error('options.gltf.DracoWriter not provided');
      const n = s.DracoWriter.encodeSync({ attributes: e }),
        { parseSync: o } = r,
        a = o({ attributes: e }),
        l = s._addFauxAttributes(a.attributes),
        h = s.addBufferView(n);
      return {
        primitives: [
          { attributes: l, mode: i, extensions: { [mt]: { bufferView: h, attributes: l } } },
        ],
      };
    }
    var us = Object.freeze({
        __proto__: null,
        decode: async function (e, t, i) {
          if (!t.gltf.decompressMeshes) return;
          const s = new ls(e),
            r = [];
          for (const e of (function* (e) {
            for (const t of e.json.meshes || []) for (const e of t.primitives) yield e;
          })(s))
            s.getObjectExtension(e, mt) && r.push(cs(e, s, t, i));
          await Promise.all(r), s.removeExtension(mt);
        },
        encode: function (e, t = {}) {
          const i = new ls(e);
          for (const e of i.json.meshes || []) _s(e), i.addRequiredExtension(mt);
        },
      }),
      ds = Object.freeze({
        __proto__: null,
        decode: function (e, t) {
          const i = new ls(e),
            { json: s } = i,
            r = i.getExtension(pt);
          r && ((i.json.lights = r.lights), i.removeExtension(pt));
          for (const e of s.nodes || []) {
            const t = i.getObjectExtension(e, pt);
            t && (e.light = t.light), i.removeObjectExtension(e, pt);
          }
        },
        encode: function (e, t) {
          const i = new ls(e),
            { json: s } = i;
          if (s.lights) {
            const e = i.addExtension(pt);
            Gi(!e.lights), (e.lights = s.lights), delete s.lights;
          }
          if (i.json.lights) {
            for (const e of i.json.lights) i.addObjectExtension(e.node, pt, e);
            delete i.json.lights;
          }
        },
      });
    function ms(e, t) {
      const i = Object.assign({}, e.values);
      return (
        Object.keys(e.uniforms || {}).forEach((t) => {
          e.uniforms[t].value && !(t in i) && (i[t] = e.uniforms[t].value);
        }),
        Object.keys(i).forEach((e) => {
          'object' == typeof i[e] &&
            void 0 !== i[e].index &&
            (i[e].texture = t.getTexture(i[e].index));
        }),
        i
      );
    }
    const ps = 'KHR_texture_basisu',
      fs = [
        us,
        ds,
        Object.freeze({
          __proto__: null,
          decode: function (e, t) {
            const i = new ls(e),
              { json: s } = i;
            i.removeExtension(ft);
            for (const e of s.materials || [])
              e.extensions && e.extensions.KHR_materials_unlit && (e.unlit = !0),
                i.removeObjectExtension(e, ft);
          },
          encode: function (e, t) {
            const i = new ls(e),
              { json: s } = i;
            if (i.materials)
              for (const e of s.materials)
                e.unlit && (delete e.unlit, i.addObjectExtension(e, ft, {}), i.addExtension(ft));
          },
        }),
        Object.freeze({
          __proto__: null,
          decode: function (e, t) {
            const i = new ls(e),
              { json: s } = i,
              r = i.getExtension(gt);
            if (r) {
              const e = (function ({ programs: e = [], shaders: t = [], techniques: i = [] }, s) {
                const r = new TextDecoder();
                return (
                  t.forEach((e) => {
                    if (!Number.isFinite(e.bufferView))
                      throw new Error('KHR_techniques_webgl: no shader code');
                    e.code = r.decode(s.getTypedArrayForBufferView(e.bufferView));
                  }),
                  e.forEach((e) => {
                    (e.fragmentShader = t[e.fragmentShader]), (e.vertexShader = t[e.vertexShader]);
                  }),
                  i.forEach((t) => {
                    t.program = e[t.program];
                  }),
                  i
                );
              })(r, i);
              for (const t of s.materials || []) {
                const s = i.getObjectExtension(t, gt);
                s &&
                  ((t.technique = Object.assign({}, s, e[s.technique])),
                  (t.technique.values = ms(t.technique, i))),
                  i.removeObjectExtension(t, gt);
              }
              i.removeExtension(gt);
            }
          },
          encode: function (e, t) {},
        }),
        Object.freeze({
          __proto__: null,
          name: ps,
          preprocess: function (e, t) {
            const i = new ls(e),
              { json: s } = i;
            for (const e of s.textures || []) {
              const t = i.getObjectExtension(e, ps);
              t && (e.source = t.source), i.removeObjectExtension(e, ps);
            }
            i.removeExtension(ps);
          },
        }),
      ];
    function gs(e, t) {
      const i = t?.gltf?.excludeExtensions || {};
      return !(e in i && !i[e]);
    }
    const ys = {
        accessors: 'accessor',
        animations: 'animation',
        buffers: 'buffer',
        bufferViews: 'bufferView',
        images: 'image',
        materials: 'material',
        meshes: 'mesh',
        nodes: 'node',
        samplers: 'sampler',
        scenes: 'scene',
        skins: 'skin',
        textures: 'texture',
      },
      Ts = {
        accessor: 'accessors',
        animations: 'animation',
        buffer: 'buffers',
        bufferView: 'bufferViews',
        image: 'images',
        material: 'materials',
        mesh: 'meshes',
        node: 'nodes',
        sampler: 'samplers',
        scene: 'scenes',
        skin: 'skins',
        texture: 'textures',
      };
    class xs {
      constructor(e) {
        this.idToIndexMap = {
          animations: {},
          accessors: {},
          buffers: {},
          bufferViews: {},
          images: {},
          materials: {},
          meshes: {},
          nodes: {},
          samplers: {},
          scenes: {},
          skins: {},
          textures: {},
        };
      }
      normalize(e, t) {
        this.json = e.json;
        const i = e.json;
        switch (i.asset && i.asset.version) {
          case '2.0':
            return;
          case void 0:
          case 1:
          case '1.0':
            break;
          default:
            return;
        }
        if (!t.normalize) throw new Error('glTF v1 is not supported.');
        this._addAsset(i),
          this._convertTopLevelObjectsToArrays(i),
          (function (e, t) {
            const i = new ls(e),
              { json: s } = i;
            for (const e of s.images || []) {
              const t = i.removeObjectExtension(e, dt);
              t && Object.assign(e, t);
            }
            s.buffers && s.buffers[0] && delete s.buffers[0].uri, i.removeExtension(dt);
          })(e),
          this._convertObjectIdsToArrayIndices(i),
          this._updateObjects(i),
          this._updateMaterial(i),
          (e.buffers = i.buffers),
          (e.images = i.images);
      }
      _addAsset(e) {
        (e.asset = e.asset || {}),
          (e.asset.version = '2.0'),
          (e.asset.generator = e.asset.generator || 'Normalized to glTF 2.0 by loaders.gl');
      }
      _convertTopLevelObjectsToArrays(e) {
        for (const t in ys) this._convertTopLevelObjectToArray(e, t);
      }
      _convertTopLevelObjectToArray(e, t) {
        const i = e[t];
        if (i && !Array.isArray(i)) {
          e[t] = [];
          for (const s in i) {
            const r = i[s];
            r.id = r.id || s;
            const n = e[t].length;
            e[t].push(r), (this.idToIndexMap[t][s] = n);
          }
        }
      }
      _convertObjectIdsToArrayIndices(e) {
        for (const t in ys) this._convertIdsToIndices(e, t);
        'scene' in e && (e.scene = this._convertIdToIndex(e.scene, 'scene'));
        for (const t of e.textures) this._convertTextureIds(t);
        for (const t of e.meshes) this._convertMeshIds(t);
        for (const t of e.nodes) this._convertNodeIds(t);
        for (const t of e.scenes) this._convertSceneIds(t);
      }
      _convertTextureIds(e) {
        e.source && (e.source = this._convertIdToIndex(e.source, 'image'));
      }
      _convertMeshIds(e) {
        for (const t of e.primitives) {
          const { attributes: e, indices: i, material: s } = t;
          for (const t in e) e[t] = this._convertIdToIndex(e[t], 'accessor');
          i && (t.indices = this._convertIdToIndex(i, 'accessor')),
            s && (t.material = this._convertIdToIndex(s, 'material'));
        }
      }
      _convertNodeIds(e) {
        e.children && (e.children = e.children.map((e) => this._convertIdToIndex(e, 'node'))),
          e.meshes && (e.meshes = e.meshes.map((e) => this._convertIdToIndex(e, 'mesh')));
      }
      _convertSceneIds(e) {
        e.nodes && (e.nodes = e.nodes.map((e) => this._convertIdToIndex(e, 'node')));
      }
      _convertIdsToIndices(e, t) {
        e[t] || (e[t] = []);
        for (const i of e[t])
          for (const e in i) {
            const t = this._convertIdToIndex(i[e], e);
            i[e] = t;
          }
      }
      _convertIdToIndex(e, t) {
        const i = Ts[t];
        if (i in this.idToIndexMap) {
          const s = this.idToIndexMap[i][e];
          if (!Number.isFinite(s)) throw new Error(`gltf v1: failed to resolve ${t} with id ${e}`);
          return s;
        }
        return e;
      }
      _updateObjects(e) {
        for (const e of this.json.buffers) delete e.type;
      }
      _updateMaterial(e) {
        for (const t of e.materials) {
          t.pbrMetallicRoughness = {
            baseColorFactor: [1, 1, 1, 1],
            metallicFactor: 1,
            roughnessFactor: 1,
          };
          const i = t.values && t.values.tex,
            s = e.textures.findIndex((e) => e.id === i);
          -1 !== s && (t.pbrMetallicRoughness.baseColorTexture = { index: s });
        }
      }
    }
    class vs extends e.Object3D {
      constructor(t, i) {
        super(),
          (this.shadowNear = 10),
          (this.shadowFar = 1e3),
          (this.textureSize = 512),
          (this.epsilon = 0.01),
          (this.mapSizeScale = 1),
          (this.shadowRepaint = !0),
          (this.id = e.uuid()),
          (this.type = 'Light'),
          (this.color = e.Color.parse(t).toVector3()),
          (this.intensity = i);
      }
      setOptions(t, i) {
        'color' == t
          ? (this.color = e.Color.parse(i).toVector3())
          : 'intensity' == t
          ? (this.intensity = i)
          : console.log(`光源不支持该属性的修改 ${t}`);
      }
      setShadowOptions(e) {
        for (const t in e)
          switch (t) {
            case 'shadowFar':
              this.shadowFar = e[t];
              break;
            case 'shadowNear':
              this.shadowNear = e[t];
              break;
            case 'epsilon':
              this.epsilon = e[t];
              break;
            case 'mapSizeScale':
              this.mapSizeScale = e[t];
              break;
            case 'size':
              this.textureSize = e[t];
          }
      }
    }
    class bs {
      constructor(t) {
        (this.camera = t),
          (this.bias = 0),
          (this.radius = 1),
          (this.mapSize = new e.Vector2(512, 512)),
          (this.map = null),
          (this.matrix = new e.Matrix4()),
          (this._projScreenMatrix = new e.Matrix4()),
          (this._frustum = new i()),
          (this._frameExtents = new e.Vector2(1, 1)),
          (this._viewportCount = 1),
          (this._viewports = [new e.Vector4(0, 0, 1, 1)]);
      }
      getFrustum() {
        return this._frustum;
      }
      getViewportCount() {
        return this._viewportCount;
      }
      updateMatrices(e) {
        let t = this._projScreenMatrix;
        const i = this.camera,
          s = this.matrix,
          r = this._lookTarget,
          n = this._lightPositionWorld;
        n.setFromMatrixPosition(e.matrixWorld),
          i.position.copy(n),
          r.setFromMatrixPosition(e.target.matrixWorld),
          i.lookAt(r),
          i.updateMatrixWorld(),
          (t = i.projectionMatrix.clone().multiplyRight(i.matrixWorldInverse)),
          this._frustum.setFromMatrix(t),
          s.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
          s.multiplyRight(i.projectionMatrix),
          s.multiplyRight(i.matrixWorldInverse);
      }
      getViewport(e) {
        return this._viewports[e];
      }
    }
    class ws extends bs {
      constructor() {
        super(new o(10, 1, 0.5, 500)), (this.isDirectionalLightShadow = !0);
      }
      updateMatrices(e) {
        super.updateMatrices(e);
      }
    }
    class Cs extends vs {
      constructor(t, i) {
        super(t, i),
          (this.type = 'DirectionalLight'),
          (this.isDirectionalLight = !0),
          this.position.copy(e.DefaultUp),
          this.updateMatrix(),
          (this.target = new e.Object3D()),
          (this.shadow = new ws()),
          (this._lightPosition = new e.Vector3(0, 0, 0)),
          (this._targetPosition = new e.Vector3(0, 0, 0)),
          (this.lightDirection = new e.Vector3(0, 0, 0));
      }
      setPosition(t, i = new e.Vector3(0, 0, 0)) {
        (this._lightPosition = t),
          (this._targetPosition = i),
          (t = e.Vector3.unpack(t)),
          (i = e.Vector3.unpack(i)),
          (this.lightDirection = e.Vector3.normalize(
            e.Vector3.subtract(t, i, new e.Vector3()),
            new e.Vector3(),
          ));
      }
      getLightDirection() {
        return this.lightDirection;
      }
      serialize() {
        return {
          color: e.Vector3.pack(this.color, new Array(3)),
          intensity: this.intensity,
          lightPosition: this._lightPosition,
          targetPosition: this._targetPosition,
          type: this.type,
        };
      }
    }
    const Ss = Math.PI / 180,
      Es = 23.4397 * Ss;
    function Ps(e, t, i) {
      const s = Ss * -i,
        r = Ss * t,
        n = (function (e) {
          return (
            (function (e) {
              return e / 864e5 - 0.5 + 2440588;
            })(e) - 2451545
          );
        })(e),
        o = (function (e) {
          const t = (function (e) {
            const t = e;
            return (
              t +
              Ss * (1.9148 * Math.sin(t) + 0.02 * Math.sin(2 * t) + 3e-4 * Math.sin(3 * t)) +
              102.9372 * Ss +
              Math.PI
            );
          })(Ss * (357.5291 + 0.98560028 * e));
          return { declination: As(t, 0), rightAscension: Ms(t, 0) };
        })(n),
        a =
          (function (e, t) {
            return Ss * (280.147 + 360.9856235 * e) - t;
          })(n, s) - o.rightAscension;
      return { azimuth: Rs(a, r, o.declination), altitude: Is(a, r, o.declination) };
    }
    function Ms(e, t) {
      const i = e;
      return Math.atan2(Math.sin(i) * Math.cos(Es) - Math.tan(t) * Math.sin(Es), Math.cos(i));
    }
    function As(e, t) {
      const i = e;
      return Math.asin(Math.sin(t) * Math.cos(Es) + Math.cos(t) * Math.sin(Es) * Math.sin(i));
    }
    function Rs(e, t, i) {
      const s = e,
        r = t,
        n = i;
      return Math.atan2(Math.sin(s), Math.cos(s) * Math.sin(r) - Math.tan(n) * Math.cos(r));
    }
    function Is(e, t, i) {
      const s = e,
        r = t,
        n = i;
      return Math.asin(Math.sin(r) * Math.sin(n) + Math.cos(r) * Math.cos(n) * Math.cos(s));
    }
    function Os(e) {
      if (1 === e) return 0;
      if (2 === e) return 31;
      if (3 === e) return 59;
      if (4 === e) return 90;
      if (5 === e) return 120;
      if (6 === e) return 151;
      if (7 === e) return 181;
      if (8 === e) return 212;
      if (9 === e) return 243;
      if (10 === e) return 273;
      if (11 === e) return 304;
      if (12 === e) return 334;
      throw new Error('Error transMonth2Day Not Int!');
    }
    function Ls(t) {
      const i = new Date(t),
        s = Os(i.getMonth() + 1),
        r = [
          180 - 15 * (i.getHours() + i.getMinutes() / 60 - 8),
          23.45 * Math.sin((((360 * (s + i.getDate() - 80)) / 370) * Math.PI) / 180),
        ],
        n = e.Transforms.cartographicToCartesian3(new e.Vector3([r[0], r[1], 0]));
      return new e.Vector3(n);
    }
    class Ds extends Cs {
      constructor(e, t, i) {
        super(e, t),
          (this._cached = {}),
          (this._timestamp = null == i ? Date.now() : i),
          (this.type = 'SunLight');
      }
      set timestamp(e) {
        this._timestamp = e;
      }
      get timestamp() {
        return this._timestamp;
      }
      getSunPosition(e, t) {
        return Ps(this._timestamp, e, t);
      }
      getSunPositionWithCache(e, t) {
        if (this._cached.position) {
          if (
            this._timestamp !== this._cached.position.timestamp ||
            e !== this._cached.position.latitude ||
            t !== this._cached.position.longitude
          ) {
            const i = this.getSunPosition(e, t);
            this._cached.position = {
              timestamp: this._timestamp,
              latitude: e,
              longitude: t,
              azimuth: i.azimuth,
              altitude: i.altitude,
            };
          }
        } else {
          const i = this.getSunPosition(e, t);
          this._cached.position = {
            timestamp: this._timestamp,
            latitude: e,
            longitude: t,
            azimuth: i.azimuth,
            altitude: i.altitude,
          };
        }
        return { azimuth: this._cached.position.azimuth, altitude: this._cached.position.altitude };
      }
      getSunDirection(t, i) {
        return e.Vector3.normalize(
          new e.Vector3(
            (function (e, t, i) {
              const { azimuth: s, altitude: r } = Ps(e, t, i),
                n = s + Math.PI;
              return [-Math.sin(n), Math.cos(n), -Math.sin(r)];
            })(this.timestamp, t, i),
          ),
          new e.Vector3(),
        ).multiplyScalar(-1);
      }
      getSunDirectionWithCache(e, t) {
        return (
          (this._cached.direction &&
            this._timestamp === this._cached.direction.timestamp &&
            e === this._cached.direction.latitude &&
            t === this._cached.direction.longitude) ||
            (this._cached.direction = {
              timestamp: this._timestamp,
              latitude: e,
              longitude: t,
              direction: this.getSunDirection(e, t),
            }),
          this._cached.direction.direction
        );
      }
      getSunDirectionGlobalWithCache() {
        return (
          this._cached['g-direction']
            ? this._timestamp !== this._cached['g-direction'].timestamp &&
              (this._cached['g-direction'] = {
                timestamp: this._timestamp,
                direction: Ls(this._timestamp),
              })
            : (this._cached['g-direction'] = {
                timestamp: this._timestamp,
                direction: Ls(this._timestamp),
              }),
          this._cached['g-direction'].direction
        );
      }
      serialize() {
        return {
          color: e.Vector3.pack(this.color, new Array(3)),
          intensity: this.intensity,
          timeStamp: this.timestamp,
          type: this.type,
        };
      }
    }
    class Bs {
      constructor(t) {
        const i = (t = e.defaultValue(t, e.defaultValue.EMPTY_OBJECT)).context.gl,
          s = e.ContextLimits.maximumRenderbufferSize,
          r = e.defaultValue(t.format, e.RenderbufferFormat.RGBA4),
          n = e.defined(t.width) ? t.width : i.drawingBufferWidth,
          o = e.defined(t.height) ? t.height : i.drawingBufferHeight;
        if (!e.RenderbufferFormat.validate(r)) throw new Error('Invalid format.');
        if (n > s)
          throw new Error(
            `宽度必须小于等于 renderbuffer size (${s}).  Check maximumRenderbufferSize.`,
          );
        if (o > s)
          throw new Error(
            `高度必须小于等于 renderbuffer size (${s}).  Check maximumRenderbufferSize.`,
          );
        (this._gl = i),
          (this._format = r),
          (this._width = n),
          (this._height = o),
          (this._renderbuffer = this._gl.createRenderbuffer()),
          i.bindRenderbuffer(i.RENDERBUFFER, this._renderbuffer),
          i.renderbufferStorage(i.RENDERBUFFER, r, n, o),
          i.bindRenderbuffer(i.RENDERBUFFER, null);
      }
      get format() {
        return this._format;
      }
      get width() {
        return this._width;
      }
      get height() {
        return this._height;
      }
      _getRenderbuffer() {
        return this._renderbuffer;
      }
      isDestroyed() {
        return !1;
      }
      destroy() {
        return this._gl.deleteRenderbuffer(this._renderbuffer), e.destroyObject(this);
      }
    }
    class Vs {
      constructor(t) {
        (this.passType = t || e.RenderPassConsts.REAL_RENDER_PASS),
          (this._enableLight = !1),
          (this._lights = []),
          (this._shadowModel = e.ShadowsType.ShadowMapping),
          (this.overrideMaterial = void 0),
          (this._shadows = !1);
      }
      set shadowModel(e) {
        this._shadowModel = e;
      }
      setShadows(e) {
        this._shadows = e;
      }
      set passType(t) {
        e.defined(t) && (this._type = t);
      }
      get passType() {
        return this._type;
      }
      set framebuffer(e) {
        this._framebuffer = e;
      }
      get framebuffer() {
        return this._framebuffer;
      }
      get sunLight() {
        return this._sunLight;
      }
      set lights(e) {
        this._lights = e;
      }
      get lights() {
        return this._lights;
      }
      set camera(e) {
        this._camera = e;
      }
      get camera() {
        return this._camera;
      }
      get sameLayerFrame() {
        return this._sameLayerFrame;
      }
      set sameLayerFrame(e) {
        this._sameLayerFrame = e;
      }
      update(e) {
        e.hasOwnProperty('framebuffer') && (this.framebuffer = e.framebuffer),
          e.hasOwnProperty('lights') && (this.lights = e.lights),
          e.hasOwnProperty('camera') && (this.camera = e.camera),
          e.hasOwnProperty('passType') && (this.passType = e.passType),
          e.hasOwnProperty('shadowCamera') && (this.shadowCamera = e.shadowCamera);
      }
      bindFramebuffer(e) {
        e.bindFramebuffer.set(this.framebuffer ? this.framebuffer.framebuffer : null);
      }
      applyFrameState(e) {
        e.bindFramebuffer.set(this.framebuffer.framebuffer);
      }
      lightSerialize() {
        const t = [];
        for (let e = 0; e < this.lights.length; e++) t.push(this.lights[e].serialize());
        return (
          e.defined(this.sunLight) && t.push(this.sunLight.serialize()),
          t.push({ enableLight: this._enableLight }),
          t
        );
      }
      destroy() {
        this._framebuffer && this._framebuffer.destroy();
      }
    }
    class Ns {
      constructor(e, t, i, s, r) {
        this.context = e;
        const n = e.gl;
        (this.dynamicDraw = Boolean(i)),
          (this.type = s),
          this.unbindVAO(),
          r
            ? (this.buffer = r)
            : ((this.buffer = n.createBuffer()),
              e.bindElementBuffer.set(this.buffer),
              n.bufferData(
                n.ELEMENT_ARRAY_BUFFER,
                t.arrayBuffer ? t.arrayBuffer : t,
                this.dynamicDraw ? n.DYNAMIC_DRAW : n.STATIC_DRAW,
              ));
      }
      getBuffer() {
        return this.buffer;
      }
      unbindVAO() {
        this.context.extVertexArrayObject && this.context.bindVertexArrayOES.set(null);
      }
      bind() {
        this.context.bindElementBuffer.set(this.buffer);
      }
      updateData(e) {
        const t = this.context.gl,
          i = e.arrayBuffer ? e.arrayBuffer : e;
        this.unbindVAO(),
          this.bind(),
          t.bufferData(
            t.ELEMENT_ARRAY_BUFFER,
            i,
            this.dynamicDraw ? t.DYNAMIC_DRAW : t.STATIC_DRAW,
          );
      }
      destroy() {
        this.context &&
          this.context.gl &&
          this.buffer &&
          (this.context.gl.deleteBuffer(this.buffer),
          (this.buffer = null),
          (this.context = null),
          delete this.buffer);
      }
    }
    class ks {
      constructor() {}
      load(t) {
        const { map: i, texUrl: s } = t,
          r = i.painter.textureResourceManager,
          n = r.getTextureByName(s);
        if (n) return n;
        const o = new e.Texture(t);
        return o.load(s, t.loaded), r.addTexture(s, o), o;
      }
    }
    class Fs extends e.Material {
      constructor(t = {}) {
        super(t);
        const {
          type: i,
          pbrMetallicRoughness: s,
          emissiveTexture: r,
          emissiveFactor: n,
          occlusionTexture: o,
          normalTexture: a,
          brdfTexture: l,
          specularGlossinessTexture: h,
          color: c,
          metalness: _,
          roughness: u,
          hasNormal: d,
          hasTangent: m,
          hasVertexColor: p,
          extensions: f,
          hasMorph: g,
          hasMorphNormal: y,
          hasMorphTangent: T,
          isInstance: x,
          useStencilTest: v,
          doubleSided: b,
          clippingPlanes: w,
          skins: C,
          useIBL: S,
        } = t;
        if (
          ((this.doubleSided = b),
          (this.type = i || 'gltfPBR'),
          (this.useStencilTest = v || !1),
          (this.isInstance = x),
          (this._emissiveTexture = r),
          (this._occlusionTexture = o),
          (this._hasNormal = e.defaultValue(d, !1)),
          (this._hasTangent = m),
          (this._hasVertexColor = p),
          (this._opacity = 1),
          (this._normalTexture = a),
          a && a instanceof e.Texture && (this._normalTexture = this.#o(a)),
          (this._baseColorTexture = s?.baseColorTexture),
          t.baseColorTexture &&
            t.baseColorTexture instanceof e.Texture &&
            (this._baseColorTexture = this.#o(t.baseColorTexture)),
          (this._brdfTexture = l),
          (this._specularGlossinessTexture = h),
          (this._metallicRoughnessTexture = s?.metallicRoughnessTexture),
          t.metallicRoughnessTexture &&
            t.metallicRoughnessTexture instanceof e.Texture &&
            (this._metallicRoughnessTexture = this.#o(t.metallicRoughnessTexture)),
          (this._baseColorFactor = s?.baseColorFactor
            ? e.Color.parse(s?.baseColorFactor).toVector4()
            : new e.Vector4([1, 1, 1, 1])),
          (this._metallicFactor = e.defaultValue(s?.metallicFactor, 0.3)),
          (this._roughnessFactor = e.defaultValue(s?.roughnessFactor, 0.35)),
          c)
        ) {
          this.isForGeometry = !0;
          const t = e.Color.parse(c);
          this._baseColorFactor.set(t.r, t.g, t.b, t.a);
        }
        this.#a(_) && (this._metallicFactor = _),
          this.#a(u) && (this._roughnessFactor = u),
          (this._emissiveFactor = new e.Vector3(n || [1, 1, 1])),
          (this._specialLight = new e.Vector4([1.01, 1.9, 1.01, 0])),
          (this._lightExposure = 1),
          (this._hasMorph = g),
          (this._hasMorphNormal = y),
          (this._hasMorphTangent = T),
          (this._useSkins = e.defaultValue(C, !1)),
          (this._useIBL = e.defaultValue(S, !1)),
          (this._usePBR = !0),
          (this._specialcolor = [
            new e.Vector4([1, 0, 0, 1]),
            new e.Vector4([1, 1, 0, 1]),
            new e.Vector4([1, 0, 1, 1]),
            new e.Vector4([0, 1, 1, 1]),
          ]),
          (this._lightDirection = new e.Vector3([1, 1, 0.7]).normalize()),
          (this._lightColor = new e.Vector4([1, 1, 1, 1])),
          (this._pbrPer = new e.Vector4([1.01, 1.9, 1.01, 0])),
          this.#a(t.IBLPercent) && (this._pbrPer.x = t.IBLPercent),
          this.#a(t.diffusePercent) && (this._pbrPer.y = t.diffusePercent),
          this.#a(t.specularPercent) && (this._pbrPer.z = t.specularPercent),
          (this._satExp = new e.Vector2([
            this._metallicFactor && this._roughnessFactor ? 1.3 : 2,
            this.layer?.lightExposure ? this.layer.lightExposure : 1,
          ])),
          (this._khrValues = new e.Vector4([0, 0, 0, 0])),
          (this.selectionDepth = -1),
          (this.clippingPlanes = w),
          (this.backCulling = !1),
          this.#l(),
          this.#h(f);
      }
      #a(e) {
        return null != e && null != e && ((this.isForGeometry = !0), !0);
      }
      #o(e) {
        this.isForGeometry = !0;
        const t = { texture: { _texture: e, sampler: { parameters: {} } } };
        return (
          e.wrapS && (t.texture.sampler.wrapS = e.wrapS),
          e.wrapT && (t.texture.sampler.wrapT = e.wrapT),
          e.minFilter && (t.texture.sampler.minFilter = e.minFilter),
          e.magFilter && (t.texture.sampler.magFilter = e.magFilter),
          t
        );
      }
      updateProperty(t) {
        t.baseColorTexture &&
          t.baseColorTexture instanceof e.Texture &&
          (this._baseColorTexture = this.#o(t.baseColorTexture));
      }
      updateTexture(t) {
        const i = t.texType,
          s = e.defined(t.opacity) ? t.opacity : 1;
        let r, n;
        switch (i) {
          case 'Color':
            (r = e.Color.parse(t.colorTexture)), this._baseColorFactor.set(r.r, r.g, r.b, r.a * s);
            break;
          case 'Image':
            (n = new ks().load({ map: t.map, texUrl: t.texUrl })),
              (this._opacity = s),
              (this._baseColorTexture = this.#o(n));
        }
      }
      #c(t) {
        if (this._uniformCreated) return;
        this._uniformCreated = !0;
        for (let e = 0; e < this._specialcolor.length; e++)
          this._uniforms.set(`u_specialcolor[${e}].color`, () => this._specialcolor[e]);
        this._uniforms.set('u_BaseColorFactor', () => this._baseColorFactor),
          this._uniforms.set('u_HAS_BASECOLORMAP', () => !!this._baseColorTexture),
          this._uniforms.set('u_Opacity', () => this._opacity),
          this._uniforms.set('u_useKhr', () => !1),
          this._uniforms.set('u_khrValues', () => this._khrValues);
        const i = e.spec.phongLightConfig.Ambient.default,
          s = e.spec.phongLightConfig.Diffuse.default,
          r = e.spec.phongLightConfig.SpecularColor.default,
          n = e.spec.phongLightConfig.Shininess.default;
        this._uniforms.set('u_LightMaterial', {
          Ambient: () => new e.Vector3(i, i, i),
          Diffuse: () => new e.Vector3(s, s, s),
          SpecularColor: () => new e.Vector3(r, r, r),
          Shininess: () => n,
        }),
          this._baseColorTexture
            ? this._uniforms.set('u_BaseColorSampler', () => this.#_(this._baseColorTexture))
            : this._uniforms.set('u_reflect', () => 0),
          this._uniforms.set(
            'u_MetallicRoughnessValues',
            () => new e.Vector2(this._metallicFactor, this._roughnessFactor),
          ),
          this._uniforms.set('u_satExp', () => this._satExp),
          this._uniforms.set('u_HAS_METALROUGHNESSMAP', () => !!this._metallicRoughnessTexture),
          this._metallicRoughnessTexture &&
            this._uniforms.set('u_MetallicRoughnessSampler', () =>
              this.#_(this._metallicRoughnessTexture),
            ),
          this._uniforms.set('u_HAS_NORMALS', () => this._hasNormal),
          this._uniforms.set('u_HAS_TANGENTS', () => this._hasTangent),
          this._uniforms.set('u_HAS_NORMALMAP', () => !!this._normalTexture),
          this._uniforms.set('u_NormalScale', () => 1),
          this._normalTexture &&
            this._uniforms.set('u_NormalSampler', () => this.#_(this._normalTexture)),
          this._uniforms.set('u_HAS_OCCLUSIONMAP', () => !!this._occlusionTexture),
          this._occlusionTexture &&
            (this._uniforms.set('u_OcclusionSampler', () => this.#_(this._occlusionTexture)),
            this._uniforms.set('u_OcclusionStrength', () => 1)),
          this._uniforms.set('u_HAS_EMISSIVEMAP', () => !!this._emissiveTexture),
          this._emissiveTexture &&
            this._uniforms.set('u_EmissiveSampler', () => this.#_(this._emissiveTexture)),
          this._uniforms.set('u_EmissiveFactor', () => this._emissiveFactor),
          this._uniforms.set('u_brdfLUT', () => {
            const i = t.iBLTextures.mBrdfTex;
            return i
              ? ((i.sampler = {
                  minificationFilter: e.WebGLConstants.LINEAR,
                  magnificationFilter: e.WebGLConstants.LINEAR,
                  wrapS: e.WebGLConstants.CLAMP_TO_EDGE,
                  wrapT: e.WebGLConstants.CLAMP_TO_EDGE,
                  continueBindTextureOnExit: !0,
                }),
                i)
              : t.context.defaultTexture;
          }),
          this._uniforms.set('u_DiffuseEnvSampler', () => {
            const e = t.iBLTextures.mDiffuseEnvTex;
            return e ? (e.bind(), e) : null;
          }),
          this._uniforms.set('u_SpecularEnvSampler', () => {
            const e = t.iBLTextures.mSpecularEnvTex;
            return e ? (e.bind(), e) : null;
          }),
          this._uniforms.set('u_sunLightDirectionSpecial', () => this._lightDirection),
          this._uniforms.set('u_SunLightColor', () => this._lightColor),
          this._uniforms.set('u_pbrPer', () => this._pbrPer),
          this._uniforms.set('u_HasSkinning', () => this._useSkins),
          this._uniforms.set('u_Reflectivity', () => 1),
          this._uniforms.set('u_Shininess', () => 30);
      }
      #h() {}
      #_(t) {
        const i = t.texture._texture,
          s = t.texture.sampler;
        return (
          (t.texture.source = void 0),
          (i.sampler = {
            minificationFilter:
              (s.parameters && s?.parameters[e.WebGLConstants.TEXTURE_MIN_FILTER]) ||
              s?.minFilter ||
              e.WebGLConstants.LINEAR_MIPMAP_NEAREST,
            magnificationFilter:
              (s.parameters && s?.parameters[e.WebGLConstants.TEXTURE_MAG_FILTER]) ||
              s?.magFilter ||
              e.WebGLConstants.LINEAR,
            wrapS:
              (s.parameters && s?.parameters[e.WebGLConstants.TEXTURE_WRAP_S]) ||
              s?.wrapS ||
              e.WebGLConstants.REPEAT,
            wrapT:
              (s.parameters && s?.parameters[e.WebGLConstants.TEXTURE_WRAP_T]) ||
              s?.wrapT ||
              e.WebGLConstants.REPEAT,
          }),
          i
        );
      }
      enableIBL() {
        this._useIBL = !0;
      }
      disableIBL() {
        this._useIBL = !1;
      }
      set programId(e) {
        this.type = e;
      }
      get programId() {
        return this.type;
      }
      get specialLight() {
        return this._specialLight;
      }
      set specialLight(e) {
        this._specialLight = e;
      }
      get lightExposure() {
        return this._lightExposure;
      }
      set lightExposure(e) {
        this._lightExposure = e;
      }
      get baseColor() {
        return this._baseColorFactor;
      }
      set baseColor(e) {
        this._baseColorFactor = e;
      }
      get metallic() {
        return this._metallicFactor;
      }
      set metallic(e) {
        this._metallicFactor = e;
      }
      get emissive() {
        return this._emissiveFactor;
      }
      set emissive(e) {
        this._emissiveFactor = e;
      }
      get brdfTexture() {
        return this._brdfTexture;
      }
      set brdfTexture(e) {
        this._brdfTexture = e;
      }
      get diffuseTexture() {
        return this._diffuseTexture;
      }
      set diffuseTexture(e) {
        this._diffuseTexture = e;
      }
      get specularTexture() {
        return this._specularTexture;
      }
      set specularTexture(e) {
        this._specularTexture = e;
      }
      update(t, i, s = {}) {
        if ((this.#c(t), !t)) throw new Error('pbr material 更新失败，painter为空');
        super.update(t, i, s),
          (this.defines = this.#u()),
          s.hasMixedContent
            ? (this.selectionDepth < 0 ||
                s?.primitive?.owner?.extra?.selectionDepth !== this.#d()) &&
              this.#m(s.primitive.owner.extra.selectionDepth)
            : this.#p(s.hasMixedContent, s?.primitive?.owner?.minemap3DType, s),
          this.#f(t, i);
        const { primitive: r } = s,
          n = new e.Matrix4(r.matrixWorld).invert(new e.Matrix4());
        this._uniforms.set('u_cameraLocalPosition', () => {
          const t = new e.Vector4(i.camera.position.x, i.camera.position.y, i.camera.position.z, 1);
          return t.transform(n), new e.Vector3(t.x, t.y, t.z);
        });
      }
      #l() {
        const e = {};
        this.isForGeometry && this._useIBL && (e.USE_IBL = !0),
          this._usePBR && (e.USE_PBR = !0),
          this._hasVertexColor && (e.VERTEX_COLOR = !0),
          this._baseColorTexture && (e.HAS_BASECOLORMAP = !0),
          this._normalTexture && (e.HAS_NORMALMAP = !0),
          this._emissiveTexture && (e.HAS_EMISSIVEMAP = !0),
          this._metallicRoughnessTexture && (e.HAS_METALROUGHNESSMAP = !0),
          this._occlusionTexture && (e.HAS_OCCLUSIONMAP = !0),
          this._hasMorph &&
            ((e.USE_MORPHTARGETS = !0),
            this._hasMorphNormal && (e.USE_MORPHNORMALS = !0),
            this._hasMorphTangent && (e.USE_MORPHTANGENTS = !0)),
          this.isInstance && (e.INSTANCE_MATRIX = !0),
          (this.defines = e);
      }
      #u() {
        const t = {};
        if (
          (e.defined(this._usePickColorTexture) &&
            (t.USE_PICKINGTEXTURES = this._usePickColorTexture),
          e.defined(this._isOneDimensionBatchTexture) &&
            ((t.ONE_DIMENSION_BATCH_TEXTURE = this._isOneDimensionBatchTexture),
            (t.TWO_DIMENSION_BATCH_TEXTURE = !this._isOneDimensionBatchTexture)),
          (t.MODEL_INSTANCE_BATCH_TEXTURE = this._isModelInstanceTexture),
          this.isForGeometry && this._useIBL && (t.USE_IBL = !0),
          this.clippingPlanes && this.clippingPlanes.enabled && 0 !== this.clippingPlanes.length)
        ) {
          t.HAS_CLIPPING_PLANES = !0;
          const i = e.ClippingPlaneCollection.getTextureResolution(this.clippingPlanes);
          (t.CLIPPING_PLANES_LENGTH = this.clippingPlanes.length),
            (t.CLIPPING_PLANES_TEXTURE_WIDTH = i.x),
            (t.CLIPPING_PLANES_TEXTURE_HEIGHT = i.y),
            (t.UNION_CLIPPING_REGIONS = !!this.clippingPlanes._unionClippingRegions);
        } else (t.HAS_CLIPPING_PLANES = !1), (t.CLIPPING_PLANES_LENGTH = 0), (t.CLIPPING_PLANES_TEXTURE_WIDTH = 1), (t.CLIPPING_PLANES_TEXTURE_HEIGHT = 1);
        return t;
      }
      #m(t) {
        this.renderState = {
          depthTest: { enabled: !0, func: e.WebGLConstants.LESS },
          cull: { enabled: !1, face: e.WebGLConstants.FRONT },
          depthMask: !0,
          stencilMask: e.WebGLConstants.CESIUM_3D_TILE_MASK | e.WebGLConstants.SKIP_LOD_MASK,
          stencilTest: {
            enabled: !0,
            mask: e.WebGLConstants.SKIP_LOD_MASK,
            reference:
              e.WebGLConstants.CESIUM_3D_TILE_MASK | (t << e.WebGLConstants.SKIP_LOD_BIT_SHIFT),
            frontFunction: e.WebGLConstants.GEQUAL,
            backFunction: e.WebGLConstants.GEQUAL,
            frontOperation: {
              fail: e.WebGLConstants.KEEP,
              zFail: e.WebGLConstants.KEEP,
              zPass: e.WebGLConstants.REPLACE,
            },
            backOperation: {
              fail: e.WebGLConstants.KEEP,
              zFail: e.WebGLConstants.KEEP,
              zPass: e.WebGLConstants.REPLACE,
            },
          },
        };
      }
      #p(t, i, s) {
        if (this.needPreRender) {
          let t = !0;
          (-1 != s.primitive.owner.tileID.indexOf('top') || s.primitive.owner.extra.markAsRoot) &&
            (t = !1),
            (this.renderState = {
              cull: { enabled: !0, face: e.WebGLConstants.BACK },
              depthTest: { enabled: t, func: e.WebGLConstants.LEQUAL },
              colorMask: { red: !0, green: !0, blue: !0, alpha: !0 },
              stencilTest: {
                enabled: !0,
                frontFunction: e.WebGLConstants.ALWAYS,
                frontOperation: {
                  fail: e.WebGLConstants.KEEP,
                  zFail: e.WebGLConstants.KEEP,
                  zPass: e.WebGLConstants.REPLACE,
                },
                backFunction: e.WebGLConstants.ALWAYS,
                backOperation: {
                  fail: e.WebGLConstants.KEEP,
                  zFail: e.WebGLConstants.KEEP,
                  zPass: e.WebGLConstants.REPLACE,
                },
                reference: e.WebGLConstants.CESIUM_3D_TILE_MASK - s?.primitive?.owner?.extra?.depth,
                mask: 255,
              },
              stencilMask: 255,
            });
        } else this.needTilesNextRender ? (this.renderState = { cull: { enabled: !0, face: e.WebGLConstants.BACK }, depthTest: { enabled: !0, func: e.WebGLConstants.LEQUAL }, polygonOffset: { enabled: !1, factor: 5, units: 5 }, stencilTest: { enabled: !0, mask: 255, reference: e.WebGLConstants.CESIUM_3D_TILE_MASK, frontFunction: e.WebGLConstants.GEQUAL, backFunction: e.WebGLConstants.GEQUAL, frontOperation: { fail: e.WebGLConstants.KEEP, zFail: e.WebGLConstants.KEEP, zPass: e.WebGLConstants.REPLACE }, backOperation: { fail: e.WebGLConstants.KEEP, zFail: e.WebGLConstants.KEEP, zPass: e.WebGLConstants.REPLACE } }, stencilMask: 255 }) : t || '3d-model' == i || null == i || (this.renderState = { cull: { enabled: this.backCulling, face: e.WebGLConstants.BACK }, depthTest: { enabled: !0, func: e.WebGLConstants.LEQUAL }, polygonOffset: { enabled: !1, factor: 5, units: 5 }, stencilTest: { enabled: !1, mask: e.WebGLConstants.SKIP_LOD_MASK, reference: e.WebGLConstants.CESIUM_3D_TILE_MASK, frontFunction: e.WebGLConstants.ALWAYS, backFunction: e.WebGLConstants.ALWAYS, frontOperation: { fail: e.WebGLConstants.KEEP, zFail: e.WebGLConstants.KEEP, zPass: e.WebGLConstants.REPLACE }, backOperation: { fail: e.WebGLConstants.KEEP, zFail: e.WebGLConstants.KEEP, zPass: e.WebGLConstants.REPLACE } } });
        this.doubleSided &&
          this.renderState.cull?.enabled &&
          (this.renderState.cull = e.renderStateEnum.disableCull);
      }
      #d() {
        return (
          ((this.renderState?.stencilTest?.reference || 0) & e.WebGLConstants.SKIP_LOD_MASK) >>>
          e.WebGLConstants.SKIP_LOD_BIT_SHIFT
        );
      }
      #f(t, i) {
        if (this.clippingPlanes && this.clippingPlanes.enabled) {
          this.clippingPlanes.update(t, i),
            this._uniforms.set(
              'u_model_clippingPlanesEdgeStyle',
              () =>
                new e.Vector4(
                  this.clippingPlanes.edgeColor.r,
                  this.clippingPlanes.edgeColor.g,
                  this.clippingPlanes.edgeColor.b,
                  this.clippingPlanes.edgeWidth,
                ),
            ),
            this._uniforms.set('u_model_clippingPlanes', () => this.clippingPlanes.texture);
          let s = e.Matrix4.multiply(
            new e.Matrix4(),
            i.camera.matrixWorldInverse,
            this.clippingPlanes.modelMatrix,
          );
          (s = e.Matrix4.inverseTranspose(s, new e.Matrix4())),
            this._uniforms.set('u_model_clippingPlanesMatrix', () => s);
          const r = {
              x: t.context.viewport.current.x,
              y: t.context.viewport.current.y,
              width: t.context.viewport.current.width,
              height: t.context.viewport.current.height,
            },
            n = new e.Matrix4();
          e.Matrix4.computeViewportTransformation(r, 0, 1, n),
            this._uniforms.set('u_ViewportTransformation', () => n),
            this._uniforms.set('u_InverseProjection', () => i.camera.projectionMatrixInverse);
        }
      }
      serialize() {
        const t = {
          metalness: this._metallicFactor,
          roughness: this._roughnessFactor,
          hasNormal: this._hasNormal,
          diffusePercent: this._pbrPer.y,
          specularPercent: this._pbrPer.z,
          IBLPercent: this._pbrPer.x,
          type: this.type,
        };
        return (
          e.defined(this._baseColorTexture) &&
            (this._baseColorTexture instanceof e.Texture
              ? (t.baseColorTextureUrl = this._baseColorTexture.serialize())
              : e.defined(this._baseColorTexture.texture) &&
                this._baseColorTexture.texture instanceof e.Texture &&
                (t.baseColorTextureUrl = this._baseColorTexture.texture.serialize())),
          e.defined(this._normalTexture) &&
            (this._normalTexture instanceof e.Texture
              ? (t.normalTextureUrl = this._normalTexture.serialize())
              : e.defined(this._normalTexture.texture) &&
                this._normalTexture.texture instanceof e.Texture &&
                (t.normalTextureUrl = this._normalTexture.texture.serialize())),
          e.defined(this._metallicRoughnessTexture) &&
            (this._metallicRoughnessTexture instanceof e.Texture
              ? (t.metallicRoughnessTextureUrl = this._metallicRoughnessTexture.serialize())
              : e.defined(this._metallicRoughnessTexture.texture) &&
                this._metallicRoughnessTexture.texture instanceof e.Texture &&
                (t.metallicRoughnessTextureUrl =
                  this._metallicRoughnessTexture.texture.serialize())),
          e.defined(this._baseColorFactor) &&
            (t.color = e.Vector4.pack(this._baseColorFactor, new Array(4))),
          t
        );
      }
      destroy() {
        const e = this._baseColorTexture?.texture?._texture?.context?.painter;
        (this._uniforms = void 0),
          (this.type = void 0),
          (this.isInstance = void 0),
          this._emissiveTexture &&
            e?.textureResourceManager.removeTexture(this._emissiveTexture.texture._texture.name),
          (this._emissiveTexture = void 0),
          this._occlusionTexture &&
            e?.textureResourceManager.removeTexture(this._occlusionTexture.texture._texture.name),
          (this._occlusionTexture = void 0),
          (this._hasNormal = void 0),
          (this._hasTangent = void 0),
          (this._hasVertexColor = void 0),
          this._normalTexture &&
            e?.textureResourceManager.removeTexture(this._normalTexture.texture._texture.name),
          (this._normalTexture = void 0),
          this._baseColorTexture &&
            e?.textureResourceManager.removeTexture(this._baseColorTexture.texture._texture.name),
          (this._baseColorTexture = void 0),
          (this._brdfTexture = void 0),
          (this._diffuseTexture = void 0),
          (this._specularGlossinessTexture = void 0),
          (this._metallicRoughnessTexture = void 0),
          (this._baseColorFactor = void 0),
          (this._metallicFactor = void 0),
          (this._roughnessFactor = void 0),
          (this._emissiveFactor = void 0),
          (this._specialLight = void 0),
          (this._lightExposure = void 0),
          (this._hasMorph = void 0),
          (this._hasMorphNormal = void 0),
          (this._hasMorphTangent = void 0),
          (this._specialcolor = void 0),
          (this._lightDirection = void 0),
          (this._lightColor = void 0),
          (this._pbrPer = void 0),
          (this.highSat = void 0),
          (this.lightExp = void 0),
          (this._satExp = void 0),
          (this._khrValues = void 0);
      }
    }
    const Gs = {
      nextPowerOfTwo(e) {
        if ('number' != typeof e || e < 0 || e > 2147483648)
          throw new Error('A number between 0 and 2^31 is required.');
        return --e, (e |= e >> 1), (e |= e >> 2), (e |= e >> 4), (e |= e >> 8), (e |= e >> 16), ++e;
      },
      generateImage(t) {
        const i = e.window.document.createElement('canvas');
        return (
          (i.width = Gs.nextPowerOfTwo(t.width)),
          (i.height = Gs.nextPowerOfTwo(t.height)),
          i.getContext('2d').drawImage(t, 0, 0, t.width, t.height, 0, 0, i.width, i.height),
          i
        );
      },
      resize(t, i, s) {
        const r = e.window.document.createElement('canvas');
        return (
          (r.width = i),
          (r.height = s),
          r.getContext('2d').drawImage(t, 0, 0, t.width, t.height, 0, 0, i, s),
          r
        );
      },
      isPowerOfTwo(e) {
        if ('number' != typeof e || e < 0 || e > 4294967295)
          throw new Error('A number between 0 and (2^32)-1 is required.');
        return 0 !== e && 0 == (e & (e - 1));
      },
    };
    function Us(e) {
      const t = { hasMorph: !1, hasMorphNormal: !1, hasMorphTangent: !1 };
      if (e.targets) {
        t.hasMorph = !0;
        const i = e.targets[0];
        i.NORMAL && (t.hasMorphNormal = !0), i.TANGENT && (t.hasMorphTangent = !0);
      }
      return t;
    }
    class zs {
      constructor(e) {
        (this.options = Object.assign({}, { closed: !1, state: 1 }, e)), (this._value = null);
      }
      set state(e) {
        this.options.state = e;
      }
      get state() {
        return this.options.state;
      }
      get times() {
        return this.options.times;
      }
      get controlPoint() {
        return this.options.controlPoint;
      }
      get points() {
        return this.options.points;
      }
      get weights() {
        return this.options.weights;
      }
      get interpolation() {
        return this.options.interpolation;
      }
      get node() {
        return this.options.node;
      }
      get nodeId() {
        return this.options.node.id;
      }
      get path() {
        return this.options.path;
      }
      get closed() {
        return this.options.closed;
      }
      start() {
        this._stime = Date.now();
      }
      close() {
        this.options.closed = !0;
      }
      open() {
        this.options.closed = !1;
      }
      get value() {
        return this._value;
      }
      update(e) {
        this._curtime = e;
      }
      getCurrentTick(t) {
        (t = t || Date.now()), this._stime || (this._stime = Date.now());
        const i = this.options.times;
        let s = 0;
        const r = ((t - this._stime) / 1e3) % i[i.length - 1];
        for (let t = 0; t < i.length - 1; t++)
          if (r >= i[t] && r <= i[t + 1])
            return (
              (s = (r - i[t]) / (i[t + 1] - i[t])),
              'LINEAR' === this.interpolation
                ? { ratio: s, index: t }
                : 'STEP' === this.interpolation
                ? { ratio: 1, index: t }
                : 'CUBICSPLINE' === this.interpolation
                ? { ratio: e.easeCubicInOut(s), index: t }
                : { ratio: s, index: t }
            );
        return { ratio: 1, index: i.length - 2 };
      }
      evaluate() {
        return this.options.closed ? ((this._value = null), null) : ((this._value = []), []);
      }
    }
    class Hs extends zs {
      constructor(e) {
        super(e);
      }
      evaluate() {
        return this.options.closed ? null : this.controlPoint;
      }
    }
    class Ws extends zs {
      constructor(e) {
        super(e), (this.transformationIndex = 'translation' === e.path ? 0 : 2);
      }
      evaluate(t) {
        if (this.options.closed) return null;
        const i = this.getCurrentTick(t),
          s = this.points,
          r = new e.Matrix4();
        if ('scale' === this.path)
          if (-1 === i.index) r.scale(new e.Vector3(s));
          else {
            const t = new e.Vector3(s.slice(3 * i.index, 3 * i.index + 3));
            t.lerp(s.slice(3 * (i.index + 1), 3 * (i.index + 1) + 3), i.ratio), r.scale(t);
          }
        else if ('translation' === this.path)
          if (-1 === i.index) r.translate(new e.Vector3(s));
          else {
            const t = new e.Vector3(s.slice(3 * i.index, 3 * i.index + 3));
            t.lerp(s.slice(3 * (i.index + 1), 3 * (i.index + 1) + 3), i.ratio), r.translate(t);
          }
        this.options.originNodeMatrix &&
          r.multiplyLeft(this.options.originNodeMatrix.getTranslationMatrix4()),
          (this._value = r);
      }
    }
    class js extends zs {
      constructor(e) {
        super(e), (this.transformationIndex = 1);
      }
      evaluate(t) {
        if (this.options.closed) return null;
        const i = this.getCurrentTick(t),
          s = this.points,
          r = new e.Matrix4(),
          n = new e.Quaternion(s.slice(4 * i.index, 4 * i.index + 4));
        if (
          (n.slerp(n, s.slice(4 * i.index + 4, 4 * i.index + 8), i.ratio),
          r.fromQuaternion(n),
          this.options.originNodeMatrix)
        ) {
          const e = this.options.originNodeMatrix.getRotation();
          r.multiplyLeft(e);
        }
        this._value = r;
      }
    }
    class qs extends zs {
      constructor(e) {
        super(e);
      }
      evaluate(e) {
        if (this.options.closed) return null;
        const t = this.getCurrentTick(e),
          i = this.weights,
          s = i.length / this.times.length,
          r = [];
        for (let e = 0; e < s; e++)
          r.push(i[t.index * s + e] * (1 - t.ratio) + i[t.index * s + e] * t.ratio);
        return (this._value = r), 0;
      }
    }
    var Xs = function (e) {
      for (const t of Object.getOwnPropertyNames(e.constructor.prototype)) {
        const i = e[t];
        'constructor' !== t && 'function' == typeof i && (e[t] = i.bind(e));
      }
      return e;
    };
    class Zs extends e.Evented {
      constructor(t) {
        super(),
          (this.options = Object.assign(
            { animations: [], loop: 0, delay: 0, multiplier: 1, reverse: !1 },
            t,
          )),
          delete this.options.animations,
          (this.isRunning = e.defaultValue(t.isRunning, !0)),
          (this.id = t.id),
          (this.name = t.name),
          (this.gltf = t.gltf),
          (this.groupsOfNode = {}),
          (this._defaultAnimations = {}),
          this.parseAnimation(t.animations),
          Xs(this);
      }
      parseAnimation(e) {
        if (!this.parsed) {
          for (let t = 0; t < e.length; t++) this.addAnimation(e[t], t);
          this.nodeTransformationSort();
        }
      }
      nodeTransformationSort() {
        for (const e in this.groupsOfNode)
          this.groupsOfNode[e].sort((e, t) => e.transformationIndex - t.transformationIndex);
      }
      evaluateActiveAnimations() {
        const t = Date.now();
        this.update(t),
          this.applyAllAnimationsOfNodes(),
          e.window.requestAnimationFrame(this.evaluateActiveAnimations);
      }
      update(t) {
        if (this.isRunning)
          for (const i in this.groupsOfNode) {
            const s = this.gltf.nodes[parseFloat(i.slice(5))];
            if (!s.play) continue;
            s.translateMat ||
              ((s.translateMat = new e.Matrix4().setTranslation(s._position)),
              (s.scaleMat = new e.Matrix4().scale(s._scale)),
              (s.rotateMat = new e.Matrix4().fromQuaternion(s._quaternion)));
            const r = { translation: s.translateMat, rotation: s.rotateMat, scale: s.scaleMat };
            for (let e = 0; e < this.groupsOfNode[i].length; e++)
              this.groupsOfNode[i][e].evaluate(t),
                'translation' == this.groupsOfNode[i][e].path &&
                  (r.translation = this.groupsOfNode[i][e]._value),
                'rotation' == this.groupsOfNode[i][e].path &&
                  (r.rotation = this.groupsOfNode[i][e]._value),
                'scale' == this.groupsOfNode[i][e].path &&
                  (r.scale = this.groupsOfNode[i][e]._value);
            s.setMatrix(
              r.translation
                .clone()
                .multiplyRight(r.rotation.clone())
                .multiplyRight(r.scale.clone()),
            ),
              s.updateWorldMatrix(!0, !0);
          }
      }
      play() {
        this.isRunning = !0;
      }
      stop() {
        this.isRunning = !1;
      }
      addAnimation(e, t) {
        const i = e.input,
          s = e.output,
          r = e.target.path,
          n = e.interpolation;
        let o;
        const a = e.target.node,
          l = `${a.id}`,
          h = `animation-${t}-${l}`,
          c = 'HAD' === e.type ? e.target.node.matrix : null;
        return (
          1 === i.length && 1 === s.length
            ? (o = new Hs({ id: h, controlPoint: s[0], node: a }))
            : ('LINEAR' !== n && 'STEP' !== n) ||
              ('translation' === r || 'scale' === r
                ? (o = new Ws({
                    id: h,
                    times: i,
                    points: Array.from(s),
                    node: a,
                    interpolation: n,
                    path: r,
                    originNodeMatrix: c,
                  }))
                : 'rotation' === r
                ? (o = new js({
                    id: h,
                    times: i,
                    points: Array.from(s),
                    node: a,
                    interpolation: n,
                    path: r,
                    originNodeMatrix: c,
                  }))
                : 'weights' === r &&
                  (o = new qs({
                    id: h,
                    times: i,
                    weights: Array.from(s),
                    node: a,
                    interpolation: n,
                    path: r,
                  }))),
          this.groupsOfNode[l] || (this.groupsOfNode[l] = []),
          this.groupsOfNode[l].push(o),
          h
        );
      }
      removeAll() {
        for (const e in this.groupsOfNode) {
          const t = this.groupsOfNode[e];
          for (let e = 0; e < t.length; e++) t[e].stop();
          delete this.groupsOfNode[e];
        }
      }
      getMorphAnimation() {
        for (const e in this.groupsOfNode) {
          const t = this.groupsOfNode[e];
          for (let e = 0; e < t.length; e++) if ('weights' === t[e].path) return t[e];
        }
        return null;
      }
      applyAllAnimationsOfNodes() {
        for (const e in this.groupsOfNode) this.applyAnimationByNodeId(e);
      }
      applyAnimationByNode(e) {
        return this.applyAnimationByNodeId(e.id);
      }
      applyAnimationByNodeId(t) {
        const i = [],
          s = [];
        for (const e of this.groupsOfNode[t])
          e.closed || ('weights' !== e.path ? i.push(e) : s.push(e));
        if (0 === i.length && 0 === s.length) return;
        const r = {};
        if (i.length > 0)
          if (1 === i.length) r.anim = i[0].value;
          else {
            const t = new e.Matrix4();
            for (let e = 0; e < i.length; e++) t.multiplyRight(i[e].value);
            r.anim = t;
          }
        return s.length > 0 && (r.weights = s[0].value), (i[0].node.weights = r.weights), r;
      }
    }
    function $s(t, i) {
      if (null === t || 'object' != typeof t) return t;
      i = e.defaultValue(i, !1);
      const s = new t.constructor();
      for (const e in t)
        if (t.hasOwnProperty(e)) {
          let r = t[e];
          i && (r = $s(r, i)), (s[e] = r);
        }
      return s;
    }
    const Ks = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
      Ys = { 5120: 1, 5121: 1, 5122: 2, 5123: 2, 5125: 4, 5126: 4 },
      Qs = {
        TEXTURE_MAG_FILTER: 10240,
        TEXTURE_MIN_FILTER: 10241,
        TEXTURE_WRAP_S: 10242,
        TEXTURE_WRAP_T: 10243,
        REPEAT: 10497,
        LINEAR: 9729,
        NEAREST_MIPMAP_LINEAR: 9986,
      },
      Js = {
        magFilter: Qs.TEXTURE_MAG_FILTER,
        minFilter: Qs.TEXTURE_MIN_FILTER,
        wrapS: Qs.TEXTURE_WRAP_S,
        wrapT: Qs.TEXTURE_WRAP_T,
      },
      er = {
        [Qs.TEXTURE_MAG_FILTER]: Qs.LINEAR,
        [Qs.TEXTURE_MIN_FILTER]: Qs.NEAREST_MIPMAP_LINEAR,
        [Qs.TEXTURE_WRAP_S]: Qs.REPEAT,
        [Qs.TEXTURE_WRAP_]: Qs.REPEAT,
      };
    class tr {
      postProcess(e, t = {}) {
        const { json: i, buffers: s = [], images: r = [], baseUri: n = '' } = e;
        return (
          Gi(i),
          (this.vBuffer = {}),
          (this.iBuffer = {}),
          (this.useMipmap = t.useMipmap),
          (this.clippingPlanes = t.clippingPlanes),
          (this.allowPick = t.allowPick),
          (this.context = t.context),
          (this.modelInstanceCollection = t.modelInstanceCollection),
          (this.baseUri = n),
          (this.json = i),
          (this.buffers = s),
          (this.images = r),
          (this.json.textureByteSize = e.textureByteSize),
          (function (e) {
            const t = e.meshes;
            for (let e = 0; e < t.length; e++) {
              const i = t[e].primitives;
              for (let e = 0; e < i.length; e++) {
                const t = i[e];
                if (t.extensions && t.extensions.KHR_draco_mesh_compression) {
                  const e = t.extensions.KHR_draco_mesh_compression.attributes;
                  Object.keys(t.attributes).forEach((i, s) => {
                    if (-1 !== i.indexOf('CUSTOM_ATTRIBUTE')) {
                      const s = parseInt(i.split('_')[2]);
                      for (const r in t.extensions.KHR_draco_mesh_compression.attributes)
                        e[r] == s && ((t.attributes[r] = t.attributes[i]), delete t.attributes[i]);
                    }
                  });
                }
              }
            }
          })(this.json),
          this._resolveTree(this.json, t),
          (this.context = null),
          (this.vBuffer = null),
          (this.iBuffer = null),
          this.json
        );
      }
      _resolveTree(t, i = {}) {
        t.bufferViews &&
          (t.bufferViews = t.bufferViews.map((e, t) => this._resolveBufferView(e, t))),
          t.images && (t.images = t.images.map((e, t) => this._resolveImage(e, t))),
          t.samplers && (t.samplers = t.samplers.map((e, t) => this._resolveSampler(e, t))),
          t.textures && (t.textures = t.textures.map((e, t) => this._resolveTexture(e, t))),
          t.accessors && (t.accessors = t.accessors.map((e, t) => this._resolveAccessor(e, t))),
          t.materials && (t.materials = t.materials.map((e, t) => this._resolveMaterial(e, t))),
          t.skins && (t.skins = t.skins.map((e, t) => this._resolveSkin(e, t))),
          t.nodes &&
            ((t.nodes = t.nodes.map(
              i.instances ? (t) => new e.Node(t, !1) : (t) => new e.Node(t, !0),
            )),
            (t.nodes = t.nodes.map((e, t) => this._resolveNode(e, t)))),
          t.animations && (t.animations = t.animations.map((e, t) => this._resolveAnimation(e, t))),
          t.scenes && (t.scenes = t.scenes.map((e, t) => this._resolveScene(e, t))),
          (t.scene = e.defined(t.scene) ? t.scenes[this.json.scene] : t.scenes[0]);
      }
      getScene(e) {
        return this._get('scenes', e);
      }
      getNode(t) {
        let i = this._get('nodes', t);
        return i instanceof e.Node || (i = new e.Node(i)), i;
      }
      getSkin(e) {
        return this._get('skins', e);
      }
      getMesh(e) {
        return this._get('meshes', e);
      }
      getMaterial(e) {
        return this._get('materials', e);
      }
      getAccessor(e) {
        return this._get('accessors', e);
      }
      getCamera(e) {
        return null;
      }
      getTexture(e) {
        return this._get('textures', e);
      }
      getSampler(e) {
        return this._get('samplers', e);
      }
      getImage(e) {
        return this._get('images', e);
      }
      getBufferView(e) {
        return this._get('bufferViews', e);
      }
      getBuffer(e) {
        return this._get('buffers', e);
      }
      _get(e, t) {
        return 'object' == typeof t ? t : this.json[e] && this.json[e][t];
      }
      _resolveAnimation(e, t) {
        return (
          (e.id = e.id || t),
          (e.name = e.name || 'default-animation'),
          (e.isRunning = !1),
          0 === t && (e.isRunning = !0),
          (function (e, t) {
            const i = [],
              s = e;
            for (let e = 0; e < s.channels.length; e++) {
              const r = s.channels[e],
                n = s.samplers[r.sampler],
                o = t.accessors[n.input];
              let a = null;
              r.extras && r.extras.type && (a = r.extras.type);
              const l = {
                count: o.count,
                input: o.value,
                output: t.accessors[n.output].value,
                target: r.target,
                interpolation: n.interpolation,
                type: a,
              };
              (l.target.node = t.nodes[l.target.node]), i.push(l);
            }
            return new Zs({
              id: e.id,
              name: e.name,
              animations: i,
              gltf: t,
              isRunning: e.isRunning,
            });
          })(e, this.json)
        );
      }
      createNodeMesh(t) {
        const i = this.json;
        if (void 0 === t.mesh) return null;
        let s = i.meshes[t.mesh],
          r = !0;
        return (
          s.primitives.forEach((i) => {
            e.defined(i.attributes.POSITION) && e.defined(i.attributes.POSITION.value) && (r = !1),
              (i.skinsIndex = t._skinsIndex);
          }),
          r && (s = $s(i.meshes[t.mesh], !0)),
          this._resolveMesh(s, t)
        );
      }
      _resolveScene(e, t) {
        return (
          (e.id = e.id || `scene-${t}`), (e.nodes = (e.nodes || []).map((e) => this.getNode(e))), e
        );
      }
      _resolveNode(e, t) {
        if (((e.id = e.id || `node-${t}`), e.childIdxes)) {
          const t = e.childIdxes.map((e) => this.getNode(e));
          e.add(...t);
        }
        return (
          void 0 !== e.mesh
            ? ((e.mesh = this.createNodeMesh(e)), e.add(...e.mesh.primitives))
            : void 0 !== e.meshes &&
              e.meshes.length &&
              ((e.mesh = e.meshes.reduce(
                (e, t) => {
                  const i = this.createNodeMesh(t);
                  return (e.id = i.id), (e.primitives = e.primitives.concat(i.primitives)), e;
                },
                { primitives: [] },
              )),
              e.add(...e.mesh.primitives)),
          void 0 !== e.camera && (e.camera = this.getCamera(e.camera)),
          void 0 !== e.skin && (e.skin = this.getSkin(e.skin)),
          e.createSkeleton(this.json),
          e
        );
      }
      _resolveSkin(t, i) {
        t.id = t.id || `skin-${i}`;
        const s = this.getAccessor(t.inverseBindMatrices),
          r = [];
        for (let i = 0; i < t.joints.length; i++)
          r.push(new e.Matrix4(s.value.slice(16 * i, 16 * (i + 1))));
        return (t.inverseBindMatrices = r), t;
      }
      _resolveMesh(t, i) {
        const s = i.mesh;
        return (
          t.id ? (i.properties.id = t.id) : (t.id = `mesh-${s}`),
          t.primitives &&
            (t.primitives = t.primitives.map((t, i) => {
              const r = (t = { ...t }).attributes;
              t.attributes = {};
              for (const e in r) t.attributes[e] = this.getAccessor(r[e]);
              return (
                void 0 !== t.indices &&
                  ((t.indicesId = t.indices), (t.indices = this.getAccessor(t.indices))),
                void 0 !== t.material &&
                  ((t.materialId = t.material),
                  (t.material = this.getMaterial(t.material)),
                  t.material.alphaMode || (t.material.alphaMode = 'OPAQUE')),
                (function ({
                  primitive: t,
                  context: i,
                  vbuffer: s,
                  ibuffer: r,
                  gltf: n,
                  ppi: o,
                  meshInd: a,
                  modelInstanceCollection: l,
                  clippingPlanes: h,
                  allowPick: c,
                }) {
                  const _ = {},
                    u = !!(t.targets && t.targets.length > 0),
                    d = null != l;
                  !t.attributes.hasOwnProperty('NORMAL') &&
                    i._enableNormal &&
                    (t.attributes.NORMAL = {
                      value: new Float32Array(
                        e.PolygonGeometryLibrary.computeNormal(
                          t.attributes.POSITION.value,
                          t.indices.value,
                        ),
                      ),
                      size: 3,
                      bufferView: t.attributes.POSITION.bufferView,
                      byteOffset: t.attributes.POSITION.byteOffset,
                      count: t.attributes.POSITION.count,
                      type: 'VEC3',
                      components: 3,
                      componentType: t.attributes.POSITION.componentType,
                    });
                  const m = (function (e) {
                      const t = { u_HAS_TANGENTS: !1, u_HAS_NORMALS: !1, u_HAS_VERTEX_COLOR: !1 };
                      for (const i in e.attributes) {
                        const e = i.toUpperCase();
                        -1 !== e.indexOf('NORMAL') && (t.u_HAS_NORMALS = !0),
                          -1 !== e.indexOf('TANGENT') && (t.u_HAS_TANGENTS = !0),
                          -1 !== e.indexOf('COLOR_0') && (t.u_HAS_VERTEX_COLOR = !0);
                      }
                      return t;
                    })(t),
                    p = (function ({
                      primitive: t,
                      bufferDataConfig: i,
                      isMorphModel: s,
                      gltf: r,
                    }) {
                      const n = t.attributes,
                        o = t.extensions,
                        a = o ? o.KHR_draco_mesh_compression : void 0,
                        l = [];
                      for (const t in n) {
                        const s = n[t],
                          o = s.bufferView || s.value,
                          h = s.byteOffset ? s.byteOffset : 0,
                          c = s.componentType,
                          _ = o.byteStride
                            ? o.byteStride
                            : e.WebGLSizes[c] * (e.WebGLComponentCounts[s.type] || s.components);
                        a && (n[t].bufferViewId = r.bufferViews[a.bufferView].id),
                          'POSITION' === t && (i.VB = { offset: h, byteStride: _, type: c }),
                          '_' == t.charAt(0)
                            ? l.push({
                                name: `a${t}`,
                                type: c,
                                components: e.WebGLComponentCounts[s.type],
                                offset: h,
                                byteStride: _,
                              })
                            : l.push({
                                name: `a_${t}`,
                                type: c,
                                components: e.WebGLComponentCounts[s.type],
                                offset: h,
                                byteStride: _,
                              });
                      }
                      if (s)
                        for (let i = 0; i < t.targets.length; i++) {
                          const s = t.targets[i];
                          for (const t in s) {
                            const s = n[t],
                              r = s.bufferView,
                              o = s.componentType,
                              a = s.components;
                            l.push({
                              name: `a_${t}_${i + 1}`,
                              type: o,
                              components: e.WebGLComponentCounts[s.type],
                              offset: s.byteOffset ? s.byteOffset : 0,
                              byteStride: r.byteStride
                                ? r.byteStride
                                : 5121 === o
                                ? a
                                : 5123 === o
                                ? 2 * a
                                : 4 * a,
                            });
                          }
                        }
                      return e.createLayoutGltf(l);
                    })({ primitive: t, bufferDataConfig: _, isMorphModel: u, gltf: n });
                  let f;
                  const g = !!t.hasOwnProperty('indices');
                  g && (f = t.indices);
                  const y = t.attributes,
                    T = t.mode,
                    x = t.attributes.POSITION || t.attributes.CENTEROFFSETS;
                  x.min ||
                    (t.boundingBox
                      ? ((x.min = t.boundingBox.min), (x.max = t.boundingBox.max))
                      : ((x.min = [0, 0, 0]), (x.max = [1e4, 1e4, 1e4])));
                  const v = null != x.bufferView ? x.bufferView.id : x.bufferViewId;
                  _.VB && (_.VB.byteOffset = (x && x.byteOffset) || 0);
                  const b = !s[v + p.key],
                    w = t.targets;
                  b &&
                    w &&
                    w.length > 0 &&
                    w.forEach((e, t) => {
                      const i = e;
                      for (const e in i) y[`${e}_${t + 1}`] = n.accessors[i[e]];
                    });
                  const C = new e.VertexBuffer({
                    context: i,
                    attributesbuffviewObject: b ? y : null,
                    attributes: p.members,
                    dynamicDraw: !1,
                    buffers: s[v + p.key],
                  });
                  let S, E, P;
                  if ((l && l.update({ context: i }), b && (s[v + p.key] = C.getBuffers()), g)) {
                    const e = null != f.bufferView ? f.bufferView : {};
                    e && !e.hasOwnProperty('byteOffset') && (e.byteOffset = 0),
                      e && void 0 === e.id && (e.id = `bufferView-${a}_${o}`);
                    const t = null != f.bufferView ? f.bufferView.data : f.value;
                    E = f.byteOffset ? f.byteOffset : 0;
                    const s = f.componentType;
                    (P = f.count),
                      (_.IB = { byteStride: 2, count: P, type: s, value: f.value }),
                      r[e.id]
                        ? (S = new Ns(i, null, !1, s, r[e.id]))
                        : ((S = new Ns(i, t, !1, s)), (r[e.id] = S.getBuffer()));
                  } else P = t.attributes.POSITION.count;
                  const M = new e.SegmentVector();
                  M.pushSegment({
                    isModel: !0,
                    isInstance: d,
                    modelVertexOffset: E || 0,
                    modelVertexCount: P,
                    instancesCount: l?._instances?.size || 0,
                  });
                  const A = new e.Geometry({
                    indexBuffer: S,
                    vertBuffer: C,
                    dynamicLayoutBuffer1: l?.instanceBuffer,
                    primitiveType: void 0 === T ? e.WebGLConstants.TRIANGLES : T,
                    segmentVector: M,
                    vertices:
                      ((R = x.min),
                      (I = x.max),
                      [
                        R[0],
                        R[1],
                        R[2],
                        I[0],
                        R[1],
                        R[2],
                        R[0],
                        I[1],
                        R[2],
                        R[0],
                        R[1],
                        I[2],
                        I[0],
                        I[1],
                        R[2],
                        I[0],
                        R[1],
                        I[2],
                        R[0],
                        I[1],
                        I[2],
                        I[0],
                        I[1],
                        I[2],
                      ]),
                  });
                  var R, I;
                  const O = t.material || {},
                    L = new Fs({
                      type: d ? 'gltfPBRI3DM' : void 0,
                      isInstance: d,
                      ...O,
                      hasNormal: m.u_HAS_NORMALS,
                      hasTangent: m.u_HAS_TANGENTS,
                      hasVertexColor: m.u_HAS_VERTEX_COLOR,
                      doubleSided: !!O.doubleSided,
                      ...Us(t),
                      clippingPlanes: h,
                      skins: e.defined(n.skins) && n.skins.length > 0,
                    }),
                    D = new e.Primitive({
                      geometry: A,
                      material: L,
                      properties: {
                        primitiveName: t.name,
                        indicesId: t.indicesId,
                        materialId: t.materialId,
                      },
                      normalMatrix: new e.Matrix4(),
                      allowPick: c,
                      skinsIndex: t.skinsIndex,
                    });
                  return d && (D.modelInstanceType = '3d-tile'), D;
                })({
                  primitive: t,
                  context: this.context,
                  vbuffer: this.vBuffer,
                  ibuffer: this.iBuffer,
                  gltf: this.json,
                  meshInd: s,
                  ppi: i,
                  modelInstanceCollection: this.modelInstanceCollection,
                  clippingPlanes: this.clippingPlanes,
                  allowPick: this.allowPick,
                })
              );
            })),
          t
        );
      }
      _resolveMaterial(e, t) {
        if (
          ((e.id = e.id || `material-${t}`),
          e.normalTexture &&
            ((e.normalTexture = { ...e.normalTexture }),
            (e.normalTexture.texture = this.getTexture(e.normalTexture.index))),
          e.occlusionTexture &&
            ((e.occlusionTexture = { ...e.occlusionTexture }),
            (e.occlusionTexture.texture = this.getTexture(e.occlusionTexture.index))),
          e.emissiveTexture &&
            ((e.emissiveTexture = { ...e.emissiveTexture }),
            (e.emissiveTexture.texture = this.getTexture(e.emissiveTexture.index))),
          e.emissiveFactor || (e.emissiveFactor = e.emissiveTexture ? [1, 1, 1] : [0, 0, 0]),
          e.extensions &&
            e.extensions &&
            e.extensions &&
            e.extensions.KHR_materials_pbrSpecularGlossiness)
        ) {
          e.pbrMetallicRoughness = { ...e.extensions.KHR_materials_pbrSpecularGlossiness };
          const t = e.pbrMetallicRoughness;
          t.diffuseTexture &&
            ((t.baseColorTexture = { ...t.diffuseTexture }),
            (t.baseColorTexture.texture = this.getTexture(t.diffuseTexture.index)));
        } else {
          e.pbrMetallicRoughness = { ...e.pbrMetallicRoughness };
          const t = e.pbrMetallicRoughness;
          t.baseColorTexture &&
            ((t.baseColorTexture = { ...t.baseColorTexture }),
            (t.baseColorTexture.texture = this.getTexture(t.baseColorTexture.index))),
            t.metallicRoughnessTexture &&
              ((t.metallicRoughnessTexture = { ...t.metallicRoughnessTexture }),
              (t.metallicRoughnessTexture.texture = this.getTexture(
                t.metallicRoughnessTexture.index,
              )));
        }
        return e;
      }
      _resolveAccessor(e, t) {
        if (
          ((e.id = e.id || `accessor-${t}`),
          void 0 !== e.bufferView && (e.bufferView = this.getBufferView(e.bufferView)),
          (e.bytesPerComponent = Ys[e.componentType]),
          (e.components = Ks[e.type]),
          (e.bytesPerElement = e.bytesPerComponent * e.components),
          e.bufferView)
        ) {
          const t = e.bufferView.buffer,
            { ArrayType: i, byteLength: s } = as(e, e.bufferView),
            r = (e.bufferView.byteOffset || 0) + (e.byteOffset || 0) + t.byteOffset,
            n = t.arrayBuffer.slice(r, r + s);
          e.value = new i(n);
        }
        return e;
      }
      _resolveTexture(t, i) {
        return (
          (t.id = t.id || `texture-${i}`),
          (t.sampler = 'sampler' in t ? this.getSampler(t.sampler) : er),
          (t.source = this.getImage(t.source)),
          (function (t, i, s) {
            const r = t.source,
              n = (function (t) {
                return {
                  wrapS: t.wrapS || e.WebGLConstants.REPEAT,
                  wrapT: t.wrapT || e.WebGLConstants.REPEAT,
                  magFilter: t.magFilter || e.WebGLConstants.LINEAR,
                  minFilter: t.minFilter || e.WebGLConstants.LINEAR,
                };
              })(t.sampler);
            let o = r.image,
              a = '';
            const l = i.painter.textureResourceManager;
            if (
              (r.uri && e.isUrl(r.uri) && (a = r.uri.substring(r.uri.lastIndexOf('/') + 1)),
              e.CompressedTextureUtil.isCompressedFormat(o))
            ) {
              const { format: e } = o[0],
                s = l.getTexture({
                  texUrl: r.uri,
                  name: a,
                  context: i,
                  image: o,
                  pixelFormat: e,
                  compressed: !0,
                  useMipmap: !1,
                });
              s.bind(n.magFilter, n.wrapS), (t._texture = s);
            } else {
              const h = !1;
              if (o && o.width && (s || n.wrapS === e.WebGLConstants.REPEAT)) {
                const e = !Gs.isPowerOfTwo(o.width) || !Gs.isPowerOfTwo(o.height);
                (o = e ? Gs.generateImage(o) : o),
                  e &&
                    h &&
                    console.warn(
                      `The model texture 【${
                        r.name ? r.name : r.id
                      }】 does not exist to the nth power of 2!`,
                    );
              }
              const c = l.getTexture({
                texUrl: r.uri,
                name: a,
                context: i,
                image: o,
                pixelFormat:
                  r.mimeType && -1 !== r.mimeType.indexOf('jpeg')
                    ? e.WebGLConstants.RGB
                    : e.WebGLConstants.RGBA,
                useMipmap: s,
              });
              c.bind(n.magFilter, n.wrapS), (t._texture = c);
            }
          })(t, this.context, this.useMipmap),
          t
        );
      }
      _resolveSampler(e, t) {
        (e.id = e.id || `sampler-${t}`), (e.parameters = {});
        for (const t in e) {
          const i = this._enumSamplerParameter(t);
          void 0 !== i && (e.parameters[i] = e[t]);
        }
        return e;
      }
      _enumSamplerParameter(e) {
        return Js[e];
      }
      _resolveImage(e, t) {
        (e.id = e.id || `image-${t}`),
          void 0 !== e.bufferView && (e.bufferView = this.getBufferView(e.bufferView));
        const i = this.images[t];
        return i && (e.image = i), e;
      }
      _resolveBufferView(e, t) {
        e.id = e.id || `bufferView-${t}`;
        const i = e.buffer;
        e.buffer = this.buffers[i];
        let s = this.buffers[i].byteOffset || 0;
        return (
          'byteOffset' in e && (s += e.byteOffset),
          (e.data = new Uint8Array(this.buffers[i].arrayBuffer.slice(s, s + e.byteLength))),
          e
        );
      }
      _resolveCamera(e, t) {
        return (e.id = e.id || `camera-${t}`), e;
      }
    }
    function ir(e, t) {
      return new tr().postProcess(e, t);
    }
    const sr = 1735152710,
      rr = !0;
    function nr(e, t, i, s, r) {
      const n = new Uint8Array(t.buffer.slice(i, i + s)),
        o = new TextDecoder('utf8').decode(n);
      return (e.json = JSON.parse(o)), ce(s, 4);
    }
    function or(e, t, i, s, r) {
      return (
        (e.header.hasBinChunk = !0),
        e.binChunks.push({ byteOffset: i, byteLength: s, arrayBuffer: t.buffer }),
        ce(s, 4)
      );
    }
    const ar = {
        UNSIGNED_BYTE: 5121,
        UNSIGNED_SHORT: 5123,
        UNSIGNED_INT: 5125,
        FLOAT: 5126,
        HALF_FLOAT_OES: 36193,
        UNSIGNED_INT_24_8: 34042,
        UNSIGNED_SHORT_4_4_4_4: 32819,
        UNSIGNED_SHORT_5_5_5_1: 32820,
        UNSIGNED_SHORT_5_6_5: 33635,
      },
      lr = {
        ALPHA: 6406,
        RGB: 6407,
        RGBA: 6408,
        LUMINANCE: 6409,
        LUMINANCE_ALPHA: 6410,
        RGB_DXT1: 33776,
        RGBA_DXT1: 33777,
        RGBA_DXT3: 33778,
        RGBA_DXT5: 33779,
        RGB_PVRTC_4BPPV1: 35840,
        RGB_PVRTC_2BPPV1: 35841,
        RGBA_PVRTC_4BPPV1: 35842,
        RGBA_PVRTC_2BPPV1: 35843,
        RGB_ETC1: 36196,
        isCompressedFormat(e) {
          let t;
          return (
            (t = Array.isArray(e) && e.length > 0 ? e[0].format : e.format || ''),
            t === lr.RGB_DXT1 ||
              t === lr.RGBA_DXT1 ||
              t === lr.RGBA_DXT3 ||
              t === lr.RGBA_DXT5 ||
              t === lr.RGB_PVRTC_4BPPV1 ||
              t === lr.RGB_PVRTC_2BPPV1 ||
              t === lr.RGBA_PVRTC_4BPPV1 ||
              t === lr.RGBA_PVRTC_2BPPV1 ||
              t === lr.RGB_ETC1
          );
        },
        isDXTFormat: (e) =>
          e === lr.RGB_DXT1 || e === lr.RGBA_DXT1 || e === lr.RGBA_DXT3 || e === lr.RGBA_DXT5,
        isPVRTCFormat: (e) =>
          e === lr.RGB_PVRTC_4BPPV1 ||
          e === lr.RGB_PVRTC_2BPPV1 ||
          e === lr.RGBA_PVRTC_4BPPV1 ||
          e === lr.RGBA_PVRTC_2BPPV1,
        isETC1Format: (e) => e === lr.RGB_ETC1,
        compressedTextureSizeInBytes(e, t, i) {
          switch (e) {
            case lr.RGB_DXT1:
            case lr.RGBA_DXT1:
            case lr.RGB_ETC1:
              return Math.floor((t + 3) / 4) * Math.floor((i + 3) / 4) * 8;
            case lr.RGBA_DXT3:
            case lr.RGBA_DXT5:
              return Math.floor((t + 3) / 4) * Math.floor((i + 3) / 4) * 16;
            case lr.RGB_PVRTC_4BPPV1:
            case lr.RGBA_PVRTC_4BPPV1:
              return Math.floor((Math.max(t, 8) * Math.max(i, 8) * 4 + 7) / 8);
            case lr.RGB_PVRTC_2BPPV1:
            case lr.RGBA_PVRTC_2BPPV1:
              return Math.floor((Math.max(t, 16) * Math.max(i, 8) * 2 + 7) / 8);
            default:
              return 0;
          }
        },
        componentsLength(e) {
          switch (e) {
            case lr.RGB:
              return 3;
            case lr.RGBA:
              return 4;
            case lr.LUMINANCE_ALPHA:
              return 2;
            default:
              return 1;
          }
        },
        textureSizeInBytes(e, t, i, s) {
          let r = lr.componentsLength(e);
          return lr.isPacked(t) && (r = 1), r * lr.sizeInBytes(t) * i * s;
        },
        sizeInBytes(e) {
          switch (e) {
            case ar.UNSIGNED_BYTE:
              return 1;
            case ar.UNSIGNED_SHORT:
            case ar.UNSIGNED_SHORT_4_4_4_4:
            case ar.UNSIGNED_SHORT_5_5_5_1:
            case ar.UNSIGNED_SHORT_5_6_5:
            case ar.HALF_FLOAT:
              return 2;
            case ar.UNSIGNED_INT:
            case ar.FLOAT:
            case ar.UNSIGNED_INT_24_8:
              return 4;
          }
        },
        isPacked: (e) =>
          e === ar.UNSIGNED_INT_24_8 ||
          e === ar.UNSIGNED_SHORT_4_4_4_4 ||
          e === ar.UNSIGNED_SHORT_5_5_5_1 ||
          e === ar.UNSIGNED_SHORT_5_6_5,
      };
    const hr = new Map();
    async function cr(e, t, i, s, r) {
      const { fetch: n, parse: o } = r;
      let a, l;
      if (
        t.uri &&
        (function (e) {
          const t = e.substring(0, 2),
            i = e.substring(0, 1);
          return (
            !!/^http[s]?:\/\/([\w\-\.]+)+[\w-]*([\w\-\.\/\?%&=]+)?$/gi.test(e) ||
            './' === t ||
            '/' === i
          );
        })(t.uri)
      ) {
        const h = Ui(t.uri, s),
          c = h.lastIndexOf('/') + 1;
        l = h.substring(c);
        const _ = await n(h, s);
        (a = _ instanceof ArrayBuffer ? _ : await _.arrayBuffer()),
          Number.isFinite(t.bufferView) && (a = zi(e.json, e.buffers, t.bufferView)),
          Gi(a, 'glTF image has no data');
        const u = await o(a, Ut, {}, r);
        if (hr.has(l)) {
          const t = hr.get(l),
            s = { name: '', imageParsed: null, gltf: null, index: -1 };
          t[0].imageParsed
            ? ((s.name = l),
              (s.gltf = e),
              (s.index = i),
              (s.imageParsed = t[0].imageParsed),
              (s.gltf.images[s.index] = t[0].imageParsed),
              t.push(s))
            : ((s.name = l),
              (s.gltf = e),
              (s.index = i),
              (s.imageParsed = u),
              (s.gltf.images[s.index] = u),
              t.push(s));
        } else {
          const t = { name: '', imageParsed: null, gltf: null, index: -1 };
          (t.name = l), (t.gltf = e), (t.index = i);
          const s = [];
          s.push(t),
            hr.set(l, s),
            hr.get(l).forEach((e) => {
              (e.imageParsed = u), (e.gltf.images[e.index] = u);
            });
        }
      } else {
        if (t.uri) {
          const e = Ui(t.uri, s),
            i = await n(e, s);
          a = i instanceof ArrayBuffer ? i : await i.arrayBuffer();
        }
        let l;
        switch (
          (Number.isFinite(t.bufferView) && (a = zi(e.json, e.buffers, t.bufferView)),
          Gi(a, 'glTF image has no data'),
          t.mimeType)
        ) {
          case 'image/ktx':
            l = await o(a, Oi, {}, r);
            const { ktxformat: t, ktxwidth: i, ktxheight: s } = l[0];
            e.textureByteSize += lr.compressedTextureSizeInBytes(t, i, s);
            break;
          case 'image/crn':
            (l = await o(a, ki, { worker: !0 }, r)), (e.textureByteSize += l[0].data.byteLength);
            break;
          case 'image/basis':
          case 'image/ktx2':
            (bi.options.basis.format = (function (e, t) {
              let i = e && e.basis && e.basis.format;
              return (
                'auto' === i && (i = vi()),
                'object' == typeof i && (i = i.alpha),
                (i = i.toLowerCase()),
                i
              );
            })(bi.options)),
              (l = await o(a, bi, r)),
              (e.textureByteSize += l[0].data.byteLength);
            break;
          default:
            l = await o(a, Ut, {}, r);
            const { width: n, height: h } = l;
            e.textureByteSize += lr.textureSizeInBytes(6408, 5121, n, h);
        }
        e.images[i] = l;
      }
    }
    const _r = {
      name: 'glTF',
      id: 'gltf',
      module: 'gltf',
      version: yt,
      extensions: ['gltf', 'glb'],
      mimeTypes: ['model/gltf+json', 'model/gltf-binary'],
      text: !0,
      binary: !0,
      tests: ['glTF'],
      parse: async function (t, i = {}, s) {
        ((i = { ..._r.options, ...i }).gltf = { ..._r.options.gltf, ...i.gltf }),
          (function (e) {
            'fetchImages' in e && (e.gltf.loadImages = e.fetchImages),
              'createImages' in e && (e.gltf.loadImages = e.createImages),
              'fetchLinkedResources' in e && (e.gltf.fetchBuffers = e.fetchLinkedResources),
              'decompress' in e && (e.gltf.decompressMeshes = e.decompress),
              'decompress' in e.gltf && (e.gltf.decompressMeshes = e.gltf.decompress),
              'postProcess' in e && (e.gltf.postProcess = e.postProcess);
          })(i);
        const { byteOffset: r = 0 } = i,
          n = e.decodeModel(t),
          o = await (async function (t, i, s = 0, r, n) {
            if (
              ((function (e, t, i, s) {
                if (
                  (s.uri && (e.baseUri = s.uri),
                  t instanceof ArrayBuffer &&
                    !(function (e, t = 0, i = {}) {
                      const s = new DataView(e),
                        { magic: r = sr } = i,
                        n = s.getUint32(t, !1);
                      return n === r || n === sr;
                    })(t, i, s) &&
                    (t = new TextDecoder().decode(t)),
                  'string' == typeof t)
                )
                  e.json = (function (e) {
                    try {
                      return JSON.parse(e);
                    } catch (t) {
                      throw new Error(
                        `Failed to parse JSON from data starting with "${(function (e, t = 5) {
                          return 'string' == typeof e
                            ? e.slice(0, t)
                            : ArrayBuffer.isView(e)
                            ? ae(e.buffer, e.byteOffset, t)
                            : e instanceof ArrayBuffer
                            ? ae(e, 0, t)
                            : '';
                        })(e)}"`,
                      );
                    }
                  })(t);
                else if (t instanceof ArrayBuffer) {
                  const r = {};
                  (i = (function (e, t, i = 0, s = {}) {
                    const r = new DataView(t);
                    (e.type = (function (e, t = 0) {
                      return `${String.fromCharCode(e.getUint8(t + 0))}${String.fromCharCode(
                        e.getUint8(t + 1),
                      )}${String.fromCharCode(e.getUint8(t + 2))}${String.fromCharCode(
                        e.getUint8(t + 3),
                      )}`;
                    })(r, i + 0)),
                      (e.version = r.getUint32(i + 4, rr));
                    const n = r.getUint32(i + 8, rr);
                    switch (
                      ((e.header = { byteOffset: i, byteLength: n }),
                      (e.json = {}),
                      (e.binChunks = []),
                      (i += 12),
                      e.version)
                    ) {
                      case 1:
                        return (function (e, t, i, s) {
                          P(e.header.byteLength > 20);
                          const r = t.getUint32(i + 0, rr),
                            n = t.getUint32(i + 4, rr);
                          return (
                            (i += 8),
                            P(0 === n),
                            nr(e, t, i, r),
                            (i += r) + or(e, t, i, e.header.byteLength)
                          );
                        })(e, r, i);
                      case 2:
                        return (function (e, t, i, s) {
                          return (
                            P(e.header.byteLength > 20),
                            (function (e, t, i, s) {
                              for (; i + 8 <= e.header.byteLength; ) {
                                const r = t.getUint32(i + 0, rr),
                                  n = t.getUint32(i + 4, rr);
                                switch (((i += 8), n)) {
                                  case 1313821514:
                                    nr(e, t, i, r);
                                    break;
                                  case 5130562:
                                    or(e, t, i, r);
                                    break;
                                  case 0:
                                    s.glb.strict || nr(e, t, i, r);
                                    break;
                                  case 1:
                                    s.glb.strict || or(e, t, i, r);
                                }
                                i += ce(r, 4);
                              }
                            })(e, t, i, {}),
                            i + e.header.byteLength
                          );
                        })(e, r, i);
                      default:
                        throw new Error(
                          `Invalid GLB version ${e.version}. Only supports v1 and v2.`,
                        );
                    }
                  })(r, t, i, s)),
                    Gi('glTF' === r.type, `Invalid GLB magic string ${r.type}`),
                    (e._glb = r),
                    (e.json = r.json);
                } else Gi(!1, 'GLTF: must be ArrayBuffer or string');
                if (
                  ((e.buffers = new Array((e.json.buffers || []).length).fill(null)),
                  e._glb && e._glb.header.hasBinChunk)
                ) {
                  const { binChunks: t } = e._glb;
                  e.buffers[0] = {
                    arrayBuffer: t[0].arrayBuffer,
                    byteOffset: t[0].byteOffset,
                    byteLength: t[0].byteLength,
                  };
                }
                e.images = new Array((e.json.images || []).length).fill({});
              })(t, i, s, r),
              '1.0' === t.json?.asset?.version)
            ) {
              const e = n.url;
              throw new Error(
                `The【${e.slice(e.lastIndexOf('/') + 1)}】 version is ${
                  t.json.asset.version
                }, minemap is not supported!`,
              );
            }
            !(function (e, t = {}) {
              new xs().normalize(e, t);
            })(t, { normalize: r.gltf.normalize }),
              (function (e, t = {}, i) {
                const s = fs.filter((e) => gs(e.name, t));
                for (const r of s) r.preprocess?.(e, t, i);
              })(t, r, n);
            const o = [];
            if (
              (r.gltf.loadBuffers &&
                t.json.buffers &&
                (await (async function (e, t, i) {
                  for (let s = 0; s < e.json.buffers.length; ++s) {
                    const r = e.json.buffers[s];
                    if (r.uri) {
                      const { fetch: n } = i;
                      Gi(n);
                      const o = Ui(r.uri, t),
                        a = await n(o, t);
                      let l;
                      (l = a instanceof ArrayBuffer ? a : await a.arrayBuffer()),
                        (e.buffers[s] = {
                          arrayBuffer: l,
                          byteOffset: 0,
                          byteLength: l.byteLength,
                        }),
                        delete r.uri;
                    }
                  }
                })(t, r, n)),
              r.gltf.loadImages)
            ) {
              const e = (async function (e, t, i) {
                const s = e.json.images || [],
                  r = [];
                for (let n = 0; n < s.length; ++n) r.push(cr(e, s[n], n, t, i));
                const n = await Promise.all(r);
                for (let t = 0; t < e.images.length; t++)
                  if (void 0 === e.images[t].width) {
                    const i = [...hr][t];
                    i && (e.images[t] = i[1][0].imageParsed);
                  }
                return n;
              })(t, r, n);
              o.push(e);
            }
            const a = { ...r };
            delete a.source, delete a.context;
            const l = (async function (e, t = {}, i) {
              const s = fs.filter((e) => gs(e.name, t));
              for (const r of s) await r.decode?.(e, t, i);
            })(t, a, n);
            if ((o.push(l), await Promise.all(o), r.instances)) {
              let i;
              if (t.json.nodes[0].matrix) i = new e.Matrix4(t.json.nodes[0].matrix);
              else {
                const s = new e.Quaternion(),
                  r = new e.Vector3(1, 1, 1),
                  n = new e.Vector3();
                t.json.nodes[0].rotation &&
                  (s.set(
                    t.json.nodes[0].rotation[0],
                    t.json.nodes[0].rotation[1],
                    t.json.nodes[0].rotation[2],
                    t.json.nodes[0].rotation[3],
                  ),
                  delete t.json.nodes[0].rotation),
                  t.json.nodes[0].scale &&
                    (r.copy(t.json.nodes[0].scale), delete t.json.nodes[0].scale),
                  t.json.nodes[0].translation &&
                    (n.copy(t.json.nodes[0].translation), delete t.json.nodes[0].translation),
                  (i = (function (t, i, s, r) {
                    r || (r = new e.Matrix4());
                    const n = s.x,
                      o = s.y,
                      a = s.z,
                      l = i.x * i.x,
                      h = i.x * i.y,
                      c = i.x * i.z,
                      _ = i.x * i.w,
                      u = i.y * i.y,
                      d = i.y * i.z,
                      m = i.y * i.w,
                      p = i.z * i.z,
                      f = i.z * i.w,
                      g = i.w * i.w,
                      y = 2 * (h - f),
                      T = 2 * (c + m),
                      x = 2 * (h + f),
                      v = -l + u - p + g,
                      b = 2 * (d - _),
                      w = 2 * (c - m),
                      C = 2 * (d + _),
                      S = -l - u + p + g;
                    return (
                      (r[0] = (l - u - p + g) * n),
                      (r[1] = x * n),
                      (r[2] = w * n),
                      (r[3] = 0),
                      (r[4] = y * o),
                      (r[5] = v * o),
                      (r[6] = C * o),
                      (r[7] = 0),
                      (r[8] = T * a),
                      (r[9] = b * a),
                      (r[10] = S * a),
                      (r[11] = 0),
                      (r[12] = t.x),
                      (r[13] = t.y),
                      (r[14] = t.z),
                      (r[15] = 1),
                      r
                    );
                  })(n, s, r, new e.Matrix4())),
                  (t.json.nodes[0].matrix = i);
              }
              for (const t of r.instances) {
                const s = t.modelMatrix.clone(),
                  r = new e.Matrix4().rotateX(Math.PI / 2),
                  n = s.multiplyRight(r);
                t.modelMatrix = n.multiplyRight(i);
              }
              r.modelInstanceCollection = new e.ModelInstanceCollection({
                instances: r.instances,
                type: '3d-tile',
              });
            }
            return r.gltf.postProcess ? ir(t, r) : t;
          })({ textureByteSize: 0 }, n, r, i, s);
        for (let e = 0; o.bufferViews && e < o.bufferViews.length; e++)
          (o.bufferViews[e].data = null), (o.bufferViews[e].buffer = null);
        for (let e = 0; o.images && e < o.images.length; e++)
          (o.images[e].bufferView = null), (o.images[e].image = null);
        return o;
      },
      options: {
        gltf: {
          normalize: !0,
          loadBuffers: !0,
          loadImages: !0,
          decompressMeshes: !0,
          postProcess: !0,
        },
        log: console,
      },
      deprecatedOptions: {
        fetchImages: 'gltf.loadImages',
        createImages: 'gltf.loadImages',
        decompress: 'gltf.decompressMeshes',
        postProcess: 'gltf.postProcess',
        gltf: { decompress: 'gltf.decompressMeshes' },
      },
    };
    class ur {
      constructor() {}
      static updateAnimation(t) {
        const { nodes: i, animations: s, skins: r } = t.gltfJson,
          n = { u_has_skinning: !1 };
        if (e.defined(s))
          for (let t = 0; t < s.length; t++) {
            const i = s[t];
            if (i.isRunning) {
              i.update(Date.now());
              const t = i.getMorphAnimation();
              t &&
                (n.u_morphTargetInfluences = e.Vector2.unpack(
                  1 === t.value.length ? [t.value[0], 0] : t.value.slice(0, 2),
                ));
            }
          }
        if (e.defined(r) && r.length > 0) {
          const t = [];
          i.forEach((i) => {
            i.update(), e.defined(i.skeleton) && t.push(i.skeleton.jointMatrix);
          }),
            (n.u_has_skinning = !0),
            (n.u_jointMatrixs = t);
        }
        return n;
      }
    }
    const dr = `v${C.substring(0, 1)}.0.0`,
      mr = 'minemapapi',
      pr = {
        DOMAIN: '//minedata.cn',
        DATA_DOMAIN: '//datahive.minedata.cn',
        SERVER_DOMAIN: '//datahive.minedata.cn',
        API_BASE: '/data/',
        API_URL: '//datahive.minedata.cn/data/',
        DYN_BASE: '/dynamicdata/',
        DYN_URL: '//datahive.minedata.cn/dynamicdata/',
        MERGE_BASE: '/mergeddata/',
        MERGE_URL: '//datahive.minedata.cn/mergeddata/',
        OTHER_BASE: '/otherdata/',
        OTHER_URL: '//datahive.minedata.cn/otherdata/',
        SERVER_URL: '//datahive.minedata.cn/service/',
        SRC_BASE: `/${mr}/${dr}`,
        SRC_URL: `//minedata.cn/${mr}/${dr}`,
        SERVICE_BASE: '/service',
        SERVICE_URL: '//minedata.cn/service',
        REQUIRE_ACCESS_TOKEN: !0,
        APP_KEY: null,
        KEY: null,
        ACCESS_TOKEN: null,
        spriteUrl: null,
        MAX_PARALLEL_IMAGE_REQUESTS: 16,
      };
    function fr(e, t) {
      return Array.isArray(e) ? (t && t.x && t.y ? e[(t.x + t.y) % e.length] : e[0]) : e;
    }
    function gr(t, i, s, r, n, o) {
      switch (t.protocol) {
        case 'minemap': {
          const e = Pr(pr.SRC_URL);
          (t.protocol = e.protocol), (t.authority = e.authority);
          break;
        }
        case 'minemapdata': {
          const e = Pr(fr(pr.API_URL, o));
          (t.path = e.path + t.authority + t.path),
            (t.protocol = e.protocol),
            (t.authority = e.authority);
          break;
        }
        case 'minemapdatad': {
          const e = Pr(fr(pr.DYN_URL || '', o));
          (t.path = e.path + t.authority + t.path),
            (t.protocol = e.protocol),
            (t.authority = e.authority);
          break;
        }
        case 'minemapdatam': {
          const e = Pr(fr(pr.MERGE_URL || '', o));
          (t.path = e.path + t.authority + t.path),
            (t.protocol = e.protocol),
            (t.authority = e.authority);
          break;
        }
        case 'minemapdatao': {
          const e = Pr(fr(pr.OTHER_URL || '', o));
          (t.path = e.path + t.authority + t.path),
            (t.protocol = e.protocol),
            (t.authority = e.authority);
          break;
        }
        case 'mineserver': {
          const e = Pr(fr(pr.SERVER_URL || '', o));
          (t.path = e.path + t.authority + t.path),
            (t.protocol = e.protocol),
            (t.authority = e.authority);
          break;
        }
        case 'cloudservice': {
          const e = Pr(fr(pr.SERVER_URL || '', o));
          (t.path = `/${t.authority}${t.path}`),
            (t.protocol = e.protocol),
            (t.authority = e.authority);
          break;
        }
        case 'mineservice': {
          const e = Pr(fr(pr.SERVICE_URL || '', o));
          (t.path = e.path + t.path), (t.protocol = e.protocol), (t.authority = e.authority);
          break;
        }
      }
      return pr.REQUIRE_ACCESS_TOKEN
        ? ((s = s || pr.APP_KEY),
          (r = r || pr.SOLU),
          (n = n || pr.DATA_VERSION),
          (i = i || pr.KEY)
            ? t.params.push(`key=${i}`)
            : s
            ? t.params.push(`appKey=${s}`)
            : pr.ACCESS_TOKEN && t.params.push(`token=${pr.ACCESS_TOKEN}`),
          e.defined(r) && t.params.push(`solu=${r}`),
          n && t.params.push(`version=${n}`),
          Mr(t))
        : Mr(t);
    }
    function yr(e) {
      return (
        0 === e.indexOf('minemap:') ||
        0 === e.indexOf('minemapdata:') ||
        0 === e.indexOf('minemapdatad:') ||
        0 === e.indexOf('minemapdatam:') ||
        0 === e.indexOf('minemapdatao:') ||
        0 === e.indexOf('mineserver:') ||
        0 === e.indexOf('cloudservice:') ||
        0 === e.indexOf('mineservice:')
      );
    }
    const Tr = function (e, t, i) {
        if (!yr(e)) return e;
        const s = Pr(e);
        return (s.path = `/styles/v1${s.path}`), gr(s, t, i);
      },
      xr = function (t, i) {
        return e.defined(t) && yr(t) ? gr(Pr(t), i) : t;
      },
      vr = (e) => {
        if (!yr(e)) return e;
        const t = Pr(e);
        return `${pr.SRC_URL}/${t.authority}${t.path}`;
      },
      br = function (e, t, i) {
        if (!yr(e)) return e;
        const s = Pr(e);
        return (s.path = `/v4/${s.authority}.json`), s.params.push('secure'), gr(s, t, i);
      },
      wr = function (e) {
        const t = Pr(e.url);
        return (
          (t.path = e.url.startsWith('http')
            ? `${e.url}${e.format}${e.extension}`
            : `${pr.SRC_URL}/sprite/sprite${e.format}${e.extension}`),
          (Array.isArray(pr.spriteUrl) &&
            pr.spriteUrl[e.index] &&
            `${pr.spriteUrl[e.index]}${e.format}${e.extension}`) ||
            t.path
        );
      },
      Cr = /(\.(png|jpg)\d*)(?=$)/,
      Sr = function (t, i, s, r) {
        if (!t || (t.indexOf('auth=true') < 0 && !yr(t)))
          return 0 === t.indexOf('//') ? `${e.window.document.location.protocol}${t}` : t;
        const n = Pr(t);
        return (
          (n.path = n.path.replace(
            Cr,
            `${e.exported.devicePixelRatio >= 2 || 512 === s ? '@2x' : ''}${
              e.exported.supportsWebp ? '.webp' : '$1'
            }`,
          )),
          (function (e) {
            for (let t = 0; t < e.length; t++)
              0 === e[t].indexOf('access_token=tk.') &&
                (e[t] = `access_token=${pr.ACCESS_TOKEN || ''}`);
          })(n.params),
          gr(n, void 0, void 0, void 0, void 0, r)
        );
      },
      Er = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
    function Pr(e) {
      const t = e.match(Er);
      if (!t) {
        const t = e.match(/^\/\/([^/?]+)(\/[^?]+)?\??(.+)?/);
        if (!t) throw new Error('Unable to parse URL object');
        return {
          protocol: '',
          authority: t[1],
          path: t[2] || '/',
          params: t[3] ? t[3].split('&') : [],
        };
      }
      return {
        protocol: t[1],
        authority: t[2],
        path: t[3] || '/',
        params: t[4] ? t[4].split('&') : [],
      };
    }
    function Mr(t) {
      const i = t.params.length ? `?${t.params.join('&')}` : '';
      return t.protocol && t.protocol.length > 0
        ? `${t.protocol}://${t.authority}${t.path}${i}`
        : `${e.window.document.location.protocol}//${t.authority}${t.path}${i}`;
    }
    class Ar extends E {
      constructor(t) {
        super(), (this.isSceneModel = !0);
        let { position: i, scale: s, rotation: r, quaternion: n, matrix: o } = t;
        if (
          ((this._options = t),
          (this.opaqueList = []),
          (this.translucentList = []),
          (this.animationPropertyCollection = new e.AnimationPropertyCollection()),
          (this.id = e.defaultValue(t.id, void 0)),
          (this.modelFolder = e.defaultValue(t.modelFolder, void 0)),
          (this._data = e.defaultValue(t.data, void 0)),
          (this.lightingModel = e.defaultValue(t.lightingModel, e.LightingModelType.NONE)),
          (this.classificationType = e.defaultValue(
            t.classificationType,
            e.ClassificationType.NONE,
          )),
          (this.type = '3d-model'),
          e.defined(t.positions) &&
            t.positions.length > 0 &&
            ((this.type = '3d-model-instance'),
            (this.modelInstanceCollection = new e.ModelInstanceCollection({
              instances: e.ModelInstanceCollection.generateInstanceModelMatrix({
                positions: t.positions,
                scales: t.scales,
                rotations: t.rotations,
                shows: t.shows,
                colors: t.colors,
                instanceNames: t.instanceNames,
              }),
              type: this.type,
              rootId: this.id,
            })),
            (o = new e.Matrix4())),
          (this.properties = e.defaultValue(t.properties, void 0)),
          (this._map = e.defaultValue(t.map, void 0)),
          (this._visibility = e.defaultValue(t.visibility, 'visible')),
          (this.loadedCallback = e.defaultValue(t.loaded, void 0)),
          (this.useMipmap = e.defaultValue(t.useMipmap, !1)),
          (this.clippingPlanes = e.defaultValue(t.clippingPlanes, void 0)),
          (this._allowPick = e.defaultValue(t.allowPick, !0)),
          (this.backCulling = e.defaultValue(t.backCulling, !1)),
          (this.minzoom = e.defaultValue(t.minzoom, 0)),
          (this.maxzoom = t.maxzoom),
          (this._activeAnimation = e.defaultValue(t.activeAnimation, !0)),
          (this._currentAnimations = []),
          (this._gltfJson = void 0),
          (this._boundingVolume = void 0),
          o)
        )
          this.applyMatrix(o);
        else {
          if (!i) throw new e.DeveloperError('position must be provided or matrix be provided');
          {
            if (!(Array.isArray(i) || i instanceof e.Vector3))
              throw new e.DeveloperError('position must be an array or Vector3!');
            let t;
            i instanceof e.Vector3
              ? (t = e.Vector3.unpack(i))
              : ((t = new e.Vector3(...i)),
                console.warn('请规范position的类型! 使用minemap.Math.Vector3替换!'));
            const o = e.Transforms.cartographicToFixedFrame(t);
            if (r) {
              if (!Array.isArray(r)) throw new e.DeveloperError('rotation must be an array');
              this._rotation = r;
              const t = new e.Matrix4();
              t.rotateX(r[0] * e.CONSTS.TRANSFORM.DEG_TO_RAD),
                t.rotateY(r[1] * e.CONSTS.TRANSFORM.DEG_TO_RAD),
                t.rotateZ(r[2] * e.CONSTS.TRANSFORM.DEG_TO_RAD),
                o.multiplyRight(t);
            } else if (n) {
              if (!(n instanceof e.Quaternion))
                throw new e.DeveloperError('quaternion must be an Quaternion instance');
              const t = new e.Matrix4();
              t.fromQuaternion(n), o.multiplyRight(t);
            }
            if (s) {
              if (!(Array.isArray(s) || s instanceof e.Vector3))
                throw new e.DeveloperError('scale must be an array or Vector3!');
              const t = new e.Matrix4();
              t.scale(s), o.multiplyRight(t);
            }
            this.applyMatrix(o);
          }
        }
        const a = this.matrix.clone(),
          l = this.position.clone(),
          h = e.Transforms.eastNorthUpToFixedFrame(l.clone()).invert();
        this.originalRotationScaleMatrix = a.multiplyLeft(h);
      }
      set rotation(t) {
        const i = e.Transforms.cartesian3ToCartographic(new e.Vector3(...this.position)),
          s = e.Transforms.cartographicToFixedFrame(new e.Vector3(...i)),
          r = new e.Matrix4();
        r.rotateX(t[0] * e.CONSTS.TRANSFORM.DEG_TO_RAD),
          r.rotateY(t[1] * e.CONSTS.TRANSFORM.DEG_TO_RAD),
          r.rotateZ(t[2] * e.CONSTS.TRANSFORM.DEG_TO_RAD),
          s.multiplyRight(r),
          (this.quaternion = new e.Quaternion().fromRotationMatrix4(s)),
          (this._rotation = t),
          this.updateMatrixWorld(!0);
      }
      get rotation() {
        return this._rotation;
      }
      get visibility() {
        return this._visibility;
      }
      set visibility(e) {
        for (let t = 0; t < this.opaqueList.length; t++) this.opaqueList[t].show = 'visible' === e;
        for (let t = 0; t < this.translucentList.length; t++)
          this.translucentList[t].show = 'visible' === e;
        this._visibility = e;
      }
      get scale() {
        return this._scale;
      }
      set scale(t) {
        t instanceof e.Vector3
          ? ((this.unmodified = !1),
            (this._scale = t),
            this.updateMatrixWorld(!0),
            (this._boundingVolume = this.#g()))
          : console.error(
              'The current value is unKnown type! Please use minemap.Math.Vector3 instaded!',
            );
      }
      get activeAnimation() {
        return this._activeAnimation;
      }
      set activeAnimation(t) {
        e.isBoolean(t) && (this._activeAnimation = t);
      }
      get animationsName() {
        let t;
        if (e.defined(this._gltfJson) && this._gltfJson.animations) {
          t = [];
          for (let e = 0; e < this._gltfJson.animations.length; e++)
            t.push(this._gltfJson.animations[e].name);
        }
        return t;
      }
      get currentAnimations() {
        return this._currentAnimations;
      }
      set currentAnimations(t) {
        if (!(t instanceof Array)) return;
        const i = this;
        i._currentAnimations.length = 0;
        const s = this._gltfJson.animations;
        e.defined(s) &&
          s.length > 0 &&
          s.forEach((e) => {
            for (let s = 0; s < t.length; s++) {
              if (e.name === t[s]) {
                e.play(), i._currentAnimations.push(t[s]);
                break;
              }
              e.stop();
            }
          });
      }
      get allowPick() {
        return this._allowPick;
      }
      set allowPick(e) {
        this._allowPick = e;
        let t = [];
        t = t.concat(this.translucentList, this.opaqueList);
        for (let i = 0; i < t.length; i++)
          (t[i].allowPick = e),
            e &&
              !t[i]._owner &&
              ((t[i]._owner = t[i]._geometry),
              t[i].update(this._map.painter, this._map.painter.frameState));
      }
      #g() {
        let t,
          i = [];
        if (e.defined(this.modelInstanceCollection))
          t = this.modelInstanceCollection.boundingVolume;
        else {
          (i = i.concat(this.opaqueList, this.translucentList)), (t = i[0].boundingVolume);
          for (let e = 1; e < i.length; e++) t.union(i[e].boundingVolume, t);
        }
        return t;
      }
      getBounds() {
        let t, i, s;
        if (
          ((t = this._boundingVolume),
          e.defined(t) || (t = this._boundingVolume = this.#g()),
          (i =
            t instanceof e.OrientedBoundingBox
              ? t.getBoundingMaximum(1)
              : t instanceof e.TileBoundingRegion
              ? t.boundingVolume.getBoundingMaximum()
              : t.getBoundingMaximum()),
          i)
        ) {
          const t = e.Transforms.DefaultEllipsoid.cartesianToCartographic(i.boundingMaxValue),
            r = e.Transforms.DefaultEllipsoid.cartesianToCartographic(i.boundingMinValue);
          s = new e.LngLatBounds([r[0], r[1]], [t[0], t[1]]);
        }
        return s;
      }
      addGlTF(t) {
        this.add(...t.scene.nodes),
          this.updateMatrixWorld(!0),
          (this._gltfJson = t),
          e.defined(this._gltfJson.animations) &&
            this._gltfJson.animations.length > 0 &&
            ((this._currentAnimations.length = 0),
            (this._currentAnimations[0] = this._gltfJson.animations[0].name));
        const i = e.getPrimitives(this._gltfJson);
        e.defined(this.modelInstanceCollection) &&
          ((this.modelInstanceCollection._primitivesInstance = i),
          (this.modelInstanceCollection.dirty = !0)),
          this.separatePrimitives(i);
      }
      async load() {
        const e = await this._loadModel();
        this.addGlTF(e), this.#y();
      }
      #y() {
        (this._setInstancePropertiesState = 'ready'),
          (this.state = 'loaded'),
          this.loadedCallback && this.loadedCallback(this);
      }
      async _loadModel() {
        let e;
        return (
          (e =
            'string' == typeof this._data
              ? await this._processStringGltf()
              : await this._processBinaryGltf()),
          e
        );
      }
      async _processStringGltf() {
        const { _transformRequest: t } = this._map,
          i = xr(this._data),
          s = { request: t(e.exported.resolveURL(i), e.ResourceType.Source) },
          r = await ut(
            s.request.url,
            _r,
            {
              gltf: { postProcess: !0, loadImages: !0 },
              context: this._map.painter.context,
              modelInstanceCollection: this.modelInstanceCollection,
              useMipmap: this.useMipmap,
              clippingPlanes: this.clippingPlanes,
              allowPick: this.allowPick,
              dispatcher: this._map.style.dispatcher,
              transformRequest: t,
            },
            0,
            xr(this.modelFolder),
          );
        if (r) {
          if (this._removed || (r && r.abandoned)) return;
          return (this._loaded = !0), (this.state = 'parsing'), (this.result = r), r;
        }
        return null;
      }
      async _processBinaryGltf() {
        if (this._data.byteLength)
          return await _t(
            this._data,
            _r,
            {
              gltf: { postProcess: !0, loadImages: !0 },
              modelInstanceCollection: this.modelInstanceCollection,
              clippingPlanes: this.clippingPlanes,
              allowPick: this.allowPick,
            },
            null,
          );
        let e;
        if (
          ((e = this._data.buffers[0].data
            ? (function (e) {
                return e.map((e) => ({
                  byteLength: e.byteLength,
                  arrayBuffer: e.data[0].buffer,
                  name: e.name,
                  byteOffset: 0,
                }));
              })(this._data.buffers)
            : (function (e) {
                return e.map((e) => {
                  const t = new Uint8Array(
                    ((i = e.uri),
                    window
                      .atob(i.substring(i.indexOf(',') + 1))
                      .split('')
                      .map((e) => e.charCodeAt(0))),
                  );
                  var i;
                  return {
                    byteLength: t.byteLength,
                    arrayBuffer: t.buffer,
                    name: e.name || 'name-undefined',
                    byteOffset: 0,
                  };
                });
              })(this._data.buffers)),
          (this._data.buffers = e),
          !(this._data.images && this._data.images.length > 0))
        )
          return ir({ json: this._data, buffers: this._data.buffers, baseUri: this.modelFolder });
        !(function (e, t, i) {
          const s = [];
          for (let i = 0; i < e.length; i++) {
            const r = Ui(e[i].uri, t);
            s.push(ut(r, Ut, {}, 0, null));
          }
          Promise.all(s).then((e) => {
            i(e);
          });
        })(this._data.images, { modelFolder: this.modelFolder }, (e) =>
          ir({
            json: this._data,
            buffers: this._data.buffers,
            images: e,
            baseUri: this.modelFolder,
          }),
        );
      }
      separatePrimitives(t) {
        const i = (function (t) {
          const i = {};
          return (
            e.checkIsVectorShadowVolumeDataType(t.classificationType) && (i.SHADOW_VOLUME = !0),
            (i.NUM_VIDEOS = 0),
            t.videoMatchOptions && (i.NUM_VIDEOS = t.videoMatchOptions.length),
            t.lightingModel === e.LightingModelType.PBR
              ? ((i.USE_PBR = !0), (i.USE_IBL = !0))
              : ((i.USE_PBR = !1), (i.USE_IBL = !1)),
            (i.PHONG_LIGHT = t?.lightingModel === e.LightingModelType.PHONG),
            i
          );
        })(this);
        for (let s = 0; s < t.length; s++) {
          if (
            ((t[s].rootId = this.id),
            (t[s]._material.backCulling = this.backCulling),
            e.defined(t[s]._material) && t[s]._material._hasMorph)
          ) {
            const e = this;
            t[s]._material._uniforms.set(
              'u_morphTargetInfluences',
              () => e.animationResult.u_morphTargetInfluences,
            );
          }
          delete i.JOINT_MATRIX_CNT;
          const r = t[s].skinsIndex;
          if (
            e.defined(r) &&
            (e.defined(this._gltfJson) &&
              e.defined(this._gltfJson.skins) &&
              this._gltfJson.skins.length > 0 &&
              (i.JOINT_MATRIX_CNT = this._gltfJson.skins[r].joints.length),
            (t[s]._material.defines = i),
            e.defined(this._gltfJson) &&
              e.defined(this._gltfJson.skins) &&
              this._gltfJson.skins.length > 0)
          ) {
            const e = this;
            t[s]._material._uniforms.set('u_jointMatrix', () => {
              const t = e.animationResult,
                i = [];
              for (let e = 0; t?.u_jointMatrixs && e < t.u_jointMatrixs[r].length; e++)
                i.push(t.u_jointMatrixs[r][e]);
              return i;
            });
          }
          (t[s].modelInstanceCollection = this.modelInstanceCollection),
            (this.modelInstanceCollection || this.animationPropertyCollection?.size > 0) &&
              (t[s].modelInstanceType = this.type),
            (t[s].show = 'visible' === this._visibility),
            t[s]._material.isTranslucent
              ? this.translucentList.push(t[s])
              : this.opaqueList.push(t[s]);
        }
      }
      updateAnimation() {
        const e = this.animationPropertyCollection.getAll();
        1 === e.length
          ? e[0].updateAnimation(this)
          : console.warn(`id为"${this.id}"的gltf轨迹动画只能有1个`);
      }
      update(t) {
        if ('loaded' === this.state) {
          e.defined(this._boundingVolume) || (this._boundingVolume = this.#g()),
            this.zoomControl(),
            this.activeAnimation &&
              (this.animationResult = ur.updateAnimation({ gltfJson: this._gltfJson })),
            this.animationPropertyCollection &&
              this.animationPropertyCollection.size > 0 &&
              this.updateAnimation();
          for (let e = 0; e < this.opaqueList.length; e++)
            this.opaqueList[e]._material.clippingPlanes = this.clippingPlanes;
          for (let e = 0; e < this.translucentList.length; e++)
            this.translucentList[e]._material.clippingPlanes = this.clippingPlanes;
          if (e.defined(this.modelInstanceCollection)) {
            this.modelInstanceCollection.update({ context: t.framebuffer.context });
            for (let e = 0; e < this.opaqueList.length; e++) {
              const t = this.opaqueList[e]._geometry;
              t._segmentVector.segments[0].instancesCount !==
                this.modelInstanceCollection._instances.size &&
                ((t._segmentVector.segments[0].instancesCount =
                  this.modelInstanceCollection._instances.size),
                (t.dynamicLayoutBuffer1 = this.modelInstanceCollection?.instanceBuffer));
            }
            for (let e = 0; e < this.translucentList.length; e++) {
              const t = this.translucentList[e]._geometry;
              t._segmentVector.segments[0].instancesCount !==
                this.modelInstanceCollection._instances.size &&
                ((t._segmentVector.segments[0].instancesCount =
                  this.modelInstanceCollection._instances.size),
                (t.dynamicLayoutBuffer1 = this.modelInstanceCollection?.instanceBuffer));
            }
          }
        }
      }
      setInstanceProperties() {
        this.modelInstanceCollection.update({ context: this._map.painter.context }),
          Ar.#T(this.translucentList, this),
          Ar.#T(this.opaqueList, this);
      }
      zoomControl() {
        let e = [];
        e = e.concat(this.translucentList, this.opaqueList);
        const t = e.filter((e) => !0 === e.show);
        (0 !== t.length && t.length !== e.length) ||
          (void 0 !== this.minzoom && void 0 !== this.maxzoom
            ? this._map.getZoom() < this.minzoom || this._map.getZoom() > this.maxzoom
              ? this.controlDisplay(e, !1)
              : 'visible' === this.visibility && this.controlDisplay(e, !0)
            : void 0 !== this.minzoom
            ? this._map.getZoom() < this.minzoom
              ? this.controlDisplay(e, !1)
              : 'visible' === this.visibility && this.controlDisplay(e, !0)
            : void 0 !== this.maxzoom &&
              (this._map.getZoom() > this.maxzoom
                ? this.controlDisplay(e, !1)
                : 'visible' === this.visibility && this.controlDisplay(e, !0)));
      }
      controlDisplay(e, t) {
        for (let i = 0; i < e.length; i++) e[i].show = t;
      }
      loaded() {
        return 'loaded' === this.state;
      }
      destroy() {
        if ('loaded' !== this.state)
          throw new Error(`sceneComponent "${this.id}" cannot be removed while it is not loaded`);
        if (this.animationPropertyCollection && this.animationPropertyCollection.size > 0)
          throw new Error(
            `sceneComponent "${this.id}" cannot be removed while animation is using it`,
          );
        for (let e = 0; e < this.opaqueList.length; e++) this.opaqueList[e].destroy();
        for (let e = 0; e < this.translucentList.length; e++) this.translucentList[e].destroy();
        for (const e in this) Object.hasOwnProperty.call(this, e) && (this[e] = null);
      }
      static #T(e, t) {
        if (0 !== e.length)
          for (const i of e) {
            const e = i._geometry,
              s = i._material,
              r = e._segmentVector.segments[0];
            (r.isInstance = !0),
              (r.instancesCount = t.modelInstanceCollection?._instances?.size || 0),
              (e.dynamicLayoutBuffer1 = t.modelInstanceCollection?.instanceBuffer),
              (s.isInstance = !0),
              (s.defines.INSTANCE_MATRIX = !0),
              (i.modelInstanceCollection = t.modelInstanceCollection),
              (i.modelInstanceType = t.type);
          }
      }
    }
    class Rr extends e.Material {
      constructor(t) {
        if (
          (super(t),
          (this.type = 'BillboardMaterial'),
          (this._image = t.image),
          (this._flipY = e.defaultValue(t.flipY, !1)),
          (this._imageDirty = !!this._image),
          (this._imageUrl = t.imageUrl),
          (this._sizeattenuation = t.sizeattenuation),
          this._imageUrl && this.#x(this._imageUrl),
          (this._texture = e.defaultValue(t.texture, null)),
          (this._position = t.position),
          (this._scale = t.scale),
          (this._center = e.defaultValue(t.center, new e.Vector2(0, 0))),
          (this._rotation = e.defaultValue(t.rotation, 0)),
          (this._pixelResolution = e.defaultValue(t.pixelResolution, null)),
          (this._modelMatrix = void 0),
          (this._scaleMatrix = void 0),
          t.color)
        )
          if (t.color instanceof e.Vector4)
            this._color = e.defaultValue(t.color, new e.Vector4(1, 0.6, 0.3, 1));
          else {
            const i = e.Color.parse(t.color);
            this._color = e.defaultValue(
              new e.Vector4(i.r, i.g, i.b, i.a),
              new e.Vector4(1, 0.6, 0.3, 1),
            );
          }
        (this._uvScale = void 0),
          (this._modelMatrixDirty = !0),
          (this.defines = {
            USE_BILLBOARDTEXTURE:
              null != this._imageUrl || null != this._image || null != this._texture,
            SIZEATTENUATION: 1 == this._sizeattenuation,
            FIXED_PIXEL_SIZE: !!this._pixelResolution,
            BILLBOARD: !0,
          }),
          this.isTranslucent && (this.renderState.depthMask = e.renderStateEnum.disableDepthMask);
      }
      set position(e) {
        (this._modelMatrixDirty = !0), (this._position = e);
      }
      set scale(e) {
        (this._modelMatrixDirty = !0), (this._scale = e);
      }
      set center(e) {
        this._center = e;
      }
      set rotation(e) {
        this._rotation = e;
      }
      set image(e) {
        (this._imageDirty = !0), (this._image = e);
      }
      set sizeattenuation(e) {
        (this._sizeattenuation = e), (this.defines = { SIZEATTENUATION: e });
      }
      set pixelResolution(e) {
        if (e && (!e.length || 2 !== e.length))
          throw new Error('公告板像素大小必须是长度为2的数组');
        (this._pixelResolution = e),
          (this.defines = { FIXED_PIXEL_SIZE: !!this._pixelResolution }),
          (this._modelMatrixDirty = !0);
      }
      update(e, t, i = {}) {
        super.update(e, t, i),
          this._modelMatrixDirty && this.#v(),
          this.#b(t, e),
          this._imageDirty && this.#w(e.context);
      }
      #v() {
        if (e.defined(this._position)) {
          const t = e.Transforms.cartographicToFixedFrame(this._position);
          if (this._pixelResolution) this._modelMatrix = t;
          else {
            const i = new e.Matrix4().makeScale(this._scale[0], this._scale[1], this._scale[2]);
            (this._modelMatrix = t.multiplyRight(i)), (this._scaleMatrix = e.Matrix4.IDENTITY);
          }
        } else (this._modelMatrix = void 0), (this._scaleMatrix = new e.Matrix4().makeScale(this._scale[0], this._scale[1], this._scale[2]));
        this._modelMatrixDirty = !1;
      }
      #b(t, i) {
        (this.uniforms = new Map([
          [
            'u_MvMatrix',
            () =>
              this._modelMatrix
                ? t.camera.getViewMatrix().multiplyRight(this._modelMatrix)
                : void 0,
          ],
          ['u_center', () => this._center],
          ['u_rotation', () => this._rotation],
          [
            'u_BaseColorSampler',
            () => {
              const t = e.defaultValue(this._texture, i.context.defaultTexture);
              return t.bind(e.WebGLConstants.LINEAR, e.WebGLConstants.CLAMP_TO_EDGE), t;
            },
          ],
          ['u_ProjectionMatrix', () => t.camera.getProjectionMatrix()],
          ['u_Color', () => this._color],
          ['u_InvertViewMatrix', () => t.camera.getViewMatrix().invert()],
          ['u_ScaleMatrix', () => this._scaleMatrix],
          ['u_UVScale', () => this._uvScale],
          ['u_pixelResolution'],
        ])),
          this._pixelResolution &&
            this._uniforms.set('u_PixelResolution', () => new e.Vector2(this._pixelResolution));
      }
      async #x(t) {
        const i = this;
        this._image = await new Promise((s, r) => {
          e.getImage({ url: t, imageBitmapOptions: { premultiplyAlpha: 'none' } }, (e, t) => {
            if (e) throw (r(e), new Error(e));
            (i._imageDirty = !0), s(t);
          });
        });
      }
      #w(t) {
        (this._imageDirty = !1),
          this._texture
            ? (this._texture.upload(this._image), (this._texture._hasSetSampler = !1))
            : (this._texture = new e.Texture({
                context: t,
                image: this._image,
                pixelFormat: e.WebGLConstants.RGBA,
                flipY: this._flipY,
              }));
      }
      serialize() {}
      destroy() {
        (this.type = null),
          (this.texture = null),
          (this._scale = null),
          (this._center = null),
          (this._rotate = null),
          (this._pixelResolution = null),
          (this._needInitUniforms = !1),
          (this._modelMatrixDirty = !1),
          this._texture && this._texture.destroy();
      }
    }
    const Ir = e.createLayout([
      { name: 'a_POSITION', type: 'Float32', components: 3 },
      { name: 'a_TEXCOORD_0', type: 'Float32', components: 2 },
    ]);
    class Or extends e.Geometry {
      constructor() {
        super({}),
          (this._vertBuffer = void 0),
          (this._indexBuffer = void 0),
          (this._segmentVector = void 0),
          (this.primitiveType = e.WebGLConstants.TRIANGLES),
          (this._vertexArray = new e.StructArrayLayout5f20()),
          (this._indicesArray = new e.StructArrayLayout3ui6()),
          (this.vertices = [
            -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1,
          ]),
          (this.indices = [0, 1, 2, 0, 2, 3]),
          this.#v(),
          (this.boundingSphere = null),
          (this.boundingBox = null);
      }
      #v() {
        for (let e = 0; e < this.indices.length; e += 3)
          this._indicesArray.emplaceBack(this.indices[e], this.indices[e + 1], this.indices[e + 2]);
        for (let e = 0; e < this.vertices.length; e += 5)
          this._vertexArray.emplaceBack(
            this.vertices[e],
            this.vertices[e + 1],
            this.vertices[e + 2],
            this.vertices[e + 3],
            this.vertices[e + 4],
          );
      }
      update(t) {
        const i = t.painter.context;
        (this._vertBuffer && this._indexBuffer && this._segmentVector) ||
          ((this._vertBuffer = i.createVertexBuffer(this._vertexArray, Ir.members, !1)),
          (this._indexBuffer = i.createIndexBuffer(this._indicesArray, !1)),
          (this._segmentVector = e.SegmentVector.simpleSegment(0, 0, 4, 2)));
      }
      serialize() {}
      destroy() {
        super.destroy(),
          (this._vertBuffer = void 0),
          (this._indexBuffer = void 0),
          (this._segmentVector = void 0),
          (this._vertexArray = void 0),
          (this.indices = void 0);
      }
    }
    class Lr {
      constructor(e) {
        (this._map = e), (this._animationCollection = new Map()), (this._billboardId = new Map());
      }
      get animations() {
        return this._animationCollection;
      }
      getById(e) {
        let t;
        return this.animations.has(e) && (t = this.animations.get(e)), t;
      }
      getByIndex(t) {
        let i;
        const s = [...this.animations][t];
        return e.defined(s) && (i = s[1]), i;
      }
      load(t) {
        let i;
        return (
          (i =
            'string' == typeof t
              ? new Promise((i) => {
                  e.getJSON(br(t), (e, t) => {
                    i(t);
                  });
                })
              : t),
          i
        );
      }
      add(t) {
        const i = this.load(t),
          s = this;
        return Promise.resolve(i)
          .then((t) => {
            if (e.defined(t)) return s.process(t);
          })
          .catch((e) => {
            throw new Error(e);
          });
      }
      contains(t) {
        let i = !1;
        return e.defined(t) && this.animations.has(t.id) && (i = !0), i;
      }
      remove(t) {
        let i = !1;
        return (
          e.defined(t) &&
            e.defined(t.id) &&
            this.animations.has(t.id) &&
            (i = this.removeById(t.id)),
          i
        );
      }
      removeAll() {
        const e = this;
        this.animations.forEach((t, i) => {
          e.removeById(i);
        });
      }
      removeById(t) {
        let i = this.getById(t),
          s = !1;
        if (e.defined(i))
          this.animations.delete(t),
            i._root.animationPropertyCollection.removeAll(!0),
            'BillboardMaterial' === i._root._material?.type && this._map.removePrimitive(i._root),
            e.defined(i._root.modelInstanceCollection) &&
              (i._root.modelInstanceCollection = void 0),
            e.defined(i._root.animationModelInstanceCollection) &&
              (i._root.animationModelInstanceCollection = void 0),
            i.actions.forEach((e) => {
              e.destroy();
            }),
            (i._root.animationPropertyCollection = null),
            (i._map = null),
            (i._root = null),
            (s = !0);
        else if (this._billboardId.has(t)) {
          for (const s of this._billboardId.get(t))
            (i = this.getById(s)),
              e.defined(i) &&
                (this._map.removePrimitiveById(s),
                this.animations.delete(s),
                i._root.animationPropertyCollection.removeAll(!0),
                e.defined(i._root.animationModelInstanceCollection) &&
                  (i._root.animationModelInstanceCollection = void 0),
                i.actions.forEach((e) => {
                  e.destroy();
                }),
                (i._root.animationPropertyCollection = null),
                (i._map = null),
                (i._root = null));
          s = !0;
        }
        return s;
      }
      process(t) {
        let i = [];
        if (e.defined(t.contents) && t.contents.length > 0)
          for (let e = 0; e < t.contents.length; e++) i = i.concat(Dr(this, t.contents[e]));
        else e.defined(t.id) && e.defined(t.type) && (i = i.concat(Dr(this, t)));
        return (
          this._map.trackingOptions &&
            i.forEach((e) => {
              e.trackingOptions = this._map.trackingOptions;
            }),
          i
        );
      }
      serialize() {
        const t = { document: 'Animation', contents: [] },
          i = [];
        return (
          this.animations.forEach((t, s) => {
            const r = {};
            let n, o;
            r.id = s;
            const l = t.actions[0]._clip.tracks,
              h = e.defined(l) ? t.actions[0]._clip.tracks[0].type : void 0;
            if (t._root instanceof e.Primitive)
              switch (h) {
                case 'trackingKeyframeTrack':
                case 'positionKeyframeTrack':
                  n = 'primitive';
                  break;
                case 'multiTrackingKeyframeTrack':
                case 'multiPositionKeyframeTrack':
                  n = 'primitiveInstance';
              }
            else if (t._root instanceof Ar)
              switch (h) {
                case 'trackingKeyframeTrack':
                case 'positionKeyframeTrack':
                  n = 'model';
                  break;
                case 'multiTrackingKeyframeTrack':
                case 'multiPositionKeyframeTrack':
                  n = 'modelInstance';
              }
            else t._root instanceof S && (n = 'extrusion');
            r.type = n;
            const c = [].concat(e.defined(h) ? l[0].values : []),
              _ = [];
            if ('modelInstance' === n || 'primitiveInstance' === n)
              for (let t = 0; t < c.length; t++) {
                const i = [].concat(c[t]),
                  s = [];
                for (let t = 0; t < i.length; t++) {
                  let r = i[t].clone();
                  (r = e.Cartographic.fromVector3(r)),
                    (r.x = e.toDegrees(r.x)),
                    (r.y = e.toDegrees(r.y)),
                    s.push(r.x),
                    s.push(r.y),
                    s.push(r.z);
                }
                _.push(s);
              }
            else
              for (let t = 0; t < c.length; t++) {
                let i = c[t].clone();
                (i = e.Cartographic.fromVector3(i)),
                  (i.x = e.toDegrees(i.x)),
                  (i.y = e.toDegrees(i.y)),
                  _.push(i.x),
                  _.push(i.y),
                  _.push(i.z);
              }
            _.length > 0 && (r.positions = _);
            const u = {},
              d = t.actions[0]._clip.startTime,
              m = t.actions[0]._clip.endTime,
              p = e.defined(l) ? l[0].times : void 0;
            switch (((u.start = d), (u.end = m), e.defined(p) && (u.steps = p), (r.times = u), h)) {
              case 'trackingKeyframeTrack':
              case 'multiTrackingKeyframeTrack':
                o = 'ellipsoid';
                break;
              case 'positionKeyframeTrack':
              case 'multiPositionKeyframeTrack':
                o = 'none';
                break;
              default:
                o = void 0;
            }
            e.defined(o) && (r.reference = o);
            let f = t.actions[0].loop;
            switch (f) {
              case a.LOOP_REPEAT:
                f = 'repeat';
                break;
              case a.LOOP_ONCE:
                f = 'once';
                break;
              case a.LOOP_NONE:
                f = 'none';
            }
            if (((r.loop = f), 'multiPositionKeyframeTrack' === h)) {
              const e = {};
              e.names = t.actions[0]._clip.tracks[0].primitiveNames;
              const i = [];
              for (let e = 0; e < t.actions[0]._clip.tracks[0].colors.length; e++) {
                const s = [];
                for (let i = 0; i < t.actions[0]._clip.tracks[0].colors[e].length; i++) {
                  const r = t.actions[0]._clip.tracks[0].colors[e][i].toString().split(','),
                    n = [];
                  n.push(parseFloat(r[0])),
                    n.push(parseFloat(r[1])),
                    n.push(parseFloat(r[2])),
                    n.push(parseFloat(r[3])),
                    s.push(n);
                }
                i.push(s);
              }
              (e.colors = i),
                (r.material = e),
                (r.rotations = t.actions[0]._clip.tracks[0]._angles);
            }
            i.push(r);
          }),
          (t.contents = i),
          i.length > 0 ? t : void 0
        );
      }
      update(e) {
        this.animations.forEach((t) => {
          t.update(e);
        });
      }
    }
    function Dr(t, i) {
      let s = [];
      for (let r = 0; r < Lr.updaters.length; r++) {
        const n = Lr.updaters[r](t, i);
        e.defined(n) && (e.defined(i.callback) && (n.callback = i.callback), (s = s.concat(n)));
      }
      return s;
    }
    function Br(e) {
      let t;
      return (
        (t =
          'modelInstance' === e.type || 'primitiveInstance' === e.type
            ? 'ellipsoid' === e.reference
              ? b
              : w
            : 'ellipsoid' === e.reference
            ? v
            : x),
        t
      );
    }
    function Vr(t, i) {
      if (!e.defined(i.id)) throw new Error('id is not defined!');
      let s;
      switch (i.type) {
        case 'primitive':
        case 'primitiveInstance':
        case 'billboard':
          s = t._map.getPrimitiveById(i.id);
          break;
        case 'model':
        case 'modelInstance':
          s = t._map.getSceneComponent(i.id);
          break;
        case 'extrusion':
          s = t._map.getSource(i.id);
      }
      if (!e.defined(s)) throw new Error(`${i.id} is not found!`);
      return s;
    }
    function Nr(e) {
      let t;
      switch (e.loop) {
        case 'repeat':
        default:
          t = a.LOOP_REPEAT;
          break;
        case 'once':
          t = a.LOOP_ONCE;
          break;
        case 'none':
          t = a.LOOP_NONE;
      }
      return t;
    }
    function kr(t) {
      if (!e.defined(t.times)) throw new Error(`${t.id}'s times is not defined!`);
      const i = t.times,
        s = e.JulianDate.fromIso8601(i.start),
        r = e.JulianDate.fromIso8601(i.end),
        n = e.JulianDate.secondsDifference(r, s);
      let o = i.steps;
      const a = t.positions;
      let l = 0,
        h = [];
      if (!e.defined(a) && 'extrusion' !== t.type) throw new Error('positions is not defined!');
      if (!e.defined(o)) {
        let i;
        if (((o = []), 'modelInstance' === t.type || 'primitiveInstance' === t.type))
          a.forEach((t) => {
            if (!(t instanceof Array)) throw new Error('Incorrect positions of instance!');
            if (t.length % 3 != 0) throw new Error("Incorrect number of instance's positions!");
            i = t.length / 3;
            const s = [];
            let r = 0;
            for (let s = 0; s < i - 1; s++) {
              const i = e.Vector3.fromArray(
                  e.Transforms.cartographicToCartesian3(t.slice(3 * s, 3 * s + 3)),
                ),
                r = e.Vector3.fromArray(
                  e.Transforms.cartographicToCartesian3(t.slice(3 * (s + 1), 3 * (s + 1) + 3)),
                ),
                n = e.Vector3.distance(i, r);
              h.push(n), (l += n);
            }
            for (let e = 0; e < i; e++)
              0 === e ? s.push(0) : ((r += h[e - 1]), s.push(n * (r / l)));
            (h = []), (l = 0), o.push(s);
          });
        else if ('extrusion' !== t.type) {
          if (a.length % 3 != 0) throw new Error('Incorrect number of positions!');
          i = a.length / 3;
          let t = 0;
          for (let t = 0; t < i - 1; t++) {
            const i = e.Vector3.fromArray(
                e.Transforms.cartographicToCartesian3(a.slice(3 * t, 3 * t + 3)),
              ),
              s = e.Vector3.fromArray(
                e.Transforms.cartographicToCartesian3(a.slice(3 * (t + 1), 3 * (t + 1) + 3)),
              ),
              r = e.Vector3.distance(i, s);
            h.push(r), (l += r);
          }
          for (let e = 0; e < i; e++) 0 === e ? o.push(0) : ((t += h[e - 1]), o.push(n * (t / l)));
        }
      }
      return {
        start: i.start,
        end: i.end,
        duration: n,
        steps: o,
        trackCalculation: { trackLength: l, trackSegments: h },
      };
    }
    function Fr(t) {
      const i = t.positions,
        s = t.rotations;
      if (!e.defined(s)) return;
      if (i.length !== s.length)
        throw new Error("positions's length must be equal than rotations's length!");
      let r,
        n,
        o = [];
      const a = [],
        l = Array(3);
      for (let e = 0; e < i.length; e++) {
        if (((r = i[e]), (n = s[e]), n.length % 3 != 0 || n.length < 3))
          throw new Error("Incorrect number of instance's rotations!");
        if (r.length > n.length) {
          const e = r.length - n.length;
          (l[0] = n[n.length - 3]),
            (l[1] = n[n.length - 2]),
            (l[2] = n[n.length - 1]),
            (o = o.concat(n));
          for (let t = 0; t < e; t++) o = o.concat(l);
          a.push(o);
        } else if (r.length < n.length) {
          const e = r.length - n.length;
          a.push(n.splice(n.length - 1 - e, e));
        } else a.push(n);
      }
      return a;
    }
    function Gr(e, t, i, s, r, n, o) {
      const a = new y(t, [new _(i, s, r, n, o)]);
      return e.animations.set(a.id, a), a;
    }
    Lr.updaters = [
      function (e, t) {
        if ('primitive' !== t.type && 'extrusion' !== t.type && 'model' !== t.type) return;
        const i = Br(t),
          s = t.positions,
          { start: r, end: n, duration: o, steps: a, trackCalculation: l } = kr(t),
          h = Vr(e, t);
        let c;
        'extrusion' !== t.type && (c = [new i('position', a, s)]);
        const _ = Gr(e, h, o, c, Nr(t), r, n);
        return t.autoPlay && _.play(), (_.trackCalculation = l), _;
      },
      function (t, i) {
        if ('modelInstance' !== i.type && 'primitiveInstance' !== i.type) return;
        const s = i.positions,
          { start: r, end: n, duration: o, steps: a, trackCalculation: l } = kr(i),
          h = Fr(i),
          c = i.translations,
          _ = (function (t) {
            if (e.defined(t.material) && e.defined(t.material.colors)) return t.material.colors;
          })(i),
          u = e.defined(i.material) ? i.material.names : void 0,
          d = i.trackIds,
          m = Nr(i),
          p = [new (Br(i))('position', a, s, h, c, null, _, u, d)],
          f = Gr(t, Vr(t, i), o, p, m, r, n);
        return i.autoPlay && f.play(), (f.trackCalculation = l), f;
      },
      function (t, i) {
        if ('billboard' !== i.type || !e.defined(i.extra)) return;
        if (!e.defined(i.positions)) throw new Error('positions is not defined!');
        if (!e.defined(i.id)) throw new Error('id is not defined!');
        const s = [],
          r = Fr(i),
          { start: n, end: o, duration: a, steps: l } = kr(i),
          h = i.positions.length,
          c = t._billboardId.get(i.id) || [],
          _ = [];
        for (let u = 0; u < h; u++) {
          const h = i.positions[u],
            d = i.translations ? i.translations[u] : null,
            m = r ? r[u] : null,
            p = l[u],
            f = `${i.id}_${u}`;
          let g;
          if (
            ((g = i.extra.scale
              ? Array.isArray(i.extra.scale[u])
                ? i.extra.scale[u]
                : i.extra.scale
              : [1, 1, 1]),
            _.push(f),
            c)
          ) {
            const e = c.indexOf(f);
            e > -1 && c.splice(e, 1);
          }
          let y = t._map.getPrimitiveById(f);
          if (y) {
            if ('BillboardMaterial' !== y._material.type)
              throw new e.DeveloperError(` duplicated in ${f} with different primitive type `);
            (y.animationPropertyCollection = new e.AnimationPropertyCollection()),
              (y._material.scale = g);
          } else {
            const i = new Or({}),
              s = new Rr({
                scale: g,
                center: new e.Vector2(0.5, 0.25),
                rotation: 0,
                color: [0, 0, 0, 0],
              });
            (y = new e.Primitive({ geometry: i, material: s, id: f, show: !1 })),
              t._map.addPrimitive(y);
          }
          const T = i.extra.image,
            v = {};
          for (const [e, t] of Object.entries(i.extra.imageInfo)) v[e] = t[u];
          const b = [new x(f, p, h, m, d, null, null, null, T, v)];
          T && v && b[0].parseImageInfo(T, v, t._map.painter.context);
          const w = Gr(t, y, a, b, Nr(i), n, o);
          e.defined(w) && s.push(w), i.autoPlay && w.play();
        }
        for (const e of c) t._map.removePrimitiveById(e);
        return t._billboardId.set(i.id, _), s;
      },
    ];
    const Ur = {
        create: function (t, i, s) {
          const r = e.window.document.createElement(t);
          return void 0 !== i && (r.className = i), s && s.appendChild(r), r;
        },
        createNS: function (t, i) {
          return e.window.document.createElementNS(t, i);
        },
      },
      zr = e.window.document && e.window.document.documentElement.style,
      Hr = zr && void 0 !== zr.userSelect ? 'userSelect' : 'WebkitUserSelect';
    let Wr;
    (Ur.disableDrag = function () {
      zr && Hr && ((Wr = zr[Hr]), (zr[Hr] = 'none'));
    }),
      (Ur.enableDrag = function () {
        zr && Hr && (zr[Hr] = Wr);
      }),
      (Ur.setTransform = function (e, t) {
        e.style.transform = t;
      });
    const jr = (function (e) {
      if (!zr) return null;
      for (let t = 0; t < e.length; t++) if (e[t] in zr) return e[t];
      return e[0];
    })(['transformOrigin', 'WebkitTransformOrigin']);
    (Ur.setTransformOrigin = function (e, t) {
      e.style[jr] = t;
    }),
      (Ur.getAllStyle = function (t) {
        return e.window.getComputedStyle(t);
      });
    let qr = !1;
    try {
      const t = Object.defineProperty({}, 'passive', {
        get() {
          qr = !0;
        },
      });
      e.window.addEventListener('test', t, t), e.window.removeEventListener('test', t, t);
    } catch (e) {
      qr = !1;
    }
    (Ur.addEventListener = function (e, t, i, s = {}) {
      e.addEventListener(t, i, 'passive' in s && qr ? s : s.capture);
    }),
      (Ur.removeEventListener = function (e, t, i, s = {}) {
        e.removeEventListener(t, i, 'passive' in s && qr ? s : s.capture);
      });
    const Xr = function (t) {
      t.preventDefault(), t.stopPropagation(), e.window.removeEventListener('click', Xr, !0);
    };
    function Zr(t, i, s) {
      const r = t.offsetWidth === i.width ? 1 : t.offsetWidth / i.width;
      return new e.pointGeometry3d((s.clientX - i.left) * r, (s.clientY - i.top) * r);
    }
    function $r(t, i, s) {
      if (t.length < i) return;
      let r = !0;
      for (let e = 0; e < t.length; e++) {
        if (t[e].error) return s(t[e].error);
        (t[e].image && t[e].json) || (r = !1);
      }
      if (!r) return;
      const n = {};
      for (let i = 0; i < t.length; i++) {
        const s = t[i],
          r = e.exported.getImageData(s.image),
          o = s.json;
        for (const t in o) {
          const {
              width: i,
              height: s,
              x: a,
              y: l,
              sdf: h,
              pixelRatio: c,
              stretchX: _,
              stretchY: u,
              content: d,
            } = o[t],
            m = new e.RGBAImage({ width: i, height: s });
          e.RGBAImage.copy(r, m, { x: a, y: l }, { x: 0, y: 0 }, { width: i, height: s }),
            (n[t] = { data: m, pixelRatio: c, sdf: h, stretchX: _, stretchY: u, content: d });
        }
      }
      s(null, n);
    }
    function Kr(e) {
      const { userImage: t } = e;
      return !!(t && t.render && t.render()) && (e.data.replace(new Uint8Array(t.data.buffer)), !0);
    }
    (Ur.suppressClick = function () {
      e.window.addEventListener('click', Xr, !0),
        e.window.setTimeout(() => {
          e.window.removeEventListener('click', Xr, !0);
        }, 0);
    }),
      (Ur.mousePos = function (e, t) {
        const i = e.getBoundingClientRect();
        return Zr(e, i, (t = t.touches ? t.touches[0] : t));
      }),
      (Ur.touchPos = function (e, t) {
        const i = e.getBoundingClientRect(),
          s = [];
        for (let r = 0; r < t.length; r++) s.push(Zr(e, i, t[r]));
        return s;
      }),
      (Ur.mouseButton = function (t) {
        return void 0 !== e.window.InstallTrigger &&
          2 === t.button &&
          t.ctrlKey &&
          e.window.navigator.platform.toUpperCase().indexOf('MAC') >= 0
          ? 0
          : t.button;
      }),
      (Ur.remove = function (e) {
        e.parentNode && e.parentNode.removeChild(e);
      });
    class Yr extends e.Evented {
      constructor(t = {}) {
        super(),
          (this.anisotropy = t.anisotropy || 0),
          (this.images = {}),
          (this.updatedImages = {}),
          (this.callbackDispatchedThisFrame = {}),
          (this.loaded = !1),
          (this.requestors = []),
          (this.patterns = {}),
          (this.atlasImage = new e.RGBAImage({ width: 1, height: 1 })),
          (this.dirty = !0);
      }
      isLoaded() {
        return this.loaded;
      }
      setLoaded(e) {
        if (this.loaded !== e && ((this.loaded = e), e)) {
          for (const { ids: e, callback: t } of this.requestors) this._notify(e, t);
          this.requestors = [];
        }
      }
      getImage(e) {
        return this.images[e];
      }
      addImage(e, t) {
        this._validate(e, t) && (this.images[e] = t);
      }
      _validate(t, i) {
        let s = !0;
        return (
          this._validateStretch(i.stretchX, i.data && i.data.width) ||
            (this.fire(new e.ErrorEvent(new Error(`Image "${t}" has invalid "stretchX" value`))),
            (s = !1)),
          this._validateStretch(i.stretchY, i.data && i.data.height) ||
            (this.fire(new e.ErrorEvent(new Error(`Image "${t}" has invalid "stretchY" value`))),
            (s = !1)),
          this._validateContent(i.content, i) ||
            (this.fire(new e.ErrorEvent(new Error(`Image "${t}" has invalid "content" value`))),
            (s = !1)),
          s
        );
      }
      _validateStretch(e, t) {
        if (!e) return !0;
        let i = 0;
        for (const s of e) {
          if (s[0] < i || s[1] < s[0] || t < s[1]) return !1;
          i = s[1];
        }
        return !0;
      }
      _validateContent(e, t) {
        return !(
          e &&
          (4 !== e.length ||
            e[0] < 0 ||
            t.data.width < e[0] ||
            e[1] < 0 ||
            t.data.height < e[1] ||
            e[2] < 0 ||
            t.data.width < e[2] ||
            e[3] < 0 ||
            t.data.height < e[3] ||
            e[2] < e[0] ||
            e[3] < e[1])
        );
      }
      updateImage(e, t) {
        (t.version = this.images[e].version + 1),
          (this.images[e] = t),
          (this.updatedImages[e] = !0);
      }
      removeImage(e) {
        const t = this.images[e];
        delete this.images[e],
          delete this.patterns[e],
          t.userImage && t.userImage.onRemove && t.userImage.onRemove();
      }
      listImages() {
        return Object.keys(this.images);
      }
      getImages(e, t) {
        let i = !0;
        if (!this.isLoaded()) for (const t of e) this.images[t] || (i = !1);
        this.isLoaded() || i ? this._notify(e, t) : this.requestors.push({ ids: e, callback: t });
      }
      _notify(t, i) {
        const s = {};
        for (const i of t) {
          this.images[i] || this.fire(new e.Event('styleimagemissing', { id: i }));
          const t = this.images[i];
          t
            ? (s[i] = {
                data: t.data.clone(),
                pixelRatio: t.pixelRatio,
                sdf: t.sdf,
                version: t.version,
                stretchX: t.stretchX,
                stretchY: t.stretchY,
                content: t.content,
                hasRenderCallback: Boolean(t.userImage && t.userImage.render),
              })
            : e.warnOnce(
                `Image "${i}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`,
              );
        }
        i(null, s);
      }
      getPixelSize() {
        const { width: e, height: t } = this.atlasImage;
        return { width: e, height: t };
      }
      getPattern(t) {
        const i = this.patterns[t],
          s = this.getImage(t);
        if (!s) return null;
        if (i && i.position.version === s.version) return i.position;
        if (i) i.position.version = s.version;
        else {
          const i = { w: s.data.width + 2, h: s.data.height + 2, x: 0, y: 0 },
            r = new e.ImagePosition(i, s);
          this.patterns[t] = { bin: i, position: r };
        }
        return this._updatePatternAtlas(), this.patterns[t].position;
      }
      bind(t) {
        this.atlasTexture
          ? this.dirty && (this.atlasTexture.update(this.atlasImage), (this.dirty = !1))
          : (this.atlasTexture = new e.Texture({
              context: t,
              image: this.atlasImage,
              pixelFormat: e.WebGLConstants.RGBA,
              anisotropy: this.anisotropy,
            })),
          this.atlasTexture.bind(e.WebGLConstants.LINEAR, e.WebGLConstants.CLAMP_TO_EDGE);
      }
      _updatePatternAtlas() {
        const t = [];
        for (const e in this.patterns) t.push(this.patterns[e].bin);
        const { w: i, h: s } = e.potpack(t),
          r = this.atlasImage;
        r.resize({ width: i || 1, height: s || 1 });
        for (const t in this.patterns) {
          const { bin: i } = this.patterns[t],
            s = i.x + 1,
            n = i.y + 1,
            o = this.images[t].data,
            a = o.width,
            l = o.height;
          e.RGBAImage.copy(o, r, { x: 0, y: 0 }, { x: s, y: n }, { width: a, height: l }),
            e.RGBAImage.copy(o, r, { x: 0, y: l - 1 }, { x: s, y: n - 1 }, { width: a, height: 1 }),
            e.RGBAImage.copy(o, r, { x: 0, y: 0 }, { x: s, y: n + l }, { width: a, height: 1 }),
            e.RGBAImage.copy(o, r, { x: a - 1, y: 0 }, { x: s - 1, y: n }, { width: 1, height: l }),
            e.RGBAImage.copy(o, r, { x: 0, y: 0 }, { x: s + a, y: n }, { width: 1, height: l });
        }
        this.dirty = !0;
      }
      beginFrame() {
        this.callbackDispatchedThisFrame = {};
      }
      dispatchRenderCallbacks(e) {
        for (const t of e) {
          if (this.callbackDispatchedThisFrame[t]) continue;
          this.callbackDispatchedThisFrame[t] = !0;
          const e = this.images[t];
          Kr(e) && this.updateImage(t, e);
        }
      }
      destroy() {
        let t = Object.keys(this.images);
        return (
          t.forEach((e) => {
            this.removeImage(e);
          }),
          (t = []),
          e.destroyObject(this)
        );
      }
    }
    const Qr = 1e20;
    function Jr(e, t, i, s, r, n, o, a, l) {
      for (let h = t; h < t + s; h++) en(e, i * n + h, n, r, o, a, l);
      for (let h = i; h < i + r; h++) en(e, h * n + t, 1, s, o, a, l);
    }
    function en(e, t, i, s, r, n, o) {
      (n[0] = 0), (o[0] = -Qr), (o[1] = Qr), (r[0] = e[t]);
      for (let a = 1, l = 0, h = 0; a < s; a++) {
        r[a] = e[t + a * i];
        const s = a * a;
        do {
          const e = n[l];
          h = (r[a] - r[e] + s - e * e) / (a - e) / 2;
        } while (h <= o[l] && --l > -1);
        l++, (n[l] = a), (o[l] = h), (o[l + 1] = Qr);
      }
      for (let a = 0, l = 0; a < s; a++) {
        for (; o[l + 1] < a; ) l++;
        const s = n[l],
          h = a - s;
        e[t + a * i] = r[s] + h * h;
      }
    }
    class tn {
      constructor(e, t) {
        (this.localGlyphMode = 1),
          (this.requestTransform = e),
          (this.localIdeographFontFamily = t),
          (this.entries = {}),
          (this.localGlyphs = { 200: {}, 400: {}, 500: {}, 900: {} });
      }
      setURL(e) {
        this.url = e;
      }
      getGlyphs(t, i) {
        const s = [];
        for (const e in t) for (const i of t[e]) s.push({ stack: e, id: i });
        e.asyncAll(
          s,
          ({ stack: e, id: t }, i) => {
            let s = this.entries[e];
            s || (s = this.entries[e] = { glyphs: {}, requests: {} });
            let r = s.glyphs[t];
            if (void 0 !== r) return void i(null, { stack: e, id: t, glyph: r });
            if (((r = this._tinySDF(s, e, t)), r))
              return void i(null, { stack: e, id: t, glyph: r });
            const n = Math.floor(t / 256);
            if (256 * n > 65535) return void i(new Error('glyphs > 65535 not supported'));
            let o = s.requests[n];
            o ||
              ((o = s.requests[n] = []),
              tn.loadGlyphRange(e, n, this.url, this.requestTransform, (e, t) => {
                if (t) for (const e in t) s.glyphs[+e] = t[+e];
                for (const i of o) i(e, t);
                delete s.requests[n];
              })),
              o.push((s, r) => {
                s ? i(s) : r && i(null, { stack: e, id: t, glyph: r[t] || null });
              });
          },
          (e, t) => {
            if (e) i(e);
            else if (t) {
              const e = {};
              for (const { stack: i, id: s, glyph: r } of t)
                (e[i] || (e[i] = {}))[s] = r && {
                  id: r.id,
                  bitmap: r.bitmap.clone(),
                  metrics: r.metrics,
                };
              i(null, e);
            }
          },
        );
      }
      _doesCharSupportLocalGlyph(t) {
        return (
          0 !== this.localGlyphMode &&
          (2 === this.localGlyphMode
            ? !!this.localIdeographFontFamily
            : !!this.localIdeographFontFamily &&
              (e.isChar['CJK Unified Ideographs'](t) ||
                e.isChar['Hangul Syllables'](t) ||
                e.isChar.Hiragana(t) ||
                e.isChar.Katakana(t) ||
                e.isChar['CJK Symbols and Punctuation'](t)))
        );
      }
      _tinySDF(t, i, s) {
        const r = this.localIdeographFontFamily;
        if (!r || !this._doesCharSupportLocalGlyph(s)) return;
        let n = t.tinySDF;
        if (!n) {
          let e = '500';
          /bold/i.test(i)
            ? (e = '900')
            : /medium/i.test(i)
            ? (e = '500')
            : /light/i.test(i) && (e = '200'),
            (n = t.tinySDF =
              new tn.TinySDF({ fontFamily: r, fontWeight: e, fontSize: 24, buffer: 3, radius: 8 })),
            (n.fontWeight = e);
        }
        if (this.localGlyphs[n.fontWeight][s]) return this.localGlyphs[n.fontWeight][s];
        const o = String.fromCharCode(s),
          {
            data: a,
            width: l,
            height: h,
            glyphWidth: c,
            glyphHeight: _,
            glyphLeft: u,
            glyphTop: d,
            glyphAdvance: m,
          } = n.draw(o);
        return (this.localGlyphs[n.fontWeight][s] = {
          id: s,
          bitmap: new e.AlphaImage({ width: l, height: h }, a),
          metrics: {
            width: c / 1,
            height: _ / 1,
            left: u / 1,
            top: d / 1 - 27,
            advance: m / 1,
            localGlyph: !0,
          },
        });
      }
    }
    (tn.loadGlyphRange = function (t, i, s, r, n) {
      const o = 256 * i,
        a = o + 255,
        l = r(
          (function (e) {
            if (!yr(e) && !pr.fontsUrl) return e;
            const t = Pr(e);
            return (
              (pr.fontsUrl &&
                `${pr.fontsUrl}/{fontstack}${t.path.substr(t.path.lastIndexOf('/'))}.pbf`) ||
              `${pr.SRC_URL}/fonts/{fontstack}${t.path.substr(t.path.lastIndexOf('/'))}.pbf`
            );
          })(s)
            .replace('{fontstack}', t)
            .replace('{range}', `${o}-${a}`),
          e.ResourceType.Glyphs,
        );
      e.getArrayBuffer(l, (t, i) => {
        if (t) n(t);
        else if (i) {
          const t = {};
          for (const s of e.parseGlyphPBF(i)) t[s.id] = s;
          n(null, t);
        }
      });
    }),
      (tn.TinySDF = class {
        constructor({
          fontSize: e = 24,
          buffer: t = 3,
          radius: i = 8,
          cutoff: s = 0.25,
          fontFamily: r = 'sans-serif',
          fontWeight: n = 'normal',
          fontStyle: o = 'normal',
        } = {}) {
          (this.buffer = t), (this.cutoff = s), (this.radius = i);
          const a = (this.size = e + 4 * t),
            l = this._createCanvas(a),
            h = (this.ctx = l.getContext('2d', { willReadFrequently: !0 }));
          (h.font = `${o} ${n} ${e}px ${r}`),
            (h.textBaseline = 'alphabetic'),
            (h.textAlign = 'left'),
            (h.fillStyle = 'black'),
            (this.gridOuter = new Float32Array(a * a)),
            (this.gridInner = new Float32Array(a * a)),
            (this.f = new Float32Array(a)),
            (this.z = new Float32Array(a + 1)),
            (this.v = new Uint16Array(a));
        }
        _createCanvas(e) {
          const t = document.createElement('canvas');
          return (t.width = t.height = e), t;
        }
        draw(e) {
          const {
              width: t,
              actualBoundingBoxAscent: i,
              actualBoundingBoxDescent: s,
              actualBoundingBoxLeft: r,
              actualBoundingBoxRight: n,
            } = this.ctx.measureText(e),
            o = Math.ceil(i),
            a = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(n - r))),
            l = Math.min(this.size - this.buffer, o + Math.ceil(s)),
            h = a + 2 * this.buffer,
            c = l + 2 * this.buffer,
            _ = Math.max(h * c, 0),
            u = new Uint8ClampedArray(_),
            d = {
              data: u,
              width: h,
              height: c,
              glyphWidth: a,
              glyphHeight: l,
              glyphTop: o,
              glyphLeft: 0,
              glyphAdvance: t,
            };
          if (0 === a || 0 === l) return d;
          const { ctx: m, buffer: p, gridInner: f, gridOuter: g } = this;
          m.clearRect(p, p, a, l), m.fillText(e, p, p + o);
          const y = m.getImageData(p, p, a, l);
          g.fill(Qr, 0, _), f.fill(0, 0, _);
          for (let e = 0; e < l; e++)
            for (let t = 0; t < a; t++) {
              const i = y.data[4 * (e * a + t) + 3] / 255;
              if (0 === i) continue;
              const s = (e + p) * h + t + p;
              if (1 === i) (g[s] = 0), (f[s] = Qr);
              else {
                const e = 0.5 - i;
                (g[s] = e > 0 ? e * e : 0), (f[s] = e < 0 ? e * e : 0);
              }
            }
          Jr(g, 0, 0, h, c, h, this.f, this.v, this.z),
            Jr(f, p, p, a, l, h, this.f, this.v, this.z);
          for (let e = 0; e < _; e++) {
            const t = Math.sqrt(g[e]) - Math.sqrt(f[e]);
            u[e] = Math.round(255 - 255 * (t / this.radius + this.cutoff));
          }
          return d;
        }
      });
    class sn {
      constructor(t, i) {
        (this.width = t),
          (this.height = i),
          (this.nextRow = 0),
          (this.data = new Uint8Array(this.width * this.height)),
          (this.dashEntry = {}),
          (this._target = e.WebGLConstants.TEXTURE_2D);
      }
      getDash(e, t) {
        const i = e.join(',') + String(t);
        return this.dashEntry[i] || (this.dashEntry[i] = this.addDash(e, t)), this.dashEntry[i];
      }
      getDashRanges(e, t, i) {
        const s = [];
        let r = e.length % 2 == 1 ? -e[e.length - 1] * i : 0,
          n = e[0] * i,
          o = !0;
        s.push({ left: r, right: n, isDash: o, zeroLength: 0 === e[0] });
        let a = e[0];
        for (let t = 1; t < e.length; t++) {
          o = !o;
          const l = e[t];
          (r = a * i),
            (a += l),
            (n = a * i),
            s.push({ left: r, right: n, isDash: o, zeroLength: 0 === l });
        }
        return s;
      }
      addRoundDash(e, t, i) {
        const s = t / 2;
        for (let t = -i; t <= i; t++) {
          const r = this.width * (this.nextRow + i + t);
          let n = 0,
            o = e[n];
          for (let a = 0; a < this.width; a++) {
            a / o.right > 1 && (o = e[++n]);
            const l = Math.abs(a - o.left),
              h = Math.abs(a - o.right),
              c = Math.min(l, h);
            let _;
            const u = (t / i) * (s + 1);
            if (o.isDash) {
              const e = s - Math.abs(u);
              _ = Math.sqrt(c * c + e * e);
            } else _ = s - Math.sqrt(c * c + u * u);
            this.data[r + a] = Math.max(0, Math.min(255, _ + 128));
          }
        }
      }
      addRegularDash(e) {
        for (let t = e.length - 1; t >= 0; --t) {
          const i = e[t],
            s = e[t + 1];
          i.zeroLength
            ? e.splice(t, 1)
            : s && s.isDash === i.isDash && ((s.left = i.left), e.splice(t, 1));
        }
        const t = e[0],
          i = e[e.length - 1];
        t.isDash === i.isDash && ((t.left = i.left - this.width), (i.right = t.right + this.width));
        const s = this.width * this.nextRow;
        let r = 0,
          n = e[r];
        for (let t = 0; t < this.width; t++) {
          t / n.right > 1 && (n = e[++r]);
          const i = Math.abs(t - n.left),
            o = Math.abs(t - n.right),
            a = Math.min(i, o);
          this.data[s + t] = Math.max(0, Math.min(255, (n.isDash ? a : -a) + 128));
        }
      }
      addDash(t, i) {
        const s = i ? 7 : 0,
          r = 2 * s + 1;
        if (this.nextRow + r > this.height) return e.warnOnce('LineAtlas out of space'), null;
        let n = 0;
        for (let e = 0; e < t.length; e++) n += t[e];
        if (0 !== n) {
          const e = this.width / n,
            r = this.getDashRanges(t, this.width, e);
          i ? this.addRoundDash(r, e, s) : this.addRegularDash(r);
        }
        const o = {
          y: (this.nextRow + s + 0.5) / this.height,
          height: (2 * s) / this.height,
          width: n,
        };
        return (this.nextRow += r), (this.dirty = !0), o;
      }
      bind(t) {
        const i = t.gl;
        this.texture
          ? (i.bindTexture(e.WebGLConstants.TEXTURE_2D, this.texture),
            this.dirty &&
              ((this.dirty = !1),
              i.texSubImage2D(
                e.WebGLConstants.TEXTURE_2D,
                0,
                0,
                0,
                this.width,
                this.height,
                e.WebGLConstants.ALPHA,
                e.WebGLConstants.UNSIGNED_BYTE,
                this.data,
              )))
          : ((this.texture = i.createTexture()),
            i.bindTexture(e.WebGLConstants.TEXTURE_2D, this.texture),
            i.texParameteri(
              e.WebGLConstants.TEXTURE_2D,
              e.WebGLConstants.TEXTURE_WRAP_S,
              e.WebGLConstants.REPEAT,
            ),
            i.texParameteri(
              e.WebGLConstants.TEXTURE_2D,
              e.WebGLConstants.TEXTURE_WRAP_T,
              e.WebGLConstants.REPEAT,
            ),
            i.texParameteri(
              e.WebGLConstants.TEXTURE_2D,
              e.WebGLConstants.TEXTURE_MIN_FILTER,
              e.WebGLConstants.LINEAR,
            ),
            i.texParameteri(
              e.WebGLConstants.TEXTURE_2D,
              e.WebGLConstants.TEXTURE_MAG_FILTER,
              e.WebGLConstants.LINEAR,
            ),
            i.texImage2D(
              e.WebGLConstants.TEXTURE_2D,
              0,
              e.WebGLConstants.ALPHA,
              this.width,
              this.height,
              0,
              e.WebGLConstants.ALPHA,
              e.WebGLConstants.UNSIGNED_BYTE,
              this.data,
            ));
      }
      destroy() {
        return (this.data = null), e.destroyObject(this);
      }
    }
    class rn {
      constructor(t, i) {
        (this.workerPool = t),
          (this.actors = []),
          (this.currentActor = 0),
          (this.id = e.uniqueId());
        const s = this.workerPool.acquire(this.id);
        for (let e = 0; e < s.length; e++) {
          const t = new rn.Actor(s[e], i, this.id);
          (t.name = `Worker ${e}`), this.actors.push(t);
        }
      }
      broadcast(t, i, s) {
        e.asyncAll(
          this.actors,
          (e, s) => {
            e.send(t, i, s);
          },
          (s = s || function () {}),
        );
      }
      send(e, t, i, s) {
        return (
          (isNaN(s) || 'number' != typeof s) &&
            (s = this.currentActor = (this.currentActor + 1) % this.actors.length),
          this.actors[s] && this.actors[s].send(e, t, i),
          s
        );
      }
      remove() {
        this.actors.forEach((e) => {
          e.remove();
        }),
          (this.actors = []),
          this.workerPool.release(this.id);
      }
    }
    function nn(t, i, s) {
      const r = function (t, i) {
        if (t) return s(t);
        if (i) {
          const t = e.pick(i, [
            'tiles',
            'minzoom',
            'maxzoom',
            'attribution',
            'minemap_logo',
            'bounds',
          ]);
          i.vector_layers &&
            ((t.vectorLayers = i.vector_layers),
            (t.vectorLayerIds = t.vectorLayers.map((e) => e.id))),
            s(null, t);
        }
      };
      return t.url
        ? e.getJSON(i(br(t.url), e.ResourceType.Source), r)
        : e.exported.frame(() => r(null, t));
    }
    rn.Actor = e.Actor;
    class on {
      constructor(t, i, s) {
        (this.bounds = e.LngLatBounds.convert(this.validateBounds(t))),
          (this.minzoom = i || 0),
          (this.maxzoom = s || 24);
      }
      validateBounds(e) {
        return Array.isArray(e) && 4 === e.length
          ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])]
          : [-180, -90, 180, 90];
      }
      contains(e) {
        const t = Math.floor(this.lngX(this.bounds.getWest(), e.z)),
          i = Math.floor(this.latY(this.bounds.getNorth(), e.z)),
          s = Math.ceil(this.lngX(this.bounds.getEast(), e.z)),
          r = Math.ceil(this.latY(this.bounds.getSouth(), e.z));
        return e.x >= t && e.x < s && e.y >= i && e.y < r;
      }
      lngX(e, t) {
        return (e + 180) * (Math.pow(2, t) / 360);
      }
      latY(t, i) {
        const s = e.clamp(Math.sin((Math.PI / 180) * t), -0.9999, 0.9999),
          r = Math.pow(2, i) / (2 * Math.PI);
        return Math.pow(2, i - 1) + 0.5 * Math.log((1 + s) / (1 - s)) * -r;
      }
    }
    class an {
      constructor(t) {
        (this._ellipsoid = e.defaultValue(t, e.Ellipsoid.WGS84)),
          (this._semimajorAxis = this._ellipsoid.maximumRadius),
          (this._oneOverSemimajorAxis = 1 / this._semimajorAxis);
      }
      get ellipsoid() {
        return this._ellipsoid;
      }
      static mercatorAngleToGeodeticLatitude(t) {
        return e.CONSTS.CesiumMath.PI_OVER_TWO - 2 * Math.atan(Math.exp(-t));
      }
      static geodeticLatitudeToMercatorAngle(e) {
        e > an.MaximumLatitude
          ? (e = an.MaximumLatitude)
          : e < -an.MaximumLatitude && (e = -an.MaximumLatitude);
        const t = Math.sin(e);
        return 0.5 * Math.log((1 + t) / (1 - t));
      }
      project(t, i) {
        const s = this._semimajorAxis,
          r = t.longitude * s,
          n = an.geodeticLatitudeToMercatorAngle(t.latitude) * s,
          o = t.height;
        return e.defined(i) ? ((i.x = r), (i.y = n), (i.z = o), i) : new e.Vector3(r, n, o);
      }
      unproject(t, i) {
        const s = this._oneOverSemimajorAxis,
          r = t.x * s,
          n = an.mercatorAngleToGeodeticLatitude(t.y * s),
          o = t.z;
        return e.defined(i)
          ? ((i.longitude = r), (i.latitude = n), (i.height = o), i)
          : new e.Cartographic(r, n, o);
      }
    }
    an.MaximumLatitude = an.mercatorAngleToGeodeticLatitude(Math.PI);
    class ln {
      constructor(t) {
        if (
          ((t = e.defaultValue(t, e.defaultValue.EMPTY_OBJECT)),
          (this._ellipsoid = e.defaultValue(t.ellipsoid, e.Ellipsoid.WGS84)),
          (this._numberOfLevelZeroTilesX = e.defaultValue(t.numberOfLevelZeroTilesX, 1)),
          (this._numberOfLevelZeroTilesY = e.defaultValue(t.numberOfLevelZeroTilesY, 1)),
          (this._projection = new an(this._ellipsoid)),
          e.defined(t.rectangleSouthwestInMeters) && e.defined(t.rectangleNortheastInMeters))
        )
          (this._rectangleSouthwestInMeters = t.rectangleSouthwestInMeters),
            (this._rectangleNortheastInMeters = t.rectangleNortheastInMeters);
        else {
          const t = this._ellipsoid.maximumRadius * Math.PI;
          (this._rectangleSouthwestInMeters = new e.Vector2(-t, -t)),
            (this._rectangleNortheastInMeters = new e.Vector2(t, t));
        }
        const i = this._projection.unproject(this._rectangleSouthwestInMeters),
          s = this._projection.unproject(this._rectangleNortheastInMeters);
        this._rectangle = new e.Rectangle(i.longitude, i.latitude, s.longitude, s.latitude);
      }
      get ellipsoid() {
        return this._ellipsoid;
      }
      get rectangle() {
        return this._rectangle;
      }
      get projection() {
        return this._projection;
      }
      getNumberOfXTilesAtLevel(e) {
        return this._numberOfLevelZeroTilesX << e;
      }
      getNumberOfYTilesAtLevel(e) {
        return this._numberOfLevelZeroTilesY << e;
      }
      rectangleToNativeRectangle(t, i) {
        const s = this._projection,
          r = s.project(e.Rectangle.southwest(t)),
          n = s.project(e.Rectangle.northeast(t));
        return e.defined(i)
          ? ((i.west = r.x), (i.south = r.y), (i.east = n.x), (i.north = n.y), i)
          : new e.Rectangle(r.x, r.y, n.x, n.y);
      }
      tileXYToNativeRectangle(t, i, s, r) {
        const n = this.getNumberOfXTilesAtLevel(s),
          o = this.getNumberOfYTilesAtLevel(s),
          a = (this._rectangleNortheastInMeters.x - this._rectangleSouthwestInMeters.x) / n,
          l = this._rectangleSouthwestInMeters.x + t * a,
          h = this._rectangleSouthwestInMeters.x + (t + 1) * a,
          c = (this._rectangleNortheastInMeters.y - this._rectangleSouthwestInMeters.y) / o,
          _ = this._rectangleNortheastInMeters.y - i * c,
          u = this._rectangleNortheastInMeters.y - (i + 1) * c;
        return e.defined(r)
          ? ((r.west = l), (r.south = u), (r.east = h), (r.north = _), r)
          : new e.Rectangle(l, u, h, _);
      }
      tileXYToRectangle(t, i, s, r) {
        const n = this.tileXYToNativeRectangle(t, i, s, r),
          o = this._projection,
          a = o.unproject(new e.Vector2(n.west, n.south)),
          l = o.unproject(new e.Vector2(n.east, n.north));
        return (
          (n.west = a.longitude),
          (n.south = a.latitude),
          (n.east = l.longitude),
          (n.north = l.latitude),
          n
        );
      }
      positionToTileXY(t, i, s) {
        if (!e.Rectangle.contains(this._rectangle, t)) return;
        const r = this.getNumberOfXTilesAtLevel(i),
          n = this.getNumberOfYTilesAtLevel(i),
          o = (this._rectangleNortheastInMeters.x - this._rectangleSouthwestInMeters.x) / r,
          a = (this._rectangleNortheastInMeters.y - this._rectangleSouthwestInMeters.y) / n,
          l = this._projection.project(t);
        let h = ((l.x - this._rectangleSouthwestInMeters.x) / o) | 0;
        h >= r && (h = r - 1);
        let c = ((this._rectangleNortheastInMeters.y - l.y) / a) | 0;
        return (
          c >= n && (c = n - 1), e.defined(s) ? ((s.x = h), (s.y = c), s) : new e.Vector2(h, c)
        );
      }
    }
    class hn {
      constructor(t) {
        (t = e.defaultValue(t, e.defaultValue.EMPTY_OBJECT)),
          (this._ellipsoid = e.defaultValue(t.ellipsoid, e.Ellipsoid.WGS84)),
          (this._rectangle = e.defaultValue(t.rectangle, e.Rectangle.MAX_VALUE)),
          (this._projection = new e.GeographicProjection(this._ellipsoid)),
          (this._numberOfLevelZeroTilesX = e.defaultValue(t.numberOfLevelZeroTilesX, 2)),
          (this._numberOfLevelZeroTilesY = e.defaultValue(t.numberOfLevelZeroTilesY, 1));
      }
      get ellipsoid() {
        return this._ellipsoid;
      }
      get rectangle() {
        return this._rectangle;
      }
      get projection() {
        return this._projection;
      }
      getNumberOfXTilesAtLevel(e) {
        return this._numberOfLevelZeroTilesX << e;
      }
      getNumberOfYTilesAtLevel(e) {
        return this._numberOfLevelZeroTilesY << e;
      }
      rectangleToNativeRectangle(t, i) {
        const s = e.CONSTS.CesiumMath.toDegrees(t.west),
          r = e.CONSTS.CesiumMath.toDegrees(t.south),
          n = e.CONSTS.CesiumMath.toDegrees(t.east),
          o = e.CONSTS.CesiumMath.toDegrees(t.north);
        return e.defined(i)
          ? ((i.west = s), (i.south = r), (i.east = n), (i.north = o), i)
          : new e.Rectangle(s, r, n, o);
      }
      tileXYToNativeRectangle(t, i, s, r) {
        const n = this.tileXYToRectangle(t, i, s, r);
        return (
          (n.west = e.CONSTS.CesiumMath.toDegrees(n.west)),
          (n.south = e.CONSTS.CesiumMath.toDegrees(n.south)),
          (n.east = e.CONSTS.CesiumMath.toDegrees(n.east)),
          (n.north = e.CONSTS.CesiumMath.toDegrees(n.north)),
          n
        );
      }
      tileXYToRectangle(t, i, s, r) {
        const n = this._rectangle,
          o = this.getNumberOfXTilesAtLevel(s),
          a = this.getNumberOfYTilesAtLevel(s),
          l = n.width / o,
          h = t * l + n.west,
          c = (t + 1) * l + n.west,
          _ = n.height / a,
          u = n.north - i * _,
          d = n.north - (i + 1) * _;
        return (
          e.defined(r) || (r = new e.Rectangle(h, d, c, u)),
          (r.west = h),
          (r.south = d),
          (r.east = c),
          (r.north = u),
          r
        );
      }
      positionToTileXY(t, i, s) {
        const r = this._rectangle;
        if (!e.Rectangle.contains(r, t)) return;
        const n = this.getNumberOfXTilesAtLevel(i),
          o = this.getNumberOfYTilesAtLevel(i);
        let a = t.longitude;
        r.east < r.west && (a += e.CONSTS.CesiumMath.TWO_PI);
        let l = ((a - r.west) / (r.width / n)) | 0;
        l >= n && (l = n - 1);
        let h = ((r.north - t.latitude) / (r.height / o)) | 0;
        return (
          h >= o && (h = o - 1), e.defined(s) ? ((s.x = l), (s.y = h), s) : new e.Vector2(l, h)
        );
      }
    }
    const cn = {
      off0: [4, 1],
      off1: [5, 1],
      off2: [6, 2],
      off3: [8, 8],
      off4: [16, 32],
      off5: [48, 128],
      off6: [176, 512],
      off7: [688, 2048],
      off8: [2736, 8192],
      off9: [10928, 32768],
      off10: [43696, 131072],
      off11: [174768, 524288],
      off12: [699056, 2097152],
    };
    class _n {
      constructor(t, i) {
        (this._cache = new e.window.Map()),
          (this._requestMap = new e.window.Map()),
          (this._baseUrl = t),
          (this._minzoom = i || 10);
      }
      getStatusById(e) {
        const t = e.key,
          i = e.scaledTo(this._minzoom).key;
        if (this.hasIndexFile(i)) return this._getBitValue(i, t);
        this.hasRequestingFile(i) || this.requestFile(i);
      }
      _getBitValue(t, i) {
        const s = new DataView(this._cache.get(t)),
          r = s.getUint8(0),
          n = s.getUint8(1),
          o = i.split('_'),
          a = new Uint8Array(3),
          l = parseInt(o[0]),
          h = parseInt(o[1]),
          c = parseInt(o[2]);
        if (((a[0] = l), (a[1] = h), (a[2] = c), a[0] < r)) return 1;
        if (a[0] > n) return 0;
        const _ = a[0] - r,
          u = cn[`off${_}`];
        if (0 == _) return (this._genSelectBinary(1) & s.getUint8(u[0])) >> 7;
        if (1 == _) {
          let e = 0;
          return (
            (e += (h % 2) + 1 + (c % 2) * 2),
            (this._genSelectBinary(e) & s.getUint8(u[0])) >> (8 - e)
          );
        }
        {
          let t = 1;
          const i = new e.OverscaledTileID(l, 0, l, h, c);
          let n = 0;
          for (; t <= _; ) {
            const e = i.scaledTo(r + t),
              s = (e.canonical.x % 2) + (e.canonical.y % 2) * 2;
            (n += ((8 * u[1]) / Math.pow(4, t)) * s), t++;
          }
          const o = Math.floor(n / 8),
            a = (n % 8) + 1;
          return (this._genSelectBinary(a) & s.getUint8(u[0] + o)) >> (8 - a);
        }
      }
      _genSelectBinary(t) {
        switch ((e.defined(t) || (t = 1), t)) {
          case 1:
            return 128;
          case 2:
            return 64;
          case 3:
            return 32;
          case 4:
            return 16;
          case 5:
            return 8;
          case 6:
            return 4;
          case 7:
            return 2;
          case 8:
            return 1;
        }
      }
      hasRequestingFile(e) {
        return this._requestMap.has(e);
      }
      hasIndexFile(e) {
        return this._cache.has(e);
      }
      requestFile(t) {
        const i = t.split('_'),
          s = this._baseUrl.replace(/\{z\}/g, i[0]).replace(/\{x\}/g, i[1]).replace(/\{y\}/g, i[2]),
          r = e.getArrayBuffer({ url: s }, (e, i) => {
            e ? console.error(e) : (this._cache.set(t, i), this._requestMap.delete(t));
          });
        this._requestMap.set(t, r);
      }
      cancelRequest(e) {
        this._requestMap.has(e) && this._requestMap.get(e).cancel();
      }
    }
    class un {
      constructor(t, i, s, r) {
        (this.rasterTileSource = r),
          (this.x = t),
          (this.y = i),
          (this.level = s),
          (this.tileID = new e.OverscaledTileID(s, 0, s, t, i)),
          (this.state = 'unloaded'),
          (this.texture = void 0),
          (this.referenceCount = 0),
          (this.references = []);
      }
      addReference(e) {
        ++this.referenceCount, this.references.includes(e) || this.references.push(e);
      }
      releaseReference(t) {
        return (
          --this.referenceCount,
          this.references.splice(this.references.indexOf(t), 1),
          0 === this.referenceCount
            ? (this.rasterTileSource.removeImageryFromCache(this),
              e.defined(this.texture) && this.texture.destroy(),
              e.destroyObject(this),
              0)
            : this.referenceCount
        );
      }
      loadImage(t) {
        const { painter: i, callbacks: s, url: r } = t;
        let n = t.data;
        const o = i.context;
        if (n.img)
          if (e.window.hasOwnProperty('createImageBitmap')) {
            let i = e.window.createImageBitmap(n.img);
            i.then((r) => {
              const a = o.gl;
              (this.texture = new e.Texture({
                context: o,
                image: r,
                pixelFormat: e.WebGLConstants.RGBA,
                useMipmap: !1,
              })),
                this.texture.bind(e.WebGLConstants.LINEAR, e.WebGLConstants.CLAMP_TO_EDGE),
                o.extTextureFilterAnisotropic &&
                  (a.bindTexture(this.texture._target, this.texture.texture),
                  a.texParameterf(
                    e.WebGLConstants.TEXTURE_2D,
                    o.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,
                    e.ContextLimits._maximumTextureFilterAnisotropy,
                  ),
                  a.bindTexture(this.texture._target, null)),
                (n.img = null),
                (n = null),
                (r = null),
                (this.state = 'loaded'),
                (t.url = null),
                (t.painter = null),
                (t = null),
                (i = null);
              for (const e of s) e(null);
            });
          } else
            (this.texture = new e.Texture({
              context: o,
              image: n.img,
              pixelFormat: e.WebGLConstants.RGBA,
              useMipmap: !1,
            })),
              this.texture.bind(e.WebGLConstants.LINEAR, e.WebGLConstants.CLAMP_TO_EDGE),
              (n.img = null),
              (n = null),
              (t.url = null),
              (t.painter = null),
              (t = null),
              (this.state = 'loaded');
        else
          n.sampleImage
            ? (n.sampleImage.onload = () => {
                (this.texture = new e.Texture({
                  context: o,
                  image: n.sampleImage,
                  pixelFormat: e.WebGLConstants.RGBA,
                  useMipmap: !1,
                })),
                  this.texture.bind(e.WebGLConstants.LINEAR, e.WebGLConstants.CLAMP_TO_EDGE),
                  (n.sampleImage = null),
                  (this.state = 'loaded');
                for (const e of s) e(null);
              })
            : e.getImage({ url: r }, (t, i) => {
                if (t) throw new Error(t);
                (this.texture = new e.Texture({
                  context: o,
                  image: i,
                  pixelFormat: e.WebGLConstants.RGBA,
                  useMipmap: !1,
                })),
                  this.texture.bind(e.WebGLConstants.LINEAR, e.WebGLConstants.CLAMP_TO_EDGE),
                  (i = null),
                  (this.state = 'loaded');
                for (const e of s) e(null);
              });
      }
    }
    class dn {
      constructor(e, t, i) {
        (this.imagery = e),
          (this.textureCoordinateRectangle = t),
          (this.textureTranslationAndScale = i);
      }
      freeResources(t) {
        e.defined(this.imagery) && this.imagery.releaseReference(t);
      }
      loadImage(e) {
        this.imagery.loadImage(e);
      }
    }
    var mn = e.createLayout([
        { name: 'a_POSITION', type: 'Int16', components: 2 },
        { name: 'a_texture_pos', type: 'Int16', components: 2 },
      ]),
      pn = e.createLayout([
        { name: 'a_POSITION', type: 'Float32', components: 3 },
        { name: 'a_texture_pos', type: 'Float32', components: 2 },
      ]);
    class fn extends e.Material {
      constructor(t) {
        super(t),
          (this.isVectorMaterial = !0),
          (this.layer = t.layer),
          (this.tile = t.tile),
          (this._renderState = t.renderState),
          (this.textureFilter =
            e.defined(this.layer) && 'nearest' === this.layer.paint.get('raster-resampling')
              ? e.WebGLConstants.NEAREST
              : e.WebGLConstants.LINEAR),
          (this._lightColor = new e.Vector3([1, 1, 1])),
          (this._lightDirection = new e.Vector3()),
          (this._spinWeights = new e.Vector3()),
          this.createUniforms();
      }
      setLayer(e) {
        this.layer = e;
      }
      update(t, i, s = {}) {
        super.update(t, i, s),
          (this.defines = {
            ENCODE_DEPTH_TO_FRAGCOLOR: i.passType === e.RenderPassConsts.PICK_PASS,
            STATIC_IMAGE: !0,
          });
      }
      createUniforms() {
        this._uniforms.set('u_brightness_low', () => this.layer.paint.get('raster-brightness-min')),
          this._uniforms.set('u_brightness_high', () =>
            this.layer.paint.get('raster-brightness-max'),
          ),
          this._uniforms.set('u_saturation_factor', () => {
            return (e = this.layer.paint.get('raster-saturation')) > 0 ? 1 - 1 / (1.001 - e) : -e;
            var e;
          }),
          this._uniforms.set('u_contrast_factor', () => {
            return (e = this.layer.paint.get('raster-contrast')) > 0 ? 1 / (1 - e) : 1 + e;
            var e;
          }),
          this._uniforms.set('u_spin_weights', () => {
            const e = (function (e) {
              e *= Math.PI / 180;
              const t = Math.sin(e),
                i = Math.cos(e);
              return [
                (2 * i + 1) / 3,
                (-Math.sqrt(3) * t - i + 1) / 3,
                (Math.sqrt(3) * t - i + 1) / 3,
              ];
            })(this.layer.paint.get('raster-hue-rotate'));
            return this._spinWeights.set(e[0], e[1], e[2]);
          }),
          this._uniforms.set('u_Opacity', () => this.layer.paint.get('raster-opacity')),
          this._uniforms.set(
            'u_BaseColorSampler',
            () => (
              this.tile.texture.bind(this.textureFilter, e.WebGLConstants.CLAMP_TO_EDGE),
              this.tile.texture
            ),
          );
      }
      checkLayer() {
        if (!this.layer)
          throw new Error(
            '请在image plotter中针对image source进行layer的注册，即调用material.setLayer(layer)',
          );
      }
      destroy() {
        (this.layer = void 0),
          this.tile.texture && (this.tile.texture.destroy(), (this.tile.texture = null)),
          (this.__texture = null),
          (this.tile = void 0),
          (this.programId = void 0),
          (this.type = void 0),
          (this._uniforms = void 0),
          (this._textures = void 0),
          (this._program = void 0),
          (this._programConfiguration = void 0),
          (this._renderState = void 0),
          (this.textureFilter = void 0),
          (this.parentScaleBy = void 0);
      }
    }
    class gn extends e.Evented {
      constructor(e, t, i, s) {
        super(),
          (this.id = e),
          (this.dispatcher = i),
          (this.coordinates = t.coordinates),
          (this.grid = t.grid),
          (this.wms = !!t.wms && t.wms),
          (this.url = t.url),
          (this.type = 'image'),
          (this.minzoom = 0),
          (this.maxzoom = 22),
          (this.tileSize = 512),
          (this.tiles = {}),
          (this.priorityRequest = t.priorityRequest || !1),
          this.setEventedParent(s),
          (this.options = t),
          Xs(this);
      }
      _moveFn() {
        const e = this.map,
          t = e.unproject([0, 0]),
          i = e.unproject([e.transform.width, 0]),
          s = e.unproject([e.transform.width, e.transform.height]),
          r = e.unproject([0, e.transform.height]),
          n = Math.min(t.lat, i.lat, s.lat, r.lat),
          o = Math.min(t.lng, i.lng, s.lng, r.lng),
          a = Math.max(t.lat, i.lat, s.lat, r.lat),
          l = Math.max(t.lng, i.lng, s.lng, r.lng),
          h = `${o},${n},${l},${a}`,
          c = Math.ceil(e.transform.width),
          _ = Math.ceil(e.transform.height),
          u = Math.ceil(e.style.getNearestTileZoom());
        (this.options.url = this.wmsUrl
          .replace('{bbox}', h)
          .replace('{width}', c.toString())
          .replace('{height}', _.toString())
          .replace('{z}', u.toString())),
          this.setUrl(this.options.url, [
            [o, a],
            [l, a],
            [l, n],
            [o, n],
          ]);
      }
      setUrl(t, i) {
        (this.url = t),
          (this.options.url = t),
          e.getImage(this.map._transformRequest(this.url, e.ResourceType.Image), (t, s) => {
            t
              ? this.fire(new e.ErrorEvent(t))
              : s &&
                ((this.image = e.exported.getImageData(s)),
                delete this.texture,
                i && (this.coordinates = i),
                this._finishLoading());
          });
      }
      load(t, i) {
        (this._loaded = !1),
          this.fire(new e.Event('dataloading', { dataType: 'source' })),
          (this.url = this.options.url),
          e.getImage(this.map._transformRequest(this.url, e.ResourceType.Image), (s, r) => {
            (this._loaded = !0),
              s
                ? this.fire(new e.ErrorEvent(s))
                : r &&
                  ((this.image = r), t && (this.coordinates = t), i && i(), this._finishLoading());
          });
      }
      updateImage(e) {
        return this.image && e.url
          ? ((this.options.url = e.url),
            this.load(e.coordinates, () => {
              this.texture = null;
            }),
            this)
          : this;
      }
      _finishLoading() {
        this.map &&
          (this.setCoordinates(this.coordinates),
          this.fire(new e.Event('data', { dataType: 'source', sourceDataType: 'metadata' })));
      }
      onAdd(e) {
        if (((this.map = e), this.wms)) {
          this.wmsUrl || (this.wmsUrl = this.options.url);
          const t = Math.ceil(e.transform.width),
            i = Math.ceil(e.transform.height),
            s = Math.ceil(e.style.getNearestTileZoom()),
            r = `${e.getBounds()._sw.lng},${e.getBounds()._sw.lat},${e.getBounds()._ne.lng},${
              e.getBounds()._ne.lat
            }`;
          (this.options.url = this.wmsUrl
            .replace('{bbox}', r)
            .replace('{width}', t.toString())
            .replace('{height}', i.toString())
            .replace('{z}', s.toString())),
            (this.coordinates = [
              e.getBounds().getNorthWest().toArray(),
              e.getBounds().getNorthEast().toArray(),
              e.getBounds().getSouthEast().toArray(),
              e.getBounds().getSouthWest().toArray(),
            ]),
            this.setCoordinates(this.coordinates),
            this.map.on('moveend', this._moveFn);
        }
        this.load();
      }
      onRemove() {
        this.map.off('moveend', this._moveFn);
      }
      setCoordinates(t) {
        this.coordinates = t;
        const i = this.map,
          s = t.map((t) => i.transform.locationCoordinate(e.LngLat.convert(t)).zoomTo(0)),
          r = (this.centerCoord = e.getCoordinatesCenter(s));
        (r.column = Math.floor(r.column)),
          (r.row = Math.floor(r.row)),
          (this.tileID = new e.CanonicalTileID(r.zoom, r.column, r.row)),
          (this.minzoom = this.maxzoom = r.zoom);
        const n = s.map((t) => {
            const i = t.zoomTo(r.zoom);
            return new e.pointGeometry3d(
              Math.round((i.column - r.column) * e.EXTENT),
              Math.round((i.row - r.row) * e.EXTENT),
            );
          }),
          o = [n[3].x, n[3].y],
          a = [n[2].x, n[2].y],
          l = [n[0].x, n[0].y],
          h = [n[1].x, n[1].y];
        let c = !1,
          _ = null;
        (c = !0),
          (this._sphereBoundsArray = new e.StructArrayLayout5f20()),
          (this._sphereIndexArray = new e.StructArrayLayout3ui6()),
          (this.sphereSegments = new e.SegmentVector()),
          this.sphereSegments.prepareSegment(0, this._sphereBoundsArray, this._sphereIndexArray),
          (_ = this.sphereSegments.prepareSegment(
            4,
            this._sphereBoundsArray,
            this._sphereIndexArray,
          )),
          (this._boundsArray = new e.StructArrayLayout4i8()),
          (this._indexArray = new e.StructArrayLayout3ui6()),
          (this.segments = new e.SegmentVector()),
          this.segments.prepareSegment(0, this._boundsArray, this._indexArray);
        const u = this.segments.prepareSegment(4, this._boundsArray, this._indexArray),
          d = 19;
        for (let t = 0; t <= d; t++) {
          const s = [o[0] + ((l[0] - o[0]) / d) * t, o[1] + ((l[1] - o[1]) / d) * t],
            n = [a[0] + ((h[0] - a[0]) / d) * t, a[1] + ((h[1] - a[1]) / d) * t];
          for (let o = 0; o <= d; o++) {
            const a = [s[0] + ((n[0] - s[0]) / d) * o, s[1] + ((n[1] - s[1]) / d) * o],
              l = [(o / d) * e.EXTENT * 4, (1 - t / d) * e.EXTENT * 4];
            this._boundsArray.emplaceBack(
              parseInt(a[0]),
              parseInt(a[1]),
              parseInt(l[0]),
              parseInt(l[1]),
            ),
              u.vertexLength++;
            {
              const t = e.getSpherePos(
                a[0],
                a[1],
                1,
                r.column,
                r.row,
                r.zoom,
                i.transform.projection,
              );
              this.spaceBasePos ||
                ((this.spaceBasePos = t),
                (this.matrix = new e.Matrix4(
                  e.calc3dVectorTileTranslateMatrix([], this.spaceBasePos),
                ))),
                this._sphereBoundsArray.emplaceBack(
                  t[0] - this.spaceBasePos[0],
                  t[1] - this.spaceBasePos[1],
                  t[2] - this.spaceBasePos[2],
                  parseInt(l[0]),
                  parseInt(l[1]),
                ),
                _.vertexLength++;
            }
            const h = o + 20 * t;
            t !== d &&
              o !== d &&
              (this._indexArray.emplaceBack(h, h + 20 + 1, h + 20),
              this._indexArray.emplaceBack(h, h + 1, h + 20 + 1),
              (u.primitiveLength += 2),
              this._sphereIndexArray.emplaceBack(h, h + 20 + 1, h + 20),
              this._sphereIndexArray.emplaceBack(h, h + 1, h + 20 + 1),
              (_.primitiveLength += 2));
          }
        }
        return (
          this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer),
          this.indexBuffer && (this.indexBuffer.destroy(), delete this.indexBuffer),
          this.sphereBoundsBuffer &&
            (this.sphereBoundsBuffer.destroy(), delete this.sphereBoundsBuffer),
          this.sphereIndexBuffer &&
            (this.sphereIndexBuffer.destroy(), delete this.sphereIndexBuffer),
          this.fire(new e.Event('data', { dataType: 'source', sourceDataType: 'content' })),
          this
        );
      }
      prepare() {
        if (0 === Object.keys(this.tiles).length || !this.image) return;
        const t = this.map.painter.context;
        if (
          (this.boundsBuffer ||
            ((this.boundsBuffer = t.createVertexBuffer(this._boundsArray, mn.members)),
            (this.indexBuffer = t.createIndexBuffer(this._indexArray))),
          this.sphereBoundsBuffer ||
            ((this.sphereBoundsBuffer = t.createVertexBuffer(this._sphereBoundsArray, pn.members)),
            (this.sphereIndexBuffer = t.createIndexBuffer(this._sphereIndexArray))),
          !this.texture)
        ) {
          (this.texture = new e.Texture({
            context: t,
            image: this.image,
            pixelFormat: e.WebGLConstants.RGBA,
          })),
            this.texture.bind(e.WebGLConstants.LINEAR, e.WebGLConstants.CLAMP_TO_EDGE);
          const i = new e.Geometry({
              primitiveType: e.WebGLConstants.TRIANGLES,
              vertBuffer: this.sphereBoundsBuffer,
              indexBuffer: this.sphereIndexBuffer,
              segmentVector: this.sphereSegments,
            }),
            s = new fn({
              painter: this.map.painter,
              tile: this,
              defines: {},
              type: 'sphereImage',
              renderState: {},
            });
          this.primitive = new e.Primitive({ modelMatrix: this.matrix, geometry: i, material: s });
        }
        for (const e in this.tiles) {
          const t = this.tiles[e];
          'loaded' !== t.state && ((t.state = 'loaded'), (t.texture = this.texture));
        }
      }
      loadTile(e, t) {
        this.tileID && this.tileID.containsOrContained(e.tileID.canonical)
          ? ((this.tiles[String(e.tileID.wrap)] = e), (e.buckets = {}), t(null))
          : ((e.state = 'errored'), t(null));
      }
      serialize() {
        return { type: 'image', url: this.options.url, coordinates: this.coordinates };
      }
      hasTransition() {
        return !1;
      }
      isEarthSource() {
        return !0;
      }
    }
    class yn {
      constructor() {
        (this.boundProgram = null),
          (this.boundLayoutVertexBuffer = null),
          (this.boundPaintVertexBuffers = []),
          (this.boundIndexBuffer = null),
          (this.boundVertexOffset = null),
          (this.boundDynamicVertexBuffer = null),
          (this.vao = null);
      }
      bind(e, t, i, s, r, n, o, a, l, h, c) {
        this.context = e;
        let _ = this.boundPaintVertexBuffers.length !== s.length;
        for (let e = 0; !_ && e < s.length; e++)
          this.boundPaintVertexBuffers[e] !== s[e] && (_ = !0);
        const u = this._requireFreshBind({
          program: t,
          layoutVertexBuffer: i,
          paintVertexBuffers: s,
          indexBuffer: r,
          vertexOffset: n,
          dynamicVertexBuffer: o,
          dynamicVertexBuffer2: a,
          dynamicVertexBuffer3: l,
          animationVertexBuffers: h,
          instanceVerterBuffers: c,
        });
        if (!e.extVertexArrayObject || u) this.freshBind(t, i, s, r, n, o, a, l, h, c);
        else {
          e.bindVertexArrayOES.set(this.vao);
          const i = e.gl;
          o && o.bind(),
            r && r.dynamicDraw && r.bind(),
            a && a.bind(),
            l && l.bind(),
            h && this._setAnimationBoundBuffers(h, i, t, n);
        }
      }
      freshBind(e, t, i, s, r, n, o, a, l, h) {
        let c;
        const _ = e.numAttributes,
          u = this.context,
          d = u.gl;
        if (u.extVertexArrayObject)
          this.vao && this.destroy(),
            (this.vao = u.extVertexArrayObject.createVertexArrayOES()),
            u.bindVertexArrayOES.set(this.vao),
            (c = 0),
            (this.boundProgram = e),
            (this.boundLayoutVertexBuffer = t),
            (this.boundPaintVertexBuffers = i),
            (this.boundIndexBuffer = s),
            (this.boundVertexOffset = r),
            (this.boundDynamicVertexBuffer = n),
            (this.boundDynamicVertexBuffer2 = o),
            (this.boundDynamicVertexBuffer3 = a),
            (this.instanceVerterBuffers = h),
            this._initAnimationBoundBuffer(l);
        else {
          c = u.currentNumAttributes || 0;
          for (let e = _; e < c; e++) d.disableVertexAttribArray(e);
        }
        t.enableAttributes(d, e);
        for (const t of i) t.enableAttributes(d, e);
        t.setVertexAttribPointers(d, e, r);
        for (const t of i) t.bind('default'), t.setVertexAttribPointers(d, e, r);
        s && s.bind(),
          n && (n.enableAttributes(d, e), n.bind('default'), n.setVertexAttribPointers(d, e, r)),
          o && (o.enableAttributes(d, e), o.bind('default'), o.setVertexAttribPointers(d, e, r)),
          a && (a.enableAttributes(d, e), a.bind('default'), a.setVertexAttribPointers(d, e, r)),
          l && this._setAnimationBoundBuffers(l, d, e, r),
          h && h.setVertexAttribPointers(d, e),
          (u.currentNumAttributes = _);
      }
      _requireFreshBind(e) {
        const {
          program: t,
          layoutVertexBuffer: i,
          paintBuffersDiffer: s,
          indexBuffer: r,
          vertexOffset: n,
          dynamicVertexBuffer: o,
          dynamicVertexBuffer2: a,
          dynamicVertexBuffer3: l,
          animationVertexBuffers: h,
        } = e;
        let c =
          !this.vao ||
          this.boundProgram !== t ||
          this.boundLayoutVertexBuffer !== i ||
          s ||
          this.boundIndexBuffer !== r ||
          this.boundVertexOffset !== n ||
          this.boundDynamicVertexBuffer !== o ||
          this.boundDynamicVertexBuffer2 !== a ||
          this.boundDynamicVertexBuffer3 !== l;
        if (h)
          for (const e in h) Object.hasOwnProperty.call(h, e) && (c = this[`bound${e}`] !== h[e]);
        return c;
      }
      _initAnimationBoundBuffer(e) {
        if (e) for (const t in e) Object.hasOwnProperty.call(e, t) && (this[`bound${t}`] = e[t]);
      }
      _setAnimationBoundBuffers(e, t, i, s) {
        for (const r in e)
          if (Object.hasOwnProperty.call(e, r)) {
            const n = e[r];
            n.enableAttributes(t, i), n.bind('default'), n.setVertexAttribPointers(t, i, s);
          }
      }
      _destroyAnimationVertexBuffers() {}
      destroy() {
        this.vao &&
          (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), (this.vao = null));
      }
      remove() {
        this.destroy(),
          (this.context = null),
          (this.boundProgram = null),
          (this.boundLayoutVertexBuffer = null),
          (this.boundPaintVertexBuffers = null),
          (this.boundIndexBuffer = null),
          (this.boundVertexOffset = null),
          (this.boundDynamicVertexBuffer = null),
          (this.boundDynamicVertexBuffer2 = null),
          (this.boundDynamicVertexBuffer3 = null),
          (this.instanceVerterBuffers = null),
          this._destroyAnimationVertexBuffers();
      }
    }
    class Tn extends e.Evented {
      constructor(t, i, s, r) {
        super(),
          (this.id = t),
          (this.type = '3d-model'),
          (this.minzoom = 15),
          (this.maxzoom = 18),
          (this.tileSize = 512),
          (this.isTileClipped = !0),
          (this.reparseOverscaled = !0),
          (this._removed = !1),
          (this.dispatcher = s),
          this.setEventedParent(r),
          (this.textures = []),
          (this.nodes = []),
          (this.meshes = []),
          (this.primitives = []),
          (this.materials = []),
          (this._loadedTextures = {}),
          (this._data = i.data),
          (this._options = e.extend({}, i)),
          (this.location = i.location || [0, 0]),
          (this.upAxis = i['up-axis'] || 'Y-UP'),
          (this.modelFolder = i.modelFolder),
          (this.scale = i.scale),
          (this.rotation = i.rotation),
          (this.translation = i.translation || [0, 0, 0]),
          (this._collectResourceTiming = i.collectResourceTiming),
          (this._resourceTiming = []),
          void 0 !== i.maxzoom && (this.maxzoom = i.maxzoom),
          i.type && (this.type = i.type),
          i.attribution && (this.attribution = i.attribution),
          (this.filter = i.filter),
          (this._pickable = i.pickable || !1),
          (this.log = i.log || !1),
          (this.useMipmap = void 0 === i.useMipmap || i.useMipmap),
          (this._abortListMap = new Map()),
          (this.lightingModel = i.lightingModel || e.LightingModelType.NONE),
          this.filter && this.setFilter(this.filter),
          i.aabbFilter && this.setAABBFilter(i.aabbFilter);
      }
      setFilter(t) {
        this._featureFilter = e.createFilter(t);
      }
      setAABBFilter(t) {
        this._aabbFilter = e.createFilter(t);
      }
      highlightModel() {}
      load(t) {
        this.fire(new e.Event('dataloading', { dataType: 'source' })), (this.state = 'dataloading');
        const i = e.extend({}, this.workerOptions);
        (i.location = this.location), (i.source = this.id);
        const s = this._data;
        (i.request =
          'string' == typeof s
            ? {
                url: e.exported.resolveURL(xr(s)),
                collectResourceTiming: this._collectResourceTiming,
              }
            : {
                url: new e.window.Blob([JSON.stringify(s)]),
                collectResourceTiming: this._collectResourceTiming,
              }),
          ut(
            i.request.url,
            _r,
            {
              gltf: { postProcess: !0, loadImages: !0 },
              context: this.map.painter.context,
              useMipmap: this.useMipmap,
              source: this,
              transformRequest: this.map._transformRequest,
              collectResourceTiming: this._collectResourceTiming,
              isDestroyed: this._removed,
              _abortListMap: this._abortListMap,
              dispatcher: this.map.style.dispatcher,
            },
            0,
            xr(this.modelFolder),
          ).then((e) => {
            if (e) {
              if (this._removed || (e && e.abandoned)) return;
              (this._loaded = !0), (this.state = 'parsing'), (this.result = e), t(null, e);
            } else t({ msg: 'loaders.gl load data fail' }, null);
          });
      }
      onAdd(e, t) {
        (this.map = e), this.load(t);
      }
      setLocation() {}
      prepare() {}
      loadTile(e, t) {
        e.state = 'loaded';
      }
      abortTile(e) {
        e.aborted = !0;
      }
      unloadTile(e) {}
      onRemove() {
        (this._removed = !0),
          this._abortListMap.forEach((e, t) => {
            e.abort(), this._abortListMap.delete(t);
          }),
          this.dispatcher.send(
            'removeSource',
            { type: this.type, source: this.id },
            null,
            this.workerID,
          );
      }
      serialize() {
        return e.extend({}, this._options, {
          type: this.type,
          data: this._data,
          maxzoom: this.maxzoom,
          bounds: this.bounds,
          location: this.location,
          'up-axis': this.upAxis,
        });
      }
      hasTransition() {
        return !1;
      }
      isEarthSource() {
        return !0;
      }
    }
    class xn extends e.Evented {
      constructor(t, i, s, r) {
        super(),
          (this.id = t),
          (this.dispatcher = s),
          (this.minzoom = 15),
          (this.maxzoom = 22),
          (this.reparseOverscaled = !0),
          (this.isTileClipped = !0),
          (this.vectorLayerIds = []),
          (this.type = '3d-tiles'),
          (this.priorityRequest = i.priorityRequest || !1),
          (this.layers = i.urls),
          (this.log = i.log || !1),
          (this.useMipmap = void 0 !== i.useMipmap && i.useMipmap),
          (this.allowPick = void 0 === i.allowPick || i.allowPick),
          e.extend(
            this,
            e.pick(i, [
              'url',
              'urls',
              'scheme',
              'modelFolder',
              'location',
              'filter',
              'minzoom',
              'maxzoom',
            ]),
          ),
          (this._options = e.extend({ type: this.type }, i)),
          (this.priorityRequest = i.priorityRequest || !1),
          (this.lightingModel = i.lightingModel || e.LightingModelType.NONE),
          (this._collectResourceTiming = i.collectResourceTiming),
          this.filter && this.setFilter(this.filter),
          this.setEventedParent(r);
      }
      load() {
        this.fire(new e.Event('data', { dataType: 'source', sourceDataType: 'metadata' }));
      }
      loadTile(e, t, i) {}
      setFilter(t) {
        this._featureFilter = e.createFilter(t);
      }
      prepare() {
        this.gltfModelVAO || (this.gltfModelVAO = new yn());
      }
      hasTile(e) {
        return !0;
      }
      onAdd(e) {
        (this.map = e), this.load();
      }
      onRemove(e) {}
      serialize() {
        return e.extend({}, this._options);
      }
      abortTile(e) {
        this.dispatcher.send(
          'abortTile',
          { uid: e.uid, type: this.type, source: this.id },
          void 0,
          e.workerID,
        );
      }
      unloadTile(e) {
        e.unloadVectorData(),
          this.dispatcher.send(
            'abortTile',
            { uid: e.uid, type: this.type, source: this.id },
            void 0,
            e.workerID,
          ),
          this.dispatcher.send(
            'removeTile',
            { uid: e.uid, type: this.type, source: this.id },
            void 0,
            e.workerID,
          );
      }
      hasTransition() {
        return !1;
      }
      isEarthSource() {
        return !0;
      }
      setViewFrustum(e) {
        this._eventedParent._setViewFrustum(e);
      }
    }
    const vn = {
      NONE: 0,
      CULLED: 1,
      RENDERED: 2,
      REFINED: 3,
      RENDERED_AND_KICKED: 6,
      REFINED_AND_KICKED: 7,
      CULLED_BUT_NEEDED: 9,
      wasKicked: (e) => e >= vn.RENDERED_AND_KICKED,
      originalResult: (e) => 3 & e,
      kick: (e) => 4 | e,
    };
    var bn = {
      data: new Map([
        ['0_0_0', [0, 12]],
        ['0_0_1', [1.74652099609375, 4076.049560546875]],
        ['1_0_0', [0, 12]],
        ['1_0_1', [0, 12]],
        ['1_0_2', [11.735595703125, 3884.501953125]],
        ['1_1_0', [0, 12]],
        ['1_1_1', [0, 12]],
        ['1_1_2', [26.597900390625, 4078.5]],
        ['2_0_0', [0, 12]],
        ['2_0_1', [0, 12]],
        ['2_0_2', [0, 12]],
        ['2_0_3', [0, 12]],
        ['2_0_4', [50.3212890625, 3741.1416015625]],
        ['2_1_0', [0, 12]],
        ['2_1_1', [0, 12]],
        ['2_1_2', [0, 12]],
        ['2_1_3', [0, 12]],
        ['2_1_4', [76.0703125, 3446.0634765625]],
        ['2_2_0', [0, 12]],
        ['2_2_1', [0, 12]],
        ['2_2_2', [0, 12]],
        ['2_2_3', [0, 12]],
        ['2_2_4', [1639.45703125, 3991.2802734375]],
        ['2_3_0', [0, 12]],
        ['2_3_1', [0, 12]],
        ['2_3_2', [0, 12]],
        ['2_3_3', [0, 12]],
        ['2_3_4', [19.154296875, 4008.1123046875]],
        ['3_0_0', [0, 12]],
        ['3_0_1', [0, 12]],
        ['3_0_2', [0, 12]],
        ['3_0_3', [0, 12]],
        ['3_0_4', [0, 12]],
        ['3_0_5', [0, 12]],
        ['3_0_6', [0, 12]],
        ['3_0_7', [0, 12]],
        ['3_0_8', [46.078125, 3758.09765625]],
        ['3_0_9', [2164.640625, 3153.890625]],
        ['3_1_0', [0, 12]],
        ['3_1_1', [0, 12]],
        ['3_1_2', [0, 12]],
        ['3_1_3', [0, 12]],
        ['3_1_4', [0, 12]],
        ['3_1_5', [0, 12]],
        ['3_1_6', [0, 12]],
        ['3_1_7', [0, 12]],
        ['3_1_8', [124.38671875, 3432.30859375]],
        ['3_1_9', [2215.0625, 3153.890625]],
        ['3_2_0', [0, 12]],
        ['3_2_1', [0, 12]],
        ['3_2_2', [0, 12]],
        ['3_2_3', [0, 12]],
        ['3_2_4', [0, 12]],
        ['3_2_5', [0, 12]],
        ['3_2_6', [0, 12]],
        ['3_2_7', [0, 12]],
        ['3_2_8', [344.16015625, 3153.890625]],
        ['3_2_9', [1899.703125, 3153.890625]],
        ['3_3_0', [0, 12]],
        ['3_3_1', [0, 12]],
        ['3_3_2', [0, 12]],
        ['3_3_3', [0, 12]],
        ['3_3_4', [0, 12]],
        ['3_3_5', [0, 12]],
        ['3_3_6', [0, 12]],
        ['3_3_7', [0, 12]],
        ['3_3_8', [711.09375, 3289.5703125]],
        ['3_3_9', [2070.8828125, 3095.5625]],
        ['3_4_0', [0, 12]],
        ['3_4_1', [0, 12]],
        ['3_4_2', [0, 12]],
        ['3_4_3', [0, 12]],
        ['3_4_4', [0, 12]],
        ['3_4_5', [0, 12]],
        ['3_4_6', [0, 12]],
        ['3_4_7', [0, 12]],
        ['3_4_8', [1842.58984375, 4081.046875]],
        ['3_4_9', [2450.3203125, 3247.0625]],
        ['3_5_0', [0, 12]],
        ['3_5_1', [0, 12]],
        ['3_5_2', [0, 12]],
        ['3_5_3', [0, 12]],
        ['3_5_4', [0, 12]],
        ['3_5_5', [0, 12]],
        ['3_5_6', [0, 12]],
        ['3_5_7', [0, 12]],
        ['3_5_8', [2436.3515625, 4081.046875]],
        ['3_5_9', [2450.3203125, 3431.81640625]],
        ['3_6_0', [0, 12]],
        ['3_6_1', [0, 12]],
        ['3_6_2', [0, 12]],
        ['3_6_3', [0, 12]],
        ['3_6_4', [0, 12]],
        ['3_6_5', [0, 12]],
        ['3_6_6', [0, 12]],
        ['3_6_7', [0, 12]],
        ['3_6_8', [2482.8203125, 4080.890625]],
        ['3_6_9', [2867.875, 3587.5625]],
        ['3_7_0', [0, 12]],
        ['3_7_1', [0, 12]],
        ['3_7_2', [0, 12]],
        ['3_7_3', [0, 12]],
        ['3_7_4', [0, 12]],
        ['3_7_5', [0, 12]],
        ['3_7_6', [0, 12]],
        ['3_7_7', [0, 12]],
        ['3_7_8', [36.33666229248047, 3826.6015625]],
        ['3_7_9', [2523.09375, 3153.5625]],
        ['4_0_0', [0, 3134]],
        ['4_0_1', [0, 0]],
        ['4_0_10', [1.796875, 30.21875]],
        ['4_0_11', [1.796875, 30.21875]],
        ['4_0_12', [0, 480]],
        ['4_0_13', [0, 572]],
        ['4_0_14', [0, 658.5]],
        ['4_0_15', [0, 0]],
        ['4_0_16', [63.734375, 3759.625]],
        ['4_0_17', [1422, 3759.625]],
        ['4_0_18', [2446.125, 3154]],
        ['4_0_2', [0.671875, 6.0625]],
        ['4_0_3', [0.015625, 1789.03125]],
        ['4_0_4', [0, 64]],
        ['4_0_5', [0, 178]],
        ['4_0_6', [0, 671.6666870117188]],
        ['4_0_7', [0, 1]],
        ['4_0_8', [0, 0]],
        ['4_0_9', [0, 0]],
        ['4_10_0', [0, 2770]],
        ['4_10_1', [0, 2344.75]],
        ['4_10_10', [0, 12]],
        ['4_10_11', [0, 220.25]],
        ['4_10_12', [0, 828.75]],
        ['4_10_13', [0, 1830.25]],
        ['4_10_14', [0, 2222.25]],
        ['4_10_15', [0, 1940]],
        ['4_10_16', [2574.875, 3565.453125]],
        ['4_10_17', [2574.875, 3565.453125]],
        ['4_10_18', [2574.875, 3565.453125]],
        ['4_10_2', [0, 2002.25]],
        ['4_10_3', [0, 532.25]],
        ['4_10_4', [-54.5, 1356.75]],
        ['4_10_5', [3, 5067]],
        ['4_10_6', [66, 4931.25]],
        ['4_10_7', [13, 657.75]],
        ['4_10_8', [0, 2192.5]],
        ['4_10_9', [0, 570.75]],
        ['4_11_0', [0, 2771]],
        ['4_11_1', [0, 438.5]],
        ['4_11_10', [0, 0]],
        ['4_11_11', [0, 0]],
        ['4_11_12', [0, 275.75]],
        ['4_11_13', [0, 2818.75]],
        ['4_11_14', [0, 2869.5]],
        ['4_11_15', [0, 2411]],
        ['4_11_16', [2729, 3565.453125]],
        ['4_11_17', [2729, 3565.453125]],
        ['4_11_18', [2729, 3565.453125]],
        ['4_11_2', [0, 458.5]],
        ['4_11_3', [0, 0]],
        ['4_11_4', [0, 266.25]],
        ['4_11_5', [0, 1518]],
        ['4_11_6', [94.5, 1545]],
        ['4_11_7', [0, 862.75]],
        ['4_11_8', [0, 538.75]],
        ['4_11_9', [0, 0]],
        ['4_12_0', [0, 2772]],
        ['4_12_1', [0, 730.5]],
        ['4_12_10', [0, 0]],
        ['4_12_11', [0, 0]],
        ['4_12_12', [0, 0]],
        ['4_12_13', [0, 2920.5]],
        ['4_12_14', [496.25, 3273.75]],
        ['4_12_15', [0, 2427]],
        ['4_12_16', [2599.71875, 3534.53125]],
        ['4_12_17', [2969, 3534.53125]],
        ['4_12_18', [2969, 3534.53125]],
        ['4_12_2', [0, 61.5]],
        ['4_12_3', [0, 940.25]],
        ['4_12_4', [0, 0]],
        ['4_12_5', [0, 1377.75]],
        ['4_12_6', [0, 1555.5]],
        ['4_12_7', [0, 998.5]],
        ['4_12_8', [0, 0]],
        ['4_12_9', [0, 0]],
        ['4_13_0', [0, 2774]],
        ['4_13_1', [0, 1613.25]],
        ['4_13_10', [0, 0]],
        ['4_13_11', [0, 581]],
        ['4_13_12', [0, 0]],
        ['4_13_13', [0, 628]],
        ['4_13_14', [0, 3126.25]],
        ['4_13_15', [0, 1961.75]],
        ['4_13_16', [2599.71875, 3534.53125]],
        ['4_13_17', [2817.5, 3534.53125]],
        ['4_13_18', [2907.875, 3534.53125]],
        ['4_13_2', [0, 294.5]],
        ['4_13_3', [0, 0]],
        ['4_13_4', [0, 0]],
        ['4_13_5', [0, 0]],
        ['4_13_6', [0, 52]],
        ['4_13_7', [0, 23]],
        ['4_13_8', [0, 0]],
        ['4_13_9', [0, 1058.5]],
        ['4_14_0', [559.25, 2777]],
        ['4_14_1', [0, 2532]],
        ['4_14_10', [0, 1718]],
        ['4_14_11', [0, 0]],
        ['4_14_12', [0, 0]],
        ['4_14_13', [0, 1716.5]],
        ['4_14_14', [0, 1267]],
        ['4_14_15', [0, 1114.5]],
        ['4_14_16', [1693.953125, 3534.53125]],
        ['4_14_17', [2206.125, 3131]],
        ['4_14_18', [2907.875, 3131]],
        ['4_14_2', [0.7083333134651184, 419.6875]],
        ['4_14_3', [0.7083333134651184, 2400.703125]],
        ['4_14_4', [0, 659]],
        ['4_14_5', [0, 0]],
        ['4_14_6', [0, 0]],
        ['4_14_7', [0, 135]],
        ['4_14_8', [0, 1064.5]],
        ['4_14_9', [0, 978]],
        ['4_15_0', [1795.25, 2780]],
        ['4_15_1', [0, 2921.5]],
        ['4_15_10', [0, 2952.25]],
        ['4_15_11', [0, 2189.75]],
        ['4_15_12', [0, 532.25]],
        ['4_15_13', [0, 713.25]],
        ['4_15_14', [0, 797.25]],
        ['4_15_15', [0, 0]],
        ['4_15_16', [338.65625, 3703.96875]],
        ['4_15_17', [2357.5, 3154]],
        ['4_15_18', [2379.21875, 3154]],
        ['4_15_2', [4.625, 24.49576759338379]],
        ['4_15_3', [0.09375, 1400]],
        ['4_15_4', [0, 332]],
        ['4_15_5', [0, 0]],
        ['4_15_6', [0, 273]],
        ['4_15_7', [0, 0]],
        ['4_15_8', [0, 877.25]],
        ['4_15_9', [64.5, 615.75]],
        ['4_1_0', [0, 3133.5]],
        ['4_1_1', [0, 447.5]],
        ['4_1_10', [1.796875, 30.21875]],
        ['4_1_11', [1.796875, 30.21875]],
        ['4_1_12', [0, 668.75]],
        ['4_1_13', [0, 663]],
        ['4_1_14', [0, 881.5]],
        ['4_1_15', [0, 0]],
        ['4_1_16', [63.734375, 3759.625]],
        ['4_1_17', [1304.765625, 3759.625]],
        ['4_1_18', [2428.875, 3154]],
        ['4_1_2', [0.671875, 6.0625]],
        ['4_1_3', [0.1875, 2243]],
        ['4_1_4', [0, 0]],
        ['4_1_5', [0, 0]],
        ['4_1_6', [0, 110]],
        ['4_1_7', [0, 1]],
        ['4_1_8', [0, 1]],
        ['4_1_9', [0, 516]],
        ['4_2_0', [0, 3085.5]],
        ['4_2_1', [0, 947.5]],
        ['4_2_10', [1.796875, 87.09375]],
        ['4_2_11', [1.796875, 87.09375]],
        ['4_2_12', [0, 119]],
        ['4_2_13', [0, 2440.25]],
        ['4_2_14', [0, 1496.25]],
        ['4_2_15', [0, 0]],
        ['4_2_16', [189.640625, 3443.125]],
        ['4_2_17', [1677.625, 3154]],
        ['4_2_18', [2428.875, 3154]],
        ['4_2_2', [0.3125, 695.640625]],
        ['4_2_3', [0.0625, 2081.296875]],
        ['4_2_4', [0, 0]],
        ['4_2_5', [0, 0]],
        ['4_2_6', [0, 462.6666564941406]],
        ['4_2_7', [0, 0]],
        ['4_2_8', [0, 0]],
        ['4_2_9', [0, 1918.6666259765625]],
        ['4_3_0', [132.5, 2982]],
        ['4_3_1', [0, 2438.5]],
        ['4_3_10', [1.234375, 590.125]],
        ['4_3_11', [5.0625, 590.125]],
        ['4_3_12', [0, 0]],
        ['4_3_13', [0, 2965.75]],
        ['4_3_14', [0, 1752.25]],
        ['4_3_15', [0, 0]],
        ['4_3_16', [694.40625, 2931]],
        ['4_3_17', [1421.375, 2931]],
        ['4_3_18', [1849.9375, 2931]],
        ['4_3_2', [0.046875, 2011]],
        ['4_3_3', [0.109375, 1291.046875]],
        ['4_3_4', [0, 0]],
        ['4_3_5', [0, 59]],
        ['4_3_6', [0, 1]],
        ['4_3_7', [0, 322]],
        ['4_3_8', [0, 0]],
        ['4_3_9', [0, 0]],
        ['4_4_0', [435, 2916.25]],
        ['4_4_1', [0, 2667.25]],
        ['4_4_10', [0, 0]],
        ['4_4_11', [0, 1213.25]],
        ['4_4_12', [0, 2339]],
        ['4_4_13', [0, 2041]],
        ['4_4_14', [0, 434.75]],
        ['4_4_15', [0, 0]],
        ['4_4_16', [510.375, 2931]],
        ['4_4_17', [1421.375, 2931]],
        ['4_4_18', [1849.9375, 2931]],
        ['4_4_2', [0.0625, 2027.765625]],
        ['4_4_3', [0.078125, 1909.375]],
        ['4_4_4', [0, 0]],
        ['4_4_5', [0, 6]],
        ['4_4_6', [0.1875, 2411.328125]],
        ['4_4_7', [0.15625, 4634.25]],
        ['4_4_8', [0, 0]],
        ['4_4_9', [0, 0]],
        ['4_5_0', [865.25, 2905]],
        ['4_5_1', [0, 2840.75]],
        ['4_5_10', [-65.75, 2189.75]],
        ['4_5_11', [-3.75, 3412.5]],
        ['4_5_12', [0, 2555.25]],
        ['4_5_13', [86.75, 1656.25]],
        ['4_5_14', [0, 774.25]],
        ['4_5_15', [0, 0]],
        ['4_5_16', [510.375, 2931]],
        ['4_5_17', [1421.375, 2931]],
        ['4_5_18', [1779.390625, 2931]],
        ['4_5_2', [0.25, 3230.796875]],
        ['4_5_3', [0.078125, 3230.796875]],
        ['4_5_4', [0, 0]],
        ['4_5_5', [0, 0]],
        ['4_5_6', [0.640625, 2228.5]],
        ['4_5_7', [0.15625, 4397.890625]],
        ['4_5_8', [0, 0]],
        ['4_5_9', [0, 1]],
        ['4_6_0', [1473.5, 2840]],
        ['4_6_1', [0, 2786.75]],
        ['4_6_10', [0, 2842.25]],
        ['4_6_11', [480.75, 3618]],
        ['4_6_12', [258.5, 3037]],
        ['4_6_13', [0, 787.75]],
        ['4_6_14', [0, 420]],
        ['4_6_15', [0, 193.25]],
        ['4_6_16', [1152.171875, 2953.015625]],
        ['4_6_17', [1823.90625, 2953.015625]],
        ['4_6_18', [1823.90625, 2953.015625]],
        ['4_6_2', [0.03125, 3230.796875]],
        ['4_6_3', [0.015625, 3230.796875]],
        ['4_6_4', [0, 0]],
        ['4_6_5', [0, 108]],
        ['4_6_6', [0, 0]],
        ['4_6_7', [0, 0]],
        ['4_6_8', [0, 0]],
        ['4_6_9', [0, 2547]],
        ['4_7_0', [1680.5, 2788.25]],
        ['4_7_1', [0, 1900.75]],
        ['4_7_10', [0, 2681.25]],
        ['4_7_11', [40.25, 1032.5]],
        ['4_7_12', [36.25, 693.75]],
        ['4_7_13', [0, 481.75]],
        ['4_7_14', [0, 1229.75]],
        ['4_7_15', [0, 1710.75]],
        ['4_7_16', [1823.90625, 2953.015625]],
        ['4_7_17', [1823.90625, 2953.015625]],
        ['4_7_18', [1823.90625, 2953.015625]],
        ['4_7_2', [0.03125, 2785.96875]],
        ['4_7_3', [0.015625, 2785.96875]],
        ['4_7_4', [0, 0]],
        ['4_7_5', [0, 0]],
        ['4_7_6', [0, 0]],
        ['4_7_7', [0, 604.25]],
        ['4_7_8', [0, 550.75]],
        ['4_7_9', [0, 3255.25]],
        ['4_8_0', [0, 2768]],
        ['4_8_1', [0, 3665]],
        ['4_8_10', [0, 361]],
        ['4_8_11', [6, 1300.75]],
        ['4_8_12', [0, 543.5]],
        ['4_8_13', [0, 420]],
        ['4_8_14', [0, 1748.25]],
        ['4_8_15', [0, 1660.25]],
        ['4_8_16', [1943.75, 2953.015625]],
        ['4_8_17', [2326.203125, 2953.015625]],
        ['4_8_18', [2326.203125, 2953.015625]],
        ['4_8_2', [0, 0]],
        ['4_8_3', [0, 0]],
        ['4_8_4', [0, 0]],
        ['4_8_5', [0, 467]],
        ['4_8_6', [0, 0]],
        ['4_8_7', [0, 4033.5]],
        ['4_8_8', [0, 2634.5]],
        ['4_8_9', [0, 1756.5]],
        ['4_9_0', [0, 2769]],
        ['4_9_1', [0, 2139.25]],
        ['4_9_10', [0, 15]],
        ['4_9_11', [0, 839.5]],
        ['4_9_12', [0, 896.75]],
        ['4_9_13', [0, 948.75]],
        ['4_9_14', [0, 1494.5]],
        ['4_9_15', [0, 1885]],
        ['4_9_16', [2574.875, 3565.453125]],
        ['4_9_17', [2574.875, 3565.453125]],
        ['4_9_18', [2574.875, 3565.453125]],
        ['4_9_2', [0, 1030.5]],
        ['4_9_3', [-54.75, 3417.5]],
        ['4_9_4', [0, 4059.5]],
        ['4_9_5', [0, 5609.25]],
        ['4_9_6', [0, 5336.75]],
        ['4_9_7', [0, 4774.75]],
        ['4_9_8', [0, 4299.75]],
        ['4_9_9', [0, 1894.75]],
        ['5_0_0', [0, 3130]],
        ['5_0_1', [0, 1010]],
        ['5_0_10', [0, 178]],
        ['5_0_11', [0, 0]],
        ['5_0_12', [0, 468]],
        ['5_0_13', [0, 454]],
        ['5_0_14', [0, 0]],
        ['5_0_15', [0, 0]],
        ['5_0_16', [1.4375, 1654.1875]],
        ['5_0_17', [1.8125, 1654.1875]],
        ['5_0_18', [10.5625, 402.25]],
        ['5_0_19', [10.5625, 402.25]],
        ['5_0_20', [14.625, 35.75]],
        ['5_0_21', [14.625, 35.75]],
        ['5_0_22', [14.625, 35.75]],
        ['5_0_24', [0, 0]],
        ['5_0_25', [0, 480]],
        ['5_0_26', [0, 0]],
        ['5_0_27', [0, 619]],
        ['5_0_28', [0, 793]],
        ['5_0_29', [0, 0]],
        ['5_0_30', [51.75, 137.25]],
        ['5_0_31', [51.75, 3607]],
        ['5_0_32', [74.75, 3607]],
        ['5_0_33', [1646.25, 3123.5]],
        ['5_0_34', [1646.25, 3059]],
        ['5_0_35', [2191.75, 3154]],
        ['5_0_36', [2898.75, 3154]],
        ['5_0_37', [2898.75, 3154]],
        ['5_0_5', [0.375, 30.0625]],
        ['5_0_6', [0.25, 790.75]],
        ['5_0_7', [0.0625, 1219.8125]],
        ['5_0_8', [0, 72]],
        ['5_0_9', [0, 0]],
        ['5_10_0', [0, 2906]],
        ['5_10_1', [861, 1666]],
        ['5_10_10', [0.0625, 1100.0625]],
        ['5_10_11', [0.0625, 1140.5]],
        ['5_10_12', [0.0625, 209.625]],
        ['5_10_13', [0.0625, 728.75]],
        ['5_10_14', [0.5, 2988.8125]],
        ['5_10_15', [0.5625, 2988.8125]],
        ['5_10_16', [1, 5104.375]],
        ['5_10_17', [5.875, 5538.1875]],
        ['5_10_18', [0, 0]],
        ['5_10_19', [0, 0]],
        ['5_10_2', [0, 2332]],
        ['5_10_20', [0, 0]],
        ['5_10_21', [0, 707]],
        ['5_10_22', [-10, 3580]],
        ['5_10_23', [19, 2564]],
        ['5_10_24', [0, 2473]],
        ['5_10_25', [514, 2485]],
        ['5_10_26', [136, 1731]],
        ['5_10_27', [69, 925]],
        ['5_10_28', [0, 805]],
        ['5_10_29', [0, 392]],
        ['5_10_3', [0, 0]],
        ['5_10_30', [77.0625, 1605]],
        ['5_10_31', [161, 2021.5]],
        ['5_10_32', [754.5, 2365.25]],
        ['5_10_33', [1289.75, 2449]],
        ['5_10_34', [1418, 2449]],
        ['5_10_35', [2253, 2668]],
        ['5_10_36', [2253, 2668]],
        ['5_10_37', [2253, 2668]],
        ['5_10_4', [0.4375, 2452.125]],
        ['5_10_5', [0.125, 2768.75]],
        ['5_10_6', [0.0625, 2316.875]],
        ['5_10_7', [0.0625, 1965]],
        ['5_10_8', [0.125, 1965]],
        ['5_10_9', [0.125, 1216.25]],
        ['5_11_0', [0, 2887]],
        ['5_11_1', [1102, 1801]],
        ['5_11_10', [0.3125, 972.9375]],
        ['5_11_11', [0.375, 739.3125]],
        ['5_11_12', [0.9375, 167]],
        ['5_11_13', [0.9375, 167]],
        ['5_11_14', [1.125, 283.9375]],
        ['5_11_15', [1, 778.25]],
        ['5_11_16', [1, 1547.125]],
        ['5_11_17', [0.375, 2273.25]],
        ['5_11_18', [0, 0]],
        ['5_11_19', [0, 1]],
        ['5_11_2', [0, 2937]],
        ['5_11_20', [0, 1029]],
        ['5_11_21', [-69, 2352]],
        ['5_11_22', [-37, 3038]],
        ['5_11_23', [668, 2912]],
        ['5_11_24', [361, 2664]],
        ['5_11_25', [450, 2720]],
        ['5_11_26', [145, 931]],
        ['5_11_27', [153, 608]],
        ['5_11_28', [0, 556]],
        ['5_11_29', [0, 633]],
        ['5_11_3', [0, 0]],
        ['5_11_30', [77.0625, 1979.5]],
        ['5_11_31', [161, 1843.5]],
        ['5_11_32', [754.5, 2365.25]],
        ['5_11_33', [1289.75, 2449]],
        ['5_11_34', [1479, 2449]],
        ['5_11_35', [2253, 2668]],
        ['5_11_36', [2253, 2668]],
        ['5_11_37', [2253, 2668]],
        ['5_11_4', [759.625, 2806.75]],
        ['5_11_5', [0.375, 3107.6875]],
        ['5_11_6', [0.0625, 3107.6875]],
        ['5_11_7', [0.0625, 3102.75]],
        ['5_11_8', [0.0625, 2795.0625]],
        ['5_11_9', [0.25, 2795.0625]],
        ['5_12_0', [0, 2841]],
        ['5_12_1', [1463, 2022]],
        ['5_12_10', [0, 0]],
        ['5_12_11', [0, 108]],
        ['5_12_12', [2.347222328186035, 677.3125]],
        ['5_12_13', [1.8125, 227.75]],
        ['5_12_14', [1.75, 380.1875]],
        ['5_12_15', [1.75, 315.25]],
        ['5_12_16', [0.125, 1646.0625]],
        ['5_12_17', [0.375, 2273.25]],
        ['5_12_18', [0, 0]],
        ['5_12_19', [0, 1]],
        ['5_12_2', [0, 3159]],
        ['5_12_20', [0, 2580]],
        ['5_12_21', [0, 2802]],
        ['5_12_22', [435, 3693]],
        ['5_12_23', [1114, 3570]],
        ['5_12_24', [641, 3232]],
        ['5_12_25', [388, 1002]],
        ['5_12_26', [164, 811]],
        ['5_12_27', [0, 604]],
        ['5_12_28', [0, 486]],
        ['5_12_29', [0, 324]],
        ['5_12_3', [0, 0]],
        ['5_12_30', [0, 10]],
        ['5_12_31', [0, 0]],
        ['5_12_32', [1362.5, 2582]],
        ['5_12_33', [1362.5, 2582]],
        ['5_12_34', [1362.5, 2582]],
        ['5_12_35', [2246, 2645]],
        ['5_12_36', [2246, 2645]],
        ['5_12_37', [2246, 2645]],
        ['5_12_4', [1596.25, 2856.5]],
        ['5_12_5', [1799.25, 3137.25]],
        ['5_12_6', [1264.1875, 3137.25]],
        ['5_12_7', [1.1875, 3169.375]],
        ['5_12_8', [0.25, 3171.75]],
        ['5_12_9', [0.25, 2649.25]],
        ['5_13_0', [0, 2805]],
        ['5_13_1', [1713, 2204]],
        ['5_13_10', [0, 0]],
        ['5_13_11', [0, 0]],
        ['5_13_12', [1.0625, 1451.75]],
        ['5_13_13', [1.8125, 632.5]],
        ['5_13_14', [0.9375, 1814.6875]],
        ['5_13_15', [0.9375, 396]],
        ['5_13_16', [0.125, 1079.75]],
        ['5_13_17', [0.625, 931.625]],
        ['5_13_18', [0, 0]],
        ['5_13_19', [0, 2931]],
        ['5_13_2', [0, 1834]],
        ['5_13_20', [0, 2874]],
        ['5_13_21', [344, 2725]],
        ['5_13_22', [745, 3687]],
        ['5_13_23', [545, 3643]],
        ['5_13_24', [436, 1294]],
        ['5_13_25', [258, 779]],
        ['5_13_26', [238, 606]],
        ['5_13_27', [28, 457]],
        ['5_13_28', [0, 282]],
        ['5_13_29', [0, 266]],
        ['5_13_3', [0, 599]],
        ['5_13_30', [0, 203]],
        ['5_13_31', [0, 0]],
        ['5_13_32', [1362.5, 2582]],
        ['5_13_33', [1362.5, 2582]],
        ['5_13_34', [1362.5, 2582]],
        ['5_13_35', [2246, 2645]],
        ['5_13_36', [2246, 2645]],
        ['5_13_37', [2246, 2645]],
        ['5_13_4', [0.0625, 2781]],
        ['5_13_5', [0.125, 3137.25]],
        ['5_13_6', [0.125, 3137.25]],
        ['5_13_7', [0.125, 3306]],
        ['5_13_8', [0.0625, 3171.75]],
        ['5_13_9', [0.875, 77.0625]],
        ['5_14_0', [0, 2791]],
        ['5_14_1', [1834, 2449]],
        ['5_14_10', [0.8125, 551.4375]],
        ['5_14_11', [0.3125, 782.9375]],
        ['5_14_12', [0.3125, 2879.0625]],
        ['5_14_13', [0.25, 2879.0625]],
        ['5_14_14', [0, 0]],
        ['5_14_15', [0, 0]],
        ['5_14_16', [0, 0]],
        ['5_14_17', [0, 0]],
        ['5_14_18', [0, 2828]],
        ['5_14_19', [0, 3765]],
        ['5_14_2', [0, 1852]],
        ['5_14_20', [0, 2781]],
        ['5_14_21', [0, 926]],
        ['5_14_22', [135, 1024]],
        ['5_14_23', [282, 1052]],
        ['5_14_24', [213, 706]],
        ['5_14_25', [152, 733]],
        ['5_14_26', [49, 531]],
        ['5_14_27', [0, 327]],
        ['5_14_28', [0, 414]],
        ['5_14_29', [0, 363]],
        ['5_14_3', [0, 649]],
        ['5_14_30', [0, 287]],
        ['5_14_31', [0, 0]],
        ['5_14_32', [1362.5, 2582]],
        ['5_14_33', [1362.5, 2582]],
        ['5_14_34', [1362.5, 2582]],
        ['5_14_35', [2246, 2645]],
        ['5_14_36', [2246, 2645]],
        ['5_14_37', [2246, 2645]],
        ['5_14_4', [0.0625, 1855]],
        ['5_14_5', [0.125, 2137.5]],
        ['5_14_6', [0.125, 2443.75]],
        ['5_14_7', [0.125, 1938.0625]],
        ['5_14_8', [0.0625, 1992.3125]],
        ['5_14_9', [0.875, 412.0625]],
        ['5_15_0', [0, 2769]],
        ['5_15_1', [1684, 2294]],
        ['5_15_10', [0.1875, 1052.3125]],
        ['5_15_11', [0.8125, 2703.8125]],
        ['5_15_12', [0.625, 3541.875]],
        ['5_15_13', [0.625, 3541.875]],
        ['5_15_14', [0, 0]],
        ['5_15_15', [0, 897]],
        ['5_15_16', [0, 861]],
        ['5_15_17', [0, 0]],
        ['5_15_18', [0, 3282]],
        ['5_15_19', [0, 2059]],
        ['5_15_2', [0, 1911]],
        ['5_15_20', [0, 0]],
        ['5_15_21', [0, 160]],
        ['5_15_22', [39, 630]],
        ['5_15_23', [137, 479]],
        ['5_15_24', [183, 598]],
        ['5_15_25', [37, 447]],
        ['5_15_26', [0, 204]],
        ['5_15_27', [0, 492]],
        ['5_15_28', [0, 491]],
        ['5_15_29', [0, 1200]],
        ['5_15_3', [0, 810]],
        ['5_15_30', [0, 1751]],
        ['5_15_31', [0, 0]],
        ['5_15_32', [2299.75, 2785]],
        ['5_15_33', [2299.75, 2785]],
        ['5_15_34', [2299.75, 2785]],
        ['5_15_35', [2443.5, 2822]],
        ['5_15_36', [2443.5, 2822]],
        ['5_15_37', [2443.5, 2822]],
        ['5_15_4', [0.75, 312.25]],
        ['5_15_5', [0.5333333611488342, 235.75]],
        ['5_15_6', [0.5333333611488342, 1805.125]],
        ['5_15_7', [0.5333333611488342, 1805.125]],
        ['5_15_8', [0.625, 857.75]],
        ['5_15_9', [0.1875, 1052.3125]],
        ['5_16_0', [0, 2768]],
        ['5_16_1', [490, 2380]],
        ['5_16_10', [0, 0]],
        ['5_16_11', [0, 0]],
        ['5_16_12', [0.8125, 2703.8125]],
        ['5_16_13', [0.9375, 2393.5625]],
        ['5_16_14', [0, 0]],
        ['5_16_15', [0, 334]],
        ['5_16_16', [0, 0]],
        ['5_16_17', [0, 1776]],
        ['5_16_18', [0, 2117]],
        ['5_16_19', [0, 672]],
        ['5_16_2', [0, 4010]],
        ['5_16_20', [0, 0]],
        ['5_16_21', [0, 374]],
        ['5_16_22', [62, 817]],
        ['5_16_23', [146, 433]],
        ['5_16_24', [120, 553]],
        ['5_16_25', [0, 395]],
        ['5_16_26', [0, 99]],
        ['5_16_27', [0, 465]],
        ['5_16_28', [0, 629]],
        ['5_16_29', [0, 1408]],
        ['5_16_3', [0, 251]],
        ['5_16_30', [0, 1274]],
        ['5_16_31', [0, 0]],
        ['5_16_32', [2299.75, 2785]],
        ['5_16_33', [2299.75, 2785]],
        ['5_16_34', [2299.75, 2785]],
        ['5_16_35', [2443.5, 2822]],
        ['5_16_36', [2443.5, 2822]],
        ['5_16_37', [2443.5, 2822]],
        ['5_16_4', [0.125, 1308.5]],
        ['5_16_5', [0.5333333611488342, 386]],
        ['5_16_6', [0.5333333611488342, 382]],
        ['5_16_7', [0.5333333611488342, 1498.0625]],
        ['5_16_8', [0.5, 2098.5625]],
        ['5_16_9', [0.25, 2098.5625]],
        ['5_17_0', [0, 2768]],
        ['5_17_1', [0, 1867]],
        ['5_17_10', [0, 467]],
        ['5_17_11', [0, 0]],
        ['5_17_12', [0.125, 2712.4375]],
        ['5_17_13', [0.8125, 3114.0625]],
        ['5_17_14', [0, 3708]],
        ['5_17_15', [0, 4414]],
        ['5_17_16', [0, 2295]],
        ['5_17_17', [0, 3021]],
        ['5_17_18', [0, 317]],
        ['5_17_19', [0, 703]],
        ['5_17_2', [0, 1381]],
        ['5_17_20', [0, 337]],
        ['5_17_21', [0, 289]],
        ['5_17_22', [0, 1438]],
        ['5_17_23', [75, 812]],
        ['5_17_24', [67, 516]],
        ['5_17_25', [0, 186]],
        ['5_17_26', [0, 143]],
        ['5_17_27', [0, 463]],
        ['5_17_28', [0, 1475]],
        ['5_17_29', [0, 1849]],
        ['5_17_3', [0, 308]],
        ['5_17_30', [0, 1758]],
        ['5_17_31', [0, 0]],
        ['5_17_32', [2299.75, 2785]],
        ['5_17_33', [2299.75, 2785]],
        ['5_17_34', [2299.75, 2785]],
        ['5_17_35', [2443.5, 2822]],
        ['5_17_36', [2443.5, 2822]],
        ['5_17_37', [2443.5, 2822]],
        ['5_17_4', [0.0625, 1500.5]],
        ['5_17_5', [0.125, 915.9375]],
        ['5_17_6', [0.125, 1153.75]],
        ['5_17_7', [0.0625, 1704.5]],
        ['5_17_8', [1, 2098.5625]],
        ['5_17_9', [1.8125, 2098.5625]],
        ['5_18_0', [0, 2769]],
        ['5_18_1', [0, 1263]],
        ['5_18_10', [0, 0]],
        ['5_18_11', [0, 0]],
        ['5_18_12', [0, 0]],
        ['5_18_13', [0, 5174]],
        ['5_18_14', [0, 5318]],
        ['5_18_15', [92, 4436]],
        ['5_18_16', [0, 4545]],
        ['5_18_17', [0, 4475]],
        ['5_18_18', [0, 576]],
        ['5_18_19', [0, 1224]],
        ['5_18_2', [0, 1699]],
        ['5_18_20', [0, 15]],
        ['5_18_21', [0, 6]],
        ['5_18_22', [0, 734]],
        ['5_18_23', [0, 994]],
        ['5_18_24', [5, 608]],
        ['5_18_25', [0, 591]],
        ['5_18_26', [0, 618]],
        ['5_18_27', [0, 593]],
        ['5_18_28', [0, 1515]],
        ['5_18_29', [0, 1598]],
        ['5_18_3', [0, 634]],
        ['5_18_30', [0, 1938]],
        ['5_18_31', [0, 0]],
        ['5_18_32', [2613.75, 3471]],
        ['5_18_33', [2613.75, 3471]],
        ['5_18_34', [2613.75, 3471]],
        ['5_18_35', [2735, 3108]],
        ['5_18_36', [2735, 3108]],
        ['5_18_37', [2735, 3108]],
        ['5_18_4', [0, 0]],
        ['5_18_5', [0, 0]],
        ['5_18_6', [0, 1793]],
        ['5_18_7', [0, 3826]],
        ['5_18_8', [0, 648]],
        ['5_18_9', [0, 1118]],
        ['5_19_0', [0, 2769]],
        ['5_19_1', [0, 1009]],
        ['5_19_10', [0, 5304]],
        ['5_19_11', [0, 5893]],
        ['5_19_12', [0, 5074]],
        ['5_19_13', [0, 5556]],
        ['5_19_14', [77, 587]],
        ['5_19_15', [55, 285]],
        ['5_19_16', [34, 3434]],
        ['5_19_17', [0, 4231]],
        ['5_19_18', [0, 771]],
        ['5_19_19', [-19, 2102]],
        ['5_19_2', [0, 2016]],
        ['5_19_20', [0, 0]],
        ['5_19_21', [0, 0]],
        ['5_19_22', [0, 0]],
        ['5_19_23', [0, 1008]],
        ['5_19_24', [0, 935]],
        ['5_19_25', [133, 923]],
        ['5_19_26', [0, 589]],
        ['5_19_27', [0, 934]],
        ['5_19_28', [0, 1328]],
        ['5_19_29', [0, 1433]],
        ['5_19_3', [0, 2297]],
        ['5_19_30', [0, 1754]],
        ['5_19_31', [0, 0]],
        ['5_19_32', [2613.75, 3471]],
        ['5_19_33', [2613.75, 3471]],
        ['5_19_34', [2613.75, 3471]],
        ['5_19_35', [2735, 3108]],
        ['5_19_36', [2735, 3108]],
        ['5_19_37', [2735, 3108]],
        ['5_19_4', [0, 1266]],
        ['5_19_5', [0, 0]],
        ['5_19_6', [0, 1275]],
        ['5_19_7', [-75, 2339]],
        ['5_19_8', [0, 1882]],
        ['5_19_9', [0, 4748]],
        ['5_1_0', [0, 3135]],
        ['5_1_1', [0, 0]],
        ['5_1_10', [0, 0]],
        ['5_1_11', [0, 0]],
        ['5_1_12', [0, 19]],
        ['5_1_13', [0, 828]],
        ['5_1_14', [0, 0]],
        ['5_1_15', [0, 1]],
        ['5_1_16', [1.4375, 701.25]],
        ['5_1_17', [1.8125, 701.25]],
        ['5_1_18', [10.5625, 182.3125]],
        ['5_1_19', [10.5625, 182.3125]],
        ['5_1_20', [14.625, 35.75]],
        ['5_1_21', [14.625, 35.75]],
        ['5_1_22', [14.625, 35.75]],
        ['5_1_24', [0, 0]],
        ['5_1_25', [0, 515]],
        ['5_1_26', [0, 106]],
        ['5_1_27', [0, 466]],
        ['5_1_28', [0, 0]],
        ['5_1_29', [0, 0]],
        ['5_1_30', [51.75, 137.25]],
        ['5_1_31', [51.75, 3607]],
        ['5_1_32', [74.75, 3607]],
        ['5_1_33', [596.25, 3761.25]],
        ['5_1_34', [1646.25, 3279]],
        ['5_1_35', [2163, 3154]],
        ['5_1_36', [2546.75, 3154]],
        ['5_1_37', [2546.75, 3154]],
        ['5_1_5', [0.375, 30.0625]],
        ['5_1_6', [0.375, 325.875]],
        ['5_1_7', [0.0625, 1887.5]],
        ['5_1_8', [0, 0]],
        ['5_1_9', [0, 0]],
        ['5_20_0', [0, 2769]],
        ['5_20_1', [0, 769]],
        ['5_20_10', [56, 3801]],
        ['5_20_11', [70, 5256]],
        ['5_20_12', [169, 5128]],
        ['5_20_13', [119, 4541]],
        ['5_20_14', [47, 889]],
        ['5_20_15', [24, 208]],
        ['5_20_16', [26, 2466]],
        ['5_20_17', [0, 2379]],
        ['5_20_18', [0, 310]],
        ['5_20_19', [0, 745]],
        ['5_20_2', [0, 2091]],
        ['5_20_20', [0, 0]],
        ['5_20_21', [0, 12]],
        ['5_20_22', [0, 0]],
        ['5_20_23', [0, 228]],
        ['5_20_24', [0, 927]],
        ['5_20_25', [0, 902]],
        ['5_20_26', [0, 970]],
        ['5_20_27', [0, 1889]],
        ['5_20_28', [0, 1279]],
        ['5_20_29', [0, 1906]],
        ['5_20_3', [0, 2494]],
        ['5_20_30', [0, 1528]],
        ['5_20_31', [0, 0]],
        ['5_20_32', [2613.75, 3471]],
        ['5_20_33', [2613.75, 3471]],
        ['5_20_34', [2613.75, 3471]],
        ['5_20_35', [2735, 3108]],
        ['5_20_36', [2735, 3108]],
        ['5_20_37', [2735, 3108]],
        ['5_20_4', [0, 2049]],
        ['5_20_5', [0, 0]],
        ['5_20_6', [0, 603]],
        ['5_20_7', [0, 584]],
        ['5_20_8', [-73, 1371]],
        ['5_20_9', [-15, 725]],
        ['5_21_0', [0, 2770]],
        ['5_21_1', [0, 1173]],
        ['5_21_10', [0, 325]],
        ['5_21_11', [39, 497]],
        ['5_21_12', [58, 706]],
        ['5_21_13', [96, 787]],
        ['5_21_14', [28, 591]],
        ['5_21_15', [12, 304]],
        ['5_21_16', [2, 2115]],
        ['5_21_17', [0, 2272]],
        ['5_21_18', [0, 590]],
        ['5_21_19', [0, 2]],
        ['5_21_2', [0, 898]],
        ['5_21_20', [0, 0]],
        ['5_21_21', [0, 0]],
        ['5_21_22', [0, 0]],
        ['5_21_23', [0, 4]],
        ['5_21_24', [0, 604]],
        ['5_21_25', [0, 762]],
        ['5_21_26', [0, 469]],
        ['5_21_27', [0, 736]],
        ['5_21_28', [0, 199]],
        ['5_21_29', [0, 2220]],
        ['5_21_3', [0, 1227]],
        ['5_21_30', [0, 1947]],
        ['5_21_31', [0, 0]],
        ['5_21_32', [3058, 3365]],
        ['5_21_33', [3058, 3365]],
        ['5_21_34', [3058, 3365]],
        ['5_21_35', [3023, 3121]],
        ['5_21_36', [3023, 3121]],
        ['5_21_37', [3023, 3121]],
        ['5_21_4', [0, 1961]],
        ['5_21_5', [0, 0]],
        ['5_21_6', [0, 177]],
        ['5_21_7', [0, 0]],
        ['5_21_8', [0, 0]],
        ['5_21_9', [0, 503]],
        ['5_22_0', [0, 2770]],
        ['5_22_1', [0, 1405]],
        ['5_22_10', [0, 998]],
        ['5_22_11', [62, 1260]],
        ['5_22_12', [88, 920]],
        ['5_22_13', [108, 853]],
        ['5_22_14', [80, 594]],
        ['5_22_15', [0, 499]],
        ['5_22_16', [0, 598]],
        ['5_22_17', [0, 28]],
        ['5_22_18', [5.5625, 198.4375]],
        ['5_22_19', [5.5625, 441.8125]],
        ['5_22_2', [0, 0]],
        ['5_22_20', [0.6875, 978.9375]],
        ['5_22_21', [0.6875, 2126.9375]],
        ['5_22_22', [10.5, 264.53125]],
        ['5_22_23', [0.625, 945.625]],
        ['5_22_24', [0, 301]],
        ['5_22_25', [0, 277]],
        ['5_22_26', [0, 0]],
        ['5_22_27', [0, 2075]],
        ['5_22_28', [0, 2132]],
        ['5_22_29', [0, 2511]],
        ['5_22_3', [0, 0]],
        ['5_22_30', [0, 2216]],
        ['5_22_31', [0, 0]],
        ['5_22_32', [3058, 3365]],
        ['5_22_33', [3058, 3365]],
        ['5_22_34', [3058, 3365]],
        ['5_22_35', [3023, 3121]],
        ['5_22_36', [3023, 3121]],
        ['5_22_37', [3023, 3121]],
        ['5_22_4', [0, 475]],
        ['5_22_5', [0, 683]],
        ['5_22_6', [0.1875, 390.3125]],
        ['5_22_7', [0.1875, 1079.5]],
        ['5_22_8', [0, 0]],
        ['5_22_9', [0, 328]],
        ['5_23_0', [0, 2771]],
        ['5_23_1', [0, 1404]],
        ['5_23_10', [0, 1491]],
        ['5_23_11', [0, 1660]],
        ['5_23_12', [270, 1548]],
        ['5_23_13', [183, 1209]],
        ['5_23_14', [74, 913]],
        ['5_23_15', [0, 333]],
        ['5_23_16', [0, 25]],
        ['5_23_17', [0, 0]],
        ['5_23_18', [5.5625, 198.4375]],
        ['5_23_19', [5.5625, 441.8125]],
        ['5_23_2', [0, 471]],
        ['5_23_20', [0.6875, 264.53125]],
        ['5_23_21', [0.6875, 264.53125]],
        ['5_23_22', [10.5, 264.53125]],
        ['5_23_23', [0.625, 2250.125]],
        ['5_23_24', [0, 0]],
        ['5_23_25', [0, 0]],
        ['5_23_26', [0, 2496]],
        ['5_23_27', [0, 2807]],
        ['5_23_28', [0, 2859]],
        ['5_23_29', [2024, 2859]],
        ['5_23_3', [0, 0]],
        ['5_23_30', [0, 2417]],
        ['5_23_31', [0, 0]],
        ['5_23_32', [3058, 3365]],
        ['5_23_33', [3058, 3365]],
        ['5_23_34', [3058, 3365]],
        ['5_23_35', [3023, 3121]],
        ['5_23_36', [3023, 3121]],
        ['5_23_37', [3023, 3121]],
        ['5_23_4', [0, 0]],
        ['5_23_5', [0, 411]],
        ['5_23_6', [0.1875, 1567]],
        ['5_23_7', [0.1875, 1567]],
        ['5_23_8', [0, 0]],
        ['5_23_9', [0, 0]],
        ['5_24_0', [0, 2772]],
        ['5_24_1', [0, 1686]],
        ['5_24_10', [0, 0]],
        ['5_24_11', [0, 1585]],
        ['5_24_12', [0, 1852]],
        ['5_24_13', [36, 1272]],
        ['5_24_14', [99, 1053]],
        ['5_24_15', [0, 872]],
        ['5_24_16', [0.625, 2567.8125]],
        ['5_24_17', [0.5625, 49.6875]],
        ['5_24_18', [0.5625, 49.6875]],
        ['5_24_19', [0.5625, 49.6875]],
        ['5_24_2', [0, 242]],
        ['5_24_23', [1.125, 2618.875]],
        ['5_24_24', [1.125, 3488.125]],
        ['5_24_25', [2163.0625, 3703.875]],
        ['5_24_26', [0, 2568]],
        ['5_24_27', [0, 2850]],
        ['5_24_28', [2198, 3211]],
        ['5_24_29', [2322, 3179]],
        ['5_24_3', [0, 0]],
        ['5_24_30', [0, 2435]],
        ['5_24_31', [0, 0]],
        ['5_24_32', [2854.75, 3436]],
        ['5_24_33', [2854.75, 3436]],
        ['5_24_34', [2854.75, 3436]],
        ['5_24_35', [3052, 3114]],
        ['5_24_36', [3052, 3114]],
        ['5_24_37', [3052, 3114]],
        ['5_24_4', [0, 0]],
        ['5_24_5', [0, 86]],
        ['5_24_6', [0, 0]],
        ['5_24_7', [0, 0]],
        ['5_24_8', [18.0625, 1145.625]],
        ['5_24_9', [26.6875, 2118.875]],
        ['5_25_0', [0, 2772]],
        ['5_25_1', [0, 1814]],
        ['5_25_10', [0, 0]],
        ['5_25_11', [0, 0]],
        ['5_25_12', [0, 50]],
        ['5_25_13', [0, 421]],
        ['5_25_14', [0, 1060]],
        ['5_25_15', [0, 697]],
        ['5_25_16', [0.125, 2610.3125]],
        ['5_25_17', [0.125, 1314.6875]],
        ['5_25_18', [0.5625, 516.8125]],
        ['5_25_19', [0.5625, 492.75]],
        ['5_25_2', [0, 711]],
        ['5_25_23', [1.125, 2279.0625]],
        ['5_25_24', [1.125, 3488.125]],
        ['5_25_25', [2103.375, 3703.875]],
        ['5_25_26', [0, 0]],
        ['5_25_27', [0, 2924]],
        ['5_25_28', [634, 3275]],
        ['5_25_29', [1978, 3214]],
        ['5_25_3', [0, 0]],
        ['5_25_30', [0, 2322]],
        ['5_25_31', [0, 0]],
        ['5_25_32', [2854.75, 3436]],
        ['5_25_33', [2854.75, 3436]],
        ['5_25_34', [2854.75, 3436]],
        ['5_25_35', [3052, 3114]],
        ['5_25_36', [3052, 3114]],
        ['5_25_37', [3052, 3114]],
        ['5_25_4', [0, 0]],
        ['5_25_5', [0, 0]],
        ['5_25_6', [0, 1259]],
        ['5_25_7', [0, 0]],
        ['5_25_8', [17.25, 1094.5]],
        ['5_25_9', [105.875, 2250.375]],
        ['5_26_0', [0, 2773]],
        ['5_26_1', [0, 1967]],
        ['5_26_10', [139.3125, 2524.8125]],
        ['5_26_11', [1.75, 2651.125]],
        ['5_26_12', [0, 52]],
        ['5_26_13', [0, 0]],
        ['5_26_14', [0, 0]],
        ['5_26_15', [0, 23]],
        ['5_26_16', [0.0625, 2644.375]],
        ['5_26_17', [0.0625, 2343.625]],
        ['5_26_18', [0, 0]],
        ['5_26_19', [0, 0]],
        ['5_26_2', [0, 1302]],
        ['5_26_22', [0, 718]],
        ['5_26_23', [0, 427]],
        ['5_26_24', [1.25, 3488.125]],
        ['5_26_25', [1255.875, 3703.875]],
        ['5_26_26', [0, 0]],
        ['5_26_27', [0, 634]],
        ['5_26_28', [0, 3127]],
        ['5_26_29', [1350, 3134]],
        ['5_26_3', [0, 0]],
        ['5_26_30', [0, 1978]],
        ['5_26_31', [0, 0]],
        ['5_26_32', [2854.75, 3436]],
        ['5_26_33', [2854.75, 3436]],
        ['5_26_34', [2854.75, 3436]],
        ['5_26_35', [3052, 3114]],
        ['5_26_36', [3052, 3114]],
        ['5_26_37', [3052, 3114]],
        ['5_26_4', [0, 0]],
        ['5_26_5', [0, 0]],
        ['5_26_6', [0.4375, 881.1875]],
        ['5_26_7', [8.5, 1244]],
        ['5_26_8', [17.25, 1244]],
        ['5_26_9', [34.25, 2524.8125]],
        ['5_27_0', [0, 2774]],
        ['5_27_1', [301, 2101]],
        ['5_27_10', [0.875, 1944.125]],
        ['5_27_11', [0.5625, 2382.25]],
        ['5_27_12', [0, 0]],
        ['5_27_13', [0, 0]],
        ['5_27_14', [0, 0]],
        ['5_27_15', [0, 0]],
        ['5_27_16', [0.125, 4323.1875]],
        ['5_27_17', [0.3125, 2124.9375]],
        ['5_27_18', [0, 1379]],
        ['5_27_19', [0, 1067]],
        ['5_27_2', [0, 1610]],
        ['5_27_20', [2.75, 252.25]],
        ['5_27_21', [2.774305582046509, 252.25]],
        ['5_27_22', [0, 515]],
        ['5_27_23', [0, 0]],
        ['5_27_24', [0.4375, 3211.25]],
        ['5_27_25', [1569, 3211.25]],
        ['5_27_26', [0, 0]],
        ['5_27_27', [0, 651]],
        ['5_27_28', [0, 2484]],
        ['5_27_29', [0, 2284]],
        ['5_27_3', [0, 0]],
        ['5_27_30', [0, 1379]],
        ['5_27_31', [0, 0]],
        ['5_27_32', [2378, 3103]],
        ['5_27_33', [2668.875, 3103]],
        ['5_27_34', [2848.5, 3103]],
        ['5_27_35', [3014, 3128]],
        ['5_27_36', [3014, 3128]],
        ['5_27_37', [3014, 3128]],
        ['5_27_4', [0, 0]],
        ['5_27_5', [0, 356]],
        ['5_27_6', [0.5, 1212.25]],
        ['5_27_7', [1.25, 1971.125]],
        ['5_27_8', [19.25, 1927.5625]],
        ['5_27_9', [0.875, 1944.125]],
        ['5_28_0', [0, 2776]],
        ['5_28_1', [539, 2238]],
        ['5_28_10', [0.0625, 1893.0625]],
        ['5_28_11', [0.0625, 1893.0625]],
        ['5_28_12', [0.25, 2592.3125]],
        ['5_28_13', [0.25, 1507.6875]],
        ['5_28_14', [0, 0]],
        ['5_28_15', [0, 0]],
        ['5_28_16', [0, 0]],
        ['5_28_17', [0, 0]],
        ['5_28_18', [0, 78]],
        ['5_28_19', [0, 71]],
        ['5_28_2', [0, 1814]],
        ['5_28_20', [0, 844]],
        ['5_28_21', [0, 1415]],
        ['5_28_22', [2.774305582046509, 252.25]],
        ['5_28_23', [0.4375, 2388.25]],
        ['5_28_24', [0.4375, 3039.6875]],
        ['5_28_25', [967.0625, 3211.25]],
        ['5_28_26', [0, 0]],
        ['5_28_27', [0, 1867]],
        ['5_28_28', [0, 795]],
        ['5_28_29', [0, 1476]],
        ['5_28_3', [0, 0]],
        ['5_28_30', [0, 1144]],
        ['5_28_31', [0, 0]],
        ['5_28_32', [2378, 3103]],
        ['5_28_33', [2668.875, 3103]],
        ['5_28_34', [2848.5, 3103]],
        ['5_28_35', [3014, 3128]],
        ['5_28_36', [3014, 3128]],
        ['5_28_37', [3014, 3128]],
        ['5_28_4', [0, 3.2083332538604736]],
        ['5_28_5', [0.5, 12.5625]],
        ['5_28_6', [0.5, 1096.5625]],
        ['5_28_7', [0.5, 2264.8125]],
        ['5_28_8', [0, 0]],
        ['5_28_9', [0, 0]],
        ['5_29_0', [0, 2777]],
        ['5_29_1', [1303, 2347]],
        ['5_29_10', [0.125, 3592.75]],
        ['5_29_11', [0.0625, 1218.6875]],
        ['5_29_12', [0.25, 522.625]],
        ['5_29_13', [0.75, 522.625]],
        ['5_29_14', [0, 135]],
        ['5_29_15', [0, 0]],
        ['5_29_16', [0, 0]],
        ['5_29_17', [0, 1142]],
        ['5_29_18', [0, 1223]],
        ['5_29_19', [0, 631]],
        ['5_29_2', [0, 2607]],
        ['5_29_20', [0, 978]],
        ['5_29_21', [0, 2105]],
        ['5_29_22', [2.774305582046509, 252.25]],
        ['5_29_23', [0.25, 1111.375]],
        ['5_29_24', [0.25, 3039.6875]],
        ['5_29_25', [5.125, 3211.25]],
        ['5_29_26', [0, 0]],
        ['5_29_27', [0, 1620]],
        ['5_29_28', [0, 0]],
        ['5_29_29', [0, 0]],
        ['5_29_3', [0, 628]],
        ['5_29_30', [0, 655]],
        ['5_29_31', [0, 0]],
        ['5_29_32', [2156.6875, 3103]],
        ['5_29_33', [2156.6875, 3103]],
        ['5_29_34', [2848.5, 3103]],
        ['5_29_35', [3014, 3128]],
        ['5_29_36', [3014, 3128]],
        ['5_29_37', [3014, 3128]],
        ['5_29_4', [0, 3.2083332538604736]],
        ['5_29_5', [0.5, 196.375]],
        ['5_29_6', [0.5, 526.75]],
        ['5_29_7', [0.5, 2074.9375]],
        ['5_29_8', [0, 0]],
        ['5_29_9', [0, 659]],
        ['5_2_0', [0, 3135]],
        ['5_2_1', [0, 208]],
        ['5_2_10', [1.0625, 2011.1875]],
        ['5_2_11', [3.5625, 358.1875]],
        ['5_2_12', [0, 0]],
        ['5_2_13', [0, 0]],
        ['5_2_14', [0, 0]],
        ['5_2_15', [0, 0]],
        ['5_2_16', [0, 0]],
        ['5_2_17', [0, 0]],
        ['5_2_18', [0, 0]],
        ['5_2_19', [0, 0]],
        ['5_2_2', [0, 0]],
        ['5_2_20', [14.625, 35.75]],
        ['5_2_21', [14.625, 35.75]],
        ['5_2_22', [14.625, 35.75]],
        ['5_2_24', [0, 0]],
        ['5_2_25', [0, 571]],
        ['5_2_26', [0, 195]],
        ['5_2_27', [0, 516]],
        ['5_2_28', [0, 571]],
        ['5_2_29', [0, 0]],
        ['5_2_3', [0, 0]],
        ['5_2_30', [51.75, 356.25]],
        ['5_2_31', [51.75, 616.5]],
        ['5_2_32', [74.75, 3138.75]],
        ['5_2_33', [470.25, 3761.25]],
        ['5_2_34', [1444.25, 3279]],
        ['5_2_35', [2163, 3154]],
        ['5_2_36', [2546.75, 3154]],
        ['5_2_37', [2546.75, 3154]],
        ['5_2_5', [0.8645833134651184, 30.0625]],
        ['5_2_6', [0.8645833134651184, 1098.75]],
        ['5_2_7', [0.375, 2332.625]],
        ['5_2_8', [0.1875, 5710.9375]],
        ['5_2_9', [0.0625, 4575.9375]],
        ['5_30_0', [0, 2778]],
        ['5_30_1', [1789, 2429]],
        ['5_30_10', [0.1875, 3946]],
        ['5_30_11', [2.375, 1218.6875]],
        ['5_30_12', [0, 0]],
        ['5_30_13', [0, 322]],
        ['5_30_14', [5.25, 193.32464599609375]],
        ['5_30_15', [1.5625, 414.9375]],
        ['5_30_16', [0, 581]],
        ['5_30_17', [0, 899]],
        ['5_30_18', [52, 675]],
        ['5_30_19', [124, 575]],
        ['5_30_2', [628, 2717]],
        ['5_30_20', [192, 568]],
        ['5_30_21', [0, 3060]],
        ['5_30_22', [0, 758]],
        ['5_30_23', [0, 1706]],
        ['5_30_24', [0, 119]],
        ['5_30_25', [0, 486]],
        ['5_30_26', [0, 391]],
        ['5_30_27', [0, 318]],
        ['5_30_28', [0, 1089]],
        ['5_30_29', [0, 0]],
        ['5_30_3', [0, 2106]],
        ['5_30_30', [21.5625, 3895.75]],
        ['5_30_31', [69.75, 3895.75]],
        ['5_30_32', [1135, 3056]],
        ['5_30_33', [2293, 3059.5]],
        ['5_30_34', [2293, 3059.5]],
        ['5_30_35', [2984, 3154]],
        ['5_30_36', [2984, 3154]],
        ['5_30_37', [2984, 3154]],
        ['5_30_4', [0.5, 0.59375]],
        ['5_30_5', [0.5, 228.1875]],
        ['5_30_6', [0.25, 1031.4375]],
        ['5_30_7', [0.25, 1480.75]],
        ['5_30_8', [0, 332]],
        ['5_30_9', [0, 0]],
        ['5_31_0', [0, 2780]],
        ['5_31_1', [2009, 2512]],
        ['5_31_10', [0.4375, 645.75]],
        ['5_31_11', [4, 153.4375]],
        ['5_31_12', [0, 0]],
        ['5_31_13', [0, 0]],
        ['5_31_14', [5.25, 193.32464599609375]],
        ['5_31_15', [1.5625, 396.5625]],
        ['5_31_16', [0, 197]],
        ['5_31_17', [0, 560]],
        ['5_31_18', [192, 677]],
        ['5_31_19', [194, 489]],
        ['5_31_2', [1795, 2919]],
        ['5_31_20', [184, 656]],
        ['5_31_21', [178, 2706]],
        ['5_31_22', [0, 2513]],
        ['5_31_23', [0, 2312]],
        ['5_31_24', [0, 458]],
        ['5_31_25', [0, 592]],
        ['5_31_26', [0, 820]],
        ['5_31_27', [0, 0]],
        ['5_31_28', [0, 0]],
        ['5_31_29', [0, 0]],
        ['5_31_3', [0, 2129]],
        ['5_31_30', [21.5625, 3895.75]],
        ['5_31_31', [54.625, 3895.75]],
        ['5_31_32', [972.75, 3415.75]],
        ['5_31_33', [2293, 3059.5]],
        ['5_31_34', [2293, 3059.5]],
        ['5_31_35', [2984, 3154]],
        ['5_31_36', [2984, 3154]],
        ['5_31_37', [2984, 3154]],
        ['5_31_4', [0.5, 0.59375]],
        ['5_31_5', [0.5, 11.625]],
        ['5_31_6', [0.25, 1031.4375]],
        ['5_31_7', [0.25, 1499.5]],
        ['5_31_8', [0, 0]],
        ['5_31_9', [0, 0]],
        ['5_3_0', [0, 3118]],
        ['5_3_1', [0, 419]],
        ['5_3_10', [0.0625, 2157.375]],
        ['5_3_11', [0.1875, 317.875]],
        ['5_3_12', [0, 110]],
        ['5_3_13', [0, 0]],
        ['5_3_14', [0, 1]],
        ['5_3_15', [0, 0]],
        ['5_3_16', [0, 1]],
        ['5_3_17', [0, 0]],
        ['5_3_18', [0, 0]],
        ['5_3_19', [0, 545]],
        ['5_3_2', [0, 400]],
        ['5_3_23', [12.6875, 76.81771087646484]],
        ['5_3_24', [0, 0]],
        ['5_3_25', [0, 853]],
        ['5_3_26', [0, 764]],
        ['5_3_27', [0, 623]],
        ['5_3_28', [0, 898]],
        ['5_3_29', [0, 0]],
        ['5_3_3', [0, 0]],
        ['5_3_30', [169.25, 1902.75]],
        ['5_3_31', [169.25, 1005.5]],
        ['5_3_32', [133.75, 3148.25]],
        ['5_3_33', [793.75, 3148.25]],
        ['5_3_34', [1450.75, 3089.5]],
        ['5_3_35', [2189, 3048]],
        ['5_3_36', [2189, 3048]],
        ['5_3_37', [2189, 3048]],
        ['5_3_4', [0, 1.5625]],
        ['5_3_5', [0.125, 47.75]],
        ['5_3_6', [0.125, 1171.9375]],
        ['5_3_7', [0.125, 2332.625]],
        ['5_3_8', [0.9375, 5573.3125]],
        ['5_3_9', [0.0625, 5573.3125]],
        ['5_4_0', [0, 3091]],
        ['5_4_1', [0, 463]],
        ['5_4_10', [0.0625, 3032.875]],
        ['5_4_11', [0.0625, 3734]],
        ['5_4_12', [0, 0]],
        ['5_4_13', [0, 0]],
        ['5_4_14', [9.6875, 239.75]],
        ['5_4_15', [9.6875, 239.75]],
        ['5_4_16', [9.6875, 239.75]],
        ['5_4_17', [22.8125, 145.5625]],
        ['5_4_18', [0, 0]],
        ['5_4_19', [0, 2086]],
        ['5_4_2', [0, 959]],
        ['5_4_23', [12.6875, 76.81771087646484]],
        ['5_4_24', [0, 0]],
        ['5_4_25', [0, 119]],
        ['5_4_26', [0, 1745]],
        ['5_4_27', [42, 1768]],
        ['5_4_28', [0, 1414]],
        ['5_4_29', [0, 0]],
        ['5_4_3', [0, 0]],
        ['5_4_30', [170.25, 1902.75]],
        ['5_4_31', [170.25, 1872.5]],
        ['5_4_32', [159, 3451.5]],
        ['5_4_33', [1016.75, 3451.5]],
        ['5_4_34', [1837.5, 2774.75]],
        ['5_4_35', [2575, 3048]],
        ['5_4_36', [2575, 3048]],
        ['5_4_37', [2575, 3048]],
        ['5_4_4', [0, 1.5625]],
        ['5_4_5', [0.125, 430.0625]],
        ['5_4_6', [0.125, 643.5625]],
        ['5_4_7', [0.125, 1659.5625]],
        ['5_4_8', [9.6875, 2554]],
        ['5_4_9', [0.0625, 3565.5]],
        ['5_5_0', [0, 3034]],
        ['5_5_1', [0, 721]],
        ['5_5_10', [0.125, 3110]],
        ['5_5_11', [0.0625, 3754.0625]],
        ['5_5_12', [0, 552]],
        ['5_5_13', [0, 241]],
        ['5_5_14', [1.3125, 1673.9375]],
        ['5_5_15', [2.875, 239.75]],
        ['5_5_16', [2.875, 239.75]],
        ['5_5_17', [22.8125, 145.5625]],
        ['5_5_18', [0, 0]],
        ['5_5_19', [0, 0]],
        ['5_5_2', [0, 951]],
        ['5_5_23', [14.375, 81.1875]],
        ['5_5_24', [0, 0]],
        ['5_5_25', [0, 0]],
        ['5_5_26', [0, 2278]],
        ['5_5_27', [64, 2834]],
        ['5_5_28', [0, 1582]],
        ['5_5_29', [0, 0]],
        ['5_5_3', [0, 0]],
        ['5_5_30', [370.5, 1902.75]],
        ['5_5_31', [370.5, 2581.5]],
        ['5_5_32', [159, 3237.5]],
        ['5_5_33', [1687, 3237.5]],
        ['5_5_34', [1837.5, 2646]],
        ['5_5_35', [2575, 3048]],
        ['5_5_36', [2575, 3048]],
        ['5_5_37', [2575, 3048]],
        ['5_5_4', [0, 446]],
        ['5_5_5', [0.0625, 742.4375]],
        ['5_5_6', [0.125, 643.5625]],
        ['5_5_7', [0.125, 849.1875]],
        ['5_5_8', [6.875, 2247.625]],
        ['5_5_9', [68.0625, 2375.75]],
        ['5_6_0', [0, 2986]],
        ['5_6_1', [125, 749]],
        ['5_6_10', [0, 0]],
        ['5_6_11', [0, 0]],
        ['5_6_12', [0, 1]],
        ['5_6_13', [0, 1]],
        ['5_6_14', [0, 100]],
        ['5_6_15', [0, 0]],
        ['5_6_16', [0.75, 523.4375]],
        ['5_6_17', [2.625, 567.875]],
        ['5_6_18', [3.125, 567.875]],
        ['5_6_19', [3.125, 567.875]],
        ['5_6_2', [0, 1480]],
        ['5_6_20', [2.875, 471.625]],
        ['5_6_21', [2.875, 375.75]],
        ['5_6_22', [12.8125, 139.6875]],
        ['5_6_23', [2.3125, 73.6875]],
        ['5_6_24', [2.3125, 73.6875]],
        ['5_6_25', [1.1875, 1113.625]],
        ['5_6_26', [0, 3082]],
        ['5_6_27', [121, 2680]],
        ['5_6_28', [0, 1790]],
        ['5_6_29', [0, 0]],
        ['5_6_3', [0, 0]],
        ['5_6_30', [1163, 2553.9375]],
        ['5_6_31', [1163, 2584.5]],
        ['5_6_32', [1693.75, 2737]],
        ['5_6_33', [1846.5, 2737]],
        ['5_6_34', [1962.75, 2737]],
        ['5_6_35', [2294.5, 2901]],
        ['5_6_36', [2294.5, 2901]],
        ['5_6_37', [2294.5, 2901]],
        ['5_6_4', [0.25, 493.5]],
        ['5_6_5', [0.0625, 742.4375]],
        ['5_6_6', [0.0625, 619.1875]],
        ['5_6_7', [0.25, 619.1875]],
        ['5_6_8', [1, 631.4375]],
        ['5_6_9', [1, 1285.875]],
        ['5_7_0', [0, 2943]],
        ['5_7_1', [373, 1109]],
        ['5_7_10', [0, 0]],
        ['5_7_11', [0, 59]],
        ['5_7_12', [0, 1]],
        ['5_7_13', [0, 0]],
        ['5_7_14', [0, 322]],
        ['5_7_15', [0, 0]],
        ['5_7_16', [0.3125, 1256.875]],
        ['5_7_17', [2.625, 567.875]],
        ['5_7_18', [3.125, 567.875]],
        ['5_7_19', [3.125, 567.875]],
        ['5_7_2', [0, 2528]],
        ['5_7_20', [2.875, 471.625]],
        ['5_7_21', [2.875, 375.75]],
        ['5_7_22', [12.8125, 139.6875]],
        ['5_7_23', [2.3125, 107.1875]],
        ['5_7_24', [2.3125, 107.1875]],
        ['5_7_25', [1.1875, 1600.375]],
        ['5_7_26', [0, 3062]],
        ['5_7_27', [9, 1609]],
        ['5_7_28', [0, 956]],
        ['5_7_29', [0, 0]],
        ['5_7_3', [0, 0]],
        ['5_7_30', [771.125, 2553.9375]],
        ['5_7_31', [1017.75, 2644]],
        ['5_7_32', [987.25, 2737]],
        ['5_7_33', [1347, 2737]],
        ['5_7_34', [1347, 2737]],
        ['5_7_35', [2294.5, 2901]],
        ['5_7_36', [2294.5, 2901]],
        ['5_7_37', [2294.5, 2901]],
        ['5_7_4', [0.125, 1958.75]],
        ['5_7_5', [0.25, 878.0625]],
        ['5_7_6', [0.25, 688.8125]],
        ['5_7_7', [0.25, 565.375]],
        ['5_7_8', [0.125, 530]],
        ['5_7_9', [0.125, 736.8125]],
        ['5_8_0', [0, 2917]],
        ['5_8_1', [430, 1398]],
        ['5_8_10', [0, 0]],
        ['5_8_11', [0, 0]],
        ['5_8_12', [0.1875, 1659.8125]],
        ['5_8_13', [0.1875, 1265.875]],
        ['5_8_14', [0.0625, 3566.875]],
        ['5_8_15', [0.0625, 4994.625]],
        ['5_8_16', [0.3125, 5422.3125]],
        ['5_8_17', [0.0625, 5422.3125]],
        ['5_8_18', [0.0625, 567.875]],
        ['5_8_19', [0.0625, 567.875]],
        ['5_8_2', [0, 2630]],
        ['5_8_20', [2.875, 471.625]],
        ['5_8_21', [2.875, 375.75]],
        ['5_8_22', [0, 0]],
        ['5_8_23', [0, 0]],
        ['5_8_24', [0, 0]],
        ['5_8_25', [0, 1806]],
        ['5_8_26', [0, 2040]],
        ['5_8_27', [9, 2009]],
        ['5_8_28', [0, 313]],
        ['5_8_29', [0, 0]],
        ['5_8_3', [0, 0]],
        ['5_8_30', [135, 2347.25]],
        ['5_8_31', [135, 2644]],
        ['5_8_32', [987.25, 2737]],
        ['5_8_33', [1347, 2737]],
        ['5_8_34', [1347, 2737]],
        ['5_8_35', [2294.5, 2901]],
        ['5_8_36', [2294.5, 2901]],
        ['5_8_37', [2294.5, 2901]],
        ['5_8_4', [0.0625, 2076.5]],
        ['5_8_5', [0.125, 1894.375]],
        ['5_8_6', [0.0625, 1644.1875]],
        ['5_8_7', [0.0625, 930.3125]],
        ['5_8_8', [0.125, 550.6875]],
        ['5_8_9', [0.125, 509.9375]],
        ['5_9_0', [0, 2906]],
        ['5_9_1', [621, 1555]],
        ['5_9_10', [0, 0]],
        ['5_9_11', [0, 6]],
        ['5_9_12', [0.0625, 1430.9375]],
        ['5_9_13', [0.0625, 1265.875]],
        ['5_9_14', [0.0625, 4928.3125]],
        ['5_9_15', [0.0625, 4994.625]],
        ['5_9_16', [0.0625, 5422.3125]],
        ['5_9_17', [0.3125, 5863.9375]],
        ['5_9_18', [0.4375, 6179.3125]],
        ['5_9_19', [0.0625, 5815.1875]],
        ['5_9_2', [0, 2899]],
        ['5_9_20', [0.0625, 3030.5]],
        ['5_9_21', [0.0625, 2971.3125]],
        ['5_9_22', [0, 245]],
        ['5_9_23', [0, 1316]],
        ['5_9_24', [0, 2041]],
        ['5_9_25', [0, 2462]],
        ['5_9_26', [265, 2274]],
        ['5_9_27', [23, 2240]],
        ['5_9_28', [0, 437]],
        ['5_9_29', [0, 241]],
        ['5_9_3', [0, 0]],
        ['5_9_30', [77.0625, 1416.5]],
        ['5_9_31', [161, 2021.5]],
        ['5_9_32', [754.5, 2449]],
        ['5_9_33', [1317.75, 2449]],
        ['5_9_34', [1418, 2449]],
        ['5_9_35', [2253, 2668]],
        ['5_9_36', [2253, 2668]],
        ['5_9_37', [2253, 2668]],
        ['5_9_4', [0.25, 2076.5]],
        ['5_9_5', [0.125, 1894.375]],
        ['5_9_6', [0.125, 1644.1875]],
        ['5_9_7', [0.125, 1965]],
        ['5_9_8', [0.0625, 1965]],
        ['5_9_9', [0.125, 877.0625]],
        ['6_0_12', [0.625, 42]],
        ['6_0_13', [0.25, 848]],
        ['6_0_14', [0.25, 1298]],
        ['6_0_15', [0.25, 1298]],
        ['6_0_16', [0.25, 1275.25]],
        ['6_0_17', [0.25, 960.5]],
        ['6_0_18', [0.25, 354.25]],
        ['6_0_19', [0.25, 95.5]],
        ['6_0_20', [0.25, 1451]],
        ['6_0_21', [2.25, 1451]],
        ['6_0_22', [3.25, 22.75]],
        ['6_0_23', [3.25, 22.75]],
        ['6_0_27', [0.25, 5.75]],
        ['6_0_28', [0.25, 5.75]],
        ['6_0_29', [0.25, 5.75]],
        ['6_0_33', [1.25, 198.6666717529297]],
        ['6_0_34', [0.5, 910.25]],
        ['6_0_35', [0.5, 910.25]],
        ['6_0_36', [4.5, 273]],
        ['6_0_37', [4.5, 273]],
        ['6_0_38', [4.5, 273]],
        ['6_0_39', [8.75, 12.75]],
        ['6_0_40', [8.75, 12.75]],
        ['6_0_41', [8.75, 12.75]],
        ['6_0_54', [2.5, 77.5]],
        ['6_0_55', [2.5, 79]],
        ['6_0_56', [2.5, 79]],
        ['6_0_57', [51, 248]],
        ['6_0_58', [51, 248]],
        ['6_0_59', [51, 248]],
        ['6_0_60', [63.5, 114.5]],
        ['6_0_61', [63.5, 114.5]],
        ['6_0_62', [63.5, 2308.5]],
        ['6_0_63', [76, 3309.5]],
        ['6_0_64', [891.25, 3309.5]],
        ['6_0_65', [1541, 2861.5]],
        ['6_0_66', [2151.5, 3052]],
        ['6_0_67', [2151.5, 3052]],
        ['6_0_68', [2349.5, 3052]],
        ['6_0_69', [2534, 3110]],
        ['6_0_70', [2534, 3110]],
        ['6_0_71', [2534, 3110]],
        ['6_0_72', [2925, 3154]],
        ['6_0_73', [2925, 3154]],
        ['6_0_74', [2925, 3154]],
        ['6_10_10', [0.25, 525]],
        ['6_10_11', [0.25, 525]],
        ['6_10_12', [0.5, 439.5]],
        ['6_10_13', [0.25, 662.75]],
        ['6_10_14', [0.25, 850.5]],
        ['6_10_15', [0.75, 850.5]],
        ['6_10_16', [39, 1276.25]],
        ['6_10_17', [39, 1902]],
        ['6_10_18', [84, 2569]],
        ['6_10_19', [249.75, 2591]],
        ['6_10_20', [311.5, 3329.5]],
        ['6_10_21', [0.25, 3329.5]],
        ['6_10_22', [0.25, 4141]],
        ['6_10_23', [0.5, 3619.25]],
        ['6_10_24', [0.75, 4013.75]],
        ['6_10_25', [0.75, 4013.75]],
        ['6_10_26', [0.25, 1597.5]],
        ['6_10_27', [0.5, 565.25]],
        ['6_10_28', [7, 142.6875]],
        ['6_10_29', [12.5, 142.6875]],
        ['6_10_36', [21.41666603088379, 24.058332443237305]],
        ['6_10_37', [21.41666603088379, 24.058332443237305]],
        ['6_10_38', [21.41666603088379, 24.058332443237305]],
        ['6_10_51', [4.5, 646.25]],
        ['6_10_52', [4.5, 2469]],
        ['6_10_53', [86.5, 3051.5]],
        ['6_10_54', [841, 3051.5]],
        ['6_10_55', [841, 2090.25]],
        ['6_10_56', [841, 2048.5]],
        ['6_10_57', [531, 1811.5]],
        ['6_10_58', [531, 1811.5]],
        ['6_10_59', [531, 1811.5]],
        ['6_10_6', [0, 1.0833333730697632]],
        ['6_10_60', [678, 1717]],
        ['6_10_61', [678, 1717]],
        ['6_10_62', [678, 1717]],
        ['6_10_63', [670, 2347]],
        ['6_10_64', [670, 3007]],
        ['6_10_65', [1230, 3068]],
        ['6_10_66', [1766.5, 3031]],
        ['6_10_67', [1766.5, 2604]],
        ['6_10_68', [1901.5, 2604]],
        ['6_10_69', [2468, 2863]],
        ['6_10_7', [0, 1.0833333730697632]],
        ['6_10_70', [2468, 2863]],
        ['6_10_71', [2468, 2863]],
        ['6_10_72', [2737.5, 2936]],
        ['6_10_73', [2737.5, 2936]],
        ['6_10_74', [2737.5, 2936]],
        ['6_10_8', [0, 1.0833333730697632]],
        ['6_10_9', [0.25, 364]],
        ['6_11_10', [0.25, 750]],
        ['6_11_11', [0.25, 750]],
        ['6_11_12', [0.5, 620]],
        ['6_11_13', [0.25, 643.5]],
        ['6_11_14', [0.25, 766.5]],
        ['6_11_15', [0.5, 780]],
        ['6_11_16', [114.5, 759.5]],
        ['6_11_17', [137, 840.5]],
        ['6_11_18', [129, 1046]],
        ['6_11_19', [207, 1268]],
        ['6_11_20', [254, 3329.5]],
        ['6_11_21', [258.5, 3329.5]],
        ['6_11_22', [87, 3296.75]],
        ['6_11_23', [87, 3297.75]],
        ['6_11_24', [0.75, 4013.75]],
        ['6_11_25', [0.25, 4013.75]],
        ['6_11_26', [0.25, 2661]],
        ['6_11_27', [0.25, 1469.25]],
        ['6_11_28', [1, 142.6875]],
        ['6_11_29', [12.5, 142.6875]],
        ['6_11_36', [21.41666603088379, 24.058332443237305]],
        ['6_11_37', [21.41666603088379, 24.058332443237305]],
        ['6_11_38', [21.41666603088379, 24.058332443237305]],
        ['6_11_51', [2, 653.5]],
        ['6_11_52', [2, 2767]],
        ['6_11_53', [52, 3163]],
        ['6_11_54', [1086.25, 3051.5]],
        ['6_11_55', [841, 2013.5]],
        ['6_11_56', [841, 1856]],
        ['6_11_57', [531, 1811.5]],
        ['6_11_58', [531, 1811.5]],
        ['6_11_59', [531, 1811.5]],
        ['6_11_6', [0, 1.0833333730697632]],
        ['6_11_60', [678, 2059.5]],
        ['6_11_61', [678, 2059.5]],
        ['6_11_62', [678, 2179.25]],
        ['6_11_63', [670, 2586]],
        ['6_11_64', [670, 2547.5]],
        ['6_11_65', [1685, 2547.5]],
        ['6_11_66', [2083, 2604]],
        ['6_11_67', [2083, 2604]],
        ['6_11_68', [2083, 2604]],
        ['6_11_69', [2468, 2863]],
        ['6_11_7', [0, 1.0833333730697632]],
        ['6_11_70', [2468, 2863]],
        ['6_11_71', [2468, 2863]],
        ['6_11_72', [2737.5, 2936]],
        ['6_11_73', [2737.5, 2936]],
        ['6_11_74', [2737.5, 2936]],
        ['6_11_8', [0, 1.0833333730697632]],
        ['6_11_9', [0.5, 364]],
        ['6_12_10', [0.5, 642.5]],
        ['6_12_11', [0.25, 642.5]],
        ['6_12_12', [0.5, 643.5]],
        ['6_12_13', [0.5, 643.5]],
        ['6_12_14', [1.25, 471.25]],
        ['6_12_15', [0.25, 634.25]],
        ['6_12_16', [0.25, 634.25]],
        ['6_12_17', [90, 634.25]],
        ['6_12_18', [45.5, 887]],
        ['6_12_19', [184.5, 913.5]],
        ['6_12_20', [264.25, 1496]],
        ['6_12_21', [299.25, 2476]],
        ['6_12_22', [513.25, 3621]],
        ['6_12_23', [733.75, 3938.75]],
        ['6_12_24', [375.75, 4034]],
        ['6_12_25', [5.5, 3901.25]],
        ['6_12_26', [0.25, 3063]],
        ['6_12_27', [0.25, 3063]],
        ['6_12_28', [1.25, 1857.75]],
        ['6_12_29', [2.25, 95.17500305175781]],
        ['6_12_3', [0, 27.44230842590332]],
        ['6_12_4', [0, 27.44230842590332]],
        ['6_12_48', [0, 56.75]],
        ['6_12_49', [0, 56.75]],
        ['6_12_5', [0, 27.44230842590332]],
        ['6_12_50', [0, 56.75]],
        ['6_12_51', [2.75, 638.5]],
        ['6_12_52', [2.75, 1936.5]],
        ['6_12_53', [7, 3163]],
        ['6_12_54', [1102, 2429]],
        ['6_12_55', [1102, 2429]],
        ['6_12_56', [1102, 2429]],
        ['6_12_57', [1392.5, 2279]],
        ['6_12_58', [1303, 2556]],
        ['6_12_59', [1303, 2556]],
        ['6_12_6', [1, 106]],
        ['6_12_60', [1319.5, 2556]],
        ['6_12_61', [1319.5, 2556]],
        ['6_12_62', [1319.5, 2363.5]],
        ['6_12_63', [1422.5, 2635]],
        ['6_12_64', [1948, 2635]],
        ['6_12_65', [1952, 2635]],
        ['6_12_66', [2170.5, 2668]],
        ['6_12_67', [2170.5, 2668]],
        ['6_12_68', [2291, 2668]],
        ['6_12_69', [2127.5, 2819]],
        ['6_12_7', [1, 183]],
        ['6_12_70', [2127.5, 2819]],
        ['6_12_71', [2127.5, 2819]],
        ['6_12_72', [2538, 2880.5]],
        ['6_12_73', [2538, 2880.5]],
        ['6_12_74', [2538, 2880.5]],
        ['6_12_8', [1, 183]],
        ['6_12_9', [0.5, 3.5]],
        ['6_13_10', [0.25, 379.5]],
        ['6_13_11', [0.25, 353]],
        ['6_13_12', [1, 167]],
        ['6_13_13', [1, 368.5]],
        ['6_13_14', [1, 368.5]],
        ['6_13_15', [0.25, 634.25]],
        ['6_13_16', [0.25, 634.25]],
        ['6_13_17', [1, 634.25]],
        ['6_13_18', [5.5, 628]],
        ['6_13_19', [5.5, 762.75]],
        ['6_13_20', [5.5, 819.5]],
        ['6_13_21', [231.5, 1219.5]],
        ['6_13_22', [231.5, 3621]],
        ['6_13_23', [335, 3809.75]],
        ['6_13_24', [127.75, 4034]],
        ['6_13_25', [127.75, 3922.75]],
        ['6_13_26', [2.5, 3063]],
        ['6_13_27', [1.25, 3430.25]],
        ['6_13_28', [1.25, 3737.5]],
        ['6_13_29', [2.5, 3060.75]],
        ['6_13_3', [0, 27.44230842590332]],
        ['6_13_4', [0, 27.44230842590332]],
        ['6_13_48', [0, 56.75]],
        ['6_13_49', [0, 56.75]],
        ['6_13_5', [0, 27.44230842590332]],
        ['6_13_50', [0, 744.5]],
        ['6_13_51', [0.25, 776]],
        ['6_13_52', [0.25, 1e3]],
        ['6_13_53', [2, 1498.75]],
        ['6_13_54', [1102, 2429]],
        ['6_13_55', [1102, 2429]],
        ['6_13_56', [1102, 2429]],
        ['6_13_57', [1392.5, 2279]],
        ['6_13_58', [1392.5, 2556]],
        ['6_13_59', [1303, 2556]],
        ['6_13_6', [1, 106]],
        ['6_13_60', [1319.5, 2556]],
        ['6_13_61', [1319.5, 2556]],
        ['6_13_62', [1683, 2401]],
        ['6_13_63', [1422.5, 2635]],
        ['6_13_64', [2027, 2635]],
        ['6_13_65', [1913.5, 2635]],
        ['6_13_66', [2039.5, 2668]],
        ['6_13_67', [2039.5, 2668]],
        ['6_13_68', [2170.5, 2668]],
        ['6_13_69', [2127.5, 2819]],
        ['6_13_7', [1, 183]],
        ['6_13_70', [2127.5, 2819]],
        ['6_13_71', [2127.5, 2819]],
        ['6_13_72', [2538, 2880.5]],
        ['6_13_73', [2538, 2880.5]],
        ['6_13_74', [2538, 2880.5]],
        ['6_13_8', [1, 183]],
        ['6_13_9', [0.5, 349.5]],
        ['6_14_10', [0.25, 506.5]],
        ['6_14_11', [0.25, 426]],
        ['6_14_12', [0.25, 476.5]],
        ['6_14_13', [0.25, 573.25]],
        ['6_14_14', [0.25, 573.25]],
        ['6_14_15', [0.5, 468.5]],
        ['6_14_16', [0.5, 474]],
        ['6_14_17', [1, 618]],
        ['6_14_18', [5.5, 587]],
        ['6_14_19', [5.5, 746.75]],
        ['6_14_20', [5.5, 819.5]],
        ['6_14_21', [231.5, 926.5]],
        ['6_14_22', [231.5, 1079]],
        ['6_14_23', [221.75, 1678]],
        ['6_14_24', [127.75, 1630.5]],
        ['6_14_25', [0.5, 1630.5]],
        ['6_14_26', [0.5, 2651.25]],
        ['6_14_27', [1.5, 3430.25]],
        ['6_14_28', [1.25, 4912.5]],
        ['6_14_29', [1.25, 3457.5]],
        ['6_14_3', [0, 27.44230842590332]],
        ['6_14_4', [0, 27.44230842590332]],
        ['6_14_48', [0, 85.75]],
        ['6_14_49', [0, 85.75]],
        ['6_14_5', [0, 588.5]],
        ['6_14_50', [0, 763.5]],
        ['6_14_51', [0.25, 1599]],
        ['6_14_52', [0.25, 1599]],
        ['6_14_53', [2, 1498.75]],
        ['6_14_54', [1102, 2429]],
        ['6_14_55', [1102, 2429]],
        ['6_14_56', [1102, 2429]],
        ['6_14_57', [1726.5, 2279]],
        ['6_14_58', [1726.5, 2556]],
        ['6_14_59', [1726.5, 2556]],
        ['6_14_6', [1, 1076.5]],
        ['6_14_60', [1684, 2556]],
        ['6_14_61', [1684, 2556]],
        ['6_14_62', [1684, 2401]],
        ['6_14_63', [1895.5, 2635]],
        ['6_14_64', [1895.5, 2635]],
        ['6_14_65', [1895.5, 2635]],
        ['6_14_66', [2039.5, 2668]],
        ['6_14_67', [2039.5, 2668]],
        ['6_14_68', [2039.5, 2614]],
        ['6_14_69', [2127.5, 2819]],
        ['6_14_7', [1, 1181]],
        ['6_14_70', [2127.5, 2819]],
        ['6_14_71', [2127.5, 2819]],
        ['6_14_72', [2538, 2880.5]],
        ['6_14_73', [2538, 2880.5]],
        ['6_14_74', [2538, 2880.5]],
        ['6_14_8', [1, 317]],
        ['6_14_9', [0.25, 506.5]],
        ['6_15_0', [0, 27.08333396911621]],
        ['6_15_1', [0, 27.08333396911621]],
        ['6_15_10', [0.25, 595.5]],
        ['6_15_11', [0.25, 509]],
        ['6_15_12', [0.25, 491.5]],
        ['6_15_13', [0.25, 573.25]],
        ['6_15_14', [0.25, 573.25]],
        ['6_15_15', [0.25, 551]],
        ['6_15_16', [0.25, 551]],
        ['6_15_17', [0.25, 411]],
        ['6_15_18', [1, 296.25]],
        ['6_15_19', [1, 278.75]],
        ['6_15_2', [0, 27.08333396911621]],
        ['6_15_20', [1, 278.75]],
        ['6_15_21', [0.25, 647]],
        ['6_15_22', [0.25, 647]],
        ['6_15_23', [3, 585.75]],
        ['6_15_24', [11, 693]],
        ['6_15_25', [2.25, 734]],
        ['6_15_26', [2.25, 332.5]],
        ['6_15_27', [0.25, 320.75]],
        ['6_15_28', [0.25, 3729]],
        ['6_15_29', [0.25, 3729]],
        ['6_15_3', [0.5, 9.050000190734863]],
        ['6_15_30', [0.75, 144.5]],
        ['6_15_31', [0.75, 1447.25]],
        ['6_15_32', [0.75, 1447.25]],
        ['6_15_33', [5, 101.25]],
        ['6_15_34', [5, 101.25]],
        ['6_15_35', [5, 101.25]],
        ['6_15_36', [53.5, 556]],
        ['6_15_37', [53.5, 556]],
        ['6_15_38', [50.75, 556]],
        ['6_15_4', [0.5, 774]],
        ['6_15_48', [5, 444]],
        ['6_15_49', [5, 444]],
        ['6_15_5', [0.5, 852]],
        ['6_15_50', [2.5, 614]],
        ['6_15_51', [6, 1598.5]],
        ['6_15_52', [60, 1598.5]],
        ['6_15_53', [622, 1509.5]],
        ['6_15_54', [968, 2298.5]],
        ['6_15_55', [1340.5, 2298.5]],
        ['6_15_56', [1064, 2298.5]],
        ['6_15_57', [1007.5, 2429]],
        ['6_15_58', [773.5, 2428]],
        ['6_15_59', [773.5, 2428]],
        ['6_15_6', [0.25, 1905.5]],
        ['6_15_60', [531, 2155]],
        ['6_15_61', [531, 2155]],
        ['6_15_62', [531, 2155]],
        ['6_15_63', [1123.5, 2644]],
        ['6_15_64', [1123.5, 2644]],
        ['6_15_65', [1403, 2469]],
        ['6_15_66', [1500, 2486]],
        ['6_15_67', [1500, 2486]],
        ['6_15_68', [1500, 2399.5]],
        ['6_15_69', [2214, 2615]],
        ['6_15_7', [0.25, 2036.5]],
        ['6_15_70', [2214, 2615]],
        ['6_15_71', [2214, 2615]],
        ['6_15_72', [2528, 2737]],
        ['6_15_73', [2528, 2737]],
        ['6_15_74', [2528, 2737]],
        ['6_15_8', [0.5, 1665.5]],
        ['6_15_9', [0.25, 916]],
        ['6_16_0', [0, 27.08333396911621]],
        ['6_16_1', [0, 27.08333396911621]],
        ['6_16_10', [0.25, 1897.5]],
        ['6_16_11', [0.25, 1897.5]],
        ['6_16_12', [0.25, 1273]],
        ['6_16_13', [0.25, 921.5]],
        ['6_16_14', [0.25, 586.5]],
        ['6_16_15', [0.5, 551]],
        ['6_16_16', [0.25, 578.5]],
        ['6_16_17', [0.25, 578.5]],
        ['6_16_18', [1, 296.25]],
        ['6_16_19', [1, 278.75]],
        ['6_16_2', [0, 27.08333396911621]],
        ['6_16_20', [1, 278.75]],
        ['6_16_21', [0.25, 647]],
        ['6_16_22', [0.25, 647]],
        ['6_16_23', [0.25, 581.25]],
        ['6_16_24', [11, 1766.75]],
        ['6_16_25', [2.25, 1766.75]],
        ['6_16_26', [2.25, 545.75]],
        ['6_16_27', [0.25, 459.5]],
        ['6_16_28', [0.25, 3228.75]],
        ['6_16_29', [0.25, 3232]],
        ['6_16_3', [0.5, 1007]],
        ['6_16_30', [0.5, 3609.75]],
        ['6_16_31', [0.75, 1447.25]],
        ['6_16_32', [0.75, 1447.25]],
        ['6_16_33', [5, 101.25]],
        ['6_16_34', [5, 101.25]],
        ['6_16_35', [5, 101.25]],
        ['6_16_36', [53.5, 556]],
        ['6_16_37', [53.5, 556]],
        ['6_16_38', [50.75, 556]],
        ['6_16_4', [0.5, 1614.5]],
        ['6_16_48', [5, 444]],
        ['6_16_49', [5, 444]],
        ['6_16_5', [0.5, 1614.5]],
        ['6_16_50', [2.5, 533]],
        ['6_16_51', [0.5, 1371]],
        ['6_16_52', [3.5, 1476.5]],
        ['6_16_53', [396.75, 1476.5]],
        ['6_16_54', [198, 3122]],
        ['6_16_55', [168, 3990]],
        ['6_16_56', [168, 2190]],
        ['6_16_57', [1007.5, 2428]],
        ['6_16_58', [773.5, 2428]],
        ['6_16_59', [773.5, 2428]],
        ['6_16_6', [0.25, 1726]],
        ['6_16_60', [531, 2155]],
        ['6_16_61', [531, 2155]],
        ['6_16_62', [531, 2155]],
        ['6_16_63', [1123.5, 2644]],
        ['6_16_64', [1123.5, 2644]],
        ['6_16_65', [1340, 2466.5]],
        ['6_16_66', [1500, 2486]],
        ['6_16_67', [1500, 2486]],
        ['6_16_68', [1500, 2399.5]],
        ['6_16_69', [2214, 2615]],
        ['6_16_7', [0.25, 2036.5]],
        ['6_16_70', [2214, 2615]],
        ['6_16_71', [2214, 2615]],
        ['6_16_72', [2528, 2737]],
        ['6_16_73', [2528, 2737]],
        ['6_16_74', [2528, 2737]],
        ['6_16_8', [0.25, 1665.5]],
        ['6_16_9', [0.25, 1478.5]],
        ['6_17_0', [0, 27.08333396911621]],
        ['6_17_1', [0, 27.08333396911621]],
        ['6_17_10', [0.5, 1897.5]],
        ['6_17_11', [0.5, 1897.5]],
        ['6_17_12', [0.25, 1670]],
        ['6_17_13', [0.25, 1406]],
        ['6_17_14', [0.25, 725]],
        ['6_17_15', [0.25, 483.5]],
        ['6_17_16', [0.25, 578.5]],
        ['6_17_17', [0.25, 578.5]],
        ['6_17_18', [1, 465.5]],
        ['6_17_19', [1, 278.75]],
        ['6_17_2', [0, 27.08333396911621]],
        ['6_17_20', [1, 278.75]],
        ['6_17_21', [2, 582.5]],
        ['6_17_22', [0.25, 582.5]],
        ['6_17_23', [0.25, 857.5]],
        ['6_17_24', [1.25, 1766.75]],
        ['6_17_25', [2, 1766.75]],
        ['6_17_26', [2, 545.75]],
        ['6_17_27', [0.25, 958.75]],
        ['6_17_28', [0.25, 1451]],
        ['6_17_29', [0.25, 3231]],
        ['6_17_3', [0.5, 1679.5]],
        ['6_17_30', [0.5, 3609.75]],
        ['6_17_31', [0.75, 5170.25]],
        ['6_17_32', [0.75, 5536.25]],
        ['6_17_33', [0.25, 6068.5]],
        ['6_17_34', [5, 5002.75]],
        ['6_17_35', [5, 101.25]],
        ['6_17_36', [50.75, 556]],
        ['6_17_37', [50.75, 556]],
        ['6_17_38', [50.75, 868]],
        ['6_17_4', [0.5, 2155.5]],
        ['6_17_48', [2, 444]],
        ['6_17_49', [2, 444]],
        ['6_17_5', [0.5, 2155.5]],
        ['6_17_50', [2, 499.5]],
        ['6_17_51', [0.25, 1371]],
        ['6_17_52', [3.5, 1371]],
        ['6_17_53', [123.5, 1463.5]],
        ['6_17_54', [113, 3084.5]],
        ['6_17_55', [122, 3990]],
        ['6_17_56', [122, 2190]],
        ['6_17_57', [137, 2189.5]],
        ['6_17_58', [156.5, 2034]],
        ['6_17_59', [156.5, 2034]],
        ['6_17_6', [0.5, 1913.5]],
        ['6_17_60', [531, 2155]],
        ['6_17_61', [531, 2155]],
        ['6_17_62', [531, 2155]],
        ['6_17_63', [1123.5, 2199]],
        ['6_17_64', [1123.5, 2147]],
        ['6_17_65', [1340, 2148.75]],
        ['6_17_66', [1500, 2399.5]],
        ['6_17_67', [1500, 2399.5]],
        ['6_17_68', [1500, 2399.5]],
        ['6_17_69', [2214, 2615]],
        ['6_17_7', [0.5, 1913.5]],
        ['6_17_70', [2214, 2615]],
        ['6_17_71', [2214, 2615]],
        ['6_17_72', [2528, 2737]],
        ['6_17_73', [2528, 2737]],
        ['6_17_74', [2528, 2737]],
        ['6_17_8', [0.25, 2120]],
        ['6_17_9', [0.25, 1834.5]],
        ['6_18_0', [1, 10.160714149475098]],
        ['6_18_1', [1, 10.160714149475098]],
        ['6_18_10', [0.25, 1256]],
        ['6_18_11', [0.5, 1099.5]],
        ['6_18_12', [0.5, 1703]],
        ['6_18_13', [0.5, 1703]],
        ['6_18_14', [0.5, 1622.5]],
        ['6_18_15', [0.75, 560.5]],
        ['6_18_16', [0.5, 559]],
        ['6_18_17', [0.5, 669]],
        ['6_18_18', [0.25, 669]],
        ['6_18_19', [1, 567.75]],
        ['6_18_2', [1, 10.160714149475098]],
        ['6_18_20', [4.5, 856]],
        ['6_18_21', [0.75, 856]],
        ['6_18_22', [1, 1366.5]],
        ['6_18_23', [0.25, 1366.5]],
        ['6_18_24', [0.25, 1365]],
        ['6_18_25', [0.25, 1105]],
        ['6_18_26', [1, 82.75]],
        ['6_18_27', [0.75, 958.75]],
        ['6_18_28', [0.75, 2418.75]],
        ['6_18_29', [0.25, 5071]],
        ['6_18_3', [0.5, 1838]],
        ['6_18_30', [0.25, 5071]],
        ['6_18_31', [0.25, 5170.25]],
        ['6_18_32', [0.5, 5536.25]],
        ['6_18_33', [1, 6068.5]],
        ['6_18_34', [0.75, 6051.25]],
        ['6_18_35', [0.75, 6051.25]],
        ['6_18_36', [1.25, 237.25]],
        ['6_18_37', [0.75, 237.25]],
        ['6_18_38', [0.25, 1500.75]],
        ['6_18_39', [2, 2764]],
        ['6_18_4', [1, 2322.5]],
        ['6_18_40', [0.25, 2764]],
        ['6_18_41', [0.25, 3338.25]],
        ['6_18_42', [0.25, 3070]],
        ['6_18_43', [0.25, 1467.75]],
        ['6_18_44', [1.5, 165.5]],
        ['6_18_45', [0, 134.5]],
        ['6_18_46', [0, 134.5]],
        ['6_18_47', [0, 323]],
        ['6_18_48', [0.25, 1273]],
        ['6_18_49', [0.5, 1273]],
        ['6_18_5', [0.5, 2322.5]],
        ['6_18_50', [0.5, 678]],
        ['6_18_51', [0.5, 1850.5]],
        ['6_18_52', [28, 1850.5]],
        ['6_18_53', [60.5, 1355]],
        ['6_18_54', [64.5, 1357.5]],
        ['6_18_55', [76.5, 999]],
        ['6_18_56', [76.5, 972.5]],
        ['6_18_57', [116, 1124]],
        ['6_18_58', [120, 1124]],
        ['6_18_59', [120, 1124]],
        ['6_18_6', [0.5, 2002]],
        ['6_18_60', [149.5, 1346]],
        ['6_18_61', [149.5, 1346]],
        ['6_18_62', [149.5, 1346]],
        ['6_18_63', [426, 1736]],
        ['6_18_64', [945.5, 1736]],
        ['6_18_65', [1301.75, 1736]],
        ['6_18_66', [1423, 2339.5]],
        ['6_18_67', [1423, 2339.5]],
        ['6_18_68', [1423, 2339.5]],
        ['6_18_69', [2198, 2576]],
        ['6_18_7', [0.25, 2002]],
        ['6_18_70', [2198, 2576]],
        ['6_18_71', [2198, 2576]],
        ['6_18_72', [2527, 2660]],
        ['6_18_73', [2527, 2660]],
        ['6_18_74', [2527, 2660]],
        ['6_18_8', [0.25, 2120]],
        ['6_18_9', [0.25, 1818.5]],
        ['6_19_0', [1, 19.321428298950195]],
        ['6_19_1', [1, 19.321428298950195]],
        ['6_19_10', [0.25, 1404]],
        ['6_19_11', [0.5, 323.5]],
        ['6_19_12', [4, 797]],
        ['6_19_13', [0.5, 1622.5]],
        ['6_19_14', [0.25, 1622.5]],
        ['6_19_15', [0.5, 1954.5]],
        ['6_19_16', [0.25, 1954.5]],
        ['6_19_17', [0.25, 927]],
        ['6_19_18', [0.25, 852]],
        ['6_19_19', [1, 830.25]],
        ['6_19_2', [1, 19.321428298950195]],
        ['6_19_20', [4.5, 1043]],
        ['6_19_21', [0.25, 1065.25]],
        ['6_19_22', [0.25, 1684.5]],
        ['6_19_23', [1, 1684.5]],
        ['6_19_24', [0.75, 1040.25]],
        ['6_19_25', [0.75, 54.25]],
        ['6_19_26', [1, 54.25]],
        ['6_19_27', [2.5, 160.75]],
        ['6_19_28', [0.5, 2809.75]],
        ['6_19_29', [0.25, 5071]],
        ['6_19_3', [0.5, 1675.5]],
        ['6_19_30', [0.25, 5071]],
        ['6_19_31', [7.25, 4802.5]],
        ['6_19_32', [7.25, 1879.5]],
        ['6_19_33', [11.5, 4430.5]],
        ['6_19_34', [2, 6051.25]],
        ['6_19_35', [2, 6100.25]],
        ['6_19_36', [0.75, 6416.25]],
        ['6_19_37', [0.75, 6416.25]],
        ['6_19_38', [0.25, 6060.25]],
        ['6_19_39', [2, 4195.25]],
        ['6_19_4', [1, 2322.5]],
        ['6_19_40', [0.25, 2764]],
        ['6_19_41', [0.25, 3338.25]],
        ['6_19_42', [0.25, 3070]],
        ['6_19_43', [0.25, 2347]],
        ['6_19_44', [0.25, 1106.5]],
        ['6_19_45', [0, 134.5]],
        ['6_19_46', [0, 134.5]],
        ['6_19_47', [0, 1896]],
        ['6_19_48', [0.25, 2545.5]],
        ['6_19_49', [0.25, 2545.5]],
        ['6_19_5', [1, 2322.5]],
        ['6_19_50', [0.5, 2077.5]],
        ['6_19_51', [0.5, 2244]],
        ['6_19_52', [28, 2244]],
        ['6_19_53', [60.5, 1856]],
        ['6_19_54', [56, 672]],
        ['6_19_55', [62, 537]],
        ['6_19_56', [62, 458]],
        ['6_19_57', [119, 317]],
        ['6_19_58', [120, 1124]],
        ['6_19_59', [120, 1124]],
        ['6_19_6', [0.5, 2002]],
        ['6_19_60', [149.5, 1288]],
        ['6_19_61', [149.5, 1288]],
        ['6_19_62', [149.5, 1288]],
        ['6_19_63', [426, 1914]],
        ['6_19_64', [945.5, 1953]],
        ['6_19_65', [1301.75, 1953]],
        ['6_19_66', [1423, 2339.5]],
        ['6_19_67', [1423, 2339.5]],
        ['6_19_68', [1423, 2339.5]],
        ['6_19_69', [2198, 2576]],
        ['6_19_7', [0.5, 2002]],
        ['6_19_70', [2198, 2576]],
        ['6_19_71', [2198, 2576]],
        ['6_19_72', [2527, 2660]],
        ['6_19_73', [2527, 2660]],
        ['6_19_74', [2527, 2660]],
        ['6_19_8', [0.25, 1719.5]],
        ['6_19_9', [0.25, 1626.5]],
        ['6_1_12', [0.625, 42]],
        ['6_1_13', [0.5, 52]],
        ['6_1_14', [0.5, 52]],
        ['6_1_15', [0.75, 813.25]],
        ['6_1_16', [0.25, 960.5]],
        ['6_1_17', [0.25, 960.5]],
        ['6_1_18', [0.25, 354.25]],
        ['6_1_19', [0.25, 95.5]],
        ['6_1_20', [0.25, 1697.75]],
        ['6_1_21', [0.5, 1697.75]],
        ['6_1_22', [2.25, 31.25]],
        ['6_1_23', [2.25, 31.25]],
        ['6_1_27', [0.25, 5.75]],
        ['6_1_28', [0.25, 5.75]],
        ['6_1_29', [0.25, 5.75]],
        ['6_1_33', [1.25, 430.75]],
        ['6_1_34', [0.5, 1768.25]],
        ['6_1_35', [0.5, 430.75]],
        ['6_1_36', [4.5, 273]],
        ['6_1_37', [4.5, 273]],
        ['6_1_38', [4.5, 273]],
        ['6_1_39', [8.75, 12.75]],
        ['6_1_40', [8.75, 12.75]],
        ['6_1_41', [8.75, 12.75]],
        ['6_1_54', [2.5, 77.5]],
        ['6_1_55', [2.5, 79]],
        ['6_1_56', [2.5, 79]],
        ['6_1_57', [51, 248]],
        ['6_1_58', [51, 248]],
        ['6_1_59', [51, 248]],
        ['6_1_60', [63.5, 107]],
        ['6_1_61', [63.5, 107]],
        ['6_1_62', [63.5, 1481]],
        ['6_1_63', [76, 3609.5]],
        ['6_1_64', [95, 3609.5]],
        ['6_1_65', [1541, 3391]],
        ['6_1_66', [1803.5, 3052]],
        ['6_1_67', [1803.5, 3052]],
        ['6_1_68', [2349.5, 3052]],
        ['6_1_69', [2534, 3110]],
        ['6_1_70', [2534, 3110]],
        ['6_1_71', [2534, 3110]],
        ['6_1_72', [2925, 3154]],
        ['6_1_73', [2925, 3154]],
        ['6_1_74', [2925, 3154]],
        ['6_20_0', [1, 19.321428298950195]],
        ['6_20_1', [1, 19.321428298950195]],
        ['6_20_10', [0.25, 1857]],
        ['6_20_11', [0.5, 323.5]],
        ['6_20_12', [5, 80.94999694824219]],
        ['6_20_13', [1, 773.5]],
        ['6_20_14', [0.25, 1423]],
        ['6_20_15', [0.25, 2005]],
        ['6_20_16', [0.25, 2005]],
        ['6_20_17', [0.25, 1092.25]],
        ['6_20_18', [0.25, 1379.5]],
        ['6_20_19', [0.25, 1379.5]],
        ['6_20_2', [1, 19.321428298950195]],
        ['6_20_20', [1.5, 1043]],
        ['6_20_21', [0.25, 1174.5]],
        ['6_20_22', [0.25, 1343.75]],
        ['6_20_23', [1, 1343.75]],
        ['6_20_24', [1, 54.25]],
        ['6_20_25', [1, 54.25]],
        ['6_20_26', [1, 54.25]],
        ['6_20_27', [0.75, 160.75]],
        ['6_20_28', [0.5, 1126.5]],
        ['6_20_29', [0.25, 2238.25]],
        ['6_20_3', [1.5, 1460.5]],
        ['6_20_30', [0.5, 2612]],
        ['6_20_31', [7.25, 2714]],
        ['6_20_32', [7.25, 2407.5]],
        ['6_20_33', [11.5, 1046.25]],
        ['6_20_34', [11.5, 5892.5]],
        ['6_20_35', [113, 6100.25]],
        ['6_20_36', [51.25, 6416.25]],
        ['6_20_37', [11.5, 6416.25]],
        ['6_20_38', [4.25, 3455.25]],
        ['6_20_39', [1, 3455.25]],
        ['6_20_4', [1, 1654]],
        ['6_20_40', [0.25, 1852.75]],
        ['6_20_41', [0.25, 1128.75]],
        ['6_20_42', [0.5, 964.5]],
        ['6_20_43', [0.25, 1219.25]],
        ['6_20_44', [0.25, 974.75]],
        ['6_20_45', [0, 134.5]],
        ['6_20_46', [0, 2139.75]],
        ['6_20_47', [0, 2139.75]],
        ['6_20_48', [0.25, 2136.25]],
        ['6_20_49', [0.25, 2596]],
        ['6_20_5', [0.5, 1414]],
        ['6_20_50', [1, 2324]],
        ['6_20_51', [1.5, 2244]],
        ['6_20_52', [1.5, 2244]],
        ['6_20_53', [6.5, 1856]],
        ['6_20_54', [56, 458]],
        ['6_20_55', [62, 458]],
        ['6_20_56', [62, 458]],
        ['6_20_57', [79, 317]],
        ['6_20_58', [79, 1124]],
        ['6_20_59', [79, 1124]],
        ['6_20_6', [0.5, 1453.5]],
        ['6_20_60', [149.5, 1288]],
        ['6_20_61', [149.5, 1288]],
        ['6_20_62', [149.5, 1288]],
        ['6_20_63', [426, 2022]],
        ['6_20_64', [945.5, 2022]],
        ['6_20_65', [1204.5, 1953]],
        ['6_20_66', [1423, 2339.5]],
        ['6_20_67', [1423, 2339.5]],
        ['6_20_68', [1423, 2339.5]],
        ['6_20_69', [2198, 2576]],
        ['6_20_7', [0.5, 2049.5]],
        ['6_20_70', [2198, 2576]],
        ['6_20_71', [2198, 2576]],
        ['6_20_72', [2527, 2660]],
        ['6_20_73', [2527, 2660]],
        ['6_20_74', [2527, 2660]],
        ['6_20_8', [0.5, 2049.5]],
        ['6_20_9', [0.5, 1857]],
        ['6_21_0', [0, 27.5]],
        ['6_21_1', [0, 27.5]],
        ['6_21_10', [0.5, 2408]],
        ['6_21_11', [0.5, 2300.5]],
        ['6_21_12', [0.25, 1865]],
        ['6_21_13', [0.25, 1284]],
        ['6_21_14', [1.5, 637.5]],
        ['6_21_15', [0.25, 1518.5]],
        ['6_21_16', [0.25, 1518.5]],
        ['6_21_17', [0.25, 190.5]],
        ['6_21_18', [0.25, 1093.5]],
        ['6_21_19', [0.25, 1093.5]],
        ['6_21_2', [0, 27.5]],
        ['6_21_20', [0.25, 1034]],
        ['6_21_21', [0.25, 770.5]],
        ['6_21_22', [0.25, 770.5]],
        ['6_21_23', [0.25, 367.75]],
        ['6_21_27', [0.75, 51]],
        ['6_21_28', [0.75, 1098]],
        ['6_21_29', [0.25, 1147.75]],
        ['6_21_3', [1, 459.5]],
        ['6_21_30', [0.5, 2612]],
        ['6_21_31', [2, 2612]],
        ['6_21_32', [9.5, 1415]],
        ['6_21_33', [4.25, 708]],
        ['6_21_34', [83, 1017]],
        ['6_21_35', [64.75, 1545]],
        ['6_21_36', [53.25, 1335.25]],
        ['6_21_37', [41.75, 658.5]],
        ['6_21_38', [0.25, 681]],
        ['6_21_39', [1.5, 856.25]],
        ['6_21_4', [0.5, 883.5]],
        ['6_21_40', [1.5, 46]],
        ['6_21_41', [1.5, 46]],
        ['6_21_42', [0.5, 555.25]],
        ['6_21_43', [0.5, 555.25]],
        ['6_21_44', [1, 109.75]],
        ['6_21_45', [0.5, 629]],
        ['6_21_46', [0.25, 2139.75]],
        ['6_21_47', [0.25, 2139.75]],
        ['6_21_48', [0.5, 1556.25]],
        ['6_21_49', [1, 1772.25]],
        ['6_21_5', [0.5, 1455]],
        ['6_21_50', [1, 2306.5]],
        ['6_21_51', [4, 1986]],
        ['6_21_52', [4, 1676]],
        ['6_21_53', [9.841666221618652, 723.75]],
        ['6_21_54', [52, 226]],
        ['6_21_55', [52, 226]],
        ['6_21_56', [60, 487]],
        ['6_21_57', [65.5, 305]],
        ['6_21_58', [71, 305]],
        ['6_21_59', [71, 884]],
        ['6_21_6', [0.5, 2584]],
        ['6_21_60', [114, 1616.5]],
        ['6_21_61', [134, 1616.5]],
        ['6_21_62', [204.5, 1545.75]],
        ['6_21_63', [586, 1936]],
        ['6_21_64', [1194, 2011]],
        ['6_21_65', [1360, 2011]],
        ['6_21_66', [1750, 2340]],
        ['6_21_67', [1750, 2340]],
        ['6_21_68', [1750, 2340]],
        ['6_21_69', [2215, 2576]],
        ['6_21_7', [13, 2584]],
        ['6_21_70', [2215, 2576]],
        ['6_21_71', [2215, 2576]],
        ['6_21_72', [2407, 2647]],
        ['6_21_73', [2407, 2647]],
        ['6_21_74', [2407, 2647]],
        ['6_21_8', [13, 2584]],
        ['6_21_9', [488, 2429.5]],
        ['6_22_0', [0, 27.5]],
        ['6_22_1', [0, 27.5]],
        ['6_22_10', [18.5, 2742]],
        ['6_22_11', [0.5, 2742]],
        ['6_22_12', [0.25, 2951.5]],
        ['6_22_13', [0.25, 2951.5]],
        ['6_22_14', [0.5, 2103.5]],
        ['6_22_15', [0.25, 1806]],
        ['6_22_16', [0.25, 1986]],
        ['6_22_17', [0.25, 1986]],
        ['6_22_18', [0.25, 952.25]],
        ['6_22_19', [0.25, 386.5]],
        ['6_22_2', [0, 27.5]],
        ['6_22_20', [0.25, 589.5]],
        ['6_22_21', [0.25, 722.25]],
        ['6_22_22', [0.25, 722.25]],
        ['6_22_23', [0.25, 330.25]],
        ['6_22_27', [0.75, 16.25]],
        ['6_22_28', [0.75, 16.25]],
        ['6_22_29', [0.75, 385.75]],
        ['6_22_3', [0.5, 213]],
        ['6_22_30', [2, 603.75]],
        ['6_22_31', [1, 980.25]],
        ['6_22_32', [1, 805.75]],
        ['6_22_33', [4.25, 743.5]],
        ['6_22_34', [90.5, 1122.5]],
        ['6_22_35', [64.75, 1122.5]],
        ['6_22_36', [53.25, 1678.25]],
        ['6_22_37', [0.25, 1678.25]],
        ['6_22_38', [0.25, 542.5]],
        ['6_22_39', [1.5, 307.25]],
        ['6_22_4', [0.5, 1045.5]],
        ['6_22_40', [1.5, 46]],
        ['6_22_41', [1.5, 46]],
        ['6_22_42', [1, 109.75]],
        ['6_22_43', [1, 109.75]],
        ['6_22_44', [1, 109.75]],
        ['6_22_45', [1, 878.25]],
        ['6_22_46', [1, 1520.5]],
        ['6_22_47', [1, 1520.5]],
        ['6_22_48', [12.5, 124]],
        ['6_22_49', [8, 72.36666870117188]],
        ['6_22_5', [0.5, 1455]],
        ['6_22_50', [8, 97]],
        ['6_22_51', [6.5, 160]],
        ['6_22_52', [6.5, 160]],
        ['6_22_53', [9.841666221618652, 160]],
        ['6_22_54', [52, 628.5]],
        ['6_22_55', [52, 887]],
        ['6_22_56', [67, 887]],
        ['6_22_57', [65.5, 845]],
        ['6_22_58', [71, 573]],
        ['6_22_59', [71, 1547]],
        ['6_22_6', [133, 2584]],
        ['6_22_60', [114, 1982]],
        ['6_22_61', [134, 1982]],
        ['6_22_62', [493.5, 1545.75]],
        ['6_22_63', [586, 2011]],
        ['6_22_64', [1194, 2011]],
        ['6_22_65', [1360, 2011]],
        ['6_22_66', [1750, 2340]],
        ['6_22_67', [1750, 2340]],
        ['6_22_68', [1750, 2340]],
        ['6_22_69', [2215, 2576]],
        ['6_22_7', [285.25, 2584]],
        ['6_22_70', [2215, 2576]],
        ['6_22_71', [2215, 2576]],
        ['6_22_72', [2407, 2647]],
        ['6_22_73', [2407, 2647]],
        ['6_22_74', [2407, 2647]],
        ['6_22_8', [1077.5, 2584]],
        ['6_22_9', [1178, 2741.5]],
        ['6_23_0', [0, 468]],
        ['6_23_1', [0, 468]],
        ['6_23_10', [1284.75, 2975.25]],
        ['6_23_11', [1284.75, 2975.25]],
        ['6_23_12', [817, 2956.75]],
        ['6_23_13', [0.5, 2956.75]],
        ['6_23_14', [0.5, 2786.5]],
        ['6_23_15', [0.25, 2590.5]],
        ['6_23_16', [0.25, 2782.5]],
        ['6_23_17', [0.25, 2782.5]],
        ['6_23_18', [0.25, 2718.75]],
        ['6_23_19', [0.25, 386.5]],
        ['6_23_2', [0, 468]],
        ['6_23_20', [0.25, 26]],
        ['6_23_21', [0.75, 291]],
        ['6_23_22', [0.25, 291]],
        ['6_23_23', [0.25, 291]],
        ['6_23_27', [0.75, 16.25]],
        ['6_23_28', [0.75, 16.25]],
        ['6_23_29', [0.75, 385.75]],
        ['6_23_3', [0.5, 1083.5]],
        ['6_23_30', [5.138888835906982, 274.25]],
        ['6_23_31', [1, 488.5]],
        ['6_23_32', [1, 743.5]],
        ['6_23_33', [31.75, 972]],
        ['6_23_34', [161.5, 1583.5]],
        ['6_23_35', [1.25, 2489]],
        ['6_23_36', [0.25, 2489]],
        ['6_23_37', [0.25, 1678.25]],
        ['6_23_38', [0.25, 542.5]],
        ['6_23_39', [1.5, 188.25]],
        ['6_23_4', [0.5, 1510.5]],
        ['6_23_40', [1.5, 46]],
        ['6_23_41', [1.5, 46]],
        ['6_23_42', [1, 109.75]],
        ['6_23_43', [1, 109.75]],
        ['6_23_44', [1, 109.75]],
        ['6_23_45', [1, 216]],
        ['6_23_46', [1, 326.75]],
        ['6_23_47', [1, 326.75]],
        ['6_23_48', [12.5, 124]],
        ['6_23_49', [8, 72.36666870117188]],
        ['6_23_5', [0.5, 1925.25]],
        ['6_23_50', [8, 97]],
        ['6_23_51', [6.5, 160]],
        ['6_23_52', [6.5, 160]],
        ['6_23_53', [9.841666221618652, 160]],
        ['6_23_54', [5.5, 714]],
        ['6_23_55', [5.5, 887]],
        ['6_23_56', [67, 887]],
        ['6_23_57', [65.5, 845]],
        ['6_23_58', [75, 573]],
        ['6_23_59', [75, 1547]],
        ['6_23_6', [284.5, 2584]],
        ['6_23_60', [119, 1982]],
        ['6_23_61', [573, 1982]],
        ['6_23_62', [797, 1605]],
        ['6_23_63', [586, 2011]],
        ['6_23_64', [1194, 2011]],
        ['6_23_65', [1508.5, 2011]],
        ['6_23_66', [1750, 2340]],
        ['6_23_67', [1750, 2340]],
        ['6_23_68', [1750, 2340]],
        ['6_23_69', [2215, 2576]],
        ['6_23_7', [952, 2584]],
        ['6_23_70', [2215, 2576]],
        ['6_23_71', [2215, 2576]],
        ['6_23_72', [2407, 2647]],
        ['6_23_73', [2407, 2647]],
        ['6_23_74', [2407, 2647]],
        ['6_23_8', [1077.5, 2584]],
        ['6_23_9', [1401, 2975.25]],
        ['6_24_0', [1.5, 67.5]],
        ['6_24_1', [1.5, 67.5]],
        ['6_24_10', [2104.5, 2955.5]],
        ['6_24_11', [2403.5, 3075.5]],
        ['6_24_12', [1965, 3216]],
        ['6_24_13', [1675, 3216]],
        ['6_24_14', [1675, 3156.5]],
        ['6_24_15', [1.5, 3003.5]],
        ['6_24_16', [0.25, 2743.5]],
        ['6_24_17', [0.25, 2743.5]],
        ['6_24_18', [0.25, 2718.75]],
        ['6_24_19', [1, 442.5]],
        ['6_24_2', [0.5, 1228]],
        ['6_24_20', [1, 442.5]],
        ['6_24_21', [0, 369.25]],
        ['6_24_22', [0, 369.25]],
        ['6_24_23', [0, 369.25]],
        ['6_24_24', [22.25, 373.5]],
        ['6_24_25', [52, 238.5]],
        ['6_24_26', [52, 238.5]],
        ['6_24_3', [0.5, 1318]],
        ['6_24_30', [0.75, 108.25]],
        ['6_24_31', [0.75, 108.25]],
        ['6_24_32', [0.75, 985]],
        ['6_24_33', [0.25, 1394.5]],
        ['6_24_34', [0.25, 1768]],
        ['6_24_35', [0.25, 2552]],
        ['6_24_36', [0.25, 2489]],
        ['6_24_37', [4.25, 361.25]],
        ['6_24_38', [4.25, 361.25]],
        ['6_24_4', [0.5, 1695]],
        ['6_24_42', [0, 136]],
        ['6_24_43', [0, 459.25]],
        ['6_24_44', [0, 210]],
        ['6_24_45', [0.5, 166.4583282470703]],
        ['6_24_46', [0.5, 166.4583282470703]],
        ['6_24_47', [0.5, 166.4583282470703]],
        ['6_24_5', [0.5, 1991]],
        ['6_24_51', [0, 110.5]],
        ['6_24_52', [0, 110.5]],
        ['6_24_53', [0, 110.5]],
        ['6_24_54', [0.5, 713.5]],
        ['6_24_55', [0.5, 887]],
        ['6_24_56', [61, 887]],
        ['6_24_57', [81.5, 1065]],
        ['6_24_58', [81.5, 1845]],
        ['6_24_59', [89, 1845]],
        ['6_24_6', [466.5, 2554]],
        ['6_24_60', [125, 2161]],
        ['6_24_61', [582.5, 2161]],
        ['6_24_62', [858, 2161]],
        ['6_24_63', [1351, 2241]],
        ['6_24_64', [1351, 2241]],
        ['6_24_65', [1351, 2241]],
        ['6_24_66', [1818, 2358.5]],
        ['6_24_67', [1818, 2358.5]],
        ['6_24_68', [1818, 2358.5]],
        ['6_24_69', [2189, 2525]],
        ['6_24_7', [1239.5, 2554]],
        ['6_24_70', [2189, 2525]],
        ['6_24_71', [2189, 2525]],
        ['6_24_72', [2425, 2587]],
        ['6_24_73', [2425, 2587]],
        ['6_24_74', [2425, 2587]],
        ['6_24_8', [1831, 2554]],
        ['6_24_9', [2104.5, 2670]],
        ['6_25_0', [1.5, 67.5]],
        ['6_25_1', [1.5, 67.5]],
        ['6_25_10', [1041, 2955.5]],
        ['6_25_11', [2223.5, 3075.5]],
        ['6_25_12', [1936.5, 3216]],
        ['6_25_13', [1965, 3216]],
        ['6_25_14', [1.75, 3156.5]],
        ['6_25_15', [0.5, 3174.75]],
        ['6_25_16', [0.5, 2878.75]],
        ['6_25_17', [0.75, 840]],
        ['6_25_18', [1, 106.75]],
        ['6_25_19', [1, 10.75]],
        ['6_25_2', [1, 1643]],
        ['6_25_20', [1, 10.75]],
        ['6_25_21', [0, 369.25]],
        ['6_25_22', [0, 369.25]],
        ['6_25_23', [0, 369.25]],
        ['6_25_24', [22.25, 373.5]],
        ['6_25_25', [52, 238.5]],
        ['6_25_26', [52, 238.5]],
        ['6_25_3', [0.5, 1643]],
        ['6_25_30', [0.75, 14.75]],
        ['6_25_31', [0.75, 14.75]],
        ['6_25_32', [0.75, 985]],
        ['6_25_33', [0.25, 1144.5]],
        ['6_25_34', [0.25, 1144.5]],
        ['6_25_35', [0.25, 958.5]],
        ['6_25_36', [0.25, 942.75]],
        ['6_25_37', [4.25, 203]],
        ['6_25_38', [4.25, 203]],
        ['6_25_4', [0.75, 1695]],
        ['6_25_42', [0, 365.25]],
        ['6_25_43', [0, 2507.25]],
        ['6_25_44', [0, 357.5]],
        ['6_25_45', [0.5, 166.4583282470703]],
        ['6_25_46', [0.5, 166.4583282470703]],
        ['6_25_47', [0.5, 166.4583282470703]],
        ['6_25_5', [1.25, 1991]],
        ['6_25_51', [0, 110.5]],
        ['6_25_52', [0, 110.5]],
        ['6_25_53', [0, 653.25]],
        ['6_25_54', [0.5, 1192]],
        ['6_25_55', [0.5, 1192]],
        ['6_25_56', [61, 626]],
        ['6_25_57', [81.5, 1192]],
        ['6_25_58', [81.5, 1845]],
        ['6_25_59', [89, 1845]],
        ['6_25_6', [627.5, 2554]],
        ['6_25_60', [131, 2161]],
        ['6_25_61', [994.5, 2161]],
        ['6_25_62', [994.5, 2161]],
        ['6_25_63', [1351, 2241]],
        ['6_25_64', [1351, 2241]],
        ['6_25_65', [1351, 2241]],
        ['6_25_66', [1818, 2358.5]],
        ['6_25_67', [1818, 2358.5]],
        ['6_25_68', [1818, 2358.5]],
        ['6_25_69', [2189, 2525]],
        ['6_25_7', [1156.5, 2554]],
        ['6_25_70', [2189, 2525]],
        ['6_25_71', [2189, 2525]],
        ['6_25_72', [2425, 2587]],
        ['6_25_73', [2425, 2587]],
        ['6_25_74', [2425, 2587]],
        ['6_25_8', [1154.5, 2554]],
        ['6_25_9', [1041, 2670]],
        ['6_26_0', [1, 67.5]],
        ['6_26_1', [1, 67.5]],
        ['6_26_10', [1041, 2955.5]],
        ['6_26_11', [348.5, 3075.5]],
        ['6_26_12', [1, 3216]],
        ['6_26_13', [0.5, 3216]],
        ['6_26_14', [0.5, 3328.5]],
        ['6_26_15', [0.5, 3329.75]],
        ['6_26_16', [1, 2700]],
        ['6_26_17', [2.5, 229.5]],
        ['6_26_18', [1, 106.75]],
        ['6_26_19', [1, 10.75]],
        ['6_26_2', [1, 1643]],
        ['6_26_20', [1, 10.75]],
        ['6_26_21', [0, 369.25]],
        ['6_26_22', [0, 369.25]],
        ['6_26_23', [0, 369.25]],
        ['6_26_24', [1.5, 1885.5]],
        ['6_26_25', [2, 238.5]],
        ['6_26_26', [2, 238.5]],
        ['6_26_3', [0.75, 1643]],
        ['6_26_30', [0.75, 14.75]],
        ['6_26_31', [0.75, 14.75]],
        ['6_26_32', [0.75, 117.75]],
        ['6_26_33', [0.25, 366.75]],
        ['6_26_34', [0.25, 203]],
        ['6_26_35', [0.25, 361.25]],
        ['6_26_36', [0.25, 203]],
        ['6_26_37', [4.25, 203]],
        ['6_26_38', [4.25, 203]],
        ['6_26_4', [0.5, 1441]],
        ['6_26_42', [0, 365.25]],
        ['6_26_43', [0, 365.25]],
        ['6_26_44', [0.75, 624]],
        ['6_26_45', [0.5, 624]],
        ['6_26_46', [0.5, 166.4583282470703]],
        ['6_26_47', [0.5, 166.4583282470703]],
        ['6_26_5', [0.5, 1829]],
        ['6_26_51', [0, 110.5]],
        ['6_26_52', [0, 110.5]],
        ['6_26_53', [0, 1417.25]],
        ['6_26_54', [0.5, 1509]],
        ['6_26_55', [0.5, 1498.5]],
        ['6_26_56', [73.25, 1749]],
        ['6_26_57', [81.5, 1845]],
        ['6_26_58', [81.5, 1845]],
        ['6_26_59', [92.5, 1845]],
        ['6_26_6', [82.5, 2293]],
        ['6_26_60', [1253.5, 2161]],
        ['6_26_61', [1253.5, 2161]],
        ['6_26_62', [1529, 2161]],
        ['6_26_63', [1351, 2241]],
        ['6_26_64', [1351, 2241]],
        ['6_26_65', [1351, 2241]],
        ['6_26_66', [1818, 2358.5]],
        ['6_26_67', [1818, 2358.5]],
        ['6_26_68', [1818, 2358.5]],
        ['6_26_69', [2189, 2525]],
        ['6_26_7', [153, 2293]],
        ['6_26_70', [2189, 2525]],
        ['6_26_71', [2189, 2525]],
        ['6_26_72', [2425, 2587]],
        ['6_26_73', [2425, 2587]],
        ['6_26_74', [2425, 2587]],
        ['6_26_8', [952, 2293]],
        ['6_26_9', [1041, 2670]],
        ['6_27_0', [0.5, 10]],
        ['6_27_1', [0.5, 10]],
        ['6_27_10', [0.5, 2659]],
        ['6_27_11', [0.25, 2659]],
        ['6_27_12', [0.25, 2654.5]],
        ['6_27_13', [0.25, 2513]],
        ['6_27_14', [0.25, 3297]],
        ['6_27_15', [0.5, 3295.5]],
        ['6_27_16', [0.25, 1192.75]],
        ['6_27_17', [0.75, 1192.75]],
        ['6_27_18', [0, 38.04166793823242]],
        ['6_27_19', [0, 38.04166793823242]],
        ['6_27_2', [0.5, 1101]],
        ['6_27_20', [0, 85.5]],
        ['6_27_21', [3, 30.649999618530273]],
        ['6_27_22', [3, 30.649999618530273]],
        ['6_27_23', [0.25, 30.649999618530273]],
        ['6_27_24', [1.25, 1885.5]],
        ['6_27_25', [1.25, 776.25]],
        ['6_27_26', [1.25, 347]],
        ['6_27_27', [0.5, 222.25]],
        ['6_27_28', [0.5, 1570.75]],
        ['6_27_29', [0.5, 1999.75]],
        ['6_27_3', [0.5, 1269]],
        ['6_27_30', [2.5, 367]],
        ['6_27_31', [6.25, 271.25]],
        ['6_27_32', [6.25, 271.25]],
        ['6_27_33', [69.55000305175781, 114.75]],
        ['6_27_34', [69.55000305175781, 114.75]],
        ['6_27_35', [69.55000305175781, 114.75]],
        ['6_27_36', [30, 366.875]],
        ['6_27_37', [30, 366.875]],
        ['6_27_38', [30, 434.25]],
        ['6_27_39', [23.5, 438.75]],
        ['6_27_4', [0.25, 1261.5]],
        ['6_27_40', [30, 399]],
        ['6_27_41', [30, 399]],
        ['6_27_42', [2, 254.25]],
        ['6_27_43', [2, 254.25]],
        ['6_27_44', [1, 1071.5]],
        ['6_27_45', [1, 1071.5]],
        ['6_27_46', [1, 210]],
        ['6_27_47', [1, 210]],
        ['6_27_48', [0, 43.25]],
        ['6_27_49', [0, 43.25]],
        ['6_27_5', [0.25, 1527.25]],
        ['6_27_50', [0, 81.75]],
        ['6_27_51', [2, 133.5]],
        ['6_27_52', [0.75, 907]],
        ['6_27_53', [0.75, 2130]],
        ['6_27_54', [8.5, 1730]],
        ['6_27_55', [157.5, 1730]],
        ['6_27_56', [157.5, 1620]],
        ['6_27_57', [148.5, 2133.5]],
        ['6_27_58', [812.5, 2133.5]],
        ['6_27_59', [812.5, 2133.5]],
        ['6_27_6', [0.5, 1668.5]],
        ['6_27_60', [1455.5, 2431.5]],
        ['6_27_61', [1455.5, 2431.5]],
        ['6_27_62', [1455.5, 2431.5]],
        ['6_27_63', [2020, 2549]],
        ['6_27_64', [2020, 2549]],
        ['6_27_65', [2020, 2549]],
        ['6_27_66', [2118, 2544]],
        ['6_27_67', [2118, 2544]],
        ['6_27_68', [2118, 2544]],
        ['6_27_69', [2263, 2601]],
        ['6_27_7', [1.5, 1668.5]],
        ['6_27_70', [2263, 2601]],
        ['6_27_71', [2263, 2601]],
        ['6_27_72', [2440, 2636]],
        ['6_27_73', [2440, 2636]],
        ['6_27_74', [2440, 2636]],
        ['6_27_8', [0.5, 1892]],
        ['6_27_9', [0.5, 2659]],
        ['6_28_0', [0.5, 2.5]],
        ['6_28_1', [0.5, 2.5]],
        ['6_28_10', [0.25, 1935]],
        ['6_28_11', [0.25, 2001]],
        ['6_28_12', [0.25, 1546]],
        ['6_28_13', [0.25, 1475]],
        ['6_28_14', [0.25, 1526]],
        ['6_28_15', [0.5, 1045.75]],
        ['6_28_16', [0.25, 1998.75]],
        ['6_28_17', [0.5, 1998.75]],
        ['6_28_18', [0, 38.04166793823242]],
        ['6_28_19', [0, 38.04166793823242]],
        ['6_28_2', [0.5, 18]],
        ['6_28_20', [0, 85.5]],
        ['6_28_21', [3, 30.649999618530273]],
        ['6_28_22', [3, 30.649999618530273]],
        ['6_28_23', [0.25, 30.649999618530273]],
        ['6_28_24', [1.25, 347]],
        ['6_28_25', [1.25, 1592.75]],
        ['6_28_26', [0.75, 3250.25]],
        ['6_28_27', [0.5, 3250.25]],
        ['6_28_28', [0.5, 375.25]],
        ['6_28_29', [0.5, 807.5]],
        ['6_28_3', [0.5, 674]],
        ['6_28_30', [2.5, 367]],
        ['6_28_31', [6.25, 271.25]],
        ['6_28_32', [6.25, 271.25]],
        ['6_28_33', [69.55000305175781, 114.75]],
        ['6_28_34', [69.55000305175781, 114.75]],
        ['6_28_35', [69.55000305175781, 114.75]],
        ['6_28_36', [30, 366.875]],
        ['6_28_37', [30, 366.875]],
        ['6_28_38', [30, 434.25]],
        ['6_28_39', [23.5, 438.75]],
        ['6_28_4', [0.5, 674]],
        ['6_28_40', [30, 399]],
        ['6_28_41', [30, 399]],
        ['6_28_42', [2, 56.25]],
        ['6_28_43', [2, 56.25]],
        ['6_28_44', [1, 393]],
        ['6_28_45', [1, 393]],
        ['6_28_46', [1, 210]],
        ['6_28_47', [1, 210]],
        ['6_28_48', [0, 43.25]],
        ['6_28_49', [0, 43.25]],
        ['6_28_5', [0.5, 1154]],
        ['6_28_50', [0, 81.75]],
        ['6_28_51', [2, 1108.25]],
        ['6_28_52', [2, 1956]],
        ['6_28_53', [2, 2130]],
        ['6_28_54', [676.5, 2335]],
        ['6_28_55', [470.5, 2335]],
        ['6_28_56', [470.5, 2335]],
        ['6_28_57', [162.5, 2133.5]],
        ['6_28_58', [1080, 2133.5]],
        ['6_28_59', [1080, 2133.5]],
        ['6_28_6', [0.5, 1358.5]],
        ['6_28_60', [1455.5, 2431.5]],
        ['6_28_61', [1455.5, 2431.5]],
        ['6_28_62', [1455.5, 2431.5]],
        ['6_28_63', [2020, 2549]],
        ['6_28_64', [2020, 2549]],
        ['6_28_65', [2020, 2549]],
        ['6_28_66', [2118, 2544]],
        ['6_28_67', [2118, 2544]],
        ['6_28_68', [2118, 2544]],
        ['6_28_69', [2263, 2601]],
        ['6_28_7', [0.5, 1358.5]],
        ['6_28_70', [2263, 2601]],
        ['6_28_71', [2263, 2601]],
        ['6_28_72', [2440, 2636]],
        ['6_28_73', [2440, 2636]],
        ['6_28_74', [2440, 2636]],
        ['6_28_8', [0.5, 1291]],
        ['6_28_9', [0.25, 1695.5]],
        ['6_29_0', [0.5, 2.5]],
        ['6_29_1', [0.5, 2.5]],
        ['6_29_10', [0.25, 511.5]],
        ['6_29_11', [0.25, 348]],
        ['6_29_12', [2, 233.5]],
        ['6_29_13', [0.25, 180.25]],
        ['6_29_14', [0.25, 213.75]],
        ['6_29_15', [0.5, 1045.75]],
        ['6_29_16', [0.5, 1998.75]],
        ['6_29_17', [0.5, 1998.75]],
        ['6_29_18', [0, 41]],
        ['6_29_19', [0, 41]],
        ['6_29_2', [0.5, 18]],
        ['6_29_20', [0, 701.75]],
        ['6_29_21', [0.5, 701.75]],
        ['6_29_22', [3, 49.25]],
        ['6_29_23', [0.25, 49.25]],
        ['6_29_24', [1.25, 347]],
        ['6_29_25', [1.25, 1592.75]],
        ['6_29_26', [0.5, 3250.25]],
        ['6_29_27', [0.5, 3250.25]],
        ['6_29_28', [0.5, 789.75]],
        ['6_29_29', [0.5, 1415]],
        ['6_29_3', [1.25, 23]],
        ['6_29_30', [0.5, 1557.5]],
        ['6_29_31', [5.25, 544.5]],
        ['6_29_32', [5.25, 271.25]],
        ['6_29_33', [69.55000305175781, 114.75]],
        ['6_29_34', [69.55000305175781, 114.75]],
        ['6_29_35', [69.55000305175781, 114.75]],
        ['6_29_36', [29.5, 366.875]],
        ['6_29_37', [29.5, 366.875]],
        ['6_29_38', [6.25, 1627.5]],
        ['6_29_39', [2.25, 1627.5]],
        ['6_29_4', [2, 572]],
        ['6_29_40', [2.25, 742.5]],
        ['6_29_41', [22.5, 399]],
        ['6_29_42', [2, 56.25]],
        ['6_29_43', [2, 56.25]],
        ['6_29_44', [1, 393]],
        ['6_29_45', [1, 393]],
        ['6_29_46', [1, 210]],
        ['6_29_47', [1, 210]],
        ['6_29_48', [0, 43.25]],
        ['6_29_49', [0, 444.5]],
        ['6_29_5', [0.5, 1154]],
        ['6_29_50', [0, 1391]],
        ['6_29_51', [2, 1798.5]],
        ['6_29_52', [2, 2665.5]],
        ['6_29_53', [2, 2610.5]],
        ['6_29_54', [1095.5, 2335]],
        ['6_29_55', [753.5, 2335]],
        ['6_29_56', [753.5, 2335]],
        ['6_29_57', [162.5, 2133.5]],
        ['6_29_58', [1134, 2133.5]],
        ['6_29_59', [1134, 2133.5]],
        ['6_29_6', [1, 1199]],
        ['6_29_60', [1455.5, 2431.5]],
        ['6_29_61', [1455.5, 2431.5]],
        ['6_29_62', [1455.5, 2431.5]],
        ['6_29_63', [2020, 2549]],
        ['6_29_64', [2020, 2549]],
        ['6_29_65', [2020, 2549]],
        ['6_29_66', [2118, 2544]],
        ['6_29_67', [2118, 2544]],
        ['6_29_68', [2118, 2544]],
        ['6_29_69', [2263, 2601]],
        ['6_29_7', [0.5, 1033]],
        ['6_29_70', [2263, 2601]],
        ['6_29_71', [2263, 2601]],
        ['6_29_72', [2440, 2636]],
        ['6_29_73', [2440, 2636]],
        ['6_29_74', [2440, 2636]],
        ['6_29_8', [0.5, 394.5]],
        ['6_29_9', [0.25, 511.5]],
        ['6_2_12', [0.625, 42]],
        ['6_2_13', [0.5, 52]],
        ['6_2_14', [0.5, 1006]],
        ['6_2_15', [0.75, 1151]],
        ['6_2_16', [0.5, 1030]],
        ['6_2_17', [0.5, 762.5]],
        ['6_2_18', [0.25, 590.5]],
        ['6_2_19', [0.25, 2130.75]],
        ['6_2_20', [0.25, 2308.75]],
        ['6_2_21', [0.5, 1697.75]],
        ['6_2_22', [2.25, 31.25]],
        ['6_2_23', [2.25, 31.25]],
        ['6_2_27', [0.25, 5.75]],
        ['6_2_28', [0.25, 5.75]],
        ['6_2_29', [0.25, 5.75]],
        ['6_2_33', [1.25, 430.75]],
        ['6_2_34', [0.5, 570.25]],
        ['6_2_35', [0.5, 430.75]],
        ['6_2_36', [4.5, 273]],
        ['6_2_37', [4.5, 273]],
        ['6_2_38', [4.5, 273]],
        ['6_2_39', [8.75, 12.75]],
        ['6_2_40', [8.75, 12.75]],
        ['6_2_41', [8.75, 12.75]],
        ['6_2_54', [2.5, 77.5]],
        ['6_2_55', [2.5, 551]],
        ['6_2_56', [2.5, 551]],
        ['6_2_57', [51, 248]],
        ['6_2_58', [51, 248]],
        ['6_2_59', [51, 248]],
        ['6_2_60', [63.5, 108]],
        ['6_2_61', [63.5, 108]],
        ['6_2_62', [63.5, 676.5]],
        ['6_2_63', [76, 3052]],
        ['6_2_64', [95, 3391]],
        ['6_2_65', [133.5, 3449]],
        ['6_2_66', [1278.5, 3450.5]],
        ['6_2_67', [1568, 3052]],
        ['6_2_68', [1761, 3052]],
        ['6_2_69', [2534, 3110]],
        ['6_2_70', [2534, 3110]],
        ['6_2_71', [2534, 3110]],
        ['6_2_72', [2925, 3154]],
        ['6_2_73', [2925, 3154]],
        ['6_2_74', [2925, 3154]],
        ['6_30_12', [2, 142]],
        ['6_30_13', [2, 1953.5]],
        ['6_30_14', [2, 1953.5]],
        ['6_30_15', [2, 90.40277862548828]],
        ['6_30_16', [2, 205]],
        ['6_30_17', [0.25, 698.5]],
        ['6_30_18', [0.25, 846.5]],
        ['6_30_19', [0.25, 1031.25]],
        ['6_30_20', [0.25, 957]],
        ['6_30_21', [0.25, 776]],
        ['6_30_22', [1, 377]],
        ['6_30_23', [0.5, 2368]],
        ['6_30_24', [0.75, 2228]],
        ['6_30_25', [0.75, 3768]],
        ['6_30_26', [5.5, 3768]],
        ['6_30_27', [5.25, 789.75]],
        ['6_30_28', [16.5, 789.75]],
        ['6_30_29', [16.5, 1415]],
        ['6_30_3', [1, 7.458333492279053]],
        ['6_30_30', [3.25, 1557.5]],
        ['6_30_31', [3.25, 709.5]],
        ['6_30_32', [3.25, 170.25]],
        ['6_30_33', [0, 97.5]],
        ['6_30_34', [0, 537.25]],
        ['6_30_35', [0, 537.25]],
        ['6_30_36', [29.5, 438.75]],
        ['6_30_37', [29.5, 438.75]],
        ['6_30_38', [6.25, 1627.5]],
        ['6_30_39', [2.25, 1627.5]],
        ['6_30_4', [1, 7.458333492279053]],
        ['6_30_40', [2.25, 742.5]],
        ['6_30_41', [22.5, 399]],
        ['6_30_42', [0, 99.5]],
        ['6_30_43', [0, 256]],
        ['6_30_44', [0, 256]],
        ['6_30_48', [0.5, 174.5]],
        ['6_30_49', [0.5, 785]],
        ['6_30_5', [1, 600.5]],
        ['6_30_50', [0.5, 2321.25]],
        ['6_30_51', [12.5, 3074.5]],
        ['6_30_52', [392.5, 3074.5]],
        ['6_30_53', [1385.5, 2991.75]],
        ['6_30_54', [1790, 3137.5]],
        ['6_30_55', [1790, 3137.5]],
        ['6_30_56', [1790, 3137.5]],
        ['6_30_57', [1577, 2740.5]],
        ['6_30_58', [1577, 2740.5]],
        ['6_30_59', [1577, 2740.5]],
        ['6_30_6', [1, 502]],
        ['6_30_60', [1965, 2608]],
        ['6_30_61', [1965, 2608]],
        ['6_30_62', [1965, 2608]],
        ['6_30_63', [2264, 2690]],
        ['6_30_64', [2264, 2690]],
        ['6_30_65', [2264, 2690]],
        ['6_30_66', [2493, 2695]],
        ['6_30_67', [2493, 2695]],
        ['6_30_68', [2493, 2695]],
        ['6_30_69', [2462, 2704]],
        ['6_30_7', [1.2083333730697632, 6]],
        ['6_30_70', [2462, 2704]],
        ['6_30_71', [2462, 2704]],
        ['6_30_72', [2571, 2713]],
        ['6_30_73', [2571, 2713]],
        ['6_30_74', [2571, 2713]],
        ['6_30_8', [1.2083333730697632, 6]],
        ['6_31_12', [16.866666793823242, 25.25]],
        ['6_31_13', [16.866666793823242, 55]],
        ['6_31_14', [16.866666793823242, 55]],
        ['6_31_15', [2, 90.40277862548828]],
        ['6_31_16', [2, 205]],
        ['6_31_17', [0.25, 698.5]],
        ['6_31_18', [0.25, 846.5]],
        ['6_31_19', [0.25, 1166.5]],
        ['6_31_20', [0.25, 957]],
        ['6_31_21', [0.25, 892]],
        ['6_31_22', [1, 747]],
        ['6_31_23', [0.5, 2986.25]],
        ['6_31_24', [0.5, 3116.5]],
        ['6_31_25', [0.75, 3768]],
        ['6_31_26', [139.75, 3768]],
        ['6_31_27', [145.25, 884]],
        ['6_31_28', [98, 884]],
        ['6_31_29', [98, 884]],
        ['6_31_3', [2.5, 7.458333492279053]],
        ['6_31_30', [3.25, 892.75]],
        ['6_31_31', [3.25, 787]],
        ['6_31_32', [3.25, 170.25]],
        ['6_31_33', [0, 97.5]],
        ['6_31_34', [0, 537.25]],
        ['6_31_35', [0, 537.25]],
        ['6_31_36', [29.5, 182.75]],
        ['6_31_37', [29.5, 182.75]],
        ['6_31_38', [29.5, 232.125]],
        ['6_31_39', [2.25, 399]],
        ['6_31_4', [2.5, 7.458333492279053]],
        ['6_31_40', [2.25, 399]],
        ['6_31_41', [22.5, 399]],
        ['6_31_42', [0, 99.5]],
        ['6_31_43', [0, 256]],
        ['6_31_44', [0, 256]],
        ['6_31_48', [4, 40]],
        ['6_31_49', [4, 785]],
        ['6_31_5', [1.5, 7.458333492279053]],
        ['6_31_50', [4, 2642]],
        ['6_31_51', [126.75, 3074.5]],
        ['6_31_52', [1589.5, 3074.5]],
        ['6_31_53', [2090, 2991.75]],
        ['6_31_54', [1790, 3137.5]],
        ['6_31_55', [1790, 3137.5]],
        ['6_31_56', [1790, 3137.5]],
        ['6_31_57', [1577, 2740.5]],
        ['6_31_58', [1577, 2740.5]],
        ['6_31_59', [1577, 2740.5]],
        ['6_31_6', [1.2083333730697632, 6]],
        ['6_31_60', [1965, 2608]],
        ['6_31_61', [1965, 2608]],
        ['6_31_62', [1965, 2608]],
        ['6_31_63', [2264, 2690]],
        ['6_31_64', [2264, 2690]],
        ['6_31_65', [2264, 2690]],
        ['6_31_66', [2493, 2695]],
        ['6_31_67', [2493, 2695]],
        ['6_31_68', [2493, 2695]],
        ['6_31_69', [2462, 2704]],
        ['6_31_7', [1.2083333730697632, 6]],
        ['6_31_70', [2462, 2704]],
        ['6_31_71', [2462, 2704]],
        ['6_31_72', [2571, 2713]],
        ['6_31_73', [2571, 2713]],
        ['6_31_74', [2571, 2713]],
        ['6_31_8', [1.2083333730697632, 6]],
        ['6_32_12', [16.866666793823242, 25.25]],
        ['6_32_13', [16.866666793823242, 55]],
        ['6_32_14', [16.866666793823242, 55]],
        ['6_32_15', [1, 90.40277862548828]],
        ['6_32_16', [1, 90.40277862548828]],
        ['6_32_17', [0.5, 1885]],
        ['6_32_18', [0.5, 1885]],
        ['6_32_19', [0.5, 1380.5]],
        ['6_32_20', [0.75, 460.5]],
        ['6_32_21', [1, 1205.75]],
        ['6_32_22', [5, 4161.5]],
        ['6_32_23', [0.5, 4161.5]],
        ['6_32_24', [0.5, 1947.25]],
        ['6_32_25', [0.75, 2109.25]],
        ['6_32_26', [16.75, 2041.5]],
        ['6_32_27', [144, 2456.75]],
        ['6_32_28', [171, 2456.75]],
        ['6_32_29', [61, 884]],
        ['6_32_3', [2.5, 7.458333492279053]],
        ['6_32_30', [1.75, 892.75]],
        ['6_32_31', [1.75, 1496.75]],
        ['6_32_32', [1.75, 1496.75]],
        ['6_32_33', [0, 97.5]],
        ['6_32_34', [0, 98.5]],
        ['6_32_35', [0, 98.5]],
        ['6_32_36', [29.5, 182.75]],
        ['6_32_37', [29.5, 182.75]],
        ['6_32_38', [29.5, 232.125]],
        ['6_32_39', [2.25, 399]],
        ['6_32_4', [2.5, 7.458333492279053]],
        ['6_32_40', [2.25, 399]],
        ['6_32_41', [22.5, 399]],
        ['6_32_42', [0, 549]],
        ['6_32_43', [0, 611.5]],
        ['6_32_44', [0, 360.25]],
        ['6_32_48', [4, 67]],
        ['6_32_49', [4, 1062.25]],
        ['6_32_5', [1.5, 7.458333492279053]],
        ['6_32_50', [4, 3114]],
        ['6_32_51', [126.75, 3109]],
        ['6_32_52', [2090, 3109]],
        ['6_32_53', [2090, 3109]],
        ['6_32_54', [1790, 3137.5]],
        ['6_32_55', [1790, 3137.5]],
        ['6_32_56', [1790, 3137.5]],
        ['6_32_57', [1577, 2740.5]],
        ['6_32_58', [1577, 2740.5]],
        ['6_32_59', [1577, 2740.5]],
        ['6_32_6', [1.2083333730697632, 6]],
        ['6_32_60', [1965, 2608]],
        ['6_32_61', [1965, 2608]],
        ['6_32_62', [1965, 2608]],
        ['6_32_63', [2264, 2690]],
        ['6_32_64', [2264, 2690]],
        ['6_32_65', [2264, 2690]],
        ['6_32_66', [2493, 2695]],
        ['6_32_67', [2493, 2695]],
        ['6_32_68', [2493, 2695]],
        ['6_32_69', [2462, 2704]],
        ['6_32_7', [1.2083333730697632, 6]],
        ['6_32_70', [2462, 2704]],
        ['6_32_71', [2462, 2704]],
        ['6_32_72', [2571, 2713]],
        ['6_32_73', [2571, 2713]],
        ['6_32_74', [2571, 2713]],
        ['6_32_8', [1.2083333730697632, 6]],
        ['6_33_10', [1, 30.15972137451172]],
        ['6_33_11', [1, 30.15972137451172]],
        ['6_33_12', [0.5, 331]],
        ['6_33_13', [0.5, 331]],
        ['6_33_14', [0.5, 550]],
        ['6_33_15', [0.75, 761]],
        ['6_33_16', [0.5, 1050]],
        ['6_33_17', [0.25, 2246]],
        ['6_33_18', [0.25, 2246]],
        ['6_33_19', [0.25, 1445.25]],
        ['6_33_20', [0.25, 1027.75]],
        ['6_33_21', [1, 1205.75]],
        ['6_33_22', [1.5, 4161.5]],
        ['6_33_23', [0.25, 4161.5]],
        ['6_33_24', [0.25, 2008]],
        ['6_33_25', [0.25, 2109.25]],
        ['6_33_26', [1.25, 1632.5]],
        ['6_33_27', [321.25, 2456.75]],
        ['6_33_28', [269.5, 2456.75]],
        ['6_33_29', [103, 1816.75]],
        ['6_33_3', [0, 7.25]],
        ['6_33_30', [0.75, 3710.75]],
        ['6_33_31', [0.75, 3710.75]],
        ['6_33_32', [1.25, 1496.75]],
        ['6_33_33', [1, 710.5]],
        ['6_33_34', [1.9907407760620117, 1913]],
        ['6_33_35', [1.25, 1913]],
        ['6_33_36', [4, 154]],
        ['6_33_37', [4, 154]],
        ['6_33_38', [1.25, 154]],
        ['6_33_39', [15, 20]],
        ['6_33_4', [0, 7.25]],
        ['6_33_40', [15, 20]],
        ['6_33_41', [15, 20]],
        ['6_33_42', [5.75, 167.9791717529297]],
        ['6_33_43', [5.75, 167.9791717529297]],
        ['6_33_44', [5.75, 140.2916717529297]],
        ['6_33_48', [3, 44]],
        ['6_33_49', [3, 1603]],
        ['6_33_5', [0, 7.25]],
        ['6_33_50', [3, 3189]],
        ['6_33_51', [1564.5, 3446]],
        ['6_33_52', [2657.25, 3517.25]],
        ['6_33_53', [2657.25, 3517.25]],
        ['6_33_54', [2456, 3617]],
        ['6_33_55', [2456, 3617]],
        ['6_33_56', [2456, 3617]],
        ['6_33_57', [2358, 3269]],
        ['6_33_58', [2358, 3269]],
        ['6_33_59', [2358, 3269]],
        ['6_33_6', [0.5, 390.5]],
        ['6_33_60', [2328, 2794]],
        ['6_33_61', [2328, 2794]],
        ['6_33_62', [2328, 2794]],
        ['6_33_63', [2494, 2796]],
        ['6_33_64', [2494, 2796]],
        ['6_33_65', [2494, 2796]],
        ['6_33_66', [2639, 2813]],
        ['6_33_67', [2639, 2813]],
        ['6_33_68', [2639, 2813]],
        ['6_33_69', [2642, 2803]],
        ['6_33_7', [0.25, 1185]],
        ['6_33_70', [2642, 2803]],
        ['6_33_71', [2642, 2803]],
        ['6_33_72', [2653, 2763]],
        ['6_33_73', [2653, 2763]],
        ['6_33_74', [2653, 2763]],
        ['6_33_8', [0.5, 1185]],
        ['6_33_9', [0.5, 476]],
        ['6_34_10', [0.5, 953.5]],
        ['6_34_11', [1, 30.15972137451172]],
        ['6_34_12', [0.5, 331]],
        ['6_34_13', [0.5, 331]],
        ['6_34_14', [0.5, 1632.5]],
        ['6_34_15', [0.25, 1804]],
        ['6_34_16', [0.5, 1632]],
        ['6_34_17', [0.5, 1860]],
        ['6_34_18', [0.5, 1860]],
        ['6_34_19', [0.5, 621.25]],
        ['6_34_20', [5.25, 1027.75]],
        ['6_34_21', [1, 1435.25]],
        ['6_34_22', [0.25, 3474]],
        ['6_34_23', [0.25, 2711.25]],
        ['6_34_24', [0.25, 2990]],
        ['6_34_25', [1, 2990]],
        ['6_34_26', [1.25, 1124.25]],
        ['6_34_27', [17.5, 2812.25]],
        ['6_34_28', [167.25, 2839]],
        ['6_34_29', [167.25, 1242.5]],
        ['6_34_3', [0, 7.25]],
        ['6_34_30', [19.5, 2726.5]],
        ['6_34_31', [7.25, 2726.5]],
        ['6_34_32', [1.25, 1256.5]],
        ['6_34_33', [1, 2391.25]],
        ['6_34_34', [1.9907407760620117, 2391.25]],
        ['6_34_35', [1.25, 2345.25]],
        ['6_34_36', [2.25, 2345.25]],
        ['6_34_37', [2.25, 1883.5]],
        ['6_34_38', [1.25, 871]],
        ['6_34_39', [15, 20]],
        ['6_34_4', [0, 7.25]],
        ['6_34_40', [15, 20]],
        ['6_34_41', [15, 20]],
        ['6_34_42', [5.75, 167.9791717529297]],
        ['6_34_43', [5.75, 167.9791717529297]],
        ['6_34_44', [5.75, 140.2916717529297]],
        ['6_34_48', [3, 44.5]],
        ['6_34_49', [3, 1603]],
        ['6_34_5', [0, 7.25]],
        ['6_34_50', [3, 3189]],
        ['6_34_51', [919, 3612.5]],
        ['6_34_52', [2672.25, 3612.5]],
        ['6_34_53', [2728.75, 3612.5]],
        ['6_34_54', [2456, 3617]],
        ['6_34_55', [2456, 3617]],
        ['6_34_56', [2456, 3617]],
        ['6_34_57', [2358, 3269]],
        ['6_34_58', [2358, 3269]],
        ['6_34_59', [2358, 3269]],
        ['6_34_6', [0.5, 430.5]],
        ['6_34_60', [2328, 2794]],
        ['6_34_61', [2328, 2794]],
        ['6_34_62', [2328, 2794]],
        ['6_34_63', [2494, 2796]],
        ['6_34_64', [2494, 2796]],
        ['6_34_65', [2494, 2796]],
        ['6_34_66', [2639, 2813]],
        ['6_34_67', [2639, 2813]],
        ['6_34_68', [2639, 2813]],
        ['6_34_69', [2642, 2803]],
        ['6_34_7', [0.25, 1529.5]],
        ['6_34_70', [2642, 2803]],
        ['6_34_71', [2642, 2803]],
        ['6_34_72', [2653, 2763]],
        ['6_34_73', [2653, 2763]],
        ['6_34_74', [2653, 2763]],
        ['6_34_8', [0.25, 1529.5]],
        ['6_34_9', [0.25, 1004]],
        ['6_35_10', [1, 953.5]],
        ['6_35_11', [1, 159.75]],
        ['6_35_12', [0.5, 370.75]],
        ['6_35_13', [0.5, 1165.5]],
        ['6_35_14', [0.25, 1632.5]],
        ['6_35_15', [0.25, 1804]],
        ['6_35_16', [0.25, 1623]],
        ['6_35_17', [0.25, 943]],
        ['6_35_18', [1.25, 650]],
        ['6_35_19', [4.25, 484.5]],
        ['6_35_20', [9, 491.5]],
        ['6_35_21', [1, 2157.75]],
        ['6_35_22', [9.75, 2250.75]],
        ['6_35_23', [0.25, 2693.75]],
        ['6_35_24', [0.25, 2693.75]],
        ['6_35_25', [0.25, 2039]],
        ['6_35_26', [1.25, 994.75]],
        ['6_35_27', [17.5, 2880.75]],
        ['6_35_28', [167.25, 3168.75]],
        ['6_35_29', [167.25, 1343.25]],
        ['6_35_3', [0, 7.25]],
        ['6_35_30', [252.25, 1306]],
        ['6_35_31', [280.25, 1243]],
        ['6_35_32', [266.5, 1256.5]],
        ['6_35_33', [266.25, 2153]],
        ['6_35_34', [481.25, 2153]],
        ['6_35_35', [3.5, 2210]],
        ['6_35_36', [2.25, 2210]],
        ['6_35_37', [2.25, 1883.5]],
        ['6_35_38', [1.25, 1942.75]],
        ['6_35_39', [15, 20]],
        ['6_35_4', [0, 7.25]],
        ['6_35_40', [15, 20]],
        ['6_35_41', [15, 20]],
        ['6_35_42', [5.75, 167.9791717529297]],
        ['6_35_43', [5.75, 167.9791717529297]],
        ['6_35_44', [5.75, 140.2916717529297]],
        ['6_35_48', [3, 59]],
        ['6_35_49', [3, 1458.5]],
        ['6_35_5', [0, 7.25]],
        ['6_35_50', [3, 3187]],
        ['6_35_51', [919, 3612.5]],
        ['6_35_52', [2456.75, 3612.5]],
        ['6_35_53', [2728.75, 3612.5]],
        ['6_35_54', [2456, 3617]],
        ['6_35_55', [2456, 3617]],
        ['6_35_56', [2456, 3617]],
        ['6_35_57', [2358, 3269]],
        ['6_35_58', [2358, 3269]],
        ['6_35_59', [2358, 3269]],
        ['6_35_6', [0.25, 718.75]],
        ['6_35_60', [2328, 2794]],
        ['6_35_61', [2328, 2794]],
        ['6_35_62', [2328, 2794]],
        ['6_35_63', [2494, 2796]],
        ['6_35_64', [2494, 2796]],
        ['6_35_65', [2494, 2796]],
        ['6_35_66', [2639, 2813]],
        ['6_35_67', [2639, 2813]],
        ['6_35_68', [2639, 2813]],
        ['6_35_69', [2642, 2803]],
        ['6_35_7', [0.25, 1529.5]],
        ['6_35_70', [2642, 2803]],
        ['6_35_71', [2642, 2803]],
        ['6_35_72', [2653, 2763]],
        ['6_35_73', [2653, 2763]],
        ['6_35_74', [2653, 2763]],
        ['6_35_8', [0.25, 1529.5]],
        ['6_35_9', [0.25, 1004]],
        ['6_36_10', [0.5, 26]],
        ['6_36_11', [1, 26]],
        ['6_36_12', [1.375, 73.5]],
        ['6_36_13', [0.25, 1165.5]],
        ['6_36_14', [0.25, 1288.5]],
        ['6_36_15', [2, 1164]],
        ['6_36_16', [0.9133333563804626, 484.5]],
        ['6_36_17', [0.9133333563804626, 435]],
        ['6_36_18', [1.6666666269302368, 226.75]],
        ['6_36_19', [1.6666666269302368, 226.75]],
        ['6_36_20', [1.6666666269302368, 226.75]],
        ['6_36_21', [13.75, 1857.25]],
        ['6_36_22', [0.75, 2279.5]],
        ['6_36_23', [0.25, 2693.75]],
        ['6_36_24', [0.25, 2740.25]],
        ['6_36_25', [0.5, 2740.25]],
        ['6_36_26', [0.5, 857.5]],
        ['6_36_27', [5.75, 1620.75]],
        ['6_36_28', [108.5, 1797.25]],
        ['6_36_29', [205.25, 2811.25]],
        ['6_36_3', [5.402777671813965, 7.25]],
        ['6_36_30', [353.25, 1304.25]],
        ['6_36_31', [338, 2867]],
        ['6_36_32', [338, 3804]],
        ['6_36_33', [365.5, 2498.75]],
        ['6_36_34', [365.5, 1731.25]],
        ['6_36_35', [370, 1674.25]],
        ['6_36_36', [474, 2208.75]],
        ['6_36_37', [2.25, 3343.5]],
        ['6_36_38', [1, 2764.75]],
        ['6_36_39', [6.5, 88.5]],
        ['6_36_4', [5.402777671813965, 7.25]],
        ['6_36_40', [6.5, 88.5]],
        ['6_36_41', [6.5, 435]],
        ['6_36_48', [2.5, 74.5]],
        ['6_36_49', [2.5, 1358.5]],
        ['6_36_5', [5.402777671813965, 7.25]],
        ['6_36_50', [2.5, 3179.5]],
        ['6_36_51', [791.5, 3582]],
        ['6_36_52', [2582.5, 3748.5]],
        ['6_36_53', [2582.5, 3748.5]],
        ['6_36_54', [2996, 3691.5]],
        ['6_36_55', [2996, 3691.5]],
        ['6_36_56', [2996, 3691.5]],
        ['6_36_57', [2578, 3662]],
        ['6_36_58', [2578, 3662]],
        ['6_36_59', [2578, 3662]],
        ['6_36_6', [0.5, 717]],
        ['6_36_60', [2609.5, 3433]],
        ['6_36_61', [2609.5, 3433]],
        ['6_36_62', [2609.5, 3433]],
        ['6_36_63', [2616, 3274]],
        ['6_36_64', [2616, 3274]],
        ['6_36_65', [2616, 3274]],
        ['6_36_66', [2737, 3162]],
        ['6_36_67', [2737, 3162]],
        ['6_36_68', [2737, 3162]],
        ['6_36_69', [2744, 3033]],
        ['6_36_7', [0.25, 725]],
        ['6_36_70', [2744, 3033]],
        ['6_36_71', [2744, 3033]],
        ['6_36_72', [2737, 2959]],
        ['6_36_73', [2737, 2959]],
        ['6_36_74', [2737, 2959]],
        ['6_36_8', [0.25, 722]],
        ['6_36_9', [0.25, 634]],
        ['6_37_10', [1, 6.5]],
        ['6_37_11', [1, 6.5]],
        ['6_37_12', [0.5, 20]],
        ['6_37_13', [0.25, 625]],
        ['6_37_14', [0.25, 851]],
        ['6_37_15', [1.5, 1117.5]],
        ['6_37_16', [0.9133333563804626, 614.25]],
        ['6_37_17', [0.9133333563804626, 385.5]],
        ['6_37_18', [1.6666666269302368, 226.75]],
        ['6_37_19', [1.6666666269302368, 226.75]],
        ['6_37_20', [1.6666666269302368, 226.75]],
        ['6_37_21', [13.75, 292.25]],
        ['6_37_22', [0.25, 1452.5]],
        ['6_37_23', [0.25, 2340.75]],
        ['6_37_24', [0.25, 3454.75]],
        ['6_37_25', [0.25, 3206]],
        ['6_37_26', [0.25, 2372.5]],
        ['6_37_27', [0.5, 1891.75]],
        ['6_37_28', [92, 1457.75]],
        ['6_37_29', [205.25, 1786.75]],
        ['6_37_3', [5.402777671813965, 7.25]],
        ['6_37_30', [392, 2713.5]],
        ['6_37_31', [408.75, 4474.25]],
        ['6_37_32', [471, 4474.25]],
        ['6_37_33', [476, 2827]],
        ['6_37_34', [28, 2447.75]],
        ['6_37_35', [4.25, 2340.75]],
        ['6_37_36', [1, 2226.25]],
        ['6_37_37', [0.75, 3343.5]],
        ['6_37_38', [0.75, 2764.75]],
        ['6_37_39', [6.5, 88.5]],
        ['6_37_4', [5.402777671813965, 7.25]],
        ['6_37_40', [6.5, 88.5]],
        ['6_37_41', [6.5, 435]],
        ['6_37_48', [1, 648.75]],
        ['6_37_49', [1, 2576]],
        ['6_37_5', [5.402777671813965, 7.25]],
        ['6_37_50', [2.5, 3179.5]],
        ['6_37_51', [791.5, 3582]],
        ['6_37_52', [2326.75, 3748.5]],
        ['6_37_53', [2582.5, 3748.5]],
        ['6_37_54', [2996, 3691.5]],
        ['6_37_55', [2996, 3691.5]],
        ['6_37_56', [2996, 3691.5]],
        ['6_37_57', [2578, 3662]],
        ['6_37_58', [2578, 3662]],
        ['6_37_59', [2578, 3662]],
        ['6_37_6', [0.5, 584]],
        ['6_37_60', [2609.5, 3433]],
        ['6_37_61', [2609.5, 3433]],
        ['6_37_62', [2609.5, 3433]],
        ['6_37_63', [2616, 3274]],
        ['6_37_64', [2616, 3274]],
        ['6_37_65', [2616, 3274]],
        ['6_37_66', [2737, 3162]],
        ['6_37_67', [2737, 3162]],
        ['6_37_68', [2737, 3162]],
        ['6_37_69', [2744, 3033]],
        ['6_37_7', [0.5, 584]],
        ['6_37_70', [2744, 3033]],
        ['6_37_71', [2744, 3033]],
        ['6_37_72', [2737, 2959]],
        ['6_37_73', [2737, 2959]],
        ['6_37_74', [2737, 2959]],
        ['6_37_8', [0.5, 8]],
        ['6_37_9', [1, 6.5]],
        ['6_38_10', [1, 6.5]],
        ['6_38_11', [1, 6.5]],
        ['6_38_12', [0.5, 20]],
        ['6_38_13', [0.5, 20]],
        ['6_38_14', [0.5, 833]],
        ['6_38_15', [0.5, 1117.5]],
        ['6_38_16', [0.5, 614.25]],
        ['6_38_17', [0.9133333563804626, 384.5]],
        ['6_38_18', [1.6666666269302368, 226.75]],
        ['6_38_19', [1.6666666269302368, 226.75]],
        ['6_38_20', [1.6666666269302368, 226.75]],
        ['6_38_21', [10.5, 292.25]],
        ['6_38_22', [0.25, 2138.25]],
        ['6_38_23', [0.25, 3133]],
        ['6_38_24', [0.75, 3454.75]],
        ['6_38_25', [0.25, 3224.25]],
        ['6_38_26', [0.25, 2372.5]],
        ['6_38_27', [0.25, 2509.25]],
        ['6_38_28', [0.25, 2545.25]],
        ['6_38_29', [0.25, 4224.75]],
        ['6_38_3', [5.402777671813965, 7.25]],
        ['6_38_30', [332.5, 4222.25]],
        ['6_38_31', [2.75, 4530]],
        ['6_38_32', [2.75, 5677.5]],
        ['6_38_33', [1, 2918]],
        ['6_38_34', [1, 2495.25]],
        ['6_38_35', [3, 2495.25]],
        ['6_38_36', [1, 897.75]],
        ['6_38_37', [0.75, 645.5]],
        ['6_38_38', [0.75, 162]],
        ['6_38_39', [6.5, 99.75]],
        ['6_38_4', [5.402777671813965, 7.25]],
        ['6_38_40', [6.5, 99.75]],
        ['6_38_41', [6.5, 1075]],
        ['6_38_48', [1, 1421.5]],
        ['6_38_49', [0.5, 2576]],
        ['6_38_5', [5.402777671813965, 7.25]],
        ['6_38_50', [2.5, 3035]],
        ['6_38_51', [791.5, 3582]],
        ['6_38_52', [2326.75, 3748.5]],
        ['6_38_53', [2582.5, 3748.5]],
        ['6_38_54', [2996, 3691.5]],
        ['6_38_55', [2996, 3691.5]],
        ['6_38_56', [2996, 3691.5]],
        ['6_38_57', [2578, 3662]],
        ['6_38_58', [2578, 3662]],
        ['6_38_59', [2578, 3662]],
        ['6_38_6', [0.5, 8]],
        ['6_38_60', [2609.5, 3433]],
        ['6_38_61', [2609.5, 3433]],
        ['6_38_62', [2609.5, 3433]],
        ['6_38_63', [2616, 3274]],
        ['6_38_64', [2616, 3274]],
        ['6_38_65', [2616, 3274]],
        ['6_38_66', [2737, 3162]],
        ['6_38_67', [2737, 3162]],
        ['6_38_68', [2737, 3162]],
        ['6_38_69', [2744, 3033]],
        ['6_38_7', [0.5, 8]],
        ['6_38_70', [2744, 3033]],
        ['6_38_71', [2744, 3033]],
        ['6_38_72', [2737, 2959]],
        ['6_38_73', [2737, 2959]],
        ['6_38_74', [2737, 2959]],
        ['6_38_8', [0.5, 8]],
        ['6_38_9', [1, 6.5]],
        ['6_39_10', [0, 15.25]],
        ['6_39_11', [0, 15.25]],
        ['6_39_12', [1.25, 285]],
        ['6_39_13', [2, 285]],
        ['6_39_14', [2, 285]],
        ['6_39_15', [1.5, 364.75]],
        ['6_39_16', [1.5, 452.5]],
        ['6_39_17', [1.5, 452.5]],
        ['6_39_18', [92.75, 265]],
        ['6_39_19', [117, 265]],
        ['6_39_20', [9.75, 379.5]],
        ['6_39_21', [0.75, 219.5]],
        ['6_39_22', [0.75, 2145.25]],
        ['6_39_23', [0.75, 5254.75]],
        ['6_39_24', [1.25, 4527.75]],
        ['6_39_25', [7, 3656.5]],
        ['6_39_26', [7, 1845]],
        ['6_39_27', [2, 2509.25]],
        ['6_39_28', [1.75, 3387.5]],
        ['6_39_29', [0.25, 4224.75]],
        ['6_39_3', [0, 17.700000762939453]],
        ['6_39_30', [0.5, 4222.25]],
        ['6_39_31', [3.5, 4222.25]],
        ['6_39_32', [0.5, 2266.75]],
        ['6_39_33', [0.25, 2266.75]],
        ['6_39_34', [0.25, 2222.25]],
        ['6_39_35', [0.25, 1787]],
        ['6_39_36', [0.75, 1819.75]],
        ['6_39_37', [0.75, 238]],
        ['6_39_38', [0.75, 238]],
        ['6_39_39', [39, 81.625]],
        ['6_39_4', [0, 17.700000762939453]],
        ['6_39_40', [39, 81.625]],
        ['6_39_41', [13.5, 647.5]],
        ['6_39_45', [0, 78.41666412353516]],
        ['6_39_46', [0, 78.41666412353516]],
        ['6_39_47', [0, 78.41666412353516]],
        ['6_39_48', [0.75, 2179.75]],
        ['6_39_49', [0.75, 2969.5]],
        ['6_39_5', [0, 17.700000762939453]],
        ['6_39_50', [3.5, 3168.5]],
        ['6_39_51', [2173.5, 3753.5]],
        ['6_39_52', [2173.5, 3753.5]],
        ['6_39_53', [2376.5, 3753.5]],
        ['6_39_54', [2934.5, 3790]],
        ['6_39_55', [2934.5, 3790]],
        ['6_39_56', [2934.5, 3790]],
        ['6_39_57', [3209.5, 3693]],
        ['6_39_58', [3209.5, 3693]],
        ['6_39_59', [3209.5, 3693]],
        ['6_39_6', [0.5, 384]],
        ['6_39_60', [3076.5, 3760]],
        ['6_39_61', [3076.5, 3760]],
        ['6_39_62', [3076.5, 3760]],
        ['6_39_63', [3049, 3498]],
        ['6_39_64', [3049, 3498]],
        ['6_39_65', [3049, 3498]],
        ['6_39_66', [2921, 3316]],
        ['6_39_67', [2921, 3316]],
        ['6_39_68', [2921, 3316]],
        ['6_39_69', [2866.5, 3125]],
        ['6_39_7', [0.5, 25.5]],
        ['6_39_70', [2866.5, 3125]],
        ['6_39_71', [2866.5, 3125]],
        ['6_39_72', [2864, 3078]],
        ['6_39_73', [2864, 3078]],
        ['6_39_74', [2864, 3078]],
        ['6_39_8', [0.5, 18]],
        ['6_39_9', [0, 15.25]],
        ['6_3_12', [0.5, 40]],
        ['6_3_13', [0.5, 40]],
        ['6_3_14', [0.5, 1341]],
        ['6_3_15', [0.25, 1625.25]],
        ['6_3_16', [0.25, 972.5]],
        ['6_3_17', [0.5, 1232.25]],
        ['6_3_18', [0.25, 1409.75]],
        ['6_3_19', [0.25, 2149.5]],
        ['6_3_20', [0.25, 2308.75]],
        ['6_3_27', [0.75, 2796.75]],
        ['6_3_28', [0.75, 2796.75]],
        ['6_3_29', [3.25, 58.5]],
        ['6_3_30', [15.25, 22]],
        ['6_3_31', [15.25, 22]],
        ['6_3_32', [15.25, 22]],
        ['6_3_33', [0.75, 66.22916412353516]],
        ['6_3_34', [0.75, 286]],
        ['6_3_35', [0.75, 286]],
        ['6_3_36', [6.5, 51]],
        ['6_3_37', [6.5, 51]],
        ['6_3_38', [6.5, 51]],
        ['6_3_51', [1.5, 29]],
        ['6_3_52', [1.5, 29]],
        ['6_3_53', [0.5, 355.5]],
        ['6_3_54', [1, 929]],
        ['6_3_55', [18.5, 929]],
        ['6_3_56', [27, 551]],
        ['6_3_57', [45, 410]],
        ['6_3_58', [45, 410]],
        ['6_3_59', [54, 370.5]],
        ['6_3_60', [64, 278]],
        ['6_3_61', [64, 278]],
        ['6_3_62', [64, 278]],
        ['6_3_63', [92, 1453]],
        ['6_3_64', [92, 2360]],
        ['6_3_65', [92, 3450.5]],
        ['6_3_66', [739.5, 3764]],
        ['6_3_67', [1416, 3764]],
        ['6_3_68', [2022, 2861]],
        ['6_3_69', [2181, 3030]],
        ['6_3_70', [2181, 3030]],
        ['6_3_71', [2381.5, 3030]],
        ['6_3_72', [2762, 3160]],
        ['6_3_73', [2762, 3160]],
        ['6_3_74', [2762, 3160]],
        ['6_40_10', [0, 15.25]],
        ['6_40_11', [0, 15.25]],
        ['6_40_12', [1.25, 96.5]],
        ['6_40_13', [2, 288.25]],
        ['6_40_14', [2, 285]],
        ['6_40_15', [1.5, 394]],
        ['6_40_16', [1.5, 452.5]],
        ['6_40_17', [1.5, 452.5]],
        ['6_40_18', [80.5, 265]],
        ['6_40_19', [80.5, 265]],
        ['6_40_20', [9.75, 379.5]],
        ['6_40_21', [1.75, 460.25]],
        ['6_40_22', [0.25, 650.75]],
        ['6_40_23', [0.25, 4322]],
        ['6_40_24', [0.5, 4527.75]],
        ['6_40_25', [0.5, 4382.25]],
        ['6_40_26', [1.25, 4124]],
        ['6_40_27', [1.5, 1306.5]],
        ['6_40_28', [2.25, 3387.5]],
        ['6_40_29', [0.5, 3387.5]],
        ['6_40_3', [0, 17.700000762939453]],
        ['6_40_30', [0.25, 2310.75]],
        ['6_40_31', [2.75, 1078.25]],
        ['6_40_32', [0.5, 262.25]],
        ['6_40_33', [0.25, 1560.5]],
        ['6_40_34', [0.25, 2620.75]],
        ['6_40_35', [0.25, 2516.5]],
        ['6_40_36', [0.5, 2516.5]],
        ['6_40_37', [6, 238]],
        ['6_40_38', [6, 238]],
        ['6_40_39', [8.5, 81.625]],
        ['6_40_4', [0, 17.700000762939453]],
        ['6_40_40', [8.5, 146.5]],
        ['6_40_41', [8.5, 647.5]],
        ['6_40_45', [0, 78.41666412353516]],
        ['6_40_46', [0, 78.41666412353516]],
        ['6_40_47', [0, 1461.25]],
        ['6_40_48', [0.75, 2660.5]],
        ['6_40_49', [123.75, 2969.5]],
        ['6_40_5', [0, 387.5]],
        ['6_40_50', [1587.5, 3168.5]],
        ['6_40_51', [2173.5, 3753.5]],
        ['6_40_52', [2173.5, 3753.5]],
        ['6_40_53', [2376.5, 3753.5]],
        ['6_40_54', [2934.5, 3790]],
        ['6_40_55', [2934.5, 3790]],
        ['6_40_56', [2934.5, 3790]],
        ['6_40_57', [3209.5, 3693]],
        ['6_40_58', [3209.5, 3693]],
        ['6_40_59', [3209.5, 3693]],
        ['6_40_6', [0.25, 478.5]],
        ['6_40_60', [3076.5, 3760]],
        ['6_40_61', [3076.5, 3760]],
        ['6_40_62', [3076.5, 3760]],
        ['6_40_63', [3049, 3498]],
        ['6_40_64', [3049, 3498]],
        ['6_40_65', [3049, 3498]],
        ['6_40_66', [2921, 3316]],
        ['6_40_67', [2921, 3316]],
        ['6_40_68', [2921, 3316]],
        ['6_40_69', [2866.5, 3125]],
        ['6_40_7', [0.25, 478.5]],
        ['6_40_70', [2866.5, 3125]],
        ['6_40_71', [2866.5, 3125]],
        ['6_40_72', [2864, 3078]],
        ['6_40_73', [2864, 3078]],
        ['6_40_74', [2864, 3078]],
        ['6_40_8', [0.5, 125.5]],
        ['6_40_9', [0, 15.25]],
        ['6_41_10', [0, 837.25]],
        ['6_41_11', [0, 1033]],
        ['6_41_12', [0.5, 1128.5]],
        ['6_41_13', [0.75, 762.5]],
        ['6_41_14', [0.75, 285]],
        ['6_41_15', [1.5, 394]],
        ['6_41_16', [1.5, 581.5]],
        ['6_41_17', [1.5, 581.5]],
        ['6_41_18', [80.5, 618.75]],
        ['6_41_19', [80.5, 678.75]],
        ['6_41_20', [9.75, 1119.5]],
        ['6_41_21', [1.75, 902]],
        ['6_41_22', [0.25, 524.5]],
        ['6_41_23', [0.25, 1126.5]],
        ['6_41_24', [0.25, 5013.5]],
        ['6_41_25', [0.5, 5013.5]],
        ['6_41_26', [0.75, 4135]],
        ['6_41_27', [0.25, 2911.25]],
        ['6_41_28', [1.5, 2728.5]],
        ['6_41_29', [1, 1945]],
        ['6_41_3', [0, 17.700000762939453]],
        ['6_41_30', [0.25, 1945]],
        ['6_41_31', [0.5, 739]],
        ['6_41_32', [0.5, 442.75]],
        ['6_41_33', [1.5, 1155.5]],
        ['6_41_34', [0.75, 2136.25]],
        ['6_41_35', [0.25, 2419.75]],
        ['6_41_36', [0.5, 2419.75]],
        ['6_41_37', [3, 221.5]],
        ['6_41_38', [3, 221.5]],
        ['6_41_39', [8.5, 81.625]],
        ['6_41_4', [0, 341]],
        ['6_41_40', [8.5, 146.5]],
        ['6_41_41', [8.5, 784]],
        ['6_41_45', [0, 358.5]],
        ['6_41_46', [0, 358.5]],
        ['6_41_47', [0, 2222.5]],
        ['6_41_48', [0.75, 2660.5]],
        ['6_41_49', [586, 2981]],
        ['6_41_5', [0, 518.5]],
        ['6_41_50', [2250, 3168.5]],
        ['6_41_51', [2173.5, 3753.5]],
        ['6_41_52', [2173.5, 3753.5]],
        ['6_41_53', [2376.5, 3753.5]],
        ['6_41_54', [2934.5, 3790]],
        ['6_41_55', [2934.5, 3790]],
        ['6_41_56', [2934.5, 3790]],
        ['6_41_57', [3209.5, 3693]],
        ['6_41_58', [3209.5, 3693]],
        ['6_41_59', [3209.5, 3693]],
        ['6_41_6', [0.25, 555.5]],
        ['6_41_60', [3076.5, 3760]],
        ['6_41_61', [3076.5, 3760]],
        ['6_41_62', [3076.5, 3760]],
        ['6_41_63', [3049, 3498]],
        ['6_41_64', [3049, 3498]],
        ['6_41_65', [3049, 3498]],
        ['6_41_66', [2921, 3316]],
        ['6_41_67', [2921, 3316]],
        ['6_41_68', [2921, 3316]],
        ['6_41_69', [2866.5, 3125]],
        ['6_41_7', [0.25, 555.5]],
        ['6_41_70', [2866.5, 3125]],
        ['6_41_71', [2866.5, 3125]],
        ['6_41_72', [2864, 3078]],
        ['6_41_73', [2864, 3078]],
        ['6_41_74', [2864, 3078]],
        ['6_41_8', [0.5, 183.75]],
        ['6_41_9', [0, 15.25]],
        ['6_42_10', [0.5, 1209.25]],
        ['6_42_11', [0.5, 1209.25]],
        ['6_42_12', [0.25, 1033]],
        ['6_42_13', [0.5, 571]],
        ['6_42_14', [0.5, 392.5]],
        ['6_42_15', [0.25, 980.75]],
        ['6_42_16', [2, 1595.5]],
        ['6_42_17', [2, 1343.5]],
        ['6_42_18', [20.25, 1377.25]],
        ['6_42_19', [49, 1377.25]],
        ['6_42_20', [49, 1466.75]],
        ['6_42_21', [19.5, 902]],
        ['6_42_22', [2, 538.25]],
        ['6_42_23', [1, 669.75]],
        ['6_42_24', [0.25, 3143.25]],
        ['6_42_25', [1.5, 3298.5]],
        ['6_42_26', [0.25, 4135]],
        ['6_42_27', [0.25, 3030]],
        ['6_42_28', [0.25, 2728.5]],
        ['6_42_29', [0.5, 1626.75]],
        ['6_42_3', [1, 25.5]],
        ['6_42_30', [1, 146.625]],
        ['6_42_31', [1, 146.625]],
        ['6_42_32', [1, 442.75]],
        ['6_42_33', [1.5, 442.75]],
        ['6_42_34', [1.5, 47.65833282470703]],
        ['6_42_35', [1.5, 2419.75]],
        ['6_42_36', [0.5, 2419.75]],
        ['6_42_37', [3, 113.25]],
        ['6_42_38', [3, 113.25]],
        ['6_42_39', [0, 39.67499923706055]],
        ['6_42_4', [0.25, 440]],
        ['6_42_40', [0, 39.67499923706055]],
        ['6_42_41', [0, 163.25]],
        ['6_42_42', [1, 112.5]],
        ['6_42_43', [16.5, 98.75]],
        ['6_42_44', [16.5, 98.75]],
        ['6_42_45', [12.25, 484]],
        ['6_42_46', [12.25, 484]],
        ['6_42_47', [9, 2166]],
        ['6_42_48', [1, 2774.5]],
        ['6_42_49', [693.5, 2974.5]],
        ['6_42_5', [0.25, 568.5]],
        ['6_42_50', [1117.5, 2974.5]],
        ['6_42_51', [960, 3350.75]],
        ['6_42_52', [1282.5, 3350.75]],
        ['6_42_53', [1646, 3350.75]],
        ['6_42_54', [2390, 4058.5]],
        ['6_42_55', [2400, 4058.5]],
        ['6_42_56', [2722.5, 4058.5]],
        ['6_42_57', [3603, 3903.5]],
        ['6_42_58', [3603, 3903.5]],
        ['6_42_59', [3603, 3903.5]],
        ['6_42_6', [0.5, 574]],
        ['6_42_60', [3387, 3924]],
        ['6_42_61', [3387, 3924]],
        ['6_42_62', [3387, 3924]],
        ['6_42_63', [3222, 3538]],
        ['6_42_64', [3222, 3538]],
        ['6_42_65', [3222, 3538]],
        ['6_42_66', [3094, 3327]],
        ['6_42_67', [3094, 3327]],
        ['6_42_68', [3094, 3327]],
        ['6_42_69', [3054, 3124]],
        ['6_42_7', [1, 324]],
        ['6_42_70', [3054, 3124]],
        ['6_42_71', [3054, 3124]],
        ['6_42_72', [3036, 3114]],
        ['6_42_73', [3036, 3114]],
        ['6_42_74', [3036, 3114]],
        ['6_42_8', [1, 274]],
        ['6_42_9', [1, 18]],
        ['6_43_10', [0.5, 922.5]],
        ['6_43_11', [0.5, 922.5]],
        ['6_43_12', [0.5, 238.75]],
        ['6_43_13', [0.5, 238.75]],
        ['6_43_14', [0.5, 954.5]],
        ['6_43_15', [0.25, 1210.5]],
        ['6_43_16', [1.25, 1411]],
        ['6_43_17', [2, 780.25]],
        ['6_43_18', [20.25, 277]],
        ['6_43_19', [49, 642.25]],
        ['6_43_20', [49, 642.25]],
        ['6_43_21', [19.5, 938.25]],
        ['6_43_22', [19.5, 1245]],
        ['6_43_23', [19.5, 1957.75]],
        ['6_43_24', [0.25, 4837]],
        ['6_43_25', [131, 4646.5]],
        ['6_43_26', [3, 3964.5]],
        ['6_43_27', [0.25, 2550.5]],
        ['6_43_28', [0.25, 194.25]],
        ['6_43_29', [0.5, 194.25]],
        ['6_43_3', [1, 5.5]],
        ['6_43_30', [1, 46.5]],
        ['6_43_31', [1, 46.5]],
        ['6_43_32', [1, 146.625]],
        ['6_43_33', [2.5, 47.65833282470703]],
        ['6_43_34', [2.5, 9.25]],
        ['6_43_35', [2.5, 18.25]],
        ['6_43_36', [3, 31]],
        ['6_43_37', [3, 31]],
        ['6_43_38', [3, 31]],
        ['6_43_39', [0, 39.67499923706055]],
        ['6_43_4', [1, 17.5]],
        ['6_43_40', [0, 39.67499923706055]],
        ['6_43_41', [0, 1102]],
        ['6_43_42', [0.5, 1102]],
        ['6_43_43', [16.5, 98.75]],
        ['6_43_44', [16.5, 98.75]],
        ['6_43_45', [13.5, 39.5]],
        ['6_43_46', [13.5, 39.5]],
        ['6_43_47', [13.5, 39.5]],
        ['6_43_48', [1.5, 2774.5]],
        ['6_43_49', [32.75, 2893.5]],
        ['6_43_5', [0.25, 444.5]],
        ['6_43_50', [59.5, 2893.5]],
        ['6_43_51', [83, 3028]],
        ['6_43_52', [533, 2943.5]],
        ['6_43_53', [1576, 3350.75]],
        ['6_43_54', [2390, 4058.5]],
        ['6_43_55', [2400, 4058.5]],
        ['6_43_56', [2722.5, 4058.5]],
        ['6_43_57', [3603, 3903.5]],
        ['6_43_58', [3603, 3903.5]],
        ['6_43_59', [3603, 3903.5]],
        ['6_43_6', [0.5, 574]],
        ['6_43_60', [3387, 3924]],
        ['6_43_61', [3387, 3924]],
        ['6_43_62', [3387, 3924]],
        ['6_43_63', [3222, 3538]],
        ['6_43_64', [3222, 3538]],
        ['6_43_65', [3222, 3538]],
        ['6_43_66', [3094, 3327]],
        ['6_43_67', [3094, 3327]],
        ['6_43_68', [3094, 3327]],
        ['6_43_69', [3054, 3124]],
        ['6_43_7', [1, 324]],
        ['6_43_70', [3054, 3124]],
        ['6_43_71', [3054, 3124]],
        ['6_43_72', [3036, 3114]],
        ['6_43_73', [3036, 3114]],
        ['6_43_74', [3036, 3114]],
        ['6_43_8', [1, 3.657407522201538]],
        ['6_43_9', [0.5, 820]],
        ['6_44_10', [0.5, 820]],
        ['6_44_11', [0.5, 7]],
        ['6_44_12', [0.5, 46.75]],
        ['6_44_13', [0.5, 46.75]],
        ['6_44_14', [0.5, 954.5]],
        ['6_44_15', [1, 1112.5]],
        ['6_44_16', [7.5, 957.75]],
        ['6_44_17', [15.75, 85]],
        ['6_44_18', [20.5, 339]],
        ['6_44_19', [49, 481.5]],
        ['6_44_20', [49, 768]],
        ['6_44_21', [67, 1096.5]],
        ['6_44_22', [67, 1245]],
        ['6_44_23', [67, 4566.75]],
        ['6_44_24', [177.25, 7227.25]],
        ['6_44_25', [152, 7227.25]],
        ['6_44_26', [3, 3964.5]],
        ['6_44_27', [0.25, 2212]],
        ['6_44_28', [0.25, 1325.75]],
        ['6_44_29', [0.5, 1325.75]],
        ['6_44_3', [1.0416666269302368, 5.5]],
        ['6_44_30', [1, 46.5]],
        ['6_44_31', [1, 46.5]],
        ['6_44_32', [1, 146.625]],
        ['6_44_33', [2.5, 47.65833282470703]],
        ['6_44_34', [2.5, 9.25]],
        ['6_44_35', [2.5, 18.25]],
        ['6_44_36', [3, 31]],
        ['6_44_37', [3, 31]],
        ['6_44_38', [3, 31]],
        ['6_44_39', [0, 50.25]],
        ['6_44_4', [1.0416666269302368, 5.5]],
        ['6_44_40', [0, 50.25]],
        ['6_44_41', [0, 1142.5]],
        ['6_44_42', [0.25, 2333.25]],
        ['6_44_43', [4, 2333.25]],
        ['6_44_44', [8.25, 407]],
        ['6_44_45', [13.5, 39.5]],
        ['6_44_46', [13.5, 39.5]],
        ['6_44_47', [13.5, 39.5]],
        ['6_44_48', [3.75, 1783.5]],
        ['6_44_49', [1.25, 2269]],
        ['6_44_5', [1.0416666269302368, 25]],
        ['6_44_50', [42.5, 2269]],
        ['6_44_51', [83, 2943.5]],
        ['6_44_52', [533, 2943.5]],
        ['6_44_53', [1576, 3350.75]],
        ['6_44_54', [2390, 4058.5]],
        ['6_44_55', [2400, 4058.5]],
        ['6_44_56', [2722.5, 4058.5]],
        ['6_44_57', [3603, 3903.5]],
        ['6_44_58', [3603, 3903.5]],
        ['6_44_59', [3603, 3903.5]],
        ['6_44_6', [0.5, 337]],
        ['6_44_60', [3387, 3924]],
        ['6_44_61', [3387, 3924]],
        ['6_44_62', [3387, 3924]],
        ['6_44_63', [3222, 3538]],
        ['6_44_64', [3222, 3538]],
        ['6_44_65', [3222, 3538]],
        ['6_44_66', [3094, 3327]],
        ['6_44_67', [3094, 3327]],
        ['6_44_68', [3094, 3327]],
        ['6_44_69', [3054, 3124]],
        ['6_44_7', [1, 3.657407522201538]],
        ['6_44_70', [3054, 3124]],
        ['6_44_71', [3054, 3124]],
        ['6_44_72', [3036, 3114]],
        ['6_44_73', [3036, 3114]],
        ['6_44_74', [3036, 3114]],
        ['6_44_8', [1, 3.657407522201538]],
        ['6_44_9', [0.5, 820]],
        ['6_45_10', [0.5, 10]],
        ['6_45_11', [0.5, 211.5]],
        ['6_45_12', [0.25, 188.5]],
        ['6_45_13', [0.25, 49.75]],
        ['6_45_14', [0.5, 49.75]],
        ['6_45_15', [1, 95.5]],
        ['6_45_16', [1, 249.5]],
        ['6_45_17', [1, 249.5]],
        ['6_45_18', [24, 352.5]],
        ['6_45_19', [37, 352.5]],
        ['6_45_20', [37, 669.5]],
        ['6_45_21', [82, 1386]],
        ['6_45_22', [202.75, 4000.75]],
        ['6_45_23', [313.5, 7040.75]],
        ['6_45_24', [378.75, 7513.25]],
        ['6_45_25', [100.25, 7694.25]],
        ['6_45_26', [100.25, 6792]],
        ['6_45_27', [1.5, 1376.75]],
        ['6_45_28', [0.75, 1325.75]],
        ['6_45_29', [0.75, 2431.25]],
        ['6_45_3', [0, 323]],
        ['6_45_30', [0.25, 2431.25]],
        ['6_45_31', [0.25, 642.25]],
        ['6_45_32', [0.5, 20]],
        ['6_45_33', [0.5, 4.75]],
        ['6_45_34', [0.5, 4.75]],
        ['6_45_35', [0.5, 4.75]],
        ['6_45_36', [16.5, 316.5694580078125]],
        ['6_45_37', [16.5, 316.5694580078125]],
        ['6_45_38', [16.5, 316.5694580078125]],
        ['6_45_39', [8.25, 619.5]],
        ['6_45_4', [0, 323]],
        ['6_45_40', [8.25, 61.66666793823242]],
        ['6_45_41', [8.25, 61.66666793823242]],
        ['6_45_42', [1, 2333.25]],
        ['6_45_43', [1, 2333.25]],
        ['6_45_44', [1, 407]],
        ['6_45_45', [0, 60.25]],
        ['6_45_46', [0, 60.25]],
        ['6_45_47', [0, 60.25]],
        ['6_45_48', [0.25, 1957]],
        ['6_45_49', [0.25, 3474.5]],
        ['6_45_5', [0, 323]],
        ['6_45_50', [40, 3474.5]],
        ['6_45_51', [94, 3395.5]],
        ['6_45_52', [1448.25, 3395.5]],
        ['6_45_53', [1448.25, 3718.75]],
        ['6_45_54', [2431.5, 3711.5]],
        ['6_45_55', [2431.5, 3935]],
        ['6_45_56', [2431.5, 3935]],
        ['6_45_57', [3524, 4077]],
        ['6_45_58', [3524, 4077]],
        ['6_45_59', [3524, 4077]],
        ['6_45_6', [1, 323]],
        ['6_45_60', [3342, 3919.5]],
        ['6_45_61', [3342, 3919.5]],
        ['6_45_62', [3342, 3919.5]],
        ['6_45_63', [3195, 3552]],
        ['6_45_64', [3195, 3552]],
        ['6_45_65', [3195, 3552]],
        ['6_45_66', [3101, 3336]],
        ['6_45_67', [3101, 3336]],
        ['6_45_68', [3101, 3336]],
        ['6_45_69', [3105, 3129]],
        ['6_45_7', [1, 323]],
        ['6_45_70', [3105, 3129]],
        ['6_45_71', [3105, 3129]],
        ['6_45_72', [3099.5, 3122]],
        ['6_45_73', [3099.5, 3122]],
        ['6_45_74', [3099.5, 3122]],
        ['6_45_8', [1, 323]],
        ['6_45_9', [0.5, 10]],
        ['6_46_10', [0.5, 10]],
        ['6_46_11', [0.5, 211.5]],
        ['6_46_12', [0.25, 433.5]],
        ['6_46_13', [0.25, 400.5]],
        ['6_46_14', [0.5, 140]],
        ['6_46_15', [1, 99]],
        ['6_46_16', [1, 249.5]],
        ['6_46_17', [1, 249.5]],
        ['6_46_18', [24, 236]],
        ['6_46_19', [37, 471.75]],
        ['6_46_20', [37, 1351.25]],
        ['6_46_21', [119.75, 2945.25]],
        ['6_46_22', [192.5, 4258.5]],
        ['6_46_23', [192.5, 7040.75]],
        ['6_46_24', [878, 7040.75]],
        ['6_46_25', [939.5, 6792]],
        ['6_46_26', [16, 7367.5]],
        ['6_46_27', [6.75, 6264.25]],
        ['6_46_28', [1, 1387.75]],
        ['6_46_29', [1, 2375.5]],
        ['6_46_3', [0, 323]],
        ['6_46_30', [0.25, 2362.5]],
        ['6_46_31', [0.25, 2237.25]],
        ['6_46_32', [0.5, 131.75]],
        ['6_46_33', [0.5, 4.75]],
        ['6_46_34', [0.5, 4.75]],
        ['6_46_35', [0.5, 4.75]],
        ['6_46_36', [16.5, 316.5694580078125]],
        ['6_46_37', [16.5, 316.5694580078125]],
        ['6_46_38', [16.5, 316.5694580078125]],
        ['6_46_39', [8.25, 619.5]],
        ['6_46_4', [0, 323]],
        ['6_46_40', [8.25, 61.66666793823242]],
        ['6_46_41', [8.25, 61.66666793823242]],
        ['6_46_42', [1, 40.75]],
        ['6_46_43', [1, 40.75]],
        ['6_46_44', [1, 40.75]],
        ['6_46_45', [0, 60.25]],
        ['6_46_46', [0, 60.25]],
        ['6_46_47', [0, 542.25]],
        ['6_46_48', [0.25, 2347.25]],
        ['6_46_49', [0.25, 3474.5]],
        ['6_46_5', [0, 323]],
        ['6_46_50', [1032.25, 3474.5]],
        ['6_46_51', [1393.5, 3718.75]],
        ['6_46_52', [1448.25, 3718.75]],
        ['6_46_53', [2287, 3718.75]],
        ['6_46_54', [2431.5, 3735]],
        ['6_46_55', [2431.5, 3935]],
        ['6_46_56', [2431.5, 3935]],
        ['6_46_57', [3524, 4077]],
        ['6_46_58', [3524, 4077]],
        ['6_46_59', [3524, 4077]],
        ['6_46_6', [1, 323]],
        ['6_46_60', [3342, 3919.5]],
        ['6_46_61', [3342, 3919.5]],
        ['6_46_62', [3342, 3919.5]],
        ['6_46_63', [3195, 3552]],
        ['6_46_64', [3195, 3552]],
        ['6_46_65', [3195, 3552]],
        ['6_46_66', [3101, 3336]],
        ['6_46_67', [3101, 3336]],
        ['6_46_68', [3101, 3336]],
        ['6_46_69', [3105, 3129]],
        ['6_46_7', [1, 323]],
        ['6_46_70', [3105, 3129]],
        ['6_46_71', [3105, 3129]],
        ['6_46_72', [3099.5, 3122]],
        ['6_46_73', [3099.5, 3122]],
        ['6_46_74', [3099.5, 3122]],
        ['6_46_8', [1, 323]],
        ['6_46_9', [0.5, 10]],
        ['6_47_10', [0.5, 401.5]],
        ['6_47_11', [0.5, 433.5]],
        ['6_47_12', [0.25, 433.5]],
        ['6_47_13', [1, 818.25]],
        ['6_47_14', [1, 1153]],
        ['6_47_15', [1, 1062.5]],
        ['6_47_16', [1, 833.25]],
        ['6_47_17', [1, 833.25]],
        ['6_47_18', [24, 716.25]],
        ['6_47_19', [37, 1247.5]],
        ['6_47_20', [37, 2649.25]],
        ['6_47_21', [119.75, 3995]],
        ['6_47_22', [194, 4258.5]],
        ['6_47_23', [3, 4702]],
        ['6_47_24', [720.5, 6395]],
        ['6_47_25', [996, 6395]],
        ['6_47_26', [16, 8023.25]],
        ['6_47_27', [0.75, 8023.25]],
        ['6_47_28', [0.75, 1384.25]],
        ['6_47_29', [1, 365.5]],
        ['6_47_3', [0, 323]],
        ['6_47_30', [0.5, 131.75]],
        ['6_47_31', [0.5, 131.75]],
        ['6_47_32', [0.5, 131.75]],
        ['6_47_33', [0.5, 4.75]],
        ['6_47_34', [0.5, 4.75]],
        ['6_47_35', [0.5, 4.75]],
        ['6_47_36', [16.5, 316.5694580078125]],
        ['6_47_37', [16.5, 316.5694580078125]],
        ['6_47_38', [16.5, 316.5694580078125]],
        ['6_47_39', [8.25, 254]],
        ['6_47_4', [0, 323]],
        ['6_47_40', [8.25, 61.66666793823242]],
        ['6_47_41', [8.25, 61.66666793823242]],
        ['6_47_42', [1, 40.75]],
        ['6_47_43', [1, 40.75]],
        ['6_47_44', [1, 40.75]],
        ['6_47_45', [0, 337.5]],
        ['6_47_46', [0, 337.5]],
        ['6_47_47', [0, 1348.5]],
        ['6_47_48', [0.5, 2529.5]],
        ['6_47_49', [499.5, 3474.5]],
        ['6_47_5', [0, 323]],
        ['6_47_50', [1957, 3474.5]],
        ['6_47_51', [2532, 3718.75]],
        ['6_47_52', [2481, 3718.75]],
        ['6_47_53', [2481, 3718.75]],
        ['6_47_54', [2431.5, 3735]],
        ['6_47_55', [2431.5, 3927]],
        ['6_47_56', [2431.5, 3935]],
        ['6_47_57', [3524, 4077]],
        ['6_47_58', [3524, 4077]],
        ['6_47_59', [3524, 4077]],
        ['6_47_6', [1, 323]],
        ['6_47_60', [3342, 3919.5]],
        ['6_47_61', [3342, 3919.5]],
        ['6_47_62', [3342, 3919.5]],
        ['6_47_63', [3195, 3552]],
        ['6_47_64', [3195, 3552]],
        ['6_47_65', [3195, 3552]],
        ['6_47_66', [3101, 3336]],
        ['6_47_67', [3101, 3336]],
        ['6_47_68', [3101, 3336]],
        ['6_47_69', [3105, 3129]],
        ['6_47_7', [1, 323]],
        ['6_47_70', [3105, 3129]],
        ['6_47_71', [3105, 3129]],
        ['6_47_72', [3099.5, 3122]],
        ['6_47_73', [3099.5, 3122]],
        ['6_47_74', [3099.5, 3122]],
        ['6_47_8', [1, 323]],
        ['6_47_9', [0.5, 401.5]],
        ['6_48_10', [0.5, 482.5]],
        ['6_48_11', [0.5, 637]],
        ['6_48_12', [7.5, 617.5]],
        ['6_48_13', [7.5, 899.75]],
        ['6_48_14', [7.5, 1625.5]],
        ['6_48_15', [10, 1625.5]],
        ['6_48_16', [10, 1079.5]],
        ['6_48_17', [10.5, 889.5]],
        ['6_48_18', [25, 1024]],
        ['6_48_19', [70.75, 1247.5]],
        ['6_48_20', [70.75, 2649.25]],
        ['6_48_21', [282, 3978.75]],
        ['6_48_22', [290.75, 3999.75]],
        ['6_48_23', [2.5, 4425.25]],
        ['6_48_24', [348.5, 6395]],
        ['6_48_25', [2676.5, 6395]],
        ['6_48_26', [22.75, 6960]],
        ['6_48_27', [0.25, 6901.75]],
        ['6_48_28', [0.25, 2746]],
        ['6_48_29', [0.25, 1008.75]],
        ['6_48_3', [0.5, 323]],
        ['6_48_30', [0.25, 2547.25]],
        ['6_48_31', [1, 2547.25]],
        ['6_48_32', [1, 20]],
        ['6_48_33', [2.5, 43.75]],
        ['6_48_34', [2.5, 43.75]],
        ['6_48_35', [2.5, 43.75]],
        ['6_48_4', [0.5, 323]],
        ['6_48_45', [5, 56.125]],
        ['6_48_46', [5, 56.125]],
        ['6_48_47', [1.25, 1481.5]],
        ['6_48_48', [1.25, 3286.75]],
        ['6_48_49', [1022.25, 3286.75]],
        ['6_48_5', [0.5, 647]],
        ['6_48_50', [2076, 3286.75]],
        ['6_48_51', [2767, 3589]],
        ['6_48_52', [2767, 3589]],
        ['6_48_53', [2767, 3589]],
        ['6_48_54', [3326.5, 3850.5]],
        ['6_48_55', [3326.5, 3850.5]],
        ['6_48_56', [3326.5, 3850.5]],
        ['6_48_57', [3239, 3815]],
        ['6_48_58', [3239, 3815]],
        ['6_48_59', [3239, 3815]],
        ['6_48_6', [1, 779]],
        ['6_48_60', [3145, 3692]],
        ['6_48_61', [3145, 3692]],
        ['6_48_62', [3145, 3692]],
        ['6_48_63', [3129, 3452]],
        ['6_48_64', [3129, 3452]],
        ['6_48_65', [3129, 3452]],
        ['6_48_66', [3095, 3268.5]],
        ['6_48_67', [3095, 3268.5]],
        ['6_48_68', [3095, 3268.5]],
        ['6_48_69', [3113, 3126]],
        ['6_48_7', [1, 779]],
        ['6_48_70', [3113, 3126]],
        ['6_48_71', [3113, 3126]],
        ['6_48_72', [3096, 3127]],
        ['6_48_73', [3096, 3127]],
        ['6_48_74', [3096, 3127]],
        ['6_48_8', [1, 739]],
        ['6_48_9', [0.5, 55.75]],
        ['6_49_10', [0.5, 481]],
        ['6_49_11', [0.5, 714.25]],
        ['6_49_12', [5, 687.5]],
        ['6_49_13', [12.25, 929]],
        ['6_49_14', [12.25, 1625.5]],
        ['6_49_15', [126.5, 1625.5]],
        ['6_49_16', [78, 1079.5]],
        ['6_49_17', [78, 889.5]],
        ['6_49_18', [80, 801]],
        ['6_49_19', [80, 1188.5]],
        ['6_49_20', [160.25, 3082]],
        ['6_49_21', [473.5, 3134.75]],
        ['6_49_22', [290.75, 3778]],
        ['6_49_23', [290.75, 4425.25]],
        ['6_49_24', [782.5, 5726]],
        ['6_49_25', [1333.5, 6060.75]],
        ['6_49_26', [99, 6960]],
        ['6_49_27', [48, 5108]],
        ['6_49_28', [0.25, 2420.25]],
        ['6_49_29', [0.25, 1851.5]],
        ['6_49_3', [1.326923131942749, 323]],
        ['6_49_30', [0.25, 2825.75]],
        ['6_49_31', [0.5, 3104.75]],
        ['6_49_32', [1, 2923.25]],
        ['6_49_33', [2.5, 126.5]],
        ['6_49_34', [2.5, 43.75]],
        ['6_49_35', [2.5, 43.75]],
        ['6_49_4', [1.326923131942749, 323]],
        ['6_49_45', [5, 56.125]],
        ['6_49_46', [5, 56.125]],
        ['6_49_47', [3, 1901.5]],
        ['6_49_48', [3, 3286.75]],
        ['6_49_49', [1388, 3286.75]],
        ['6_49_5', [1.326923131942749, 647]],
        ['6_49_50', [2026, 3286.75]],
        ['6_49_51', [2767, 3589]],
        ['6_49_52', [2767, 3589]],
        ['6_49_53', [2767, 3589]],
        ['6_49_54', [3326.5, 3850.5]],
        ['6_49_55', [3326.5, 3850.5]],
        ['6_49_56', [3326.5, 3850.5]],
        ['6_49_57', [3239, 3815]],
        ['6_49_58', [3239, 3815]],
        ['6_49_59', [3239, 3815]],
        ['6_49_6', [1, 779]],
        ['6_49_60', [3145, 3692]],
        ['6_49_61', [3145, 3692]],
        ['6_49_62', [3145, 3692]],
        ['6_49_63', [3129, 3452]],
        ['6_49_64', [3129, 3452]],
        ['6_49_65', [3129, 3452]],
        ['6_49_66', [3095, 3268.5]],
        ['6_49_67', [3095, 3268.5]],
        ['6_49_68', [3095, 3268.5]],
        ['6_49_69', [3113, 3126]],
        ['6_49_7', [0.75, 962]],
        ['6_49_70', [3113, 3126]],
        ['6_49_71', [3113, 3126]],
        ['6_49_72', [3096, 3127]],
        ['6_49_73', [3096, 3127]],
        ['6_49_74', [3096, 3127]],
        ['6_49_8', [0.5, 831.5]],
        ['6_49_9', [0.5, 756]],
        ['6_4_12', [0.5, 40]],
        ['6_4_13', [0.5, 40]],
        ['6_4_14', [0.5, 1998.5]],
        ['6_4_15', [15.5, 2042]],
        ['6_4_16', [15.5, 1401]],
        ['6_4_17', [1, 5845]],
        ['6_4_18', [0.25, 3244.5]],
        ['6_4_19', [0.25, 2077]],
        ['6_4_20', [0.25, 998.5]],
        ['6_4_27', [0.75, 2796.75]],
        ['6_4_28', [0.75, 4069.5]],
        ['6_4_29', [3.5, 154.75]],
        ['6_4_30', [15.25, 22]],
        ['6_4_31', [15.25, 22]],
        ['6_4_32', [15.25, 22]],
        ['6_4_33', [0.75, 66.22916412353516]],
        ['6_4_34', [0.75, 414.75]],
        ['6_4_35', [0.75, 414.75]],
        ['6_4_36', [6.5, 51]],
        ['6_4_37', [6.5, 51]],
        ['6_4_38', [6.5, 51]],
        ['6_4_51', [1.5, 29]],
        ['6_4_52', [1.5, 29]],
        ['6_4_53', [0.5, 375]],
        ['6_4_54', [1, 1072.5]],
        ['6_4_55', [18.5, 1072.5]],
        ['6_4_56', [27, 975.5]],
        ['6_4_57', [48, 665]],
        ['6_4_58', [48, 665]],
        ['6_4_59', [57, 665]],
        ['6_4_60', [64, 278]],
        ['6_4_61', [64, 278]],
        ['6_4_62', [64, 278]],
        ['6_4_63', [92, 373]],
        ['6_4_64', [92, 1253.5]],
        ['6_4_65', [92, 2981.5]],
        ['6_4_66', [739.5, 3764]],
        ['6_4_67', [1132, 3764]],
        ['6_4_68', [1469.5, 2861]],
        ['6_4_69', [1987, 3030]],
        ['6_4_70', [1987, 3030]],
        ['6_4_71', [2381.5, 3030]],
        ['6_4_72', [2762, 3160]],
        ['6_4_73', [2762, 3160]],
        ['6_4_74', [2762, 3160]],
        ['6_50_10', [1, 1080.5]],
        ['6_50_11', [1, 1080.5]],
        ['6_50_12', [5, 547.5]],
        ['6_50_13', [5, 857]],
        ['6_50_14', [15, 1232.5]],
        ['6_50_15', [153.5, 1229.5]],
        ['6_50_16', [135.5, 939.25]],
        ['6_50_17', [135.5, 877]],
        ['6_50_18', [139.25, 871.5]],
        ['6_50_19', [139.25, 1469.5]],
        ['6_50_20', [253.5, 3061.5]],
        ['6_50_21', [393.5, 3058.25]],
        ['6_50_22', [628, 3778]],
        ['6_50_23', [738.25, 3778]],
        ['6_50_24', [755.5, 4850]],
        ['6_50_25', [223, 5471.25]],
        ['6_50_26', [148, 6327.75]],
        ['6_50_27', [0.25, 5057]],
        ['6_50_28', [0.25, 2711.75]],
        ['6_50_29', [0.25, 2417.5]],
        ['6_50_3', [1.326923131942749, 3.75]],
        ['6_50_30', [0.25, 1929.75]],
        ['6_50_31', [0.25, 2461.75]],
        ['6_50_32', [0.25, 2923.25]],
        ['6_50_33', [0.5, 2595.75]],
        ['6_50_34', [0.75, 43.75]],
        ['6_50_35', [2.5, 43.75]],
        ['6_50_4', [1.326923131942749, 3.75]],
        ['6_50_45', [5.25, 115]],
        ['6_50_46', [5.25, 115]],
        ['6_50_47', [2, 1922]],
        ['6_50_48', [2.75, 3286.75]],
        ['6_50_49', [1294.5, 3286.75]],
        ['6_50_5', [1.326923131942749, 3.75]],
        ['6_50_50', [2026, 3286.75]],
        ['6_50_51', [2767, 3589]],
        ['6_50_52', [2767, 3589]],
        ['6_50_53', [2767, 3589]],
        ['6_50_54', [3326.5, 3850.5]],
        ['6_50_55', [3326.5, 3850.5]],
        ['6_50_56', [3326.5, 3850.5]],
        ['6_50_57', [3239, 3815]],
        ['6_50_58', [3239, 3815]],
        ['6_50_59', [3239, 3815]],
        ['6_50_6', [1, 380]],
        ['6_50_60', [3145, 3692]],
        ['6_50_61', [3145, 3692]],
        ['6_50_62', [3145, 3692]],
        ['6_50_63', [3129, 3452]],
        ['6_50_64', [3129, 3452]],
        ['6_50_65', [3129, 3452]],
        ['6_50_66', [3095, 3268.5]],
        ['6_50_67', [3095, 3268.5]],
        ['6_50_68', [3095, 3268.5]],
        ['6_50_69', [3113, 3126]],
        ['6_50_7', [0.75, 726.5]],
        ['6_50_70', [3113, 3126]],
        ['6_50_71', [3113, 3126]],
        ['6_50_72', [3096, 3127]],
        ['6_50_73', [3096, 3127]],
        ['6_50_74', [3096, 3127]],
        ['6_50_8', [0.5, 860]],
        ['6_50_9', [1, 756]],
        ['6_51_10', [0.5, 1080.5]],
        ['6_51_11', [0.75, 1080.5]],
        ['6_51_12', [0.375, 547.5]],
        ['6_51_13', [1.5, 888.5]],
        ['6_51_14', [21, 888.5]],
        ['6_51_15', [92, 934.5]],
        ['6_51_16', [113.5, 934.5]],
        ['6_51_17', [99, 751]],
        ['6_51_18', [153, 1306.5]],
        ['6_51_19', [174.25, 2337.5]],
        ['6_51_20', [312.5, 2440.75]],
        ['6_51_21', [449, 2553]],
        ['6_51_22', [621.5, 2553]],
        ['6_51_23', [696.5, 2241]],
        ['6_51_24', [66.25, 3259.25]],
        ['6_51_25', [26.25, 3479.75]],
        ['6_51_26', [26.25, 2859.5]],
        ['6_51_27', [0.25, 2158]],
        ['6_51_28', [0.25, 2018]],
        ['6_51_29', [0.25, 2417.5]],
        ['6_51_30', [0.25, 2099]],
        ['6_51_31', [0.25, 1774]],
        ['6_51_32', [0.5, 2536]],
        ['6_51_33', [0.5, 3245.5]],
        ['6_51_34', [1, 41.75]],
        ['6_51_35', [1, 290.25]],
        ['6_51_36', [1, 387.25]],
        ['6_51_37', [1, 387.25]],
        ['6_51_38', [1, 347.75]],
        ['6_51_39', [0.5, 37.75]],
        ['6_51_40', [0.5, 37.75]],
        ['6_51_41', [0.5, 37.75]],
        ['6_51_45', [0.5, 40.81666564941406]],
        ['6_51_46', [0.5, 40.81666564941406]],
        ['6_51_47', [0.5, 1877]],
        ['6_51_48', [0.25, 3084.75]],
        ['6_51_49', [743.25, 3167]],
        ['6_51_50', [2125, 3167]],
        ['6_51_51', [2953.5, 3522]],
        ['6_51_52', [2953.5, 3522]],
        ['6_51_53', [2953.5, 3522]],
        ['6_51_54', [2879, 3516.5]],
        ['6_51_55', [2879, 3516.5]],
        ['6_51_56', [2879, 3516.5]],
        ['6_51_57', [2857, 3469]],
        ['6_51_58', [2857, 3469]],
        ['6_51_59', [2857, 3469]],
        ['6_51_6', [0.25, 9.5]],
        ['6_51_60', [2829, 3372]],
        ['6_51_61', [2829, 3372]],
        ['6_51_62', [2829, 3372]],
        ['6_51_63', [2884, 3248]],
        ['6_51_64', [2884, 3248]],
        ['6_51_65', [2884, 3248]],
        ['6_51_66', [2975, 3150]],
        ['6_51_67', [2975, 3150]],
        ['6_51_68', [2975, 3150]],
        ['6_51_69', [3053, 3126]],
        ['6_51_7', [0.25, 9.5]],
        ['6_51_70', [3053, 3126]],
        ['6_51_71', [3053, 3126]],
        ['6_51_72', [3079, 3128]],
        ['6_51_73', [3079, 3128]],
        ['6_51_74', [3079, 3128]],
        ['6_51_8', [0.25, 135.5]],
        ['6_51_9', [0.5, 367.5]],
        ['6_52_10', [0.5, 917.5]],
        ['6_52_11', [0.75, 917.5]],
        ['6_52_12', [0.375, 393.25]],
        ['6_52_13', [2, 682]],
        ['6_52_14', [21, 682]],
        ['6_52_15', [60.5, 762]],
        ['6_52_16', [60.5, 762]],
        ['6_52_17', [99, 723.5]],
        ['6_52_18', [124, 1736]],
        ['6_52_19', [138.75, 2611.25]],
        ['6_52_20', [380.75, 2346.5]],
        ['6_52_21', [384, 2398.25]],
        ['6_52_22', [503.25, 2398.25]],
        ['6_52_23', [2, 2617.5]],
        ['6_52_24', [1, 2852.25]],
        ['6_52_25', [1, 2331.25]],
        ['6_52_26', [1, 1977.5]],
        ['6_52_27', [0.25, 1977.5]],
        ['6_52_28', [0.25, 1432.75]],
        ['6_52_29', [0.25, 1068.25]],
        ['6_52_30', [0.25, 3587]],
        ['6_52_31', [0.25, 3587]],
        ['6_52_32', [0.25, 2665.5]],
        ['6_52_33', [0.25, 3245.5]],
        ['6_52_34', [0.25, 385]],
        ['6_52_35', [0.25, 1089.5]],
        ['6_52_36', [1, 1089.5]],
        ['6_52_37', [1, 616.25]],
        ['6_52_38', [1, 743]],
        ['6_52_39', [0.5, 37.75]],
        ['6_52_40', [0.5, 37.75]],
        ['6_52_41', [0.5, 37.75]],
        ['6_52_45', [0.5, 40.81666564941406]],
        ['6_52_46', [0.5, 40.81666564941406]],
        ['6_52_47', [0.5, 1381.75]],
        ['6_52_48', [0.75, 2431]],
        ['6_52_49', [389, 3167]],
        ['6_52_50', [2125, 3167]],
        ['6_52_51', [2953.5, 3522]],
        ['6_52_52', [2953.5, 3522]],
        ['6_52_53', [2953.5, 3522]],
        ['6_52_54', [2879, 3516.5]],
        ['6_52_55', [2879, 3516.5]],
        ['6_52_56', [2879, 3516.5]],
        ['6_52_57', [2857, 3469]],
        ['6_52_58', [2857, 3469]],
        ['6_52_59', [2857, 3469]],
        ['6_52_6', [0.25, 9.5]],
        ['6_52_60', [2829, 3372]],
        ['6_52_61', [2829, 3372]],
        ['6_52_62', [2829, 3372]],
        ['6_52_63', [2884, 3248]],
        ['6_52_64', [2884, 3248]],
        ['6_52_65', [2884, 3248]],
        ['6_52_66', [2975, 3150]],
        ['6_52_67', [2975, 3150]],
        ['6_52_68', [2975, 3150]],
        ['6_52_69', [3053, 3126]],
        ['6_52_7', [0.25, 9.5]],
        ['6_52_70', [3053, 3126]],
        ['6_52_71', [3053, 3126]],
        ['6_52_72', [3079, 3128]],
        ['6_52_73', [3079, 3128]],
        ['6_52_74', [3079, 3128]],
        ['6_52_8', [0.25, 135.5]],
        ['6_52_9', [0.5, 288.5]],
        ['6_53_10', [1, 288.5]],
        ['6_53_11', [1, 57.5]],
        ['6_53_12', [0.375, 442.5]],
        ['6_53_13', [0.375, 479]],
        ['6_53_14', [12, 479]],
        ['6_53_15', [20.75, 567]],
        ['6_53_16', [20.75, 513]],
        ['6_53_17', [25.25, 518]],
        ['6_53_18', [94, 1736]],
        ['6_53_19', [138.75, 2611.25]],
        ['6_53_20', [209.75, 2248.5]],
        ['6_53_21', [143, 1382.25]],
        ['6_53_22', [68.75, 1774.75]],
        ['6_53_23', [1.25, 1948.75]],
        ['6_53_24', [0.25, 1728.75]],
        ['6_53_25', [0.25, 1141.25]],
        ['6_53_26', [0.25, 1977.5]],
        ['6_53_27', [0.25, 3514.25]],
        ['6_53_28', [0.25, 3025.75]],
        ['6_53_29', [0.25, 2676.5]],
        ['6_53_30', [0.25, 2561.75]],
        ['6_53_31', [0.25, 2457.5]],
        ['6_53_32', [0.25, 3037.25]],
        ['6_53_33', [0.25, 2511.25]],
        ['6_53_34', [0.25, 1120]],
        ['6_53_35', [0.25, 1089.5]],
        ['6_53_36', [5.25, 1089.5]],
        ['6_53_37', [0.75, 616.25]],
        ['6_53_38', [0.75, 743]],
        ['6_53_39', [0.5, 37.75]],
        ['6_53_40', [0.5, 37.75]],
        ['6_53_41', [0.5, 37.75]],
        ['6_53_45', [0.5, 40.81666564941406]],
        ['6_53_46', [0.5, 40.81666564941406]],
        ['6_53_47', [0.5, 1308.5]],
        ['6_53_48', [0.75, 2520.75]],
        ['6_53_49', [389, 3167]],
        ['6_53_50', [2125, 3167]],
        ['6_53_51', [2953.5, 3522]],
        ['6_53_52', [2953.5, 3522]],
        ['6_53_53', [2953.5, 3522]],
        ['6_53_54', [2879, 3516.5]],
        ['6_53_55', [2879, 3516.5]],
        ['6_53_56', [2879, 3516.5]],
        ['6_53_57', [2857, 3469]],
        ['6_53_58', [2857, 3469]],
        ['6_53_59', [2857, 3469]],
        ['6_53_6', [0.25, 9.5]],
        ['6_53_60', [2829, 3372]],
        ['6_53_61', [2829, 3372]],
        ['6_53_62', [2829, 3372]],
        ['6_53_63', [2884, 3248]],
        ['6_53_64', [2884, 3248]],
        ['6_53_65', [2884, 3248]],
        ['6_53_66', [2975, 3150]],
        ['6_53_67', [2975, 3150]],
        ['6_53_68', [2975, 3150]],
        ['6_53_69', [3053, 3126]],
        ['6_53_7', [0.25, 9.5]],
        ['6_53_70', [3053, 3126]],
        ['6_53_71', [3053, 3126]],
        ['6_53_72', [3079, 3128]],
        ['6_53_73', [3079, 3128]],
        ['6_53_74', [3079, 3128]],
        ['6_53_8', [0.25, 135.5]],
        ['6_53_9', [1, 288.5]],
        ['6_54_10', [0.375, 31.5]],
        ['6_54_11', [0.375, 31.5]],
        ['6_54_12', [0.5, 441]],
        ['6_54_13', [0.5, 1054.75]],
        ['6_54_14', [0.5, 2053]],
        ['6_54_15', [21, 2139]],
        ['6_54_16', [21, 1865.5]],
        ['6_54_17', [23, 1708.5]],
        ['6_54_18', [84, 1828]],
        ['6_54_19', [182, 2054.75]],
        ['6_54_20', [146.25, 2054.75]],
        ['6_54_21', [69.25, 1373.5]],
        ['6_54_22', [69.25, 1572.25]],
        ['6_54_23', [1, 2477.25]],
        ['6_54_24', [0.75, 2477.25]],
        ['6_54_25', [0.25, 1716]],
        ['6_54_26', [0.25, 1604.25]],
        ['6_54_27', [0.25, 503.25]],
        ['6_54_28', [0.25, 858.5]],
        ['6_54_29', [0.25, 1964.25]],
        ['6_54_30', [0.25, 2561.75]],
        ['6_54_31', [0.25, 2465]],
        ['6_54_32', [0.25, 2531.5]],
        ['6_54_33', [0.25, 2456.75]],
        ['6_54_34', [0.25, 1120]],
        ['6_54_35', [1, 867]],
        ['6_54_36', [10, 1128.25]],
        ['6_54_37', [0.75, 1128.25]],
        ['6_54_38', [0.75, 346]],
        ['6_54_39', [3.5, 285.75]],
        ['6_54_40', [3.5, 285.75]],
        ['6_54_41', [3.5, 285.75]],
        ['6_54_45', [3.25, 69.28571319580078]],
        ['6_54_46', [3.25, 69.28571319580078]],
        ['6_54_47', [1, 1677.5]],
        ['6_54_48', [1, 3164]],
        ['6_54_49', [1382.75, 3164]],
        ['6_54_50', [2183.75, 3164]],
        ['6_54_51', [2246, 3185]],
        ['6_54_52', [2246, 3185]],
        ['6_54_53', [2246, 3185]],
        ['6_54_54', [2258, 3206.5]],
        ['6_54_55', [2258, 3206.5]],
        ['6_54_56', [2258, 3206.5]],
        ['6_54_57', [2350, 3026.5]],
        ['6_54_58', [2350, 3026.5]],
        ['6_54_59', [2350, 3026.5]],
        ['6_54_60', [2341, 2981.5]],
        ['6_54_61', [2341, 2981.5]],
        ['6_54_62', [2341, 2981.5]],
        ['6_54_63', [2637.5, 3071]],
        ['6_54_64', [2637.5, 3071]],
        ['6_54_65', [2637.5, 3071]],
        ['6_54_66', [2875, 3088]],
        ['6_54_67', [2875, 3088]],
        ['6_54_68', [2875, 3088]],
        ['6_54_69', [2980, 3100]],
        ['6_54_70', [2980, 3100]],
        ['6_54_71', [2980, 3100]],
        ['6_54_72', [3076, 3133]],
        ['6_54_73', [3076, 3133]],
        ['6_54_74', [3076, 3133]],
        ['6_54_9', [0.375, 31.5]],
        ['6_55_10', [0.375, 31.5]],
        ['6_55_11', [0.375, 31.5]],
        ['6_55_12', [0.5, 441]],
        ['6_55_13', [0.5, 1054.75]],
        ['6_55_14', [0.5, 2053]],
        ['6_55_15', [52, 2139]],
        ['6_55_16', [24.5, 1984]],
        ['6_55_17', [24.5, 1984]],
        ['6_55_18', [84, 1828]],
        ['6_55_19', [1.5, 2054.75]],
        ['6_55_20', [1.5, 2054.75]],
        ['6_55_21', [18.25, 1980]],
        ['6_55_22', [5.5, 1572.25]],
        ['6_55_23', [1, 2477.25]],
        ['6_55_24', [1.25, 2477.25]],
        ['6_55_25', [0.25, 1589.75]],
        ['6_55_26', [0.25, 1604.25]],
        ['6_55_27', [0.25, 503.25]],
        ['6_55_28', [4.75, 71.5]],
        ['6_55_29', [4.75, 71.5]],
        ['6_55_30', [0.25, 474.5]],
        ['6_55_31', [0.5, 2602.25]],
        ['6_55_32', [0.25, 3480.25]],
        ['6_55_33', [1, 2744.5]],
        ['6_55_34', [1, 779.75]],
        ['6_55_35', [1, 967.25]],
        ['6_55_36', [0.25, 1170.5]],
        ['6_55_37', [0.25, 1159.25]],
        ['6_55_38', [0.25, 374.25]],
        ['6_55_39', [1.75, 285.75]],
        ['6_55_40', [3.5, 285.75]],
        ['6_55_41', [3.5, 285.75]],
        ['6_55_45', [3.25, 69.28571319580078]],
        ['6_55_46', [3.25, 69.28571319580078]],
        ['6_55_47', [0.5, 1677.5]],
        ['6_55_48', [1, 3164]],
        ['6_55_49', [1092.5, 3164]],
        ['6_55_50', [2167.5, 3164]],
        ['6_55_51', [2246, 3185]],
        ['6_55_52', [2246, 3185]],
        ['6_55_53', [2246, 3185]],
        ['6_55_54', [2258, 3206.5]],
        ['6_55_55', [2258, 3206.5]],
        ['6_55_56', [2258, 3206.5]],
        ['6_55_57', [2350, 3026.5]],
        ['6_55_58', [2350, 3026.5]],
        ['6_55_59', [2350, 3026.5]],
        ['6_55_60', [2341, 2981.5]],
        ['6_55_61', [2341, 2981.5]],
        ['6_55_62', [2341, 2981.5]],
        ['6_55_63', [2637.5, 3071]],
        ['6_55_64', [2637.5, 3071]],
        ['6_55_65', [2637.5, 3071]],
        ['6_55_66', [2875, 3088]],
        ['6_55_67', [2875, 3088]],
        ['6_55_68', [2875, 3088]],
        ['6_55_69', [2980, 3100]],
        ['6_55_70', [2980, 3100]],
        ['6_55_71', [2980, 3100]],
        ['6_55_72', [3076, 3133]],
        ['6_55_73', [3076, 3133]],
        ['6_55_74', [3076, 3133]],
        ['6_55_9', [0.375, 31.5]],
        ['6_56_10', [0.375, 31.5]],
        ['6_56_11', [0.375, 31.5]],
        ['6_56_12', [0.5, 159.5]],
        ['6_56_13', [0.5, 871.5]],
        ['6_56_14', [0.5, 1837.75]],
        ['6_56_15', [52, 2340.5]],
        ['6_56_16', [58, 2344]],
        ['6_56_17', [58, 2776]],
        ['6_56_18', [0.5, 2579.5]],
        ['6_56_19', [0.5, 1884.75]],
        ['6_56_20', [0.25, 2040.5]],
        ['6_56_21', [1, 1980]],
        ['6_56_22', [0.75, 1836.5]],
        ['6_56_23', [0.25, 1498.5]],
        ['6_56_24', [0.25, 2768.5]],
        ['6_56_25', [0.25, 3226.5]],
        ['6_56_26', [0.75, 428.5]],
        ['6_56_27', [0.5, 71.5]],
        ['6_56_28', [4.75, 71.5]],
        ['6_56_29', [4.75, 71.5]],
        ['6_56_30', [0.25, 474.5]],
        ['6_56_31', [0.75, 2602.25]],
        ['6_56_32', [0.25, 4445.5]],
        ['6_56_33', [1.5, 4289.25]],
        ['6_56_34', [2.25, 585.5]],
        ['6_56_35', [12, 967.25]],
        ['6_56_36', [0.25, 988]],
        ['6_56_37', [0.25, 910.75]],
        ['6_56_38', [0.25, 910.75]],
        ['6_56_39', [0.5, 543.75]],
        ['6_56_40', [0.5, 285.75]],
        ['6_56_41', [0.5, 285.75]],
        ['6_56_45', [3.25, 69.28571319580078]],
        ['6_56_46', [3.25, 69.28571319580078]],
        ['6_56_47', [0.25, 1490.5]],
        ['6_56_48', [3.25, 2662.5]],
        ['6_56_49', [768, 3164]],
        ['6_56_50', [1822, 3164]],
        ['6_56_51', [2246, 3185]],
        ['6_56_52', [2246, 3185]],
        ['6_56_53', [2246, 3185]],
        ['6_56_54', [2258, 3206.5]],
        ['6_56_55', [2258, 3206.5]],
        ['6_56_56', [2258, 3206.5]],
        ['6_56_57', [2350, 3026.5]],
        ['6_56_58', [2350, 3026.5]],
        ['6_56_59', [2350, 3026.5]],
        ['6_56_60', [2341, 2981.5]],
        ['6_56_61', [2341, 2981.5]],
        ['6_56_62', [2341, 2981.5]],
        ['6_56_63', [2637.5, 3071]],
        ['6_56_64', [2637.5, 3071]],
        ['6_56_65', [2637.5, 3071]],
        ['6_56_66', [2875, 3088]],
        ['6_56_67', [2875, 3088]],
        ['6_56_68', [2875, 3088]],
        ['6_56_69', [2980, 3100]],
        ['6_56_70', [2980, 3100]],
        ['6_56_71', [2980, 3100]],
        ['6_56_72', [3076, 3133]],
        ['6_56_73', [3076, 3133]],
        ['6_56_74', [3076, 3133]],
        ['6_56_9', [0.375, 31.5]],
        ['6_57_10', [1, 11.5]],
        ['6_57_11', [2.2604167461395264, 11.5]],
        ['6_57_12', [0.3333333432674408, 350.5]],
        ['6_57_13', [0.3333333432674408, 377.5]],
        ['6_57_14', [0.3333333432674408, 1837.75]],
        ['6_57_15', [16, 2340.5]],
        ['6_57_16', [88, 2632]],
        ['6_57_17', [418, 2776]],
        ['6_57_18', [0.75, 2577.75]],
        ['6_57_19', [0.75, 1379.5]],
        ['6_57_20', [0.25, 939.5]],
        ['6_57_21', [0.5, 1325]],
        ['6_57_22', [0.5, 1380]],
        ['6_57_23', [0.25, 2042.25]],
        ['6_57_24', [0.25, 2143.5]],
        ['6_57_25', [1.75, 2143.5]],
        ['6_57_26', [3.75, 428.5]],
        ['6_57_27', [3.625, 677.5]],
        ['6_57_28', [0.5, 677.5]],
        ['6_57_29', [0.5, 677.5]],
        ['6_57_30', [2.5, 401.5]],
        ['6_57_31', [1.75, 401.5]],
        ['6_57_32', [0.25, 4218.25]],
        ['6_57_33', [0.25, 4218.25]],
        ['6_57_34', [0.25, 1344.75]],
        ['6_57_35', [0.25, 1344.75]],
        ['6_57_36', [0.5, 1002.25]],
        ['6_57_37', [0.25, 920]],
        ['6_57_38', [1, 1792.75]],
        ['6_57_39', [0.75, 1792.75]],
        ['6_57_40', [0.5, 1468.25]],
        ['6_57_41', [1.25, 322.75]],
        ['6_57_42', [0, 235.75]],
        ['6_57_43', [0, 235.75]],
        ['6_57_44', [0, 235.75]],
        ['6_57_45', [1, 416.75]],
        ['6_57_46', [1, 416.75]],
        ['6_57_47', [1, 1469]],
        ['6_57_48', [0.5, 2675.75]],
        ['6_57_49', [3, 2675.75]],
        ['6_57_50', [1138.5, 2675.75]],
        ['6_57_51', [1908, 2644.5]],
        ['6_57_52', [1908, 2644.5]],
        ['6_57_53', [2182.25, 2644.5]],
        ['6_57_54', [2308, 2729.5]],
        ['6_57_55', [2184, 2729.5]],
        ['6_57_56', [1855.5, 2729.5]],
        ['6_57_57', [1494, 2528.5]],
        ['6_57_58', [1494, 2528.5]],
        ['6_57_59', [2138.5, 2528.5]],
        ['6_57_60', [2205, 2735]],
        ['6_57_61', [2312.5, 2735]],
        ['6_57_62', [2466, 2735]],
        ['6_57_63', [2389.5, 2934]],
        ['6_57_64', [2389.5, 2934]],
        ['6_57_65', [2389.5, 2934]],
        ['6_57_66', [2610.5, 3025]],
        ['6_57_67', [2610.5, 3025]],
        ['6_57_68', [2610.5, 3025]],
        ['6_57_69', [2973, 3101]],
        ['6_57_70', [2973, 3101]],
        ['6_57_71', [2973, 3101]],
        ['6_57_72', [3081, 3126]],
        ['6_57_73', [3081, 3126]],
        ['6_57_74', [3081, 3126]],
        ['6_57_9', [1, 11.5]],
        ['6_58_10', [1, 326.5]],
        ['6_58_11', [1, 11.5]],
        ['6_58_12', [0.3333333432674408, 17.5]],
        ['6_58_13', [0.3333333432674408, 431.5]],
        ['6_58_14', [0.3333333432674408, 634.5]],
        ['6_58_15', [11.5, 2139.5]],
        ['6_58_16', [11.5, 2632]],
        ['6_58_17', [82.5, 2255.75]],
        ['6_58_18', [0.5, 2072.25]],
        ['6_58_19', [0.5, 1336]],
        ['6_58_20', [2, 246.75]],
        ['6_58_21', [1, 878.25]],
        ['6_58_22', [0.5, 1380]],
        ['6_58_23', [0.5, 1380]],
        ['6_58_24', [13.25, 181.5]],
        ['6_58_25', [13.25, 227.75]],
        ['6_58_26', [13.25, 227.75]],
        ['6_58_27', [3.625, 677.5]],
        ['6_58_28', [0.5, 677.5]],
        ['6_58_29', [0.5, 677.5]],
        ['6_58_30', [2.5, 401.5]],
        ['6_58_31', [1.75, 401.5]],
        ['6_58_32', [0.25, 3926.5]],
        ['6_58_33', [0.25, 3926.5]],
        ['6_58_34', [0.5, 3098.25]],
        ['6_58_35', [0.5, 1344.75]],
        ['6_58_36', [0.75, 1178]],
        ['6_58_37', [0.75, 1527]],
        ['6_58_38', [0.5, 2048]],
        ['6_58_39', [0.5, 2048]],
        ['6_58_40', [0.25, 1468.25]],
        ['6_58_41', [1.25, 290.75]],
        ['6_58_42', [0, 235.75]],
        ['6_58_43', [0, 235.75]],
        ['6_58_44', [0, 235.75]],
        ['6_58_45', [1, 70.5]],
        ['6_58_46', [1, 70.5]],
        ['6_58_47', [1, 146.75]],
        ['6_58_48', [3, 1874]],
        ['6_58_49', [3, 2675.75]],
        ['6_58_50', [750.25, 2675.75]],
        ['6_58_51', [1761, 2644.5]],
        ['6_58_52', [1761, 2644.5]],
        ['6_58_53', [1761, 2644.5]],
        ['6_58_54', [1785.75, 2729.5]],
        ['6_58_55', [1785.75, 2729.5]],
        ['6_58_56', [1363.75, 2729.5]],
        ['6_58_57', [752, 2451.5]],
        ['6_58_58', [752, 2528.5]],
        ['6_58_59', [1494, 2528.5]],
        ['6_58_60', [1830, 2735]],
        ['6_58_61', [2016.5, 2735]],
        ['6_58_62', [2109.5, 2735]],
        ['6_58_63', [2389.5, 2934]],
        ['6_58_64', [2389.5, 2934]],
        ['6_58_65', [2389.5, 2934]],
        ['6_58_66', [2610.5, 3025]],
        ['6_58_67', [2610.5, 3025]],
        ['6_58_68', [2610.5, 3025]],
        ['6_58_69', [2973, 3101]],
        ['6_58_70', [2973, 3101]],
        ['6_58_71', [2973, 3101]],
        ['6_58_72', [3081, 3126]],
        ['6_58_73', [3081, 3126]],
        ['6_58_74', [3081, 3126]],
        ['6_58_9', [1, 326.5]],
        ['6_59_10', [1, 9]],
        ['6_59_11', [1, 9]],
        ['6_59_12', [0.3333333432674408, 22.25]],
        ['6_59_13', [0.3333333432674408, 431.5]],
        ['6_59_14', [0.3333333432674408, 576]],
        ['6_59_15', [2, 988.5]],
        ['6_59_16', [11.5, 1595]],
        ['6_59_17', [1, 1876.5]],
        ['6_59_18', [0.25, 1869.5]],
        ['6_59_19', [0.25, 3241.75]],
        ['6_59_20', [1, 3241.75]],
        ['6_59_21', [0.25, 2999.25]],
        ['6_59_22', [0.75, 1089.5]],
        ['6_59_23', [1, 166.5]],
        ['6_59_24', [13.25, 181.5]],
        ['6_59_25', [13.25, 227.75]],
        ['6_59_26', [13.25, 227.75]],
        ['6_59_27', [3.625, 438.25]],
        ['6_59_28', [0.5, 438.25]],
        ['6_59_29', [0.5, 438.25]],
        ['6_59_30', [3.5, 504.5]],
        ['6_59_31', [3.5, 504.5]],
        ['6_59_32', [0.25, 2441]],
        ['6_59_33', [0.5, 2441]],
        ['6_59_34', [0.5, 919.75]],
        ['6_59_35', [0.5, 409.25]],
        ['6_59_36', [0.75, 1113.5]],
        ['6_59_37', [0.75, 1527]],
        ['6_59_38', [0.75, 1527]],
        ['6_59_39', [1.25, 254.5]],
        ['6_59_40', [1.25, 290.75]],
        ['6_59_41', [1.25, 290.75]],
        ['6_59_42', [0, 235.75]],
        ['6_59_43', [0, 235.75]],
        ['6_59_44', [0, 235.75]],
        ['6_59_45', [1, 70.5]],
        ['6_59_46', [1, 70.5]],
        ['6_59_47', [1, 146.75]],
        ['6_59_48', [1.75, 1670]],
        ['6_59_49', [1.75, 2675.75]],
        ['6_59_50', [750.25, 2675.75]],
        ['6_59_51', [1009.5, 2644.5]],
        ['6_59_52', [1009.5, 2644.5]],
        ['6_59_53', [1009.5, 2644.5]],
        ['6_59_54', [1309.25, 2729.5]],
        ['6_59_55', [673.5, 2729.5]],
        ['6_59_56', [110.5, 2833.5]],
        ['6_59_57', [108, 2828]],
        ['6_59_58', [277.5, 2641]],
        ['6_59_59', [930, 2410.5]],
        ['6_59_60', [1021, 2499]],
        ['6_59_61', [1550, 2735]],
        ['6_59_62', [2023, 2735]],
        ['6_59_63', [2389.5, 2934]],
        ['6_59_64', [2389.5, 2934]],
        ['6_59_65', [2389.5, 2934]],
        ['6_59_66', [2610.5, 3025]],
        ['6_59_67', [2610.5, 3025]],
        ['6_59_68', [2610.5, 3025]],
        ['6_59_69', [2973, 3101]],
        ['6_59_70', [2973, 3101]],
        ['6_59_71', [2973, 3101]],
        ['6_59_72', [3081, 3126]],
        ['6_59_73', [3081, 3126]],
        ['6_59_74', [3081, 3126]],
        ['6_59_9', [1, 9]],
        ['6_5_12', [0.5, 41.75]],
        ['6_5_13', [0.5, 41.75]],
        ['6_5_14', [0.5, 2289]],
        ['6_5_15', [43.5, 2222.5]],
        ['6_5_16', [50, 3828.5]],
        ['6_5_17', [0.75, 5845]],
        ['6_5_18', [0.25, 3754]],
        ['6_5_19', [0.25, 1389.75]],
        ['6_5_20', [5.25, 202.5]],
        ['6_5_27', [1, 183.5]],
        ['6_5_28', [1, 183.5]],
        ['6_5_29', [3.5, 154.75]],
        ['6_5_30', [15.25, 22]],
        ['6_5_31', [15.25, 22]],
        ['6_5_32', [15.25, 22]],
        ['6_5_33', [0.75, 80.75]],
        ['6_5_34', [0.5, 1145.5]],
        ['6_5_35', [0.5, 1145.5]],
        ['6_5_36', [6.5, 51]],
        ['6_5_37', [6.5, 51]],
        ['6_5_38', [6.5, 51]],
        ['6_5_51', [1.5, 29]],
        ['6_5_52', [1.5, 387.5]],
        ['6_5_53', [0.5, 1051.5]],
        ['6_5_54', [1, 1152.5]],
        ['6_5_55', [64.5, 1152.5]],
        ['6_5_56', [64, 1105]],
        ['6_5_57', [65, 665]],
        ['6_5_58', [57, 665]],
        ['6_5_59', [57, 665]],
        ['6_5_60', [64, 278]],
        ['6_5_61', [64, 278]],
        ['6_5_62', [64, 278]],
        ['6_5_63', [92, 373]],
        ['6_5_64', [92, 1315.5]],
        ['6_5_65', [92, 2715]],
        ['6_5_66', [754.5, 2800.5]],
        ['6_5_67', [1132, 3077.5]],
        ['6_5_68', [1469.5, 3077.5]],
        ['6_5_69', [1987, 2849]],
        ['6_5_70', [1987, 3030]],
        ['6_5_71', [2450, 3030]],
        ['6_5_72', [2762, 3160]],
        ['6_5_73', [2762, 3160]],
        ['6_5_74', [2762, 3160]],
        ['6_60_12', [1, 400.25]],
        ['6_60_13', [1, 400.25]],
        ['6_60_14', [1, 893.25]],
        ['6_60_15', [1.5, 1534.5]],
        ['6_60_16', [45, 1595]],
        ['6_60_17', [1, 1645]],
        ['6_60_18', [0.5, 2099.25]],
        ['6_60_19', [0.5, 4371.5]],
        ['6_60_20', [0.25, 4371.5]],
        ['6_60_21', [0.5, 2999.25]],
        ['6_60_22', [1.75, 166.5]],
        ['6_60_23', [1.75, 166.5]],
        ['6_60_27', [0, 0.75]],
        ['6_60_28', [0, 0.75]],
        ['6_60_29', [0, 0.75]],
        ['6_60_30', [1, 504.5]],
        ['6_60_31', [1, 504.5]],
        ['6_60_32', [1, 637.25]],
        ['6_60_33', [0.25, 1939]],
        ['6_60_34', [0.25, 1411.75]],
        ['6_60_35', [1, 718]],
        ['6_60_36', [1.25, 718]],
        ['6_60_37', [4, 60.75]],
        ['6_60_38', [4, 101]],
        ['6_60_39', [0.5, 192]],
        ['6_60_40', [0.5, 192]],
        ['6_60_41', [0.5, 192]],
        ['6_60_42', [1.25, 126.02603912353516]],
        ['6_60_43', [2.75, 126.02603912353516]],
        ['6_60_44', [2.75, 126.02603912353516]],
        ['6_60_45', [2.5, 10.625]],
        ['6_60_46', [2.5, 10.625]],
        ['6_60_47', [2.5, 10.625]],
        ['6_60_48', [2, 745.75]],
        ['6_60_49', [2, 2324.5]],
        ['6_60_50', [2, 2560.5]],
        ['6_60_51', [119, 3471.5]],
        ['6_60_52', [0.5, 3471.5]],
        ['6_60_53', [0.5, 2378]],
        ['6_60_54', [0.75, 3087]],
        ['6_60_55', [0.75, 3087]],
        ['6_60_56', [35.5, 2833.5]],
        ['6_60_57', [30, 2833.5]],
        ['6_60_58', [4, 2657.5]],
        ['6_60_59', [4, 3254]],
        ['6_60_60', [87.5, 3234]],
        ['6_60_61', [1022, 2977]],
        ['6_60_62', [1380, 3032]],
        ['6_60_63', [1602.5, 2909.5]],
        ['6_60_64', [1602.5, 2861]],
        ['6_60_65', [2153, 2861]],
        ['6_60_66', [2397, 3052]],
        ['6_60_67', [2397, 3052]],
        ['6_60_68', [2397, 3052]],
        ['6_60_69', [2961.5, 3111]],
        ['6_60_70', [2961.5, 3111]],
        ['6_60_71', [2961.5, 3111]],
        ['6_60_72', [3077, 3146]],
        ['6_60_73', [3077, 3146]],
        ['6_60_74', [3077, 3146]],
        ['6_61_12', [1, 400.25]],
        ['6_61_13', [1, 400.25]],
        ['6_61_14', [0.75, 1464.75]],
        ['6_61_15', [0.5, 1534.5]],
        ['6_61_16', [1.5, 1581]],
        ['6_61_17', [1, 1553]],
        ['6_61_18', [1, 1553]],
        ['6_61_19', [0.5, 1528.5]],
        ['6_61_20', [0.5, 1133.25]],
        ['6_61_21', [1.5, 221]],
        ['6_61_22', [1.75, 166.5]],
        ['6_61_23', [1.75, 166.5]],
        ['6_61_27', [0, 0.75]],
        ['6_61_28', [0, 0.75]],
        ['6_61_29', [0, 0.75]],
        ['6_61_30', [1, 111.5]],
        ['6_61_31', [1, 111.5]],
        ['6_61_32', [1, 13.75]],
        ['6_61_33', [0.25, 784.75]],
        ['6_61_34', [0.25, 1420.25]],
        ['6_61_35', [1, 1420.25]],
        ['6_61_36', [1, 1160.75]],
        ['6_61_37', [4, 60.75]],
        ['6_61_38', [4, 101]],
        ['6_61_39', [0.5, 1064.5]],
        ['6_61_40', [0.5, 2786.25]],
        ['6_61_41', [0.5, 2207.75]],
        ['6_61_42', [1.25, 504]],
        ['6_61_43', [1.25, 126.02603912353516]],
        ['6_61_44', [1.25, 126.02603912353516]],
        ['6_61_45', [2.5, 10.625]],
        ['6_61_46', [2.5, 10.625]],
        ['6_61_47', [2.5, 10.625]],
        ['6_61_48', [2, 96.75]],
        ['6_61_49', [1, 2103.5]],
        ['6_61_50', [1, 3235.25]],
        ['6_61_51', [0.25, 3471.5]],
        ['6_61_52', [0.25, 3471.5]],
        ['6_61_53', [0.25, 1574]],
        ['6_61_54', [0.5, 3087]],
        ['6_61_55', [0.75, 3087]],
        ['6_61_56', [37, 662]],
        ['6_61_57', [30, 324]],
        ['6_61_58', [4, 1459]],
        ['6_61_59', [4, 3254]],
        ['6_61_60', [18, 3265.5]],
        ['6_61_61', [18, 3898]],
        ['6_61_62', [462.5, 3898]],
        ['6_61_63', [887, 3003.5]],
        ['6_61_64', [1602.5, 2941.5]],
        ['6_61_65', [1985, 2941.5]],
        ['6_61_66', [2397, 3052]],
        ['6_61_67', [2397, 3052]],
        ['6_61_68', [2397, 3052]],
        ['6_61_69', [2961.5, 3111]],
        ['6_61_70', [2961.5, 3111]],
        ['6_61_71', [2961.5, 3111]],
        ['6_61_72', [3077, 3146]],
        ['6_61_73', [3077, 3146]],
        ['6_61_74', [3077, 3146]],
        ['6_62_12', [0.5, 323.25]],
        ['6_62_13', [0.5, 323.25]],
        ['6_62_14', [0.5, 1464.75]],
        ['6_62_15', [0.5, 1482]],
        ['6_62_16', [1, 1482]],
        ['6_62_17', [0.5, 2189.5]],
        ['6_62_18', [0.25, 2189.5]],
        ['6_62_19', [1, 385.75]],
        ['6_62_20', [1, 682.5]],
        ['6_62_21', [1, 682.5]],
        ['6_62_22', [1, 377.5]],
        ['6_62_23', [1, 377.5]],
        ['6_62_27', [0, 0.75]],
        ['6_62_28', [0, 0.75]],
        ['6_62_29', [0, 0.75]],
        ['6_62_30', [1, 111.5]],
        ['6_62_31', [1, 111.5]],
        ['6_62_32', [1, 13.75]],
        ['6_62_33', [0.25, 430.25]],
        ['6_62_34', [0.25, 1420.25]],
        ['6_62_35', [1.25, 1420.25]],
        ['6_62_36', [1.25, 128.25]],
        ['6_62_37', [1.25, 60.75]],
        ['6_62_38', [0.25, 741.25]],
        ['6_62_39', [0.25, 2486.25]],
        ['6_62_40', [0.25, 2786.25]],
        ['6_62_41', [0.5, 2207.75]],
        ['6_62_42', [1.25, 126.02603912353516]],
        ['6_62_43', [1.25, 126.02603912353516]],
        ['6_62_44', [1.25, 126.02603912353516]],
        ['6_62_45', [2.5, 10.625]],
        ['6_62_46', [2.5, 10.625]],
        ['6_62_47', [2.5, 10.625]],
        ['6_62_48', [2, 96.75]],
        ['6_62_49', [2, 1140]],
        ['6_62_50', [0.5, 3235.25]],
        ['6_62_51', [0.25, 2854]],
        ['6_62_52', [0.25, 469.5]],
        ['6_62_53', [0.25, 123.16666412353516]],
        ['6_62_54', [0.5, 2506]],
        ['6_62_55', [3, 647]],
        ['6_62_56', [28.797618865966797, 60]],
        ['6_62_57', [30, 324]],
        ['6_62_58', [30, 218.75]],
        ['6_62_59', [30, 569]],
        ['6_62_60', [18, 1935]],
        ['6_62_61', [18, 3898]],
        ['6_62_62', [52.75, 3898]],
        ['6_62_63', [887, 3716.5]],
        ['6_62_64', [1456, 3307.5]],
        ['6_62_65', [1985, 2961]],
        ['6_62_66', [2397, 3052]],
        ['6_62_67', [2397, 3052]],
        ['6_62_68', [2397, 3052]],
        ['6_62_69', [2961.5, 3111]],
        ['6_62_70', [2961.5, 3111]],
        ['6_62_71', [2961.5, 3111]],
        ['6_62_72', [3077, 3146]],
        ['6_62_73', [3077, 3146]],
        ['6_62_74', [3077, 3146]],
        ['6_63_12', [2, 15]],
        ['6_63_13', [0.5, 555.5]],
        ['6_63_14', [0.5, 1455]],
        ['6_63_15', [2.5, 1591]],
        ['6_63_16', [1, 1154.75]],
        ['6_63_17', [0.25, 1253]],
        ['6_63_18', [1, 865]],
        ['6_63_19', [1.5, 619.25]],
        ['6_63_20', [1.5, 880]],
        ['6_63_21', [0.5, 880]],
        ['6_63_22', [0.5, 356.5]],
        ['6_63_23', [0.5, 356.5]],
        ['6_63_30', [0.25, 3.5]],
        ['6_63_31', [0.25, 3.5]],
        ['6_63_32', [0.25, 3.5]],
        ['6_63_33', [1, 6.5]],
        ['6_63_34', [0.25, 1163.75]],
        ['6_63_35', [0.25, 1163.75]],
        ['6_63_36', [1.25, 95.33333587646484]],
        ['6_63_37', [1.25, 95.33333587646484]],
        ['6_63_38', [0.25, 762.5]],
        ['6_63_39', [0.25, 2486.25]],
        ['6_63_40', [0.25, 2444.75]],
        ['6_63_41', [0.75, 83.25]],
        ['6_63_42', [60.375, 82.125]],
        ['6_63_43', [60.375, 82.125]],
        ['6_63_44', [60.375, 82.125]],
        ['6_63_54', [47.39285659790039, 52]],
        ['6_63_55', [47.39285659790039, 52]],
        ['6_63_56', [47.39285659790039, 52]],
        ['6_63_57', [51, 68]],
        ['6_63_58', [51, 68]],
        ['6_63_59', [51, 68]],
        ['6_63_60', [55, 115]],
        ['6_63_61', [55, 1797]],
        ['6_63_62', [61, 3426.5]],
        ['6_63_63', [104, 3436.5]],
        ['6_63_64', [1235.5, 3407.5]],
        ['6_63_65', [2274.5, 2961]],
        ['6_63_66', [2486.5, 3052]],
        ['6_63_67', [2486.5, 3052]],
        ['6_63_68', [2486.5, 3052]],
        ['6_63_69', [2997, 3110]],
        ['6_63_70', [2997, 3110]],
        ['6_63_71', [2997, 3110]],
        ['6_63_72', [3076, 3154]],
        ['6_63_73', [3076, 3154]],
        ['6_63_74', [3076, 3154]],
        ['6_6_12', [1, 77.5]],
        ['6_6_13', [1, 77.5]],
        ['6_6_14', [1, 2378.5]],
        ['6_6_15', [22, 2378.5]],
        ['6_6_16', [97, 3828.5]],
        ['6_6_17', [1, 4821.5]],
        ['6_6_18', [1, 5797.5]],
        ['6_6_19', [1.75, 307.75]],
        ['6_6_20', [2.25, 307.75]],
        ['6_6_21', [0.5, 164.25]],
        ['6_6_22', [0.5, 40.5]],
        ['6_6_23', [0.5, 40.5]],
        ['6_6_30', [0, 80.8499984741211]],
        ['6_6_31', [0, 80.8499984741211]],
        ['6_6_32', [0, 80.8499984741211]],
        ['6_6_33', [1.5, 916.5]],
        ['6_6_34', [1.5, 287.75]],
        ['6_6_35', [1.5, 287.75]],
        ['6_6_36', [22.25, 99]],
        ['6_6_37', [22.25, 99]],
        ['6_6_38', [22.25, 99]],
        ['6_6_51', [3.25, 64]],
        ['6_6_52', [3.25, 1315.5]],
        ['6_6_53', [3.25, 1862.5]],
        ['6_6_54', [37, 2134.5]],
        ['6_6_55', [113, 1514.5]],
        ['6_6_56', [113, 1514.5]],
        ['6_6_57', [79, 1337.5]],
        ['6_6_58', [79, 1337.5]],
        ['6_6_59', [169, 683.5]],
        ['6_6_60', [168, 984]],
        ['6_6_61', [168, 984]],
        ['6_6_62', [168, 984]],
        ['6_6_63', [143, 916]],
        ['6_6_64', [143, 1316]],
        ['6_6_65', [143, 2823]],
        ['6_6_66', [969, 2790]],
        ['6_6_67', [1502.5, 3089.5]],
        ['6_6_68', [1658.5, 3089.5]],
        ['6_6_69', [2173, 2879]],
        ['6_6_70', [2173, 2879]],
        ['6_6_71', [2173, 2879]],
        ['6_6_72', [2777.5, 3016]],
        ['6_6_73', [2777.5, 3016]],
        ['6_6_74', [2777.5, 3016]],
        ['6_7_12', [1, 28]],
        ['6_7_13', [1, 28]],
        ['6_7_14', [1, 1889.5]],
        ['6_7_15', [2, 1889.5]],
        ['6_7_16', [9, 2030.75]],
        ['6_7_17', [269.5, 4821.5]],
        ['6_7_18', [0.25, 5797.5]],
        ['6_7_19', [0.25, 4092]],
        ['6_7_20', [0.75, 848.5]],
        ['6_7_21', [0.5, 164.25]],
        ['6_7_22', [0.5, 40.5]],
        ['6_7_23', [0.5, 40.5]],
        ['6_7_30', [0, 80.8499984741211]],
        ['6_7_31', [0, 80.8499984741211]],
        ['6_7_32', [0, 80.8499984741211]],
        ['6_7_33', [1.5, 916.5]],
        ['6_7_34', [1.5, 847.25]],
        ['6_7_35', [1.5, 287.75]],
        ['6_7_36', [22.25, 99]],
        ['6_7_37', [22.25, 99]],
        ['6_7_38', [22.25, 99]],
        ['6_7_51', [4.5, 520.5]],
        ['6_7_52', [1.5, 1638.5]],
        ['6_7_53', [1.5, 2877]],
        ['6_7_54', [518, 2365.5]],
        ['6_7_55', [155.5, 1903]],
        ['6_7_56', [113, 1903]],
        ['6_7_57', [79, 1337.5]],
        ['6_7_58', [79, 1337.5]],
        ['6_7_59', [169, 961.5]],
        ['6_7_60', [168, 984]],
        ['6_7_61', [168, 984]],
        ['6_7_62', [168, 984]],
        ['6_7_63', [166, 916]],
        ['6_7_64', [166, 1316]],
        ['6_7_65', [381.5, 3145]],
        ['6_7_66', [969, 3145]],
        ['6_7_67', [2035, 3073]],
        ['6_7_68', [2049.5, 2608]],
        ['6_7_69', [2174.5, 2879]],
        ['6_7_70', [2174.5, 2879]],
        ['6_7_71', [2174.5, 2879]],
        ['6_7_72', [2777.5, 3016]],
        ['6_7_73', [2777.5, 3016]],
        ['6_7_74', [2777.5, 3016]],
        ['6_8_12', [1, 28]],
        ['6_8_13', [1, 28]],
        ['6_8_14', [1, 863]],
        ['6_8_15', [2, 1503.5]],
        ['6_8_16', [9, 2335.5]],
        ['6_8_17', [515.5, 2681.5]],
        ['6_8_18', [0.25, 2469.25]],
        ['6_8_19', [0.25, 2683.25]],
        ['6_8_20', [0.25, 2259.75]],
        ['6_8_21', [0.25, 1637.5]],
        ['6_8_22', [0.5, 40.5]],
        ['6_8_23', [0.5, 40.5]],
        ['6_8_30', [0, 80.8499984741211]],
        ['6_8_31', [0, 80.8499984741211]],
        ['6_8_32', [0, 80.8499984741211]],
        ['6_8_33', [1.5, 254]],
        ['6_8_34', [1.5, 99]],
        ['6_8_35', [1.5, 99]],
        ['6_8_36', [22.25, 99]],
        ['6_8_37', [22.25, 99]],
        ['6_8_38', [22.25, 99]],
        ['6_8_51', [3.5, 520.5]],
        ['6_8_52', [3.5, 2673.5]],
        ['6_8_53', [272, 2877]],
        ['6_8_54', [518, 2365.5]],
        ['6_8_55', [461, 1903]],
        ['6_8_56', [113, 1903]],
        ['6_8_57', [79, 1337.5]],
        ['6_8_58', [79, 1337.5]],
        ['6_8_59', [169, 961.5]],
        ['6_8_60', [168, 984]],
        ['6_8_61', [168, 984]],
        ['6_8_62', [168, 984]],
        ['6_8_63', [166, 1219]],
        ['6_8_64', [166, 1885]],
        ['6_8_65', [381.5, 3451.5]],
        ['6_8_66', [1083.5, 3267.5]],
        ['6_8_67', [1583, 3073]],
        ['6_8_68', [1859, 2608]],
        ['6_8_69', [2422, 2879]],
        ['6_8_70', [2422, 2879]],
        ['6_8_71', [2422, 2879]],
        ['6_8_72', [2777.5, 3016]],
        ['6_8_73', [2777.5, 3016]],
        ['6_8_74', [2777.5, 3016]],
        ['6_9_10', [0.25, 364]],
        ['6_9_11', [0.25, 351]],
        ['6_9_12', [1, 433]],
        ['6_9_13', [1, 662.75]],
        ['6_9_14', [0.5, 850.5]],
        ['6_9_15', [0.75, 818.5]],
        ['6_9_16', [19, 2338]],
        ['6_9_17', [39, 2681.5]],
        ['6_9_18', [84, 2654.5]],
        ['6_9_19', [1.25, 2683.25]],
        ['6_9_20', [0.25, 2589.5]],
        ['6_9_21', [0.25, 3223.25]],
        ['6_9_22', [0.25, 2271.75]],
        ['6_9_23', [0.5, 2389.5]],
        ['6_9_24', [1, 2376.75]],
        ['6_9_25', [1.25, 628.5]],
        ['6_9_26', [1.25, 245]],
        ['6_9_27', [12.5, 142.6875]],
        ['6_9_28', [12.5, 142.6875]],
        ['6_9_29', [12.5, 142.6875]],
        ['6_9_36', [21.41666603088379, 24.058332443237305]],
        ['6_9_37', [21.41666603088379, 24.058332443237305]],
        ['6_9_38', [21.41666603088379, 24.058332443237305]],
        ['6_9_51', [2.75, 2396.5]],
        ['6_9_52', [10.25, 2469]],
        ['6_9_53', [83.5, 3315.5]],
        ['6_9_54', [841, 3315.5]],
        ['6_9_55', [841, 2090.25]],
        ['6_9_56', [841, 2050.5]],
        ['6_9_57', [531, 1811.5]],
        ['6_9_58', [531, 1811.5]],
        ['6_9_59', [531, 1811.5]],
        ['6_9_6', [0, 1.0833333730697632]],
        ['6_9_60', [678, 1179.5]],
        ['6_9_61', [678, 1179.5]],
        ['6_9_62', [678, 1373]],
        ['6_9_63', [670, 1806]],
        ['6_9_64', [670, 3007]],
        ['6_9_65', [829, 3451.5]],
        ['6_9_66', [1174, 3031]],
        ['6_9_67', [1674, 2604]],
        ['6_9_68', [1847, 2604]],
        ['6_9_69', [2468, 2863]],
        ['6_9_7', [0, 1.0833333730697632]],
        ['6_9_70', [2468, 2863]],
        ['6_9_71', [2468, 2863]],
        ['6_9_72', [2737.5, 2936]],
        ['6_9_73', [2737.5, 2936]],
        ['6_9_74', [2737.5, 2936]],
        ['6_9_8', [0, 1.0833333730697632]],
        ['6_9_9', [0.25, 364]],
      ]),
    };
    const wn = bn.data;
    class Cn {
      constructor(t) {
        if (
          ((this.hasTerrainLayerFlag = t.hasTerrainLayerFlag),
          (this._tilingScheme = t.tilingScheme),
          (this._x = t.x),
          (this._y = t.y),
          (this._level = t.level),
          (this._parent = t.parent),
          (this._rectangle = this._tilingScheme.tileXYToRectangle(this._x, this._y, this._level)),
          (this._southwestChild = void 0),
          (this._southeastChild = void 0),
          (this._northwestChild = void 0),
          (this._northeastChild = void 0),
          (this.replacementPrevious = void 0),
          (this.replacementNext = void 0),
          (this._distance = 0),
          (this._loadPriority = 0),
          (this._lastSelectionResult = vn.NONE),
          (this.renderable = !1),
          (this.upsampledFromParent = !1),
          (this.data = void 0),
          (this._customHeight = {
            minimumHeight: e.defined(this.parent) ? this.parent.customHeight.minimumHeight : void 0,
            maximumHeight: e.defined(this.parent) ? this.parent.customHeight.maximumHeight : void 0,
          }),
          (this._tileIndexVisited = !1),
          (this._tileExistOnServer = 1),
          this.hasTerrainLayerFlag)
        ) {
          const e = this.getOverscaledTileID();
          let t, i;
          this.level > 6
            ? (i = [this._parent.terrainData.minimumHeight, this._parent.terrainData.maximumHeight])
            : ((t = e),
              (i = wn.has(t.canonical.key)
                ? wn.get(t.canonical.key)
                : [
                    this._parent.terrainData.minimumHeight,
                    this._parent.terrainData.maximumHeight,
                  ])),
            (this.terrainData = { minimumHeight: i[0], maximumHeight: i[1] });
        } else this.terrainData = { minimumHeight: 0, maximumHeight: 0 };
      }
      getOverscaledTileID() {
        if (!this.tileId) {
          const t = this._tilingScheme instanceof hn ? 'LATLON' : 'MERCATOR',
            i = this._level + (this._tilingScheme instanceof hn ? 1 : 0),
            s = this._x,
            r = this._y,
            n = Math.pow(2, i);
          i >= 0 &&
            i <= 25 &&
            s >= 0 &&
            s < n &&
            r >= 0 &&
            r < n &&
            (this.tileId = new e.OverscaledTileID(i, 0, i, this._x, this._y, t));
        }
        return this.tileId;
      }
      static createLevelZeroTiles(e, t) {
        const i = e.getNumberOfXTilesAtLevel(0),
          s = e.getNumberOfYTilesAtLevel(0),
          r = new Array(i * s);
        let n = 0;
        for (let o = 0; o < s; ++o)
          for (let s = 0; s < i; ++s)
            r[n++] = new Cn({ tilingScheme: e, x: s, y: o, level: 0, hasTerrainLayerFlag: t });
        return r;
      }
      get customHeight() {
        return this._customHeight;
      }
      set customHeight(t) {
        e.defined(t) &&
          ((this._customHeight.minimumHeight = t.minimumHeight),
          (this._customHeight.maximumHeight = t.maximumHeight));
      }
      get tilingScheme() {
        return this._tilingScheme;
      }
      get x() {
        return this._x;
      }
      get y() {
        return this._y;
      }
      get level() {
        return this._level;
      }
      get parent() {
        return this._parent;
      }
      get rectangle() {
        return this._rectangle;
      }
      get children() {
        return [this.northwestChild, this.northeastChild, this.southwestChild, this.southeastChild];
      }
      get southwestChild() {
        return (
          e.defined(this._southwestChild) ||
            ((this._southwestChild = new Cn({
              hasTerrainLayerFlag: this.hasTerrainLayerFlag,
              tilingScheme: this.tilingScheme,
              x: 2 * this.x,
              y: 2 * this.y + 1,
              level: this.level + 1,
              parent: this,
            })),
            this.hasTerrainLayerFlag && On(this._southwestChild)),
          this._southwestChild
        );
      }
      get southeastChild() {
        return (
          e.defined(this._southeastChild) ||
            ((this._southeastChild = new Cn({
              hasTerrainLayerFlag: this.hasTerrainLayerFlag,
              tilingScheme: this.tilingScheme,
              x: 2 * this.x + 1,
              y: 2 * this.y + 1,
              level: this.level + 1,
              parent: this,
            })),
            this.hasTerrainLayerFlag && On(this._southeastChild)),
          this._southeastChild
        );
      }
      get northwestChild() {
        return (
          e.defined(this._northwestChild) ||
            ((this._northwestChild = new Cn({
              hasTerrainLayerFlag: this.hasTerrainLayerFlag,
              tilingScheme: this.tilingScheme,
              x: 2 * this.x,
              y: 2 * this.y,
              level: this.level + 1,
              parent: this,
            })),
            this.hasTerrainLayerFlag && On(this._northwestChild)),
          this._northwestChild
        );
      }
      get northeastChild() {
        return (
          e.defined(this._northeastChild) ||
            ((this._northeastChild = new Cn({
              hasTerrainLayerFlag: this.hasTerrainLayerFlag,
              tilingScheme: this.tilingScheme,
              x: 2 * this.x + 1,
              y: 2 * this.y,
              level: this.level + 1,
              parent: this,
            })),
            this.hasTerrainLayerFlag && On(this._northeastChild)),
          this._northeastChild
        );
      }
      findLevelZeroTile(e, t, i) {
        const s = this.tilingScheme.getNumberOfXTilesAtLevel(0);
        if (
          (t < 0 ? (t += s) : t >= s && (t -= s),
          !(i < 0 || i >= this.tilingScheme.getNumberOfYTilesAtLevel(0)))
        )
          return e.filter((e) => e.x === t && e.y === i)[0];
      }
      findTileToWest(e) {
        const t = this.parent;
        if (void 0 === t) return this.findLevelZeroTile(e, this.x - 1, this.y);
        if (t.southeastChild === this) return t.southwestChild;
        if (t.northeastChild === this) return t.northwestChild;
        const i = t.findTileToWest(e);
        return void 0 !== i
          ? t.southwestChild === this
            ? i.southeastChild
            : i.northeastChild
          : void 0;
      }
      findTileToEast(e) {
        const t = this.parent;
        if (void 0 === t) return this.findLevelZeroTile(e, this.x + 1, this.y);
        if (t.southwestChild === this) return t.southeastChild;
        if (t.northwestChild === this) return t.northeastChild;
        const i = t.findTileToEast(e);
        return void 0 !== i
          ? t.southeastChild === this
            ? i.southwestChild
            : i.northwestChild
          : void 0;
      }
      findTileToSouth(e) {
        const t = this.parent;
        if (void 0 === t) return this.findLevelZeroTile(e, this.x, this.y + 1);
        if (t.northwestChild === this) return t.southwestChild;
        if (t.northeastChild === this) return t.southeastChild;
        const i = t.findTileToSouth(e);
        return void 0 !== i
          ? t.southwestChild === this
            ? i.northwestChild
            : i.northeastChild
          : void 0;
      }
      findTileToNorth(e) {
        const t = this.parent;
        if (void 0 === t) return this.findLevelZeroTile(e, this.x, this.y - 1);
        if (t.southwestChild === this) return t.northwestChild;
        if (t.southeastChild === this) return t.northeastChild;
        const i = t.findTileToNorth(e);
        return void 0 !== i
          ? t.northwestChild === this
            ? i.southwestChild
            : i.southeastChild
          : void 0;
      }
      freeResources() {
        (this.renderable = !1),
          (this.upsampledFromParent = !1),
          e.defined(this.data) && e.defined(this.data.freeResources) && this.data.freeResources(),
          Sn(this._southwestChild),
          (this._southwestChild = void 0),
          Sn(this._southeastChild),
          (this._southeastChild = void 0),
          Sn(this._northwestChild),
          (this._northwestChild = void 0),
          Sn(this._northeastChild),
          (this._northeastChild = void 0);
      }
    }
    function Sn(t) {
      e.defined(t) && t.freeResources();
    }
    var En = Object.freeze({ NONE: -1, PARTIAL: 0, FULL: 1 });
    const Pn = bn.data;
    class Mn {
      constructor() {
        (this.allAreRenderable = !0),
          (this.anyWereRenderedLastFrame = !1),
          (this.notYetRenderableCount = 0);
      }
    }
    class An {
      constructor() {
        (this.southwest = new Mn()),
          (this.southeast = new Mn()),
          (this.northwest = new Mn()),
          (this.northeast = new Mn());
      }
      combine(e) {
        const t = this.southwest,
          i = this.southeast,
          s = this.northwest,
          r = this.northeast;
        (e.allAreRenderable =
          t.allAreRenderable && i.allAreRenderable && s.allAreRenderable && r.allAreRenderable),
          (e.anyWereRenderedLastFrame =
            t.anyWereRenderedLastFrame ||
            i.anyWereRenderedLastFrame ||
            s.anyWereRenderedLastFrame ||
            r.anyWereRenderedLastFrame),
          (e.notYetRenderableCount =
            t.notYetRenderableCount +
            i.notYetRenderableCount +
            s.notYetRenderableCount +
            r.notYetRenderableCount);
      }
    }
    const Rn = new Array(31);
    for (let e = 0; e < Rn.length; ++e) Rn[e] = new An();
    class In {
      constructor(e) {
        (this.hasTerrainLayerFlag = e.hasTerrainLayerFlag),
          (this.tileScheme = e.tileScheme),
          (this._levelZeroMaximumGeometricError = 40075.16),
          (this.maximumScreenSpaceError = e.maximumScreenSpaceError || 2),
          (this.tileSize = e.tileSize || 512),
          (this.type = e.type),
          (this.drawingBufferHeight = e.drawingBufferHeight),
          (this.pixelRatio = e.pixelRatio || 1),
          (this.selectedTiles = []),
          (this._tileVisited = !1),
          (this._tileMaxZoom = e.tileMaxZoom),
          (this._tileMinZoom = e.tileMinZoom),
          (this._tmpQuadtreeTileBoundingRegionMap = {}),
          (this._tmpQuadtreeTileMap = {}),
          (this._overscaledTileIDList = []);
      }
      set tileMaxZoom(e) {
        this._tileMaxZoom = e;
      }
      get tileMaxZoom() {
        return this._tileMaxZoom;
      }
      set tileMinZoom(e) {
        this._tileMinZoom = e;
      }
      get tileMinZoom() {
        return this._tileMinZoom;
      }
      tilesIn(t, i, s) {
        if (
          ((this.tileSearchDB = i),
          (this._tileVisited = !1),
          (this._tmpQuadtreeTileMap = {}),
          (this._tmpQuadtreeTileBoundingRegionMap = {}),
          (this._overscaledTileIDList = []),
          !this.rootTiles &&
            ((this.rootTiles = Cn.createLevelZeroTiles(this.tileScheme, this.hasTerrainLayerFlag)),
            e.defined(s) && (e.defined(s.minimumHeight) || e.defined(s.maximumHeight))))
        )
          for (let e = 0; e < this.rootTiles.length; e++)
            this.rootTiles[e].customHeight = {
              minimumHeight: s.minimumHeight,
              maximumHeight: s.maximumHeight,
            };
        this.selectedTiles = [];
        for (let e = 0; e < this.rootTiles.length; e++)
          this.visitIfVisible(this.rootTiles[e], t, !1);
        this.tileSearchDB = null;
      }
      getQuadtreeTileByTileKey(e) {
        return this._tmpQuadtreeTileMap[e];
      }
      getBoundingRegionById(t) {
        let i = this._tmpQuadtreeTileBoundingRegionMap[t];
        if (!i) {
          const s = t.split('_'),
            r = parseInt(s[0]),
            n = parseInt(s[1]),
            o = parseInt(s[2]);
          if (this.hasTerrainLayerFlag) {
            let t = new e.OverscaledTileID(
              r,
              0,
              r,
              n,
              o,
              this.tileScheme instanceof hn ? 'LATLON' : 'MERCATOR',
            );
            r > 6 && (t = t.scaledTo(6)),
              (i = new e.TileBoundingRegion({
                minimumHeight: Pn.has(t.canonical.key) ? Pn.get(t.canonical.key)[0] : 0,
                maximumHeight: Pn.has(t.canonical.key) ? Pn.get(t.canonical.key)[1] : 0,
                rectangle: this.tileScheme.tileXYToRectangle(n, o, r),
              }));
          } else
            i = new e.TileBoundingRegion({
              minimumHeight: 0,
              maximumHeight: 0,
              rectangle: this.tileScheme.tileXYToRectangle(n, o, r),
            });
        }
        return i;
      }
      getOverscaledTileIDs() {
        if (!this._tileVisited) {
          for (let e = 0; e < this.selectedTiles.length; e++) {
            const t = this.selectedTiles[e],
              i = t.getOverscaledTileID();
            if (i) {
              const e = i.key;
              (this._tmpQuadtreeTileBoundingRegionMap[e] = t.tileBoundingRegion),
                (this._tmpQuadtreeTileMap[e] = t);
            }
          }
          this.selectedTiles.sort((e, t) => t.tileId.canonical.z - e.tileId.canonical.z),
            this.selectedTiles.sort((e, t) => e._loadPriority - t._loadPriority);
          for (let e = 0; e < this.selectedTiles.length; e++) {
            const t = this.selectedTiles[e];
            t.tileId.canonical.z >= this._tileMinZoom && this._overscaledTileIDList.push(t.tileId);
          }
          this._tileVisited = !0;
        }
        return this._overscaledTileIDList;
      }
      visitIfVisible(e, t, i) {
        if (this.computeTileVisibility(e, t) !== En.NONE) return this.visitTile(t, e, i);
      }
      visitTile(t, i, s) {
        const r = i.tilingScheme instanceof hn ? 2 : 1;
        let n;
        n =
          'raster' !== this.type
            ? this.screenSpaceError(t, this.drawingBufferHeight, this.pixelRatio, i) <
                this.maximumScreenSpaceError ||
              i.level + r - Math.log2(512 / this.tileSize) > Number(t.mapZoom.toFixed(5))
            : this.screenSpaceError(t, this.drawingBufferHeight, this.pixelRatio, i) <
                this.maximumScreenSpaceError ||
              i.level + r - Math.log2(512 / this.tileSize) > Number(t.heightZoom.toFixed(5));
        const o = i.southwestChild,
          a = i.southeastChild,
          l = i.northwestChild,
          h = i.northeastChild;
        if (n || s) this.selectedTiles.push(i);
        else {
          if (this.canRefine(i)) {
            if (
              o.upsampledFromParent &&
              a.upsampledFromParent &&
              l.upsampledFromParent &&
              h.upsampledFromParent
            )
              return void this.selectedTiles.push(i);
            if (i.level > 13) {
              if (this.tileSearchDB && !i._tileIndexVisited) {
                i.tileId ||
                  (i.tileId = new e.OverscaledTileID(
                    i.level,
                    0,
                    i.level,
                    i.x,
                    i.y,
                    this.tileScheme instanceof hn ? 'LATLON' : 'MERCATOR',
                  ));
                const t = this.tileSearchDB.getStatusById(i.tileId);
                e.defined(t) && ((i._tileIndexVisited = !0), (i._tileExistOnServer = t));
              }
              if (this.tileSearchDB && i._tileIndexVisited && !i._tileExistOnServer)
                return void this.selectedTiles.push(i);
            }
            if (a && o._level <= this._tileMaxZoom)
              return void this.visitVisibleChildrenNearToFar(o, a, l, h, t, s);
          }
          this.selectedTiles.push(i);
        }
      }
      computeTileVisibility(t, i) {
        const s = this.computeDistanceToTile(t, i);
        t._distance = s;
        const r = t.tileBoundingRegion;
        let n;
        t._loadPriority = this.computeTileLoadPriority(t, i);
        const o = i.frustumCrate.cullingVolume.computeVisibility(r.boundingVolume);
        return (
          o === e.INTERSECTION.OUTSIDE
            ? (n = En.NONE)
            : o === e.INTERSECTION.INTERSECTING
            ? (n = En.PARTIAL)
            : o === e.INTERSECTION.INSIDE && (n = En.FULL),
          n
        );
      }
      computeTileLoadPriority(t, i) {
        if (
          !e.defined(t.tileBoundingRegion) ||
          e.defined(t.tileBoundingRegion._orientedBoundingBox)
        )
          return 0;
        const s = i.direction,
          r = e.Vector3.subtract(
            t.tileBoundingRegion._orientedBoundingBox.center,
            i.position,
            new e.Vector3(),
          ),
          n = e.Vector3.magnitude(r);
        return n < 1e-5
          ? 0
          : (e.Vector3.divideByScalar(r, n, r), (1 - e.Vector3.dot(r, s)) * t._distance);
      }
      screenSpaceError(e, t, i, s) {
        let r =
          (this.getLevelMaximumGeometricError(s.level) * t) /
          (s._distance * e.frustumCrate.frustum._sseDenominator);
        return (r /= i), r;
      }
      computeDistanceToTile(e, t) {
        On(e);
        const i = e.tileBoundingRegion,
          s = i.minimumHeight,
          r = i.maximumHeight,
          n = i.distanceToCamera(t);
        return (i.minimumHeight = s), (i.maximumHeight = r), n;
      }
      getLevelMaximumGeometricError(e) {
        return this._levelZeroMaximumGeometricError / (1 << e);
      }
      visitVisibleChildrenNearToFar(t, i, s, r, n, o) {
        const a = e.Cartographic.fromVector3(n.position);
        a.longitude < t.rectangle.east
          ? a.latitude < t.rectangle.north
            ? (this.visitIfVisible(t, n, o),
              this.visitIfVisible(i, n, o),
              this.visitIfVisible(s, n, o),
              this.visitIfVisible(r, n, o))
            : (this.visitIfVisible(s, n, o),
              this.visitIfVisible(t, n, o),
              this.visitIfVisible(r, n, o),
              this.visitIfVisible(i, n, o))
          : a.latitude < t.rectangle.north
          ? (this.visitIfVisible(i, n, o),
            this.visitIfVisible(t, n, o),
            this.visitIfVisible(r, n, o),
            this.visitIfVisible(s, n, o))
          : (this.visitIfVisible(r, n, o),
            this.visitIfVisible(s, n, o),
            this.visitIfVisible(i, n, o),
            this.visitIfVisible(t, n, o));
      }
      canRefine(t) {
        return e.defined(t.terrainData), !0;
      }
      destroy() {
        (this.hasTerrainLayerFlag = null),
          (this.tileScheme = null),
          (this.selectedTiles = []),
          (this._tileVisited = !1),
          (this._tmpQuadtreeTileBoundingRegionMap = {}),
          (this._tmpQuadtreeTileMap = {}),
          (this._overscaledTileIDList = []);
      }
    }
    function On(t) {
      const i = t.tilingScheme.ellipsoid;
      e.defined(t.tileBoundingRegion) ||
        (t.tileBoundingRegion = new e.TileBoundingRegion({
          computeBoundingVolumes: !0,
          rectangle: t.rectangle,
          ellipsoid: i,
          minimumHeight: e.defined(t.customHeight.minimumHeight)
            ? t.customHeight.minimumHeight
            : t.terrainData.minimumHeight,
          maximumHeight: e.defined(t.customHeight.maximumHeight)
            ? t.customHeight.maximumHeight
            : t.terrainData.maximumHeight,
        }));
      const s = t.tileBoundingRegion;
      !t.terrainData ||
        0 === t.terrainData.minimumHeight ||
        0 === t.terrainData.maximumHeight ||
        (s.maximumHeight == t.terrainData.maximumHeight &&
          s.minimumHeight == t.terrainData.minimumHeight) ||
        ((s.maximumHeight = t.terrainData.maximumHeight),
        (s.minimumHeight = t.terrainData.minimumHeight),
        s.computeBoundingVolumes(i));
    }
    class Ln {
      constructor() {
        (this.state = {}), (this.stateChanges = {}), (this.deletedStates = {});
      }
      updateState(t, i, s) {
        const r = String(i);
        if (
          ((this.stateChanges[t] = this.stateChanges[t] || {}),
          (this.stateChanges[t][r] = this.stateChanges[t][r] || {}),
          e.extend(this.stateChanges[t][r], s),
          null === this.deletedStates[t])
        ) {
          this.deletedStates[t] = {};
          for (const e in this.state[t]) e !== r && (this.deletedStates[t][e] = null);
        } else if (this.deletedStates[t] && null === this.deletedStates[t][r]) {
          this.deletedStates[t][r] = {};
          for (const e in this.state[t][r]) s[e] || (this.deletedStates[t][r][e] = null);
        } else
          for (const e in s)
            this.deletedStates[t] &&
              this.deletedStates[t][r] &&
              null === this.deletedStates[t][r][e] &&
              delete this.deletedStates[t][r][e];
      }
      removeFeatureState(e, t, i) {
        if (null === this.deletedStates[e]) return;
        const s = String(t);
        if (((this.deletedStates[e] = this.deletedStates[e] || {}), i && void 0 !== t))
          null !== this.deletedStates[e][s] &&
            ((this.deletedStates[e][s] = this.deletedStates[e][s] || {}),
            (this.deletedStates[e][s][i] = null));
        else if (void 0 !== t)
          if (this.stateChanges[e] && this.stateChanges[e][s])
            for (i in ((this.deletedStates[e][s] = {}), this.stateChanges[e][s]))
              this.deletedStates[e][s][i] = null;
          else this.deletedStates[e][s] = null;
        else this.deletedStates[e] = null;
      }
      getState(t, i) {
        const s = String(i),
          r = e.extend({}, (this.state[t] || {})[s], (this.stateChanges[t] || {})[s]);
        if (null === this.deletedStates[t]) return {};
        if (this.deletedStates[t]) {
          const e = this.deletedStates[t][i];
          if (null === e) return {};
          for (const t in e) delete r[t];
        }
        return r;
      }
      initializeTileState(e, t) {
        e.setFeatureState(this.state, t);
      }
      coalesceChanges(t, i) {
        const s = {};
        for (const t in this.stateChanges) {
          this.state[t] = this.state[t] || {};
          const i = {};
          for (const s in this.stateChanges[t])
            this.state[t][s] || (this.state[t][s] = {}),
              e.extend(this.state[t][s], this.stateChanges[t][s]),
              (i[s] = this.state[t][s]);
          s[t] = i;
        }
        for (const t in this.deletedStates) {
          this.state[t] = this.state[t] || {};
          const i = {};
          if (null === this.deletedStates[t])
            for (const e in this.state[t]) (i[e] = {}), (this.state[t][e] = {});
          else
            for (const e in this.deletedStates[t]) {
              if (null === this.deletedStates[t][e]) this.state[t][e] = {};
              else
                for (const i of Object.keys(this.deletedStates[t][e])) delete this.state[t][e][i];
              i[e] = this.state[t][e];
            }
          (s[t] = s[t] || {}), e.extend(s[t], i);
        }
        if (((this.stateChanges = {}), (this.deletedStates = {}), 0 !== Object.keys(s).length))
          for (const e in t) t[e].setFeatureState(s, i);
      }
    }
    class Dn extends e.Material {
      constructor(t) {
        super(t),
          (this.layer = t.layer),
          (this.tile = t.tile),
          (this._parentTile = t.parentTile),
          (this._renderState = t.renderState),
          (this.textureFilter =
            e.defined(this.layer) && 'nearest' === this.layer.paint.get('raster-resampling')
              ? e.WebGLConstants.NEAREST
              : e.WebGLConstants.LINEAR),
          (this._lightColor = new e.Vector3([1, 1, 1])),
          (this._lightDirection = new e.Vector3()),
          (this._spinWeights = new e.Vector3()),
          (this.parentTL = new e.Vector2()),
          this.updateDynamicProperty(),
          this.createUniforms(),
          (this.emptyTexture = new e.Texture({
            context: t.painter.context,
            image: { width: 1, height: 1, data: null },
            pixelFormat: e.WebGLConstants.RGBA,
            useMipmap: !1,
          }));
      }
      setLayer(e) {
        this.layer = e;
      }
      set parentTile(e) {
        e?.tileID.key != this._parentTile?.tileID.key &&
          ((this._parentTile = e), this.updateDynamicProperty());
      }
      update(t, i, s = {}) {
        super.update(t, i, s),
          (this.defines = {
            ENCODE_DEPTH_TO_FRAGCOLOR: i.passType === e.RenderPassConsts.PICK_PASS,
            TEXTURE_UNITS: this.tile.totalImagery.length,
          });
      }
      updateDynamicProperty() {
        this._parentTile
          ? ((this.parentScaleBy = Math.pow(
              2,
              this._parentTile.tileID.overscaledZ - this.tile.tileID.overscaledZ,
            )),
            this.parentTL.set(
              (this.tile.tileID.canonical.x * this.parentScaleBy) % 1,
              (this.tile.tileID.canonical.y * this.parentScaleBy) % 1,
            ))
          : ((this.parentScaleBy = 1), this.parentTL.set(0, 0));
      }
      createUniforms() {
        this._uniforms.set('u_TextureBrightnessMin', () => this.tile.totalBrightnessMin),
          this._uniforms.set('u_TextureBrightnessMax', () => this.tile.totalBrightnessMax),
          this._uniforms.set('u_TextureSaturationFactor', () => this.tile.totalSaturationFactor),
          this._uniforms.set('u_TextureContrastFactor', () => this.tile.totalContrastFactor),
          this._uniforms.set('u_TextureSpinWeight', () => this.tile.totalSpinWight),
          this._uniforms.set('u_Opacity', () => this.tile.totalOpacity),
          this._uniforms.set('u_TextureAlpha', () => this.tile.totalOpacity),
          this._uniforms.set('u_Texture', () => {
            const e = [];
            for (let t = 0; t < this.tile.totalImagery.length; t++)
              e.push(this.tile.totalImagery[t].imagery.texture || this.emptyTexture);
            return e;
          }),
          this._uniforms.set('u_TextureTexCoordsRectangle', () => {
            const e = [];
            for (let t = 0; t < this.tile.totalImagery.length; t++)
              e.push(this.tile.totalImagery[t].textureCoordinateRectangle);
            return e;
          }),
          this._uniforms.set('u_TextureTranslationAndScale', () => {
            const e = [];
            for (let t = 0; t < this.tile.totalImagery.length; t++)
              e.push(this.tile.totalImagery[t].textureTranslationAndScale);
            return e;
          });
      }
      checkLayer() {
        if (!this.layer)
          throw new Error(
            '请在rater plotter中针对image source或者video source进行layer的注册，即调用material.setLayer(layer)',
          );
      }
      destroy() {
        (this.layer = void 0),
          this.tile.texture && (this.tile.texture.destroy(), (this.tile.texture = null)),
          (this.__texture = null),
          (this.tile = void 0),
          (this.programId = void 0),
          (this.type = void 0),
          (this._uniforms = void 0),
          (this._textures = void 0),
          (this._program = void 0),
          (this._programConfiguration = void 0),
          (this._renderState = void 0),
          (this._parentTile = void 0),
          (this.textureFilter = void 0),
          (this.parentTL = void 0),
          (this.parentScaleBy = void 0);
      }
    }
    class Bn extends e.Material {
      constructor(e) {
        super(e),
          (this.isVectorMaterial = !1),
          (this.layer = e.layer),
          (this._pattern = this.layer.paint.get('background-pattern')),
          'background-analysis' !== e.type && (this.type = this.getProgramType()),
          (this._error = null),
          (this._renderState = e.renderState),
          Bn.#C(this, e.painter);
      }
      getProgramType() {
        return this._pattern ? e.SHADER_BACKGROUND_PATTERN : e.SHADER_BACKGROUND_COLOR;
      }
      update(t, i, s = {}) {
        super.update(t, i, s),
          (this.defines = { SHOW_DEPTH: e.defaultValue(this.layer.showDepth, !1) });
      }
      static #C(t, i) {
        t._uniforms.set('u_Color', () => {
          const i = t.layer.paint.get('background-color');
          return new e.Vector4(i.r, i.g, i.b, i.a);
        }),
          t._uniforms.set('u_Opacity', () => t.layer.paint.get('background-opacity')),
          t._pattern && Bn.#S(t, i);
      }
      static #S(t, i) {
        e.isPatternMissing(t._pattern, i) && (t._error = !0);
        const s =
          void 0 === t.layer.paint.get('background-pattern-fixed') ||
          t.layer.paint.get('background-pattern-fixed');
        e.createPatternUniforms({ material: t, needFixed: s, needCrossfade: !0 });
      }
      destroy() {
        (this.layer = void 0),
          (this.programId = void 0),
          (this.type = void 0),
          (this._uniforms = void 0),
          (this._program = void 0),
          (this._programConfiguration = void 0),
          (this._renderState = void 0);
      }
    }
    class Vn extends e.Geometry {
      constructor(t) {
        super(t),
          (this.params = t),
          (this._usedDoublePrecision = !1),
          (this._vertexArray = this._usedDoublePrecision
            ? new e.StructArrayLayout11f44()
            : new e.StructArrayLayout3f2f3f32()),
          this.parse(t),
          (this.primitiveType = t.primitiveType || e.WebGLConstants.TRIANGLES),
          this.computeBoundingSphere(),
          this.computeBoundingBox(),
          (this.type = 'SphereGeometry');
      }
      parse(t) {
        (this.needUpdate = !0), super.parse(t);
        const i = this.params.radius,
          s = this.params.widthSegments,
          r = this.params.heightSegments,
          n = this.params.phiStart,
          o = this.params.phiLength,
          a = this.params.thetaStart,
          l = this.params.thetaLength,
          h = this.params.ellipse || e.Transforms.DefaultEllipsoid;
        (this._vertexArray = new e.StructArrayLayout3f2f3f32()),
          (this._indices = new e.StructArrayLayout3ui6()),
          (this.radius = i || 1),
          (this.widthSegments = Math.max(3, Math.floor(s) || 8)),
          (this.heightSegments = Math.max(2, Math.floor(r) || 6)),
          (this.phiStart = void 0 !== n ? n : 0),
          (this.phiStart *= e.CONSTS.TRANSFORM.RAD_TO_DEG),
          (this.phiLength = void 0 !== o ? o : 2 * Math.PI),
          (this.phiLength *= e.CONSTS.TRANSFORM.RAD_TO_DEG),
          (this.thetaStart = void 0 !== a ? a : 0),
          (this.thetaStart *= e.CONSTS.TRANSFORM.RAD_TO_DEG),
          (this.thetaLength = void 0 !== l ? l : Math.PI),
          (this.thetaLength *= e.CONSTS.TRANSFORM.RAD_TO_DEG);
        const c = Math.min(this.thetaStart + this.thetaLength, Math.PI);
        let _,
          u,
          d = 0;
        const m = [],
          p = new e.Vector3(),
          f = new e.Vector3(),
          g = [],
          y = [],
          T = [],
          x = [];
        for (u = 0; u <= this.heightSegments; u++) {
          const t = [],
            i = u / this.heightSegments;
          let s = 0;
          for (
            0 == u && 0 == this.thetaStart
              ? (s = 0.5 / this.widthSegments)
              : u == this.heightSegments && c == Math.PI && (s = -0.5 / this.widthSegments),
              _ = 0;
            _ <= this.widthSegments;
            _++
          ) {
            const r = _ / this.widthSegments;
            if (this.radius === e.CONSTS.TRANSFORM.R) {
              const t = h.cartographicToCartesian(
                new e.Vector3(
                  this.phiStart + r * this.phiLength,
                  90 - (this.thetaStart + i * this.thetaLength),
                  0,
                ),
              );
              y.push(t[0], t[1], t[2]);
            } else {
              const t = h.cartographicToCartesian(
                  new e.Vector3(
                    this.phiStart + r * this.phiLength,
                    90 - (this.thetaStart + i * this.thetaLength),
                    this.radius,
                  ),
                ),
                s = h.cartographicToCartesian(
                  new e.Vector3(
                    this.phiStart + r * this.phiLength,
                    90 - (this.thetaStart + i * this.thetaLength),
                    0,
                  ),
                );
              y.push(t[0] - s[0], t[1] - s[1], t[2] - s[2]);
            }
            f.copy(p).normalize(), T.push(f.x, f.y, f.z), x.push(r + s + 0.5, i), t.push(d++);
          }
          m.push(t);
        }
        for (u = 0; u < this.heightSegments; u++)
          for (_ = 0; _ < this.widthSegments; _++) {
            const e = m[u][_],
              t = m[u + 1][_],
              i = m[u + 1][_ + 1];
            (0 !== u || this.thetaStart > 0) && g.push(m[u][_ + 1], e, i),
              (u !== this.heightSegments - 1 || c < Math.PI) && g.push(e, t, i);
          }
        (this.vertices = y),
          (this.normals = T),
          (this.uvs = x),
          (this.indices = g),
          (this.normals = e.PolygonGeometryLibrary.computeNormal(y, g)),
          this.emplaceVertexBufferTriangle();
        for (let e = 0; e < this.indices.length; e += 3)
          this._indices.emplaceBack(this.indices[e], this.indices[e + 1], this.indices[e + 2]);
      }
      update(t) {
        if (this.needUpdate) {
          this.needUpdate = !1;
          const i = t.painter.context;
          (this._vertBuffer = i.createVertexBuffer(
            this._vertexArray,
            this._usedDoublePrecision ? e.layout.members : e.layout$1.members,
            !1,
          )),
            (this._indexBuffer = i.createIndexBuffer(this._indices, !1)),
            (this._segmentVector = e.SegmentVector.simpleSegment(
              0,
              0,
              this.vertices.length / 3,
              this.indices.length / 3,
            )),
            (this.vertices = []),
            (this.normals = []),
            (this.uvs = []),
            (this.indices = []),
            (this._indices = null),
            (this._vertexArray = null);
        }
      }
      serialize() {
        return {
          type: this.type,
          radius: this.radius,
          widthSegments: this.widthSegments,
          heightSegments: this.heightSegments,
          phiStart: this.phiStart / e.CONSTS.TRANSFORM.RAD_TO_DEG,
          phiLength: this.phiLength / e.CONSTS.TRANSFORM.RAD_TO_DEG,
          thetaStart: this.thetaStart / e.CONSTS.TRANSFORM.RAD_TO_DEG,
          thetaLength: this.thetaLength / e.CONSTS.TRANSFORM.RAD_TO_DEG,
        };
      }
      destroy() {
        super.destroy(), (this.type = void 0);
      }
    }
    function Nn(t) {
      const { buffers: i, symbolType: s, tileBoundingRegion: r, pickColorVertexBuffer: n } = t;
      let o;
      return (
        'icon' === s || 'text' === s
          ? (o = new e.Geometry({
              vertBuffer: i.layoutVertexBuffer,
              indexBuffer: i.indexBuffer,
              segmentVector: i.segments,
              dynamicLayoutBuffer1: i.dynamicLayoutVertexBuffer,
              dynamicLayoutBuffer2: i.opacityVertexBuffer,
              dynamicLayoutBuffer3: n,
              primitiveType: e.WebGLConstants.TRIANGLES,
              tileBoundingRegion: r,
            }))
          : 'debug' == s &&
            (o = new e.Geometry({
              vertBuffer: i.layoutVertexBuffer,
              indexBuffer: i.indexBuffer,
              segmentVector: i.segments,
              dynamicLayoutBuffer1: i.collisionVertexBuffer,
              primitiveType: e.WebGLConstants.TRIANGLES,
              tileBoundingRegion: r,
            })),
        o
      );
    }
    class kn extends e.Material {
      constructor(t) {
        super(t),
          (this.isVectorMaterial = !0),
          (this.layer = t.layer),
          (this.tile = t.tile),
          (this.programId = e.SHADER_HISTOGRAM_COLOR),
          (this._programConfiguration = t.programConfiguration),
          (this._renderState = t.renderState),
          (this.type = this.getProgramType()),
          (this._error = null),
          kn.#E(this);
      }
      getProgramType() {
        return this.programId;
      }
      update(e, t, i) {
        super.update(e, t, i),
          this.updateRenderState(i),
          this._uniforms.set('u_Opacity', () => this.layer.paint.get('histogram-opacity'));
      }
      destroy() {
        (this.layer = void 0),
          (this.tile = void 0),
          (this.programId = void 0),
          (this.plotter = void 0),
          (this.type = void 0),
          (this._uniforms = void 0),
          (this._textures = void 0),
          (this._program = void 0),
          (this.defines = void 0),
          (this._programConfiguration = void 0),
          (this._renderState = void 0),
          (this._pattern = void 0);
      }
      static #E(t) {
        e.PhongLightSetter.setPhongLightUniform({
          material: t,
          phongLightConfig: t.layer.phongLightConfig,
        });
      }
      updateRenderState(t) {
        const { renderStateTag: i, stencilTest: s } = t;
        'first' === i
          ? (this.renderState = {
              depthMask: e.renderStateEnum.enableDepthMask,
              depthTest: e.renderStateEnum.enableDepthTestWithLEQUAL,
              stencilMask: e.renderStateEnum.disableStencilMask,
              stencilTest: e.renderStateEnum.disableStencilTest,
              colorMask: e.renderStateEnum.disabledColorMask,
            })
          : 'second' === i &&
            (this.renderState = {
              depthMask: e.renderStateEnum.enableDepthMask,
              depthTest: e.renderStateEnum.enableDepthTestWithLEQUAL,
              stencilMask: e.renderStateEnum.enableStencilMask,
              stencilTest: s,
              colorMask: e.renderStateEnum.enableColorMask,
              cull: e.renderStateEnum.disableCull,
              blending: e.renderStateEnum.enableBlending,
            });
      }
    }
    class Fn extends e.Material {
      constructor(t) {
        super(t),
          (this.isVectorMaterial = !0),
          (this.layer = t.layer),
          (this.tile = t.tile),
          (this.coord = t.tile.tileID),
          (this.programId = t.programId),
          (this.drawFill = t.drawFill),
          (this._programConfiguration = t.programConfiguration),
          (this._renderState = t.renderState),
          (this._isShadowVolumeMaterial = t.shadowVolumeMaterial || !1),
          (this.type = e.VectorFillMaterial.getProgramTypeAndCreateUniforms(this, t.painter)),
          this._uniforms.set('u_World', () => {
            const i = t.painter.context.gl;
            return new e.Vector2(i.drawingBufferWidth, i.drawingBufferHeight);
          });
      }
      update(t, i, s = {}) {
        super.update(t, i, s);
        const r = t.tileClippingMask.getMaskIDByCoord(this.coord);
        !this._isShadowVolumeMaterial &&
          t.tileClippingMask.status &&
          ((this._renderState.stencilTest = e.deepCopyObj(
            t.tileClippingMask.useMaskRs.stencilTest,
          )),
          (this._renderState.stencilTest.reference = r));
      }
      destroy() {
        (this.layer = void 0),
          (this.tile = void 0),
          (this.coord = void 0),
          (this.programId = void 0),
          (this.drawFill = void 0),
          (this.type = void 0),
          (this._uniforms = void 0),
          (this._textures = void 0),
          (this._program = void 0),
          (this._programConfiguration = void 0),
          (this._renderState = void 0);
      }
    }
    class Gn extends e.Material {
      constructor(e) {
        super(e),
          (this.isVectorMaterial = !0),
          (this.type = e.type),
          (this.layer = e.layer),
          (this.tile = e.tile),
          (this._renderState = e.renderState),
          (this._defines = e.defines),
          (this._programConfiguration = e.programConfiguration),
          (this.animationsInfo = e.animationsInfo || {}),
          this.#C(e.painter);
      }
      update(e, t, i = {}) {
        super.update(e, t, i), this.#P(i);
      }
      #C(t) {
        this.animationsInfo.enabled && Gn.#M(this),
          this._uniforms.set('u_PixelMatrix', () => {
            const i = new e.Matrix2();
            return (
              i.scale([1, Math.cos(t.transform.hpr.pitch)]), i.rotate(-t.transform.hpr.heading), i
            );
          }),
          this._uniforms.set(
            'u_Ratio',
            () => 1 / e.pixelsToTileUnits(this.tile, 1, t.style.getNearestTileZoom()),
          ),
          this._uniforms.set(
            'u_GlUnitsToPixels',
            () => new e.Vector2(t.transform.width / 2, -t.transform.height / 2),
          ),
          this._uniforms.set(
            'u_start',
            () =>
              ('history' === this.layer.paint.get('tracking-type')
                ? this.layer.histCount
                : this.layer.count) - this.layer.paint.get('tracking-seg-group'),
          ),
          this._uniforms.set('u_end', () =>
            'history' === this.layer.paint.get('tracking-type')
              ? this.layer.histCount
              : this.layer.count,
          ),
          this._uniforms.set('u_segments', () => this.layer.paint.get('tracking-seg-group')),
          this._uniforms.set('u_reverse', () => this.layer.isReverse),
          this._uniforms.set('u_reserve', () => this.layer.isReserve);
      }
      destroy() {
        (this.layer = void 0),
          (this.tile = void 0),
          (this._renderState = void 0),
          (this._defines = void 0),
          (this.type = void 0);
      }
      static updateLayerProperty(e, t) {
        const i = e.paint.get('tracking-delay'),
          s = e.paint.get('tracking-speed') ? e.paint.get('tracking-speed') : 1;
        if ('history' === e.paint.get('tracking-type')) {
          e.first ||
            ((e.first = !0),
            (e.histStart = 0),
            (e.histCount = 0),
            (e.isReverse = !1),
            (e.isReserve = !1));
          const i = t._map.timer.totalTime * s;
          'loop' === e.layout.get('tracking-display-mode')
            ? ((e.histCount = i),
              (e.histCount %= e.paint.get('tracking-seg-count')),
              (e.histCount = 0 === e.histCount ? 1 : e.histCount))
            : 'reverse' === e.layout.get('tracking-display-mode')
            ? (e.histCount >= e.paint.get('tracking-seg-count') + e.paint.get('tracking-seg-group')
                ? (e.isReverse = !0)
                : e.histCount <= 1 && (e.isReverse = !1),
              (e.histCount = e.isReverse ? e.histCount - 1 : e.histCount + 1))
            : 'loop-reserve' === e.layout.get('tracking-display-mode')
            ? ((e.isReserve = !0),
              (e.histCount = i),
              (e.histCount %= e.paint.get('tracking-seg-count')),
              (e.histCount = 0 === e.histCount ? 1 : e.histCount))
            : 'reverse-reserve' === e.layout.get('tracking-display-mode') &&
              ((e.isReserve = !0),
              e.histCount >= e.paint.get('tracking-seg-count') + e.paint.get('tracking-seg-group')
                ? (e.isReverse = !0)
                : e.histCount <= 1 && (e.isReverse = !1),
              (e.histCount = e.isReverse ? e.histCount - 1 : e.histCount + 1)),
            pr.TRW && pr.TRW.setProgress(e.histCount),
            (e.histStart = e.histEnd);
        } else {
          e.count || (e.count = 1);
          const r = t._map.timer.totalTime * s,
            n = pr.TRW,
            o = e.paint.get('tracking-run-time');
          e.count = r;
          const a = n && n.hasOwnProperty('replaceOffset') ? n.replaceOffset : o + i;
          e.count %= a;
          const l = n && n.hasOwnProperty('requestOffset') ? n.requestOffset : i;
          e.count === l && n && n.request(),
            0 === e.count && (n && n.replace(), (e.count = i)),
            n && (n.currentSeq = e.count);
        }
        Gn.checkFrwardAndBackward(e, pr);
      }
      static checkFrwardAndBackward(e, t) {
        if (t && t.TRW && 'null' !== t.TRW) {
          t.TRW.layerForwards || (t.TRW.layerForwards = []);
          for (let i = 0; i < t.TRW.layerForwards.length; i++) {
            const s = t.TRW.layerForwards[i];
            if (s.id === e.id) {
              e.count && (e.count += s.count), t.TRW.layerForwards.splice(i, 1);
              break;
            }
          }
        }
      }
      static #M(e) {
        e._uniforms.set('u_ANS_CurrentTime', () => e.animationsInfo.currentClipTime);
      }
      #P(e) {
        const { animationsInfo: t = {} } = e;
        this._uniforms.set('u_ANS_CurrentTime', () => t.currentClipTime);
      }
    }
    class Un extends e.Material {
      constructor(t) {
        super(t),
          (this.isVectorMaterial = !0),
          (this.layer = t.layer),
          (this.tile = t.tile),
          (this._programConfiguration = t.programConfiguration),
          (this._renderState = t.renderState),
          (this._unitsToPixels = new e.Vector2()),
          (this._cameraPosition = new e.Vector3()),
          (this._pixelMatrix = new e.Matrix2()),
          this.#A(t.painter);
      }
      update(t, i, s = {}) {
        super.update(t, i, s),
          (this.renderState.blending = {
            enabled: !0,
            color: { red: 0, green: 0, blue: 0, alpha: 0 },
            equationRgb: e.WebGLConstants.FUNC_ADD,
            equationAlpha: e.WebGLConstants.FUNC_ADD,
            functionSourceRgb: e.WebGLConstants.ONE,
            functionSourceAlpha: e.WebGLConstants.ONE,
            functionDestinationRgb: e.WebGLConstants.ONE,
            functionDestinationAlpha: e.WebGLConstants.ONE,
          });
      }
      #A(e) {
        this._uniforms.set('u_GlUnitsToPixels', () =>
          this._unitsToPixels.set(e.transform.width / 2, e.transform.height / 2),
        ),
          this._uniforms.set(
            'u_PixelMatrix',
            () => (
              this._pixelMatrix.identity(),
              this._pixelMatrix.scale([1, Math.cos(Math.sqrt(e.transform.hpr.pitch))]),
              this._pixelMatrix.rotate(e.transform.hpr.heading),
              this._pixelMatrix
            ),
          ),
          this._uniforms.set('u_Intensity', () => this.layer.paint.get('heatmap-intensity'));
      }
      destroy() {
        (this.layer = void 0),
          (this.tile = void 0),
          (this.pattern = void 0),
          (this.type = void 0),
          (this._uniforms = void 0),
          (this._textures = void 0),
          (this._program = void 0),
          (this._programConfiguration = void 0),
          (this._renderState = void 0),
          (this._unitsToPixels = void 0),
          (this._cameraPosition = void 0),
          (this._pixelMatrix = void 0);
      }
    }
    function zn(t) {
      const {
          layer: i,
          painter: s,
          tile: r,
          programConfiguration: n,
          isText: o,
          isSDF: a,
          sizeData: l,
          bucket: h,
        } = t,
        c = 0 !== i.paint.get(o ? 'text-halo-width' : 'icon-halo-width').constantOr(1);
      let _;
      return (
        (_ =
          i.type === e.VectorLayerType.SYMTRACKING
            ? a
              ? e.SHADER_SYMTRACKING_SDF
              : e.SHADER_SYMTRACKING_ICON
            : a
            ? e.SHADER_SYMBOL_SDF
            : e.SHADER_SYMBOL_ICON),
        (r.tileID.posMatrix = s.transform.calculatePosMatrix(r.tileID.toUnwrapped())),
        new e.SymbolMaterial({
          layer: i,
          painter: s,
          tile: r,
          programConfiguration: n,
          renderState: {},
          isText: o,
          isSDF: a,
          sizeData: l,
          bucket: h,
          type: _,
          hasHalo: c,
          modeNum: 0,
        })
      );
    }
    function Hn(t) {
      const {
          layer: i,
          painter: s,
          tile: r,
          defines: n,
          programId: o,
          parentTile: a,
          geomType: l,
        } = t,
        h = new Dn({
          layer: i,
          painter: s,
          tile: r,
          defines: n,
          type: o,
          parentTile: a,
          renderState: {},
        });
      return new e.Primitive({
        modelMatrix: l.matrix,
        geometry: l.geometry,
        material: h,
        allowPick: !1,
        keepGeometryWhenFree: !0,
      });
    }
    function Wn(t) {
      const { layer: i, painter: s, tile: r, bucket: n, tileBoundingRegion: o } = t,
        a = !e.checkIsVectorShadowVolumeDataType(i.classificationType),
        l = n.programConfigurations.get(i.id),
        h = (function (t) {
          const { bucket: i, tileBoundingRegion: s, isRegularVector: r } = t;
          return r
            ? [
                e.Geometry.fromBucket(i, e.WebGLConstants.TRIANGLES, s),
                new e.Geometry({
                  primitiveType: e.WebGLConstants.LINES,
                  vertBuffer: i.layoutVertexBuffer2 ? i.layoutVertexBuffer2 : i.layoutVertexBuffer,
                  indexBuffer: i.indexBuffer2,
                  segmentVector: i.segments2,
                  tileBoundingRegion: s,
                }),
              ]
            : [
                new e.Geometry({
                  vertBuffer: i.layoutVertexBuffer,
                  indexBuffer: i.indexBuffer,
                  segmentVector: i.segments,
                  primitiveType: e.WebGLConstants.TRIANGLES,
                  tileBoundingRegion: s,
                }),
              ];
        })({ bucket: n, tileBoundingRegion: o, isRegularVector: a }),
        c = (function (t) {
          const { layer: i, painter: s, tile: r, programConfiguration: n, isRegularVector: o } = t,
            a = {},
            l = {},
            h = i.paint.get('fill-pattern');
          return o
            ? [
                new e.VectorFillMaterial({
                  layer: i,
                  painter: s,
                  tile: r,
                  pattern: h,
                  programId: e.SHADER_FILL_COLOR,
                  plotter: this,
                  renderState: a,
                  programConfiguration: n,
                  defines: l,
                }),
                new Fn({
                  layer: i,
                  painter: s,
                  tile: r,
                  programId: e.SHADER_FILL_OUTLINE_COLOR,
                  renderState: a,
                  programConfiguration: n,
                  defines: l,
                }),
              ]
            : [
                new e.VectorFillMaterial({
                  layer: i,
                  painter: s,
                  tile: r,
                  pattern: h,
                  programId: e.SHADER_FILL_COLOR,
                  renderState: a,
                  programConfiguration: n,
                  defines: l,
                  shadowVolumeMaterial: !0,
                }),
              ];
        })({ layer: i, painter: s, tile: r, programConfiguration: l, isRegularVector: a }),
        _ = n.matrix;
      return {
        fill: new e.Primitive({ modelMatrix: _, geometry: h[0], material: c[0] }),
        outline: h[1]
          ? new e.Primitive({ modelMatrix: _, geometry: h[1], material: c[1] })
          : void 0,
      };
    }
    function jn(t) {
      const {
          layer: i,
          painter: s,
          tile: r,
          bucket: n,
          tileBoundingRegion: o,
          sourceMaxZoom: a,
          animationsInfo: l,
        } = t,
        h = !e.checkIsVectorShadowVolumeDataType(i.classificationType),
        c = n.programConfigurations.get(i.id),
        _ = n.matrix,
        u = (function (t) {
          const {
              layer: i,
              painter: s,
              tile: r,
              bucket: n,
              programConfiguration: o,
              isRegularVector: a,
              sourceMaxZoom: l,
              animationsInfo: h,
            } = t,
            c = {},
            _ = {},
            u = 'visible' === i.layout.get('border-visibility'),
            d = i.paint.get('line-gradient');
          let m;
          if (
            (i.type == e.VectorLayerType.LINE
              ? (m = i.paint.get('line-dasharray')
                  ? e.SHADER_LINE_SDF
                  : i.paint.get('line-pattern')
                  ? e.SHADER_LINE_PATTERN
                  : i.paint.get('line-gradient')
                  ? e.SHADER_LINE_GRADIENT
                  : e.SHADER_LINE_COLOR)
              : i.type == e.VectorLayerType.TRACKING
              ? (Gn.updateLayerProperty(i, s), (m = e.SHADER_LINE_TRACKING_COLOR))
              : i.type == e.VectorLayerType.SPRITE &&
                (e.SpriteMaterial.updateLayerProperty(i, s),
                (m = n.hasPattern ? e.SHADER_LINE_SPRITE_PATTERN : e.SHADER_LINE_SPRITE_COLOR)),
            a)
          ) {
            let t;
            return (
              (t =
                'tracking' === i.type
                  ? new Gn({
                      type: m,
                      layer: i,
                      painter: s,
                      tile: r,
                      renderState: c,
                      defines: _,
                      programConfiguration: o,
                      animationsInfo: h,
                    })
                  : 'sprite' === i.type
                  ? new e.SpriteMaterial({
                      type: m,
                      layer: i,
                      painter: s,
                      tile: r,
                      renderState: c,
                      defines: _,
                      programConfiguration: o,
                    })
                  : new e.VectorLineMaterial({
                      layer: i,
                      painter: s,
                      tile: r,
                      isBorder: u,
                      sourceMaxZoom: l,
                      bucket: n,
                      lineGradient: d,
                      type: m,
                      programConfiguration: o,
                      defines: _,
                      renderState: c,
                    })),
              t
            );
          }
          return new e.VectorLineMaterial({
            layer: i,
            painter: s,
            tile: r,
            isBorder: u,
            sourceMaxZoom: l,
            bucket: n,
            lineGradient: d,
            type: m,
            programConfiguration: o,
            defines: _,
            renderState: c,
          });
        })({
          layer: i,
          painter: s,
          tile: r,
          bucket: n,
          programConfiguration: c,
          isRegularVector: h,
          sourceMaxZoom: a,
          animationsInfo: l,
        }),
        d = (function (t) {
          const { bucket: i, tileBoundingRegion: s, isRegularVector: r } = t;
          if (r) {
            const t = new e.Geometry({
              vertBuffer: i.layoutVertexBuffer,
              indexBuffer: i.indexBuffer,
              segmentVector: i.segments,
              dynamicLayoutBuffer1: i.layoutVertexBuffer2 || void 0,
              primitiveType: e.WebGLConstants.TRIANGLES,
              tileBoundingRegion: s,
            });
            return i._animationFlag && (t.animationVertexBuffers = i.animationVertexBuffers), t;
          }
          return new e.Geometry({
            vertBuffer: i.layoutVertexBuffer,
            indexBuffer: i.indexBuffer,
            segmentVector: i.segments,
            primitiveType: e.WebGLConstants.TRIANGLES,
            tileBoundingRegion: s,
          });
        })({ bucket: n, tileBoundingRegion: o, isRegularVector: h });
      return { line: new e.Primitive({ modelMatrix: _, geometry: d, material: u }) };
    }
    function qn(t) {
      const {
          layer: i,
          painter: s,
          tile: r,
          type: n,
          defines: o,
          bucket: a,
          tileBoundingRegion: l,
        } = t,
        h = a.programConfigurations.get(i.id),
        c = new e.VectorCircleMaterial({
          layer: i,
          painter: s,
          tile: r,
          type: n,
          programConfiguration: h,
          renderState: {},
          defines: o,
        }),
        _ = (function (t) {
          const { bucket: i, tileBoundingRegion: s } = t;
          return new e.Geometry({
            vertBuffer: i.layoutVertexBuffer,
            indexBuffer: i.indexBuffer,
            segmentVector: i.segments,
            dynamicLayoutBuffer1: i.layoutVertexBuffer2 || void 0,
            primitiveType: e.WebGLConstants.TRIANGLES,
            tileBoundingRegion: s,
          });
        })({ bucket: a, tileBoundingRegion: l });
      return new e.Primitive({ modelMatrix: a.matrix, geometry: _, material: c });
    }
    function Xn(t) {
      const {
        layer: i,
        painter: s,
        tile: r,
        defines: n,
        bucket: o,
        tileBoundingRegion: a,
        animationsInfo: l,
      } = t;
      let h = null;
      const c = {},
        _ = o.programConfigurations.get(i.id);
      switch (i.type) {
        case 'extrusion':
          h = new e.VectorExtrusionMaterial({
            layer: i,
            painter: s,
            tile: r,
            bucket: o,
            programConfiguration: _,
            defines: n,
            renderState: c,
            animationsInfo: l,
          });
          break;
        case 'histogram':
          h = new kn({
            layer: i,
            painter: s,
            tile: r,
            bucket: o,
            programConfiguration: _,
            defines: n,
            renderState: c,
          });
      }
      const u = (function (t) {
        const { bucket: i, tileBoundingRegion: s } = t;
        return e.Geometry.fromBucket(i, e.WebGLConstants.TRIANGLES, s);
      })({ bucket: o, tileBoundingRegion: a });
      return new e.Primitive({ modelMatrix: o.matrix, geometry: u, material: h });
    }
    function Zn(t) {
      const { layer: i, painter: s, tile: r, bucket: n, tileBoundingRegion: o } = t,
        a = n.matrix,
        l = (function (t) {
          const { layer: i, painter: s, tile: r, programConfiguration: n } = t;
          return new Un({
            layer: i,
            painter: s,
            tile: r,
            type: e.SHADER_HEATMAP_COLOR,
            renderState: {},
            programConfiguration: n,
            defines: {},
          });
        })({
          layer: i,
          painter: s,
          tile: r,
          programConfiguration: n.programConfigurations.get(i.id),
        }),
        h = (function (t) {
          const { bucket: i, tileBoundingRegion: s } = t;
          return new e.Geometry({
            vertBuffer: i.layoutVertexBuffer,
            indexBuffer: i.indexBuffer,
            segmentVector: i.segments,
            dynamicLayoutBuffer1: i.layoutVertexBuffer2 || void 0,
            primitiveType: e.WebGLConstants.TRIANGLES,
            tileBoundingRegion: s,
          });
        })({ bucket: n, tileBoundingRegion: o });
      return new e.Primitive({ modelMatrix: a, geometry: h, material: l });
    }
    function $n(t) {
      const { layer: i, painter: s, tile: r, geomType: n, isGlobe: o } = t,
        a = i.paint.get('background-terrain-analysis').value._parameters;
      let l;
      if (a) {
        const t = e.TerrainTileParser.genShaderScript(a);
        l = new Bn({
          layer: i,
          painter: s,
          tileID: r.tileID,
          renderState: { depthTest: e.renderStateEnum.enableDepthTest },
          type: 'background-analysis',
          defines: e.addColorDefines(a),
          vertexSource: e.reduceComma(t.vs),
          fragmentSource: e.reduceComma(t.fs),
          noCache: !0,
        });
      } else l = new Bn({ layer: i, painter: s, renderState: {}, tileID: r.tileID });
      if (o) {
        const t = new Vn({ radius: e.CONSTS.TRANSFORM.R, widthSegments: 256, heightSegments: 128 });
        return new e.Primitive({ material: l, modelMatrix: new e.Matrix4(), geometry: t });
      }
      return new e.Primitive({
        modelMatrix: n.matrix,
        geometry: n.geometry,
        material: l,
        keepGeometryWhenFree: !0,
      });
    }
    function Kn(t) {
      const { layer: i, painter: s, tile: r, bucket: n, tileBoundingRegion: o } = t,
        a = {},
        l = [
          { name: 'icon', readyToCreate: 0 !== i.paint.get('icon-opacity').constantOr(1) },
          { name: 'text', readyToCreate: 0 !== i.paint.get('text-opacity').constantOr(1) },
        ];
      let h, c;
      if (r.symbolPickIdObject[i.id]) for (const e of r.symbolPickIdObject[i.id]) e.destroy();
      r.symbolPickIdObject[i.id] = [];
      for (let t = 0; t < 2; t++) {
        const _ = l[t];
        if (!_.readyToCreate) continue;
        const u = _.name,
          d = 'text' == u,
          m = d ? n.text : n.icon;
        if (!m || !m.segments.get().length) continue;
        const p = d ? n.textSizeData : n.iconSizeData,
          f = n.matrix,
          g = zn({
            symbolType: u,
            layer: i,
            painter: s,
            tile: r,
            isText: d,
            isSDF: d || n.sdfIcons,
            programConfiguration: m.programConfigurations.get(i.id),
            sizeData: p,
            bucket: n,
          });
        if (n.pickColor && !h && !c) {
          const t = new e.StructArrayLayout4f16(),
            o = new e.StructArrayLayout4f16();
          for (const e of n.symbolInstances) {
            const a = Yn(n, r, e.featureIndex, i);
            a.isSymbolData = !0;
            const l = s.context.createPickId(a);
            r.symbolPickIdObject[i.id].push(l);
            const h = e.numIconVertices > 0;
            if (e.numGlyphVertices > 0 || e.numVerticalGlyphVertices > 0)
              for (let i = 0; i < e.numGlyphVertices + e.numVerticalGlyphVertices; i++)
                t.emplaceBack(l.color.r, l.color.g, l.color.b, l.color.a);
            if (h)
              for (let t = 0; t < e.numIconVertices; t++)
                o.emplaceBack(l.color.r, l.color.g, l.color.b, l.color.a);
          }
          (h = s.context.createVertexBuffer(t, e.pickColorAttributes.members, !0)),
            (c = s.context.createVertexBuffer(o, e.pickColorAttributes.members, !0));
        }
        const y = Nn({
            buffers: m,
            symbolType: u,
            tileBoundingRegion: o,
            bucket: n,
            pickColorVertexBuffer: d ? h : c,
          }),
          T = new e.Primitive({ modelMatrix: f, geometry: y, material: g, allowPick: n.pickColor });
        a[u] = T;
      }
      return a;
    }
    function Yn(e, t, i, s) {
      return {
        evaluate: () => {
          const r = s.id;
          return t.latestFeatureIndex.lookupSymbolFeatures(
            [i],
            e.index,
            e.sourceLayerIndex,
            null,
            [r],
            { [r]: s },
          )[r][0].feature;
        },
      };
    }
    const Qn = 'TERRAIN_SOURCE_ID_MINEMAP_001',
      Jn = 'TERRAIN',
      eo = 'REGULAR',
      to = `MINEMAP_BACKGROUND_ID_UNIQUE${Math.random()}`,
      io = `MINEMAP_BACKGROUND_LAYER_FOR_DEPTH_UNIQUE_ID${Math.random()}`,
      so = to,
      ro = io;
    class no {
      constructor(t) {
        const {
          tileID: i,
          tileSize: s,
          projType: r,
          tilePrimitiveType: n,
          sourceId: o,
          style: a,
        } = t;
        (this.symbolPickIdObject = {}),
          (this.tileID = i),
          (this.uid = e.uniqueId()),
          (this.uses = 0),
          (this.tileSize = s),
          (this.buckets = {}),
          (this.primitiveMap = new Map()),
          (this.expirationTime = null),
          (this.queryPadding = 0),
          (this.hasSymbolBuckets = !1),
          (this.hasRTLText = !1),
          (this.sourceId = o),
          (this.style = a),
          (this.dependencies = {}),
          (this.expiredRequestCount = 0),
          (this.state = 'loading'),
          (this.projType = r || e.ProjectionType.MERCATOR),
          (this.tilePrimitiveType = n);
      }
      registerFadeDuration(t) {
        const i = t + this.timeAdded;
        i < e.exported.now() ||
          (this.fadeEndTime && i < this.fadeEndTime) ||
          (this.fadeEndTime = i);
      }
      wasRequested() {
        return 'errored' === this.state || 'loaded' === this.state || 'reloading' === this.state;
      }
      loadVectorData(t, i, s) {
        if ((this.hasData() && this.unloadVectorData(), (this.state = 'loaded'), t)) {
          if (
            (t.featureIndex &&
              ((this.latestFeatureIndex = t.featureIndex),
              t.rawTileData
                ? ((this.latestRawTileData = t.rawTileData),
                  (this.latestFeatureIndex.rawTileData = t.rawTileData))
                : this.latestRawTileData &&
                  (this.latestFeatureIndex.rawTileData = this.latestRawTileData)),
            (this.collisionBoxArray = t.collisionBoxArray),
            (this.buckets = (function (e, t) {
              const i = {};
              if (!t) return i;
              for (const s of e) {
                const e = s.layerIds.map((e) => t.getLayer(e)).filter(Boolean);
                if (0 !== e.length) {
                  (s.layers = e), (s.stateDependentLayers = e.filter((e) => e.isStateDependent()));
                  for (const t of e) i[t.id] = s;
                }
              }
              return i;
            })(t.buckets, i.style)),
            s)
          )
            for (const t in this.buckets) {
              const i = this.buckets[t];
              (i.type != e.VectorLayerType.SYMTRACKING && i.type != e.VectorLayerType.SYMBOL) ||
                (i.justReloaded = !0);
            }
          this.hasSymbolBuckets = !1;
          for (const t in this.buckets) {
            const i = this.buckets[t];
            if (i.type == e.VectorLayerType.SYMBOL) {
              if (((this.hasSymbolBuckets = !0), !s)) break;
              i.justReloaded = !0;
            }
          }
          if (((this.hasRTLText = !1), this.hasSymbolBuckets))
            for (const t in this.buckets) {
              const i = this.buckets[t];
              if (i.type == e.VectorLayerType.SYMBOL && i.hasRTLText) {
                (this.hasRTLText = !0), e.lazyLoadRTLTextPlugin();
                break;
              }
            }
          this.queryPadding = 0;
          for (const e in this.buckets) {
            const t = this.buckets[e];
            this.queryPadding = Math.max(
              this.queryPadding,
              i.style.getLayer(t.layerIds[0]).queryRadius(t),
            );
          }
          t.imageAtlas && (this.imageAtlas = t.imageAtlas),
            t.glyphAtlasImage && (this.glyphAtlasImage = t.glyphAtlasImage);
        } else this.collisionBoxArray = new e.CollisionBoxArray();
      }
      _releaseTileSupplierMesh(e) {
        e.keepGeometryWhenFree &&
          this.style.terrainSourceCache.supplier.removeGeometryByTileKey(this.tileID.key);
      }
      unloadVectorData() {
        this.primitiveMap.forEach((t) => {
          const i = t;
          if (i instanceof e.Primitive) this._releaseTileSupplierMesh(i), i.destroy();
          else if (Array.isArray(i))
            for (let e = 0; e < i.length; e++) this._releaseTileSupplierMesh(i[e]), i[e].destroy();
          else
            for (const t in i) {
              const s = i[t];
              if (s instanceof e.Primitive) this._releaseTileSupplierMesh(s), s.destroy();
              else if (Array.isArray(s))
                for (let e = 0; e < s.length; e++)
                  this._releaseTileSupplierMesh(s[e]), s[e].destroy();
            }
        }),
          this.primitiveMap.clear();
        for (const e in this.buckets) {
          const t = this.buckets[e];
          if (this.symbolPickIdObject[e]) for (const t of this.symbolPickIdObject[e]) t.destroy();
          (this.symbolPickIdObject[e] = []), t.destroy();
        }
        (this.buckets = {}),
          this.imageAtlas && (this.imageAtlas = null),
          this.imageAtlasTexture && this.imageAtlasTexture.destroy(),
          this.glyphAtlasImage && (this.glyphAtlasImage = null),
          this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(),
          (this.latestFeatureIndex = null),
          (this.state = 'unloaded');
      }
      loadImage(t) {
        const { painter: i, callback: s, url: r } = t;
        let n = t.data;
        const o = i.context;
        if (n.img)
          if (e.window.hasOwnProperty('createImageBitmap')) {
            let i = e.window.createImageBitmap(n.img);
            i.then((r) => {
              const a = o.gl;
              (this.texture = new e.Texture({
                context: o,
                image: r,
                pixelFormat: e.WebGLConstants.RGBA,
                useMipmap: !1,
              })),
                this.texture.bind(e.WebGLConstants.LINEAR, e.WebGLConstants.CLAMP_TO_EDGE),
                o.extTextureFilterAnisotropic &&
                  (a.bindTexture(this.texture._target, this.texture.texture),
                  a.texParameterf(
                    e.WebGLConstants.TEXTURE_2D,
                    o.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,
                    e.ContextLimits._maximumTextureFilterAnisotropy,
                  ),
                  a.bindTexture(this.texture._target, null)),
                (n.img = null),
                (n = null),
                (r = null),
                (this.state = 'loaded'),
                (t.url = null),
                (t.painter = null),
                (t = null),
                s(null),
                (i = null);
            });
          } else
            (this.texture = new e.Texture({
              context: o,
              image: n.img,
              pixelFormat: e.WebGLConstants.RGBA,
              useMipmap: !1,
            })),
              this.texture.bind(e.WebGLConstants.LINEAR, e.WebGLConstants.CLAMP_TO_EDGE),
              (n.img = null),
              (n = null),
              (t.url = null),
              (t.painter = null),
              (t = null),
              (this.state = 'loaded');
        else
          e.getImage({ url: r }, (t, i) => {
            if (t) throw new Error(t);
            (this.texture = new e.Texture({
              context: o,
              image: i,
              pixelFormat: e.WebGLConstants.RGBA,
              useMipmap: !1,
            })),
              this.texture.bind(e.WebGLConstants.LINEAR, e.WebGLConstants.CLAMP_TO_EDGE),
              (i = null),
              (this.state = 'loaded'),
              s(null);
          });
        this._createOrCheckPrimitives();
      }
      checkCurrentSourceOfLayer(e) {
        return e.source == this.sourceId;
      }
      _createOrCheckPrimitives() {
        const t = this.style,
          i = t.map.painter,
          s = t.terrainSourceCache;
        if ('raster' == this.tilePrimitiveType) {
          if (s.supplier._proxyGetGeometryByTileId(this.tileID)) {
            const r = t._layers;
            for (const t in r) {
              const n = r[t];
              if (
                this.checkCurrentSourceOfLayer(n) &&
                n.source == this.sourceId &&
                !this.primitiveMap.has(t)
              ) {
                const r = s.supplier.getGeometryByTileId(this.tileID);
                this.primitiveMap.set(
                  t,
                  Hn({
                    layer: n,
                    painter: i,
                    tile: this,
                    defines: {},
                    programId: e.SHADER_RASTER,
                    parentTile: null,
                    geomType: r,
                  }),
                );
              }
            }
          }
        } else if ('background' == this.tilePrimitiveType) {
          if (s.supplier._proxyGetGeometryByTileId(this.tileID)) {
            const r = t._layers;
            for (const t in r) {
              const n = r[t];
              if (n.type == e.VectorLayerType.BACKGROUND && !this.primitiveMap.has(t)) {
                const e = s.supplier.getGeometryByTileId(this.tileID);
                this.primitiveMap.set(t, $n({ layer: n, painter: i, tile: this, geomType: e }));
              }
            }
            const n = t.backgroundDepthRenderLayer;
            if (n.paint && !this.primitiveMap.has(ro)) {
              if (!this.primitiveMap.has(ro)) {
                const e = s.supplier.getGeometryByTileId(this.tileID);
                this.primitiveMap.set(ro, $n({ layer: n, painter: i, tile: this, geomType: e }));
              }
              e.defined(n.mercatorGlobePrimitive) ||
                (n.mercatorGlobePrimitive = $n({ layer: n, painter: i, tile: this, isGlobe: !0 }));
            }
          }
          this.state = 'loaded';
        } else if ('vector' == this.tilePrimitiveType) {
          const i = t._layers,
            s = t.terrainSourceCache.quadtree.getBoundingRegionById(this.tileID.key);
          for (const r in i) {
            const n = i[r];
            if (!this.checkCurrentSourceOfLayer(n)) continue;
            if (this.primitiveMap.has(r)) continue;
            const o = this.getBucket(n);
            if (e.defined(o))
              if (n.type == e.VectorLayerType.CIRCLE)
                this.primitiveMap.set(
                  r,
                  qn({
                    layer: n,
                    painter: t.map.painter,
                    tile: this,
                    type: e.SHADER_CIRCLE,
                    bucket: o,
                    tileBoundingRegion: s,
                  }),
                );
              else if (
                n.type == e.VectorLayerType.EXTRUSION ||
                n.type == e.VectorLayerType.HISTOGRAM
              )
                this.primitiveMap.set(
                  r,
                  Xn({
                    layer: n,
                    painter: t.map.painter,
                    tile: this,
                    bucket: o,
                    tileBoundingRegion: s,
                    animationsInfo: t.getSource(n.source).animationsInfo,
                  }),
                );
              else if (n.type == e.VectorLayerType.FILL)
                this.primitiveMap.set(
                  r,
                  Wn({
                    layer: n,
                    painter: t.map.painter,
                    tile: this,
                    bucket: o,
                    tileBoundingRegion: s,
                  }),
                );
              else if (
                n.type == e.VectorLayerType.TRACKING ||
                n.type == e.VectorLayerType.SPRITE ||
                n.type == e.VectorLayerType.LINE
              ) {
                const e = t.getSource(n.source);
                this.primitiveMap.set(
                  r,
                  jn({
                    layer: n,
                    painter: t.map.painter,
                    tile: this,
                    bucket: o,
                    tileBoundingRegion: s,
                    sourceMaxZoom: e.maxzoom,
                    animationsInfo: e.animationsInfo,
                  }),
                );
              } else
                n.type == e.VectorLayerType.SYMBOL || n.type == e.VectorLayerType.SYMTRACKING
                  ? this.primitiveMap.set(
                      r,
                      Kn({
                        layer: n,
                        painter: t.map.painter,
                        tile: this,
                        bucket: o,
                        tileBoundingRegion: s,
                      }),
                    )
                  : n.type == e.VectorLayerType.HEATMAP &&
                    this.primitiveMap.set(
                      r,
                      Zn({
                        layer: n,
                        painter: t.map.painter,
                        tile: this,
                        bucket: o,
                        tileBoundingRegion: s,
                      }),
                    );
          }
        }
      }
      getBucket(e) {
        return this.buckets[e.id];
      }
      upload(t) {
        for (const e in this.buckets) {
          const i = this.buckets[e];
          i.uploadPending() && i.upload(t);
        }
        this.imageAtlas &&
          !this.imageAtlas.uploaded &&
          ((this.imageAtlasTexture = new e.Texture({
            context: t,
            image: this.imageAtlas.image,
            pixelFormat: e.WebGLConstants.RGBA,
          })),
          (this.imageAtlas.uploaded = !0)),
          this.glyphAtlasImage &&
            ((this.glyphAtlasTexture = new e.Texture({
              context: t,
              image: this.glyphAtlasImage,
              pixelFormat: e.WebGLConstants.ALPHA,
            })),
            (this.glyphAtlasImage = null)),
          'raster' !== this.tilePrimitiveType && this._createOrCheckPrimitives();
      }
      prepare(e) {
        this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture);
      }
      queryRenderedFeatures(e, t, i, s, r, n, o, a, l, h) {
        return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData
          ? this.latestFeatureIndex.query(
              {
                queryGeometry: i,
                cameraQueryGeometry: s,
                scale: r,
                tileSize: this.tileSize,
                posMatrix: l,
                transform: o,
                params: n,
                queryPadding: this.queryPadding * a,
              },
              e,
              t,
              h,
            )
          : {};
      }
      querySourceFeatures(t, i) {
        if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData) return;
        const s = this.latestFeatureIndex.loadVTLayers(),
          r = s._geojsonTileLayer || s[i ? i.sourceLayer : ''];
        if (!r) return;
        const n = e.createFilter(i && i.filter),
          o = {
            z: this.tileID.overscaledZ,
            x: this.tileID.canonical.x,
            y: this.tileID.canonical.y,
          };
        for (let i = 0; i < r.length; i++) {
          const s = r.feature(i);
          if (n(new e.EvaluationParameters(this.tileID.overscaledZ), s)) {
            const i = new e.Feature(s, o.z, o.x, o.y);
            (i.tile = o), t.push(i);
          }
        }
      }
      clearMask() {}
      setMask(e) {
        t(this.mask, e) || ((this.mask = e), this.clearMask());
      }
      _xyToECEF(t, i, s, r, n) {
        const o = this._xToLng(r, i, n),
          a = this._yToLat(r, s, n),
          l = e.Transforms.cartographicToCartesian3(new e.Vector3([o, a, 0]));
        return (t[0] = l[0]), (t[1] = l[1]), (t[2] = l[2]), l;
      }
      _xToLng(t, i, s) {
        return t.xLng(this.tileID.canonical.x + i / e.EXTENT, s);
      }
      _yToLat(t, i, s) {
        return t.yLat(this.tileID.canonical.y + i / e.EXTENT, s);
      }
      hasData() {
        if ('loading' === this.state && 'raster' === this.tilePrimitiveType) {
          for (const e of this.imagery) {
            if ('loading' == e.imagery.state) return !1;
            if ('loaded' === e.imagery.state)
              return (this.state = 'loaded'), this._createOrCheckPrimitives(), !0;
          }
          return (this.state = 'errored'), this._createOrCheckPrimitives(), !1;
        }
        return 'background' == this.tilePrimitiveType
          ? this.primitiveMap.size > 0 &&
              ('loaded' === this.state || 'reloading' === this.state || 'expired' === this.state)
          : 'loaded' === this.state || 'reloading' === this.state || 'expired' === this.state;
      }
      patternsLoaded() {
        return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
      }
      setExpiryData(t) {
        const i = this.expirationTime;
        if (t.cacheControl) {
          const i = e.parseCacheControl(t.cacheControl);
          i['max-age'] && (this.expirationTime = Date.now() + 1e3 * i['max-age']);
        } else t.expires && (this.expirationTime = new Date(t.expires).getTime());
        if (this.expirationTime) {
          const t = Date.now();
          let s = !1;
          if (this.expirationTime > t) s = !1;
          else if (i)
            if (this.expirationTime < i) s = !0;
            else {
              const r = this.expirationTime - i;
              r
                ? (this.expirationTime = t + Math.max(r, e.CONSTS.SOURCE.CLOCK_SKEW_RETRY_TIMEOUT))
                : (s = !0);
            }
          else s = !0;
          s
            ? (this.expiredRequestCount++, (this.state = 'expired'))
            : (this.expiredRequestCount = 0);
        }
      }
      getExpiryTimeout() {
        if (this.expirationTime)
          return this.expiredRequestCount
            ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31))
            : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);
      }
      setFeatureState(e, t) {
        if (
          !this.latestFeatureIndex ||
          !this.latestFeatureIndex.rawTileData ||
          0 === Object.keys(e).length
        )
          return;
        const i = this.latestFeatureIndex.loadVTLayers();
        for (const s in this.buckets) {
          const r = this.buckets[s],
            n = r.layers[0].sourceLayer || '_geojsonTileLayer',
            o = i[n],
            a = e[n];
          o &&
            a &&
            0 !== Object.keys(a).length &&
            (r.update(a, o),
            t &&
              t.style &&
              (this.queryPadding = Math.max(
                this.queryPadding,
                t.style.getLayer(r.layerIds[0]).queryRadius(r),
              )));
        }
      }
      setDependencies(e, t) {
        const i = {};
        for (const e of t) i[e] = !0;
        this.dependencies[e] = i;
      }
      hasDependency(e, t) {
        for (const i of e) {
          const e = this.dependencies[i];
          if (e) for (const i of t) if (e[i]) return !0;
        }
        return !1;
      }
    }
    class oo {
      constructor(e, t) {
        (this.max = e), (this.onRemove = t), this.reset();
      }
      reset() {
        for (const e in this.data)
          for (const t of this.data[e])
            t.timeout && clearTimeout(t.timeout), this.onRemove(t.value);
        return (this.data = {}), (this.order = []), this;
      }
      add(e, t, i) {
        const s = e.wrapped().key;
        void 0 === this.data[s] && (this.data[s] = []);
        const r = { value: t, timeout: void 0 };
        if (
          (void 0 !== i &&
            (r.timeout = setTimeout(() => {
              this.remove(e, r);
            }, i)),
          this.data[s].push(r),
          this.order.push(s),
          this.order.length > this.max)
        ) {
          const e = this._getAndRemoveByKey(this.order[0]);
          e && this.onRemove(e);
        }
        return this;
      }
      has(e) {
        return e.wrapped().key in this.data;
      }
      getAndRemove(e) {
        return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null;
      }
      _getAndRemoveByKey(e) {
        const t = this.data[e].shift();
        return (
          t.timeout && clearTimeout(t.timeout),
          0 === this.data[e].length && delete this.data[e],
          this.order.splice(this.order.indexOf(e), 1),
          t.value
        );
      }
      get(e) {
        return this.has(e) ? this.data[e.wrapped().key][0].value : null;
      }
      getByKey(e) {
        const t = this.data[e];
        return t ? t[0].value : null;
      }
      remove(e, t) {
        if (!this.has(e)) return this;
        const i = e.wrapped().key,
          s = void 0 === t ? 0 : this.data[i].indexOf(t),
          r = this.data[i][s];
        return (
          this.data[i].splice(s, 1),
          r.timeout && clearTimeout(r.timeout),
          0 === this.data[i].length && delete this.data[i],
          this.onRemove(r.value),
          this.order.splice(this.order.indexOf(i), 1),
          this
        );
      }
      setMaxSize(e) {
        for (this.max = e; this.order.length > this.max; ) {
          const e = this._getAndRemoveByKey(this.order[0]);
          e && this.onRemove(e);
        }
        return this;
      }
      filter(e) {
        const t = [];
        for (const i in this.data) for (const s of this.data[i]) e(s.value) || t.push(s);
        for (const e of t) this.remove(e.value.tileID, e);
      }
    }
    class ao extends e.Evented {
      constructor(t, i, s) {
        super(),
          (this.id = t),
          (this.dispatcher = s),
          this.on('data', (e) => {
            'source' === e.dataType && 'metadata' === e.sourceDataType && (this._sourceLoaded = !0),
              this._sourceLoaded &&
                !this._paused &&
                'source' === e.dataType &&
                'content' === e.sourceDataType &&
                (this.reload(), this.map.transform && this.update(this.map.transform));
          }),
          this.on('error', () => {
            this._sourceErrored = !0;
          });
        const r = So(t, i, s, this);
        (this._source = r),
          (this._tiles = {}),
          (this._cache = new oo(0, this._unloadTile.bind(this))),
          (this._timers = {}),
          (this._cacheTimers = {}),
          (this._maxTileCacheSize = null),
          (this._isIdRenderable = this._isIdRenderable.bind(this)),
          (this._coveredTiles = {}),
          (this._state = new Ln()),
          (this.sourceType = i.type),
          (this._loadedParentTiles = {}),
          (this._ancientCoverageTiles = {}),
          (this._referenceTiles = {}),
          (this.customHeight = {
            minimumHeight: e.defined(i.customHeight) ? i.customHeight.minimumHeight : void 0,
            maximumHeight: e.defined(i.customHeight) ? i.customHeight.maximumHeight : void 0,
          });
      }
      onAdd(e) {
        (this.map = e),
          (this._maxTileCacheSize = e ? e._maxTileCacheSize : null),
          this._source && this._source.onAdd && this._source.onAdd(e);
        const t = this.coveringTiles();
        (this.currentMaxTileZoom = co(t).currentMaxTileZoom),
          (this.currentMinTileZoom = co(t).currentMaxTileZoom);
      }
      onRemove(e) {
        this._source && this._source.onRemove && this._source.onRemove(e);
      }
      loaded() {
        if (this._sourceErrored) return !0;
        if ('3d-model' === this._source.type && 'loaded' === this._source.state)
          return (this._sourceLoaded = !0), !0;
        if (!this._sourceLoaded) return !1;
        for (const e in this._tiles) {
          const t = this._tiles[e];
          if ('loaded' !== t.state && 'errored' !== t.state) return !1;
        }
        return '3d-model' !== this._source.type || 'loaded' === this._source.state;
      }
      getSource() {
        return this._source;
      }
      pause() {
        this._paused = !0;
      }
      resume() {
        if (!this._paused) return;
        const e = this._shouldReloadOnResume;
        (this._paused = !1),
          (this._shouldReloadOnResume = !1),
          e && this.reload(),
          this.map && this.update();
      }
      _loadTile(e, t) {
        return this._source.loadTile(e, t);
      }
      _unloadTile(e) {
        if (this._source.unloadTile) return this._source.unloadTile(e, () => {});
      }
      _abortTile(e) {
        if (this._source.abortTile) return this._source.abortTile(e, () => {});
      }
      serialize() {
        return this._source.serialize();
      }
      prepare(e) {
        this._source.prepare && this._source.prepare(),
          this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
        for (const t in this._tiles)
          this._tiles[t].upload(e),
            this._tiles[t].prepare(this.map.style.imageManager, this.map.style.terrainSourceCache);
      }
      getIds() {
        return Object.keys(this._tiles)
          .map(String)
          .sort((e, t) => this._tiles[e].tileID.overscaledZ - this._tiles[t].tileID.overscaledZ);
      }
      getRenderableIds() {
        return this.getIds().filter(this._isIdRenderable);
      }
      hasRenderableParent(e) {
        const t = this.findLoadedParent(e, 0);
        return !!t && this._isIdRenderable(t.tileID.key);
      }
      _isIdRenderable(e) {
        return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e];
      }
      reload(e) {
        if (this._paused) this._shouldReloadOnResume = !0;
        else if ((this._cache.reset(), e))
          for (const e in this._tiles)
            'errored' !== this._tiles[e].state && this._reloadTile(e, 'expired');
        else
          for (const e in this._tiles)
            'errored' !== this._tiles[e].state && this._reloadTile(e, 'reloading');
      }
      _reloadTile(e, t) {
        const i = this._tiles[e];
        i &&
          ('loading' !== i.state && (i.state = t),
          this._loadTile(i, this._tileLoaded.bind(this, i, e, t)));
      }
      _tileLoaded(t, i, s, r) {
        if (r) {
          if (((t.state = 'errored'), t._createOrCheckPrimitives(), 'aborted' === r)) return;
          404 !== r.status ? this._source.fire(new e.ErrorEvent(r, { tile: t })) : this.update();
        } else {
          if ('raster' === t.tilePrimitiveType) {
            t.imageryOrigin &&
              'loaded' === t.imageryOrigin[0].imagery.state &&
              (t.imagery[0].freeResources(t.tileID.key),
              (t.imagery = t.imageryOrigin),
              delete t.imageryOrigin);
            for (const e of t.imagery) if ('loaded' !== e.imagery.state) return;
            (t.state = 'loaded'), t._createOrCheckPrimitives();
          }
          (t.timeAdded = e.exported.now()),
            'expired' === s && (t.refreshedUponExpiration = !0),
            this._setTileReloadTimer(i, t),
            this._state.initializeTileState(t, this.map ? this.map.painter : null),
            this._source.fire(
              new e.Event('data', { dataType: 'source', tile: t, coord: t.tileID }),
            );
        }
      }
      getTile(e) {
        return this.getTileByID(e.key);
      }
      getTileByID(e) {
        return this._tiles[e];
      }
      getZoom(e) {
        return (
          this.map.style.getNearestTileZoom() + e.scaleZoom(e.tileSize / this._source.tileSize)
        );
      }
      _retainLoadedChildren(e, t, i, s) {
        for (const r in this._tiles) {
          let n = this._tiles[r];
          if (s.has(r) || !n.hasData() || n.tileID.overscaledZ <= t || n.tileID.overscaledZ > i)
            continue;
          let o = n.tileID;
          for (; n && n.tileID.overscaledZ > t + 1; ) {
            const e = n.tileID.scaledTo(n.tileID.overscaledZ - 1);
            (n = this._tiles[e.key]), n && n.hasData() && (o = e);
          }
          let a = o;
          for (; a.overscaledZ > t; )
            if (((a = a.scaledTo(a.overscaledZ - 1)), e[a.key])) {
              s.set(o.key, o);
              break;
            }
        }
      }
      findLoadedParent(e, t) {
        if (e.key in this._loadedParentTiles) {
          const i = this._loadedParentTiles[e.key];
          return i && i.tileID.overscaledZ >= t ? i : null;
        }
        for (let i = e.overscaledZ - 1; i >= t; i--) {
          const t = e.scaledTo(i),
            s = this._getLoadedTile(t);
          if (s) return s;
        }
      }
      updateCacheSize() {
        this._cache.setMaxSize(5 * this.quadtree?.getOverscaledTileIDs().length || 64);
      }
      createQuadtree() {
        if (e.defined(this.quadtree)) return;
        const t = this._source.tileSize,
          i = this.map.style.terrainSourceCache.isTerrain();
        this.quadtree = ho({
          isLngLat: this.map.transform.projection === e.ProjectionType.LATLON,
          tileSize: t,
          hasTerrainLayerFlag: i,
          drawingBufferHeight: this.map.painter.context.gl.drawingBufferHeight,
          spaceErrorScale: this.map.spaceErrorScale,
          tileMinZoom: this._source.minzoom,
          tileMaxZoom: this._source.maxzoom,
          type: this.sourceType,
        });
      }
      coveringTiles() {
        return (
          this.createQuadtree(),
          this.quadtree.tilesIn(
            this.map.transform.activeCamera,
            this._source._serviceSearchDB,
            this.customHeight,
          ),
          this.quadtree.getOverscaledTileIDs()
        );
      }
      update() {
        if (!this._sourceLoaded || this._paused) return;
        let t;
        if ((this.updateCacheSize(), (this._coveredTiles = {}), '3d-model' === this._source.type))
          t = [];
        else if (this._source.tileID)
          t = this.coveringTiles().map(
            (t) =>
              new e.OverscaledTileID(
                t.canonical.z,
                t.wrap,
                t.canonical.z,
                t.canonical.x,
                t.canonical.y,
                this.map.projection,
              ),
          );
        else if (
          ((t = this.coveringTiles()),
          this._source.hasTile && (t = t.filter((e) => this._source.hasTile(e))),
          'raster' === this._source.type && this._source.capabilities)
        ) {
          const e = this._source.capabilities.tileGrid;
          t = t.filter((t) =>
            (function (e, t) {
              const i = t.getFullTileRange(e.canonical.z);
              return (
                !!i &&
                i.minX <= e.canonical.x &&
                e.canonical.x < i.maxX &&
                i.minY <= e.canonical.y &&
                e.canonical.y < i.maxY
              );
            })(t, e),
          );
        }
        (this.currentMaxTileZoom = co(t).currentMaxTileZoom),
          (this.currentMinTileZoom = co(t).currentMaxTileZoom),
          this.used || (t = []);
        const i = this._updateRetainedTiles(t),
          s = e.keysDifferenceWithMap(this._tiles, i);
        for (let e = 0; e < s.length; e++) this._removeTile(s[e]);
        this._updateLoadedParentTileCache();
      }
      _updateLoadedParentTileCache() {
        this._loadedParentTiles = {};
        for (const e in this._tiles) {
          const t = [];
          let i,
            s = this._tiles[e].tileID;
          for (; s.overscaledZ > 0; ) {
            if (s.key in this._loadedParentTiles) {
              i = this._loadedParentTiles[s.key];
              break;
            }
            t.push(s.key);
            const e = s.scaledTo(s.overscaledZ - 1);
            if (((i = this._getLoadedTile(e)), i)) break;
            s = e;
          }
          for (const e of t) this._loadedParentTiles[e] = i;
        }
      }
      _getLoadedTile(e) {
        const t = this._tiles[e.key];
        return t && t.hasData()
          ? t
          : this._cache.getByKey(
              this._source.reparseOverscaled ? e.wrapped().key : e.canonical.key,
            );
      }
      _updateRetainedTiles(e) {
        this._referenceTiles = {};
        const t = new Map();
        if (0 === e.length) return t;
        const i = {},
          s = e.reduce((e, t) => Math.min(e, t.overscaledZ), 1 / 0),
          r = e[0].overscaledZ,
          n = Math.max(r - ao.maxOverzooming, this._source.minzoom),
          o = Math.max(r + ao.maxUnderzooming, this._source.minzoom),
          a = {};
        for (const i of e) {
          const e = this._addTile(i);
          if ((t.set(i.key, i), 'vector' === e.tilePrimitiveType)) {
            if (e.hasData()) continue;
          } else {
            if (e.hasData() && e.primitiveMap.size > 0) continue;
            if (
              e.wasRequested() &&
              e.primitiveMap.size < 1 &&
              (e._createOrCheckPrimitives(), e.primitiveMap.size > 0)
            )
              continue;
          }
          a[i.key] = i;
        }
        this._retainLoadedChildren(a, s, o, t);
        for (const e in a) {
          const s = this._tiles[e],
            o = a[e];
          let l = s.wasRequested();
          for (let e = o.overscaledZ - 1; e >= n; --e) {
            const n = o.scaledTo(e);
            let a = this.getTile(n);
            if (i[n.key]) {
              if (!(a && 'raster' == s.tilePrimitiveType && s.primitiveMap.size > 0 && a.hasData()))
                break;
              this._refineTile(a, o, n);
            }
            if (((i[n.key] = !0), !a && l && r - n.canonical.z < 4 && (a = this._addTile(n)), a)) {
              if (
                ((l = a.wasRequested()),
                t.set(n.key, n),
                'raster' == s.tilePrimitiveType && s.primitiveMap.size > 0 && a.hasData())
              ) {
                this._refineTile(a, o, n);
                const e = o.children(23);
                t.delete(e[0].key), t.delete(e[1].key), t.delete(e[2].key), t.delete(e[3].key);
              }
              if ('loaded' === a.state) break;
            }
          }
        }
        for (const e in this._referenceTiles) t.delete(e);
        return (this._referenceTiles = {}), t;
      }
      _refineTile(t, i, s) {
        const r = t.imagery[0].imagery,
          n = this._source.getImageryFromCache(r.x, r.y, r.level, i.key),
          o = Math.pow(2, i.overscaledZ - r.level),
          a = (i.canonical.x % o) / o,
          l = (i.canonical.y % o) / o,
          h = new dn(n, new e.Vector4(0, 0, 1, 1), new e.Vector4(a, l, 1 / o, 1 / o));
        (this._tiles[i.key].imageryOrigin = this._tiles[i.key].imagery),
          delete this._tiles[i.key].imagery,
          (this._tiles[i.key].imagery = [h]),
          (this._tiles[i.key].state = 'loaded'),
          this._tiles[i.key]._createOrCheckPrimitives(),
          (this._referenceTiles[s.key] = !0);
      }
      _addTile(t) {
        let i = this._tiles[t.key];
        if (i && !('loaded' !== i.state && i.tileID.canonical.z > this._source.maxzoom))
          return (i.tileID = t), i;
        (i = this._cache.getAndRemove(t)),
          i &&
            (this._setTileReloadTimer(t.key, i),
            (i.tileID = t),
            this._state.initializeTileState(i, this.map ? this.map.painter : null),
            this._cacheTimers[t.key] &&
              (clearTimeout(this._cacheTimers[t.key]),
              delete this._cacheTimers[t.key],
              this._setTileReloadTimer(t.key, i)));
        const s = Boolean(i);
        return (
          s ||
            ((i = new no({
              tileID: t,
              tileSize: this._source.tileSize * t.overscaleFactor(),
              projType: this.map.projection,
              tilePrimitiveType: 'raster' == this._source.type ? 'raster' : 'vector',
              sourceId: this._source.id,
              style: this.map.style,
            })),
            this._loadTile(i, this._tileLoaded.bind(this, i, t.key, i.state))),
          i
            ? (i.uses++,
              (this._tiles[t.key] = i),
              s ||
                this._source.fire(
                  new e.Event('dataloading', { tile: i, coord: i.tileID, dataType: 'source' }),
                ),
              i)
            : null
        );
      }
      _setTileReloadTimer(e, t) {
        e in this._timers && (clearTimeout(this._timers[e]), delete this._timers[e]);
        const i = t.getExpiryTimeout();
        i &&
          (this._timers[e] = setTimeout(() => {
            this._reloadTile(e, 'expired'), delete this._timers[e];
          }, i));
      }
      _removeTile(e) {
        const t = this._tiles[e];
        t &&
          (t.uses--,
          delete this._tiles[e],
          this._timers[e] && (clearTimeout(this._timers[e]), delete this._timers[e]),
          t.uses > 0 ||
            (t.hasData()
              ? this._cache.add(t.tileID, t, t.getExpiryTimeout())
              : ((t.aborted = !0), this._abortTile(t), this._unloadTile(t))));
      }
      clearTiles() {
        (this._shouldReloadOnResume = !1), (this._paused = !1);
        for (const e in this._tiles) this._removeTile(e);
        this._cache && this._cache.reset(),
          this._source.unloadGPUData && this._source.unloadGPUData();
      }
      tilesInOfSphereExtrusion(e, t, i) {
        let s = [];
        s = s.concat(this.quadtree.getOverscaledTileIDs());
        const r = [];
        for (let e = 0; e < s.length; e++) {
          const t = this.getTile(s[e]);
          t && r.push(t.getBucket(i));
        }
        return r;
      }
      tilesIn(t, i, s) {
        const r = [],
          n = this.map.transform;
        if (!n) return r;
        const o = s ? n.getCameraQueryGeometry(t) : t,
          a = t.map((e) => n.pointCoordinate(e)).filter((e) => e),
          l = o.map((e) => n.pointCoordinate(e)).filter((e) => e);
        if (0 == a.length) return [];
        const h = this.getIds();
        let c = 1 / 0,
          _ = 1 / 0,
          u = -1 / 0,
          d = -1 / 0;
        const m = a[0].zoom;
        for (const e of l)
          (c = Math.min(c, e.column)),
            (_ = Math.min(_, e.row)),
            (u = Math.max(u, e.column)),
            (d = Math.max(d, e.row));
        for (let t = 0; t < h.length; t++) {
          const s = this._tiles[h[t]],
            n = s.tileID,
            o = Math.pow(2, this.map.style.getNearestTileZoom() - s.tileID.overscaledZ),
            p = (i * s.queryPadding * e.EXTENT) / s.tileSize / o,
            f = [lo(n, new e.Coordinate(c, _, m)), lo(n, new e.Coordinate(u, d, m))];
          if (
            f[0].x - p < e.EXTENT &&
            f[0].y - p < e.EXTENT &&
            f[1].x + p >= 0 &&
            f[1].y + p >= 0
          ) {
            const t = a.map((t) => {
                const i = t.zoomTo(n.canonical.z);
                return n.getTilePoint(new e.pointGeometry3d(i.column, i.row));
              }),
              i = l.map((t) => {
                const i = t.zoomTo(n.canonical.z);
                return n.getTilePoint(new e.pointGeometry3d(i.column, i.row));
              });
            r.push({ tile: s, tileID: n, queryGeometry: t, cameraQueryGeometry: i, scale: o });
          }
        }
        return r;
      }
      getVisibleCoordinates() {
        return this.getRenderableIds().map((e) => this._tiles[e].tileID);
      }
      hasTransition() {
        if (this._source.hasTransition()) return !0;
        if ('raster' === (t = this._source.type) || 'image' === t || 'video' === t)
          for (const t in this._tiles) {
            const i = this._tiles[t];
            if (void 0 !== i.fadeEndTime && i.fadeEndTime >= e.exported.now()) return !0;
          }
        var t;
        return !1;
      }
      setFeatureState(e, t, i) {
        this._state.updateState((e = e || '_geojsonTileLayer'), t, i);
      }
      removeFeatureState(e, t, i) {
        this._state.removeFeatureState((e = e || '_geojsonTileLayer'), t, i);
      }
      getFeatureState(e, t) {
        return this._state.getState((e = e || '_geojsonTileLayer'), t);
      }
      setDependencies(e, t, i) {
        const s = this._tiles[e];
        s && s.setDependencies(t, i);
      }
      reloadTilesForDependencies(e, t) {
        for (const i in this._tiles)
          this._tiles[i].hasDependency(e, t) && this._reloadTile(i, 'reloading');
        this._cache.filter((i) => !i.hasDependency(e, t));
      }
      resetQuadtree() {
        if (
          (this.quadtree?.destroy(),
          delete this.quadtree,
          this._source.type == e.VectorLayerType.RASTER)
        ) {
          for (const e in this._tiles) {
            const t = this._tiles[e];
            t.unloadVectorData(), (t.state = 'loading');
          }
          for (const e in this._cache.data) {
            const t = this._cache.data[e][0].value;
            t && (t.unloadVectorData(), (t.state = 'loading'));
          }
        }
      }
    }
    function lo(t, i) {
      const s = i.zoomTo(t.canonical.z);
      return new e.pointGeometry3d(
        (s.column - (t.canonical.x + t.wrap * Math.pow(2, t.canonical.z))) * e.EXTENT,
        (s.row - t.canonical.y) * e.EXTENT,
      );
    }
    function ho(t) {
      const i = e.defined(t.spaceErrorScale) ? t.spaceErrorScale : 1,
        {
          tileSize: s,
          isLngLat: r,
          drawingBufferHeight: n,
          hasTerrainLayerFlag: o,
          tileMaxZoom: a,
          tileMinZoom: l,
          type: h,
        } = t;
      return new In({
        tileSize: s,
        hasTerrainLayerFlag: o,
        maximumScreenSpaceError: (s / 512) * i,
        tileScheme: r ? new hn({}) : new ln({}),
        drawingBufferHeight: n,
        pixelRatio: (e.exported.devicePixelRatio / 2) * 2,
        tileMaxZoom: a || 17,
        tileMinZoom: l || 0,
        type: h,
      });
    }
    function co(e) {
      if (0 == e.length) return { currentMaxTileZoom: 22, currentMinTileZoom: 0 };
      let t = e[0].canonical.z,
        i = e[0].canonical.z;
      for (const s of e)
        (t = s.canonical.z > t ? s.canonical.z : t), (i = s.canonical.z < i ? s.canonical.z : i);
      return { currentMaxTileZoom: t, currentMinTileZoom: i };
    }
    (ao.maxOverzooming = 10), (ao.maxUnderzooming = 3);
    var _o = e.createLayout([
      { name: 'a_POSITION', type: 'Float32', components: 3 },
      { name: 'a_texture_pos', type: 'Float32', components: 2 },
      { name: 'a_NORMAL', type: 'Float32', components: 3 },
    ]);
    class uo extends Map {
      constructor() {
        super(), (this.requestingFlagSet = new Set()), (this._initialized = !1);
      }
      update(t) {
        if (!this._initialized) {
          const i = t.source;
          e.defined(i) && (this.source = i), this.initQuadtree() && (this._initialized = !0);
        }
      }
      loaded() {
        return !0;
      }
      initQuadtree() {
        if (e.defined(this.quadtree)) return !0;
        const t = this.source,
          i = this.source.map;
        return (
          !!e.defined(i) &&
          ((this.quadtree = ho({
            tileSize: t.tileSize,
            isLngLat: i.transform.projection === e.ProjectionType.LATLON,
            spaceErrorScale: i.spaceErrorScale,
            drawingBufferHeight: i.painter.context.gl.drawingBufferHeight,
            hasTerrainLayerFlag: !1,
            tileMaxZoom: 22,
            tileMinZoom: 0,
          })),
          !0)
        );
      }
      get cache() {
        return this._cache;
      }
      getGeometryByKey(e) {
        if (this.has(e)) return this.get(e);
        const t = mo(e);
        return this.getGeometryByTileId(t);
      }
      _proxyGetGeometryByTileId(t) {
        return this.has(t.key)
          ? this.get(t.key)
          : this.requestingFlagSet.has(t.key)
          ? void 0
          : (this.requestingFlagSet.add(t.key),
            this.source.loadRegularMeshTile(t, (i, s) => {
              const r = this.source.map.painter.context,
                n = new e.Geometry({
                  primitiveType: e.WebGLConstants.TRIANGLES,
                  vertBuffer: r.createVertexBuffer(s.sphereMaskedBoundsArray, _o.members),
                  indexBuffer: r.createIndexBuffer(s.sphereIndexArray),
                  wireframeIndexBuffer: r.createIndexBuffer(s.wireframeIndexArray),
                  segmentVector: s.sphereSegments,
                  tileBoundingRegion: this.quadtree.getBoundingRegionById(t.key),
                  tileId: t,
                }),
                o = new e.Matrix4();
              o.translate(s.rtc),
                this.set(t.key, { geometry: n, matrix: o, referenceCount: 0 }),
                this.requestingFlagSet.delete(t.key);
            }),
            this.get(t.key));
      }
      getGeometryByTileId(e) {
        const t = this._proxyGetGeometryByTileId(e);
        return t && t.referenceCount++, t;
      }
      removeGeometryByTileKey(e) {
        const t = this.get(e);
        t && (t.referenceCount--, t.referenceCount <= 0 && (t.geometry.destroy(), this.delete(e)));
      }
      removeGeometryByTileId(e) {
        this.removeGeometryByTileKey(e.key);
      }
      removeAllGeometry() {}
      destroy() {
        this.removeAllGeometry(), this.clear();
      }
    }
    function mo(e) {
      const t = e.split('_'),
        i = +t[0];
      return new OverscaledTileID(i, 0, i, +t[1], +t[2]);
    }
    function po(t, i) {
      const s = i.source.map.painter.context,
        r = e.tileSamplesGrid(t, i.source.map.projection),
        n = new e.Geometry({
          primitiveType: e.WebGLConstants.TRIANGLES,
          vertBuffer: s.createVertexBuffer(r.sphereMaskedBoundsArray, _o.members),
          indexBuffer: s.createIndexBuffer(r.sphereIndexArray),
          wireframeIndexBuffer: s.createIndexBuffer(r.wireframeIndexArray),
          segmentVector: r.sphereSegments,
          tileBoundingRegion: i.quadtree.getBoundingRegionById(t.key),
          tileId: t,
        }),
        o = new e.Matrix4();
      o.translate(r.rtc), i.set(t.key, { geometry: n, matrix: o, referenceCount: 0 });
    }
    var fo = e.createLayout([
      { name: 'a_GEODETIC_NORMAL', type: 'Float32', components: 3 },
      { name: 'a_ELEVATION', type: 'Float32', components: 1 },
    ]);
    const go = new e.TerrainTileParser();
    class yo extends Map {
      constructor(e) {
        super(),
          (this._initialized = !1),
          (this.resamplingTerrainMap = new Map()),
          (this.requestingFlagSet = new Set()),
          (this.requestFailedMap = new Map()),
          (this.requestInterval = e?.requestInterval || 60);
      }
      get maxzoom() {
        return this.source.maxzoom;
      }
      loaded() {
        return this.size > 0 && 0 == this.requestingFlagSet.size;
      }
      update(t) {
        if (this._initialized) {
          if (!t.tiles) return;
          let e = !1;
          const i = Math.min(this.tiles.length, t.tiles.length);
          for (let s = 0; s < i; s++)
            if (this.tiles[s] != t.tiles[s]) {
              e = !0;
              break;
            }
          e && (this.destroy(), (this.tiles = t.tiles));
        } else {
          const i = t.source,
            s = t.tiles;
          e.defined(i) && (this.source = i),
            e.defined(s) && (this.tiles = s),
            this.initQuadtree() && (this._initialized = !0);
        }
      }
      initQuadtree() {
        if (e.defined(this.quadtree)) return !0;
        const t = this.source,
          i = this.source.map;
        return (
          !!e.defined(i) &&
          ((this.quadtree = ho({
            tileSize: t.tileSize,
            isLngLat: i.transform.projection === e.ProjectionType.LATLON,
            spaceErrorScale: i.spaceErrorScale,
            drawingBufferHeight: i.painter.context.gl.drawingBufferHeight,
            hasTerrainLayerFlag: !0,
            tileMinZoom: 0,
            tileMaxZoom: 22,
          })),
          !0)
        );
      }
      get initialized() {
        return this._initialized;
      }
      getGeometryByKey(e) {
        if (this.has(e)) return this.get(e);
        const t = mo(e);
        return this.getGeometryByTileId(t);
      }
      findNearestTileOfDataDownloaded(e) {
        for (let t = e.canonical.z - 1; t > 14; t--) {
          const i = e.scaledTo(t);
          if (this.resamplingTerrainMap.has(i.key))
            return { zoom: t, tile: this.resamplingTerrainMap.get(i.key) };
        }
        return null;
      }
      _processChildrenData(e) {
        const t = this.source.map.projection,
          i = this.source.map.painter.context,
          s = this.maxzoom,
          r = this.source.map.style;
        if (this.resamplingTerrainMap.has(e.key) && !this.resamplingTerrainMap.get(e.key).isTemp)
          return this.resamplingTerrainMap.get(e.key);
        const n = this.findNearestTileOfDataDownloaded(e);
        let o, a;
        if (
          (n
            ? ((a = n.zoom), (o = n.tile))
            : ((o = this._proxyGetGeometryByTileId(e.scaledTo(s))), (a = s)),
          o)
        ) {
          if (!o.data) return void po(e, this);
          const s = o.isTemp,
            n = (function (e) {
              const {
                  terrainData: t,
                  targetTileID: i,
                  startZoom: s,
                  projection: r,
                  style: n,
                  quadtree: o,
                  isTemp: a,
                } = e,
                l = [];
              let h = s,
                c = t;
              for (;;) {
                const e = i.scaledTo(h),
                  t = i.scaledTo(h + 1),
                  s = To({ parentData: c, projection: r, parentId: e, childId: t }),
                  _ = o.getQuadtreeTileByTileKey(t.key);
                if (
                  (_ &&
                    ((_.terrainData = {
                      minimumHeight: s.minimumHeight,
                      maximumHeight: s.maximumHeight,
                    }),
                    On(_),
                    n.synchronizeTileTerrainBounding(t, 512, _.terrainData)),
                  l.push({ data: s, tileID: t, isTemp: a }),
                  h++,
                  h == i.canonical.z)
                )
                  break;
                c = s;
              }
              return l;
            })({
              terrainData: o.data,
              targetTileID: e,
              startZoom: a,
              projection: t,
              style: r,
              quadtree: this.quadtree,
              isTemp: s,
            });
          for (let e = 0; e < n.length; e++) {
            const t = n[e],
              o = t.tileID.key;
            if (this.resamplingTerrainMap.has(o) && this.resamplingTerrainMap.get(o).isTemp && s)
              continue;
            const a = xo(t.data, i, t.tileID, this.quadtree, r);
            if (((a.data = t.data), (a.isTemp = s), this.resamplingTerrainMap.has(o))) {
              const e = this.resamplingTerrainMap.get(o);
              e.isTemp && !s && (e.geometry.destroy(), (a.referenceCount = e.referenceCount));
            }
            this.resamplingTerrainMap.set(o, a);
          }
        }
        return this.resamplingTerrainMap.get(e.key);
      }
      _proxyGetGeometryByTileId(e) {
        const t = this.maxzoom;
        if (!this.source.hasTile(e)) return this.has(e.key) || po(e, this), this.get(e.key);
        if (
          (function (e, t) {
            return e.canonical.z > t;
          })(e, this.maxzoom)
        )
          return this.has(e.key) ? this.get(e.key) : this._processChildrenData(e);
        if (e.canonical.z == t && this.resamplingTerrainMap.has(e.key))
          return this.resamplingTerrainMap.get(e.key);
        if (this.has(e.key)) {
          if (!this.requestFailedMap.has(e.key)) return this.get(e.key);
          if (Date.now() - this.requestFailedMap.get(e.key) < 1e3 * this.requestInterval)
            return this.get(e.key);
        }
        return this._sendRequest(e), null;
      }
      _sendRequest(t) {
        if (this.requestingFlagSet.has(t.key)) return;
        const i = this.source.map.painter.context,
          s = this.maxzoom,
          r = this.source.map.style;
        this.requestingFlagSet.add(t.key);
        const n = JSON.stringify(this.tiles);
        this.source.loadTile(t, (o, a) => {
          if ((this.requestingFlagSet.delete(t.key), n == JSON.stringify(this.tiles))) {
            if (o) {
              if (this.requestFailedMap.size >= 1e4) {
                const e = this.requestFailedMap.entries();
                let t = e.next();
                for (let i = 0; i < 5e3 && !t.done; i++)
                  this.requestFailedMap.delete(t.value[0]), (t = e.next());
              }
              return (
                this.requestFailedMap.set(t.key, Date.now()), void (this.has(t.key) || po(t, this))
              );
            }
            if (a) {
              const n = xo(a, i, t, this.quadtree, r),
                o = t.key;
              if (t.canonical.z == s) {
                if (((n.data = a), this.resamplingTerrainMap.has(o))) return;
                this.resamplingTerrainMap.set(o, n);
              } else {
                if (this.has(o)) return;
                this.set(o, n);
              }
              this.source.fire(
                new e.Event('data', { dataType: 'source', sourceDataType: 'content' }),
              );
            }
          }
        });
      }
      getGeometryByTileId(e) {
        const t = this._proxyGetGeometryByTileId(e);
        return t && (t.referenceCount++, (t.timestamp = Date.now())), t;
      }
      _clearNoneReferencedData() {
        if (this.size + this.resamplingTerrainMap.size < 512) return;
        const e = Date.now();
        this.forEach((t, i) => {
          t.referenceCount <= 0 && e - t.timestamp > 5e3 && (t.geometry.destroy(), this.delete(i));
        }),
          this.resamplingTerrainMap.forEach((t, i) => {
            t.referenceCount <= 0 &&
              e - t.timestamp > 5e3 &&
              (t.geometry.destroy(), this.resamplingTerrainMap.delete(i));
          });
      }
      removeGeometryByTileKey(e) {
        let t = this.get(e);
        t && (t.referenceCount--, t.referenceCount <= 0 && (t.geometry.destroy(), this.delete(e))),
          (t = this.resamplingTerrainMap.get(e)),
          t &&
            (t.referenceCount--,
            t.referenceCount <= 0 && (t.geometry.destroy(), this.resamplingTerrainMap.delete(e)));
      }
      removeGeometryByTileId(e) {
        this.removeGeometryByTileKey(e.key);
      }
      removeAllGeometry() {
        this.forEach((e, t) => {
          this.removeGeometryByTileKey(t);
        });
      }
      destroy() {
        this.removeAllGeometry(),
          this.clear(),
          this.requestFailedMap.clear(),
          this.resamplingTerrainMap.clear();
      }
    }
    function To(e) {
      const t = Object.assign({}, e.parentData, {
        x: e.childId.canonical.x,
        y: e.childId.canonical.y,
        z: e.childId.canonical.z,
        isEastChild: e.childId.canonical.x % 2 > 0,
        isNorthChild: e.childId.canonical.y % 2 == 0,
        projectionType: e.projection,
      });
      return go.createChildTerrain(t);
    }
    function xo(t, i, s, r, n) {
      const o = new e.SegmentVector(),
        a = t.sphereMaskedBoundsArray,
        l = t.sphereIndexArray,
        h = t.terrainAnalysisArray,
        c = t.wireframeIndexArray,
        _ = o.prepareSegment(0, [], []);
      (_.vertexLength += t.sphereMaskedBoundsArray.length),
        (_.primitiveLength += t.sphereIndexArray.length),
        o.prepareSegment(0, a, l);
      const u = r.getQuadtreeTileByTileKey(s.key);
      u &&
        ((u.terrainData = { minimumHeight: t.minimumHeight, maximumHeight: t.maximumHeight }),
        On(u),
        n.synchronizeTileTerrainBounding(s, 512, u.terrainData));
      const d = new e.Geometry({
          primitiveType: e.WebGLConstants.TRIANGLES,
          vertBuffer: i.createVertexBuffer(a, _o.members),
          indexBuffer: i.createIndexBuffer(l),
          wireframeIndexBuffer: i.createIndexBuffer(c),
          dynamicLayoutBuffer1: i.createVertexBuffer(h, fo.members),
          segmentVector: o,
          tileBoundingRegion: r.getBoundingRegionById(s.key),
          tileId: s,
        }),
        m = new e.Matrix4();
      return (
        m.translate(t.rP),
        { geometry: d, matrix: m, referenceCount: 0, timestamp: Date.now(), data: t }
      );
    }
    function vo(t, i, s, r) {
      let n = 14;
      const o = Math.pow(2, n),
        a = Math.floor(e.ProjectionProxy.latY(t[1], o, r)),
        l = Math.floor(e.ProjectionProxy.lngX(t[0], o, r));
      if (l > o || l < 0 || a > o || a < 0 || isNaN(l) || isNaN(a))
        return { intersectionZ: 1 / 0, intersectionPoint: void 0, isUnderground: !1 };
      const h = new e.OverscaledTileID(n, 0, n, l, a, r);
      let c = null;
      const _ = e.Vector3.fromDegrees(t[0], t[1], 0);
      for (_.subtract(i); n > 0; ) {
        const t = h.scaledTo(n).key;
        let r = s.resamplingTerrainMap.get(t);
        if ((r || (r = s.get(t)), r && r.data)) {
          c = r;
          let t = bo(c, new e.Ray(i, e.Vector3.normalize(_, new e.Vector3())));
          if (t.intersectionPoint) return t;
          if (
            ((t = bo(c, new e.Ray(i, e.Vector3.normalize(_, new e.Vector3()).multiplyScalar(-1)))),
            t.intersectionPoint)
          )
            return t;
        }
        n--;
      }
      return { intersectionZ: 1 / 0, intersectionPoint: null, isUnderground: !1 };
    }
    function bo(t, i) {
      let s,
        r = 1 / 0;
      const n = new e.Vector3();
      if (t && t.data) {
        const o = t.data,
          a = o.sphereMaskedBoundsArray.float32,
          l = o.sphereIndexArray.uint16,
          h = o.rP;
        for (let t = 0; t < o.skirtIndex; t += 3) {
          const o = 8 * l[t],
            c = 8 * l[t + 1],
            _ = 8 * l[t + 2],
            u = i.intersectTriangle(
              [a[o] + h[0], a[o + 1] + h[1], a[o + 2] + h[2]],
              [a[c] + h[0], a[c + 1] + h[1], a[c + 2] + h[2]],
              [a[_] + h[0], a[_ + 1] + h[1], a[_ + 2] + h[2]],
              !1,
              n,
            );
          if (u) {
            const t = new e.Vector3(i.origin).distance(u);
            if (t < r) {
              (s = new e.Vector3(u)), (r = t);
              const n =
                e.Transforms.cartesian3ToCartographic(i.origin)[2] <
                e.Transforms.cartesian3ToCartographic(u)[2];
              return (
                n && (r = e.Transforms.cartesian3ToCartographic(u)[2]),
                { intersectionZ: r, intersectionPoint: s, isUnderground: n }
              );
            }
          }
        }
      }
      return { intersectionZ: r, intersectionPoint: s, isUnderground: !1 };
    }
    class wo extends e.Evented {
      constructor(e, t, i) {
        super(),
          (this.id = e),
          (this.dispatcher = i),
          (this.regularMeshSupplier = new uo()),
          (this.terrainMeshSupplier = new yo(t)),
          this.on('data', (e) => {
            'source' === e.dataType && 'metadata' === e.sourceDataType && (this._sourceLoaded = !0),
              this._sourceLoaded &&
                !this._paused &&
                'source' === e.dataType &&
                'content' === e.sourceDataType &&
                this.map.transform &&
                this.update(this.map.transform);
          }),
          this.on('error', () => {
            this._sourceErrored = !0;
          }),
          (this._source = So(e, t, i, this)),
          (this._maxTileCacheSize = null),
          (this.sourceType = t.type),
          this.switchSupplier({ type: eo });
      }
      switchSupplier(e) {
        e.type == eo
          ? this.supplier != this.regularMeshSupplier &&
            ((this.supplier = this.regularMeshSupplier),
            this.supplier.update({ source: this._source }),
            (this._isTerrain = !1),
            this.map?.style.resetSourceQuadtree())
          : e.type == Jn &&
            JSON.stringify(this._source._tiles) !== JSON.stringify(e.tiles) &&
            ((this.supplier = this.terrainMeshSupplier),
            this.supplier.update({ source: this._source, tiles: e.tiles }),
            (this._isTerrain = !0),
            this.map?.style.resetSourceQuadtree()),
          (this._source._tiles = e.tiles),
          this.map && this.map.style.updateHasTerrainFlag();
      }
      onAdd(e) {
        (this.map = e),
          (this._maxTileCacheSize = e ? e._maxTileCacheSize : null),
          this._source && this._source.onAdd && this._source.onAdd(e);
      }
      onRemove(e) {
        this._source && this._source.onRemove && this._source.onRemove(e);
      }
      loaded() {
        return this.supplier.loaded();
      }
      getSource() {
        return this._source;
      }
      pause() {
        this._paused = !0;
      }
      resume() {
        if (!this._paused) return;
        const e = this._shouldReloadOnResume;
        (this._paused = !1),
          (this._shouldReloadOnResume = !1),
          e && this.reload(),
          this.map && this.update();
      }
      updateCacheSize() {
        this.supplier._cache.setMaxSize(32);
      }
      get quadtree() {
        return this.supplier.quadtree;
      }
      coveringTiles() {
        return (
          this.quadtree.tilesIn(this.map.transform.activeCamera),
          this.quadtree.getOverscaledTileIDs()
        );
      }
      isTerrain() {
        return this._isTerrain;
      }
      update() {
        this.supplier.update({});
      }
      getGeometryByTileId(e) {
        return this.supplier.getGeometryByTileId(e);
      }
      getGeometryByKey(e) {
        return this.supplier.getGeometryByKey(e);
      }
      getTerrainSupplier() {
        return this.terrainMeshSupplier;
      }
      getRegularSupplier() {
        return this.regularMeshSupplier;
      }
      clearTiles() {
        (this._shouldReloadOnResume = !1),
          (this._paused = !1),
          this.supplier._cache && this.supplier._cache.reset();
      }
      serialize() {
        if (this._isTerrain)
          return {
            tiles: this._source.tiles,
            tileSize: this._source.tileSize,
            maxzoom: this._source.maxzoom,
            type: this.sourceType,
          };
      }
      resetQuadtree() {}
    }
    const Co = {
        vector: class extends e.Evented {
          constructor(t, i, s, r) {
            if (
              (super(),
              (this.id = t),
              (this.dispatcher = s),
              (this.type = 'vector'),
              (this.minzoom = i.minzoom || 0),
              (this.maxzoom = i.maxzoom || 17),
              (this.scheme = 'xyz'),
              (this.tileSize = 512),
              (this.reparseOverscaled = !0),
              (this.isTileClipped = !0),
              e.extend(this, e.pick(i, ['url', 'scheme', 'tileSize'])),
              (this._options = e.extend({ type: 'vector' }, i)),
              (this._collectResourceTiming = i.collectResourceTiming),
              (this.promoteId = i.promoteId),
              (this.priorityRequest = i.priorityRequest || !1),
              512 !== this.tileSize)
            )
              throw new Error('vector tile sources must have a tileSize of 512');
            (this._adcode = i.adcode),
              (this.clippingPlanes = i.clippingPlanes),
              this.setEventedParent(r);
          }
          set adcode(e) {
            this._adcode !== e &&
              ((this._adcode = e),
              this._eventedParent && this._eventedParent.reload && this._eventedParent.reload(!0));
          }
          get adcode() {
            return this._adcode;
          }
          load() {
            this.fire(new e.Event('dataloading', { dataType: 'source' })),
              (this._tileJSONRequest = nn(this._options, this.map._transformRequest, (t, i) => {
                (this._tileJSONRequest = null),
                  t
                    ? this.fire(new e.ErrorEvent(t))
                    : i &&
                      (e.extend(this, i),
                      i.bounds && (this.tileBounds = new on(i.bounds, this.minzoom, this.maxzoom)),
                      this.fire(
                        new e.Event('data', { dataType: 'source', sourceDataType: 'metadata' }),
                      ),
                      this.fire(
                        new e.Event('data', { dataType: 'source', sourceDataType: 'content' }),
                      ));
              }));
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical);
          }
          onAdd(e) {
            (this.map = e), this.load();
          }
          onRemove() {
            this._tileJSONRequest &&
              (this._tileJSONRequest.cancel(), (this._tileJSONRequest = null));
          }
          serialize() {
            return e.extend({}, this._options);
          }
          loadTile(t, i) {
            const s = t.tileID.canonical.toRealCoord(this.scheme);
            let r = Sr(t.tileID.canonical.url(this.tiles, this.scheme), 0, void 0, s);
            this._adcode && (r = `${r}&admincode=${this._adcode}`);
            const n = {
              request: this.map._transformRequest(r, e.ResourceType.Tile),
              uid: t.uid,
              tileID: t.tileID,
              zoom: t.tileID.overscaledZ,
              tileSize: this.tileSize * t.tileID.overscaleFactor(),
              type: this.type,
              source: this.id,
              pixelRatio: e.exported.devicePixelRatio,
              showCollisionBoxes: this.map.showCollisionBoxes,
              promoteId: this.promoteId,
            };
            function o(e, s) {
              return t.aborted
                ? i(null)
                : e
                ? i(e)
                : (s && s.resourceTiming && (t.resourceTiming = s.resourceTiming),
                  this.map._refreshExpiredTiles && t.setExpiryData(s),
                  t.loadVectorData(s, this.map.painter),
                  i(null),
                  void (
                    t.reloadCallback &&
                    (this.loadTile(t, t.reloadCallback), (t.reloadCallback = null))
                  ));
            }
            (n.request.collectResourceTiming = this._collectResourceTiming),
              void 0 === t.workerID || 'expired' === t.state
                ? (t.workerID = this.dispatcher.send('loadTile', n, o.bind(this)))
                : 'loading' === t.state
                ? (t.reloadCallback = i)
                : this.dispatcher.send('reloadTile', n, o.bind(this), t.workerID);
          }
          abortTile(e) {
            this.dispatcher.send(
              'abortTile',
              { uid: e.uid, type: this.type, source: this.id },
              void 0,
              e.workerID,
            );
          }
          unloadTile(e) {
            e.unloadVectorData(),
              this.dispatcher.send(
                'removeTile',
                { uid: e.uid, type: this.type, source: this.id },
                void 0,
                e.workerID,
              );
          }
          hasTransition() {
            return !1;
          }
          isEarthSource() {
            return !0;
          }
        },
        raster: class extends e.Evented {
          constructor(t, i, s, r) {
            if (
              (super(),
              (this.id = t),
              (this.dispatcher = s),
              this.setEventedParent(r),
              (this.type = 'raster'),
              (this.minzoom = i.minzoom || 0),
              (this.maxzoom = i.maxzoom || 17),
              (this.roundZoom = !1),
              (this.scheme = 'xyz'),
              (this.tileSize = 512),
              (this._loaded = !1),
              (this._options = e.extend({}, i)),
              e.extend(
                this,
                e.pick(i, [
                  'url',
                  'scheme',
                  'tileSize',
                  'tiles',
                  'serviceIndexUrl',
                  'capabilities',
                  'service',
                  'projection',
                ]),
              ),
              this.service && (this.scheme = this.service.toLowerCase()),
              'baidu' === this.scheme)
            ) {
              const t = new e.Vector2(-33554054, -33746824),
                i = new e.Vector2(33554054, 33746824);
              (this._tilingScheme = new ln({
                rectangleSouthwestInMeters: t,
                rectangleNortheastInMeters: i,
              })),
                (this.projection = e.ProjectionType.MERCATOR);
            } else
              this.projection === e.ProjectionType.LATLON
                ? (this._tilingScheme = new hn())
                : this.projection === e.ProjectionType.MERCATOR && (this._tilingScheme = new ln());
            (this._imageryCache = new Map()),
              (this._callbacks = new Map()),
              (this.priorityRequest = i.priorityRequest || !1),
              this.serviceIndexUrl && (this._serviceSearchDB = new _n(this.serviceIndexUrl, 10));
          }
          load() {
            this.fire(new e.Event('dataloading', { dataType: 'source' })),
              (this._tileJSONRequest = nn(this._options, this.map._transformRequest, (t, i) => {
                (this._tileJSONRequest = null),
                  t
                    ? this.fire(new e.ErrorEvent(t))
                    : i &&
                      (e.extend(this, i),
                      i.bounds && (this.tileBounds = new on(i.bounds, this.minzoom, this.maxzoom)),
                      this.fire(
                        new e.Event('data', { dataType: 'source', sourceDataType: 'metadata' }),
                      ),
                      this.fire(
                        new e.Event('data', { dataType: 'source', sourceDataType: 'content' }),
                      ));
              }));
          }
          onAdd(e) {
            (this.map = e), this.load();
          }
          onRemove() {
            this._tileJSONRequest &&
              (this._tileJSONRequest.cancel(), (this._tileJSONRequest = null));
          }
          serialize() {
            return e.extend({}, this._options);
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical);
          }
          loadTile(t, i) {
            const s = t.tileID.canonical.toRealCoord(this.scheme);
            let r;
            this._callbacks.set(t.tileID.key, i), this._createTileImagerySkeletons(t);
            let n = !0;
            for (const a of t.imagery) {
              let l;
              (l =
                'wmts' === this.scheme
                  ? a.imagery.tileID.canonical.wmtsUrl(this.tiles, this._options.capabilities)
                  : 'tms' === this.scheme
                  ? a.imagery.tileID.canonical.tmsUrl(this.tiles)
                  : 'baidu' === this.scheme
                  ? a.imagery.tileID.canonical.baiduUrl(this.tiles)
                  : a.imagery.tileID.canonical.url(this.tiles)),
                (r = Sr(l, 0, this.tileSize, s));
              const h = {
                request: this.map._transformRequest(r, e.ResourceType.Tile),
                uid: `${t.uid}_${a.imagery.tileID.key}`,
                type: this.type,
                source: this.id,
              };
              h.request.headers
                ? (h.request.headers.Accept = 'image/webp,*/*')
                : (h.request.headers = { Accept: 'image/webp,*/*' }),
                void 0 === a.workerID || 'expired' === t.state
                  ? 'unloaded' === a.imagery.state || 'errored' === a.imagery.state
                    ? ((a.workerID = this.dispatcher.send('loadTile', h, o.bind(a))),
                      (a.imagery.state = 'loading'),
                      (n = !1))
                    : 'loading' === a.imagery.state && (n = !1)
                  : 'loading' === t.state
                  ? (t.reloadCallback = i)
                  : this.dispatcher.send('reloadTile', h, o.bind(a), a.workerID);
            }
            function o(e, s) {
              if (!s || t.aborted || e)
                return (this.imagery.state = 'errored'), i((e = e || 'aborted'), s);
              s && s.resourceTiming && (t.resourceTiming = s.resourceTiming),
                t.style.map._refreshExpiredTiles && t.setExpiryData(s);
              const n = t.style.sourceCaches[t.sourceId]._source,
                o = [];
              for (const e of this.imagery.references) o.push(n._callbacks.get(e));
              this.loadImage({
                data: s,
                painter: t.style.map.painter,
                justReloaded: !1,
                callbacks: o,
                url: r,
              }),
                (s = null),
                t.reloadCallback && (n.loadTile(t, t.reloadCallback), (t.reloadCallback = null));
            }
            n && i(null);
          }
          abortTile(e, t) {
            this.dispatcher.send(
              'abortTile',
              { uid: e.uid, type: this.type, source: this.id },
              void 0,
              e.workerID,
            ),
              t();
          }
          unloadTile(e, t) {
            e.unloadVectorData();
            for (const t of e.imagery)
              this.dispatcher.send(
                'removeTile',
                { uid: `${e.uid}_${t.imagery.tileID.key}`, type: this.type, source: this.id },
                void 0,
                e.workerID,
              ),
                t.freeResources(e.tileID.key),
                this._callbacks.delete(e.tileID.key);
            t();
          }
          hasTransition() {
            return !1;
          }
          _clearSourceCacheTiles() {
            const e = this._eventedParent;
            for (const t in e._tiles) e._removeTile(t);
            e._cache && e._cache.reset();
          }
          _createTileImagerySkeletons(t) {
            const i = t.style.map._tilingScheme.tileXYToRectangle(
              t.tileID.canonical.x,
              t.tileID.canonical.y,
              t.tileID.canonical.z,
            );
            this.projection ||
              ((this.projection = t.style.map.projection),
              (this._tilingScheme = t.style.map._tilingScheme));
            const s = this._tilingScheme,
              r = t.tileID.canonical.z,
              n = e.Rectangle.intersection(s.rectangle, e.Rectangle.MAX_VALUE),
              o = e.Rectangle.intersection(i, n),
              a = s.positionToTileXY(e.Rectangle.northwest(o), r),
              l = s.positionToTileXY(e.Rectangle.southeast(o), r);
            let h = i.width / 512,
              c = i.height / 512;
            const _ = s.tileXYToRectangle(a.x, a.y, r);
            Math.abs(_.south - i.north) < c && a.y < l.y && ++a.y,
              Math.abs(_.east - i.west) < h && a.x < l.x && ++a.x;
            const u = s.tileXYToRectangle(l.x, l.y, r);
            Math.abs(u.north - i.south) < c && l.y > a.y && --l.y,
              Math.abs(u.west - i.east) < h && l.x > a.x && --l.x;
            const d = e.Rectangle.clone(i);
            let m,
              p,
              f = s.tileXYToRectangle(a.x, a.y, r),
              g = e.Rectangle.intersection(f, n);
            this.projection === e.ProjectionType.MERCATOR
              ? (s.rectangleToNativeRectangle(d, d),
                s.rectangleToNativeRectangle(f, f),
                s.rectangleToNativeRectangle(g, g),
                s.rectangleToNativeRectangle(n, n),
                (m = s.tileXYToNativeRectangle.bind(s)),
                (h = d.width / 512),
                (c = d.height / 512))
              : (m = s.tileXYToRectangle.bind(s));
            let y,
              T = 0,
              x = 1;
            t.imagery = [];
            const v = x;
            for (let i = a.x; i <= l.x; i++) {
              (p = T),
                (f = m(i, a.y, r)),
                (g = e.Rectangle.simpleIntersection(f, n)),
                (T = Math.min(1, (g.east - d.west) / d.width)),
                i === l.x && Math.abs(g.east - d.east) < h && (T = 1),
                (x = v);
              for (let s = a.y; s <= l.y; s++) {
                (y = x),
                  (f = m(i, s, r)),
                  (g = e.Rectangle.simpleIntersection(f, n)),
                  (x = Math.max(0, (g.south - d.south) / d.height)),
                  s === l.y && Math.abs(g.south - d.south) < c && (x = 0);
                const o = new e.Vector4(p, 1 - y, T, 1 - x),
                  a = d.width,
                  h = d.height,
                  _ = a / f.width,
                  u = h / f.height,
                  v = new e.Vector4(
                    (_ * (d.west - f.west)) / a,
                    (u * (f.north - d.north)) / h,
                    _,
                    u,
                  ),
                  b = this.getImageryFromCache(i, s, r, t.tileID.key);
                t.imagery.push(new dn(b, o, v));
              }
            }
          }
          getImageryFromCache(e, t, i, s) {
            const r = `${i}_${e}_${t}`;
            let n = this._imageryCache.get(r);
            return (
              n || ((n = new un(e, t, i, this)), this._imageryCache.set(r, n)), n.addReference(s), n
            );
          }
          removeImageryFromCache = function (e) {
            this._imageryCache.delete(`${e.level}_${e.x}_${e.y}`);
          };
        },
        geojson: S,
        video: class extends gn {
          constructor(e, t, i, s) {
            super(e, t, i, s), (this.roundZoom = !0), (this.type = 'video'), (this.options = t);
          }
          load() {
            const t = this.options;
            this.urls = [];
            for (const i of t.urls)
              this.urls.push(this.map._transformRequest(i, e.ResourceType.Source).url);
            e.getVideo(this.urls, (t, i) => {
              t
                ? this.fire(new e.ErrorEvent(t))
                : i &&
                  ((this.video = i),
                  (this.video.loop = !0),
                  this.video.addEventListener('playing', () => {
                    this.map.triggerRepaint();
                  }),
                  this.map && this.video.play(),
                  this._finishLoading());
            });
          }
          getVideo() {
            return this.video;
          }
          onAdd(e) {
            this.map ||
              ((this.map = e),
              this.load(),
              this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          prepare() {
            if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;
            const t = this.map.painter.context,
              i = t.gl;
            this.boundsBuffer ||
              ((this.boundsBuffer = t.createVertexBuffer(this._boundsArray, mn.members)),
              (this.indexBuffer = t.createIndexBuffer(this._indexArray))),
              this.sphereBoundsBuffer ||
                ((this.sphereBoundsBuffer = t.createVertexBuffer(
                  this._sphereBoundsArray,
                  pn.members,
                )),
                (this.sphereIndexBuffer = t.createIndexBuffer(this._sphereIndexArray))),
              this.texture
                ? this.video.paused ||
                  (this.texture.bind(e.WebGLConstants.LINEAR, e.WebGLConstants.CLAMP_TO_EDGE),
                  i.texSubImage2D(
                    e.WebGLConstants.TEXTURE_2D,
                    0,
                    0,
                    0,
                    e.WebGLConstants.RGBA,
                    e.WebGLConstants.UNSIGNED_BYTE,
                    this.video,
                  ))
                : ((this.texture = new e.Texture({
                    context: t,
                    image: this.video,
                    pixelFormat: e.WebGLConstants.RGBA,
                  })),
                  this.texture.bind(e.WebGLConstants.LINEAR, e.WebGLConstants.CLAMP_TO_EDGE));
            for (const e in this.tiles) {
              const t = this.tiles[e];
              'loaded' !== t.state && ((t.state = 'loaded'), (t.texture = this.texture));
            }
          }
          serialize() {
            return { type: 'video', urls: this.urls, coordinates: this.coordinates };
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        },
        image: gn,
        canvas: class extends gn {
          constructor(t, i, s, r) {
            super(t, i, s, r),
              i.coordinates
                ? (Array.isArray(i.coordinates) &&
                    4 === i.coordinates.length &&
                    !i.coordinates.some(
                      (e) =>
                        !Array.isArray(e) || 2 !== e.length || e.some((e) => 'number' != typeof e),
                    )) ||
                  this.fire(
                    new e.ErrorEvent(
                      new e.ValidationError(
                        `sources.${t}`,
                        null,
                        '"coordinates" property must be an array of 4 longitude/latitude array pairs',
                      ),
                    ),
                  )
                : this.fire(
                    new e.ErrorEvent(
                      new e.ValidationError(
                        `sources.${t}`,
                        null,
                        'missing required property "coordinates"',
                      ),
                    ),
                  ),
              i.animate &&
                'boolean' != typeof i.animate &&
                this.fire(
                  new e.ErrorEvent(
                    new e.ValidationError(
                      `sources.${t}`,
                      null,
                      'optional "animate" property must be a boolean value',
                    ),
                  ),
                ),
              i.canvas
                ? 'string' == typeof i.canvas ||
                  i.canvas instanceof e.window.HTMLCanvasElement ||
                  this.fire(
                    new e.ErrorEvent(
                      new e.ValidationError(
                        `sources.${t}`,
                        null,
                        '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance',
                      ),
                    ),
                  )
                : this.fire(
                    new e.ErrorEvent(
                      new e.ValidationError(
                        `sources.${t}`,
                        null,
                        'missing required property "canvas"',
                      ),
                    ),
                  ),
              (this.options = i),
              (this.animate = void 0 === i.animate || i.animate);
          }
          load() {
            this.canvas ||
              (this.canvas =
                this.options.canvas instanceof e.window.HTMLCanvasElement
                  ? this.options.canvas
                  : e.window.document.getElementById(this.options.canvas)),
              (this.width = this.canvas.width),
              (this.height = this.canvas.height),
              this._hasInvalidDimensions()
                ? this.fire(
                    new e.ErrorEvent(
                      new Error('Canvas dimensions cannot be less than or equal to zero.'),
                    ),
                  )
                : ((this.play = function () {
                    (this._playing = !0), this.map.triggerRepaint();
                  }),
                  (this.pause = function () {
                    this._playing = !1;
                  }),
                  this._finishLoading());
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(e) {
            (this.map = e), this.load(), this.canvas && this.animate && this.play();
          }
          onRemove() {
            this.pause();
          }
          prepare() {
            let t = !1;
            if (
              (this.canvas.width !== this.width && ((this.width = this.canvas.width), (t = !0)),
              this.canvas.height !== this.height && ((this.height = this.canvas.height), (t = !0)),
              this._hasInvalidDimensions())
            )
              return;
            if (0 === Object.keys(this.tiles).length) return;
            const i = this.map.painter.context,
              s = i.gl;
            this.boundsBuffer ||
              (this.boundsBuffer = i.createVertexBuffer(this._boundsArray, mn.members)),
              this.boundsVAO || (this.boundsVAO = new yn()),
              this.texture
                ? t
                  ? this.texture.update(this.canvas)
                  : this._playing &&
                    (this.texture.bind(e.WebGLConstants.LINEAR, e.WebGLConstants.CLAMP_TO_EDGE),
                    s.texSubImage2D(
                      e.WebGLConstants.TEXTURE_2D,
                      0,
                      0,
                      0,
                      e.WebGLConstants.RGBA,
                      e.WebGLConstants.UNSIGNED_BYTE,
                      this.canvas,
                    ))
                : ((this.texture = new e.Texture({
                    context: i,
                    image: this.canvas,
                    pixelFormat: e.WebGLConstants.RGBA,
                  })),
                  this.texture.bind(e.WebGLConstants.LINEAR, e.WebGLConstants.CLAMP_TO_EDGE));
            for (const e in this.tiles) {
              const t = this.tiles[e];
              'loaded' !== t.state && ((t.state = 'loaded'), (t.texture = this.texture));
            }
          }
          serialize() {
            return { type: 'canvas', coordinates: this.coordinates };
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const e of [this.canvas.width, this.canvas.height])
              if (isNaN(e) || e <= 0) return !0;
            return !1;
          }
          isEarthSource() {
            return !1;
          }
        },
        '3d-model': Tn,
        '3d-tiles': xn,
        terrain: class extends e.Evented {
          constructor(t, i, s, r) {
            super(),
              (this.id = t),
              (this.dispatcher = s),
              this.setEventedParent(r),
              (this.type = 'terrain'),
              (this.minzoom = 0),
              (this._maxzoom = 14),
              (this.roundZoom = !1),
              (this.scheme = 'xyz'),
              (this.tileSize = 512),
              (this._loaded = !1),
              (this._options = e.extend({}, i)),
              e.extend(this, e.pick(i, ['scheme', 'tileSize', 'capabilities', 'service'])),
              (this._tiles = i.tiles),
              (this.workerIDMap = new Map());
          }
          load() {
            this.fire(new e.Event('dataloading', { dataType: 'source' })),
              (this._tileJSONRequest = nn(this._options, this.map._transformRequest, (t, i) => {
                (this._tileJSONRequest = null),
                  t
                    ? this.fire(new e.ErrorEvent(t))
                    : i &&
                      (e.extend(this, i),
                      i.bounds && (this.tileBounds = new on(i.bounds, this.minzoom, this.maxzoom)),
                      this.fire(
                        new e.Event('data', { dataType: 'source', sourceDataType: 'metadata' }),
                      ),
                      this.fire(
                        new e.Event('data', { dataType: 'source', sourceDataType: 'content' }),
                      ));
              }));
          }
          onAdd(e) {
            (this.map = e), this.load();
          }
          onRemove() {
            this._tileJSONRequest &&
              (this._tileJSONRequest.cancel(), (this._tileJSONRequest = null));
          }
          serialize() {
            return e.extend({}, this._options);
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical);
          }
          loadTile(t, i) {
            const s = t.canonical.toRealCoord(this.scheme),
              r = t.canonical.url(this._tiles, this.scheme),
              n = Sr(r, 0, this.tileSize, s),
              o = {
                request: this.map._transformRequest(n, e.ResourceType.Tile),
                uid: t.key,
                tileID: t,
                type: this.type,
                source: this.id,
              },
              a = this.dispatcher.send(
                'loadTile',
                o,
                function (e, t) {
                  if ((t || i(e, t), e)) return i(e);
                  i(null, t);
                }.bind(this),
              );
            this.workerIDMap.set(t.key, a);
          }
          loadRegularMeshTile(e, t) {
            const i = this.dispatcher.send(
              'loadRegularTile',
              { uid: e.key, tileID: e, type: this.type, source: this.id },
              function (e, i) {
                if ((i || t(e, i), e)) return t(e);
                t(null, i);
              }.bind(this),
            );
            this.workerIDMap.set(e.key, i);
          }
          abortTile(e, t) {
            const i = this.workerIDMap.get(e.key);
            this.dispatcher.send(
              'abortTile',
              { uid: e.key, type: this.type, source: this.id },
              void 0,
              i,
            ),
              t();
          }
          unloadTile(e, t) {
            const i = this.workerIDMap.get(e.key);
            this.dispatcher.send(
              'removeTile',
              { uid: e.key, type: this.type, source: this.id },
              void 0,
              i,
            ),
              t();
          }
          hasTransition() {
            return !1;
          }
          set maxzoom(e) {
            isNaN(e) || (this._maxzoom = e);
          }
          get maxzoom() {
            return this._maxzoom;
          }
          set tiles(t) {
            e.defined(t)
              ? this._eventedParent.switchSupplier({ type: Jn, tiles: t })
              : this._eventedParent.switchSupplier({ type: eo });
          }
          get tiles() {
            return this._tiles;
          }
          set bounds(t) {
            e.defined(t) && (this.tileBounds = new on(t, this.minzoom, this.maxzoom));
          }
          get bounds() {
            return this.tileBounds;
          }
        },
      },
      So = function (t, i, s, r) {
        if (!Co[i.type])
          return {
            minzoom: i.minzoom,
            maxzoom: i.maxzoom,
            unloadGPUData() {},
            fire() {},
            hasTransition() {},
            serialize() {},
          };
        const n = new Co[i.type](t, i, s, r);
        if (n.id !== t) throw new Error(`Expected Source id to be ${t} instead of ${n.id}`);
        return e.bindAll(['load', 'abort', 'unload', 'serialize', 'prepare'], n), n;
      };
    function Eo(t, i) {
      const s = new e.Matrix4();
      return (
        s.translate([1, 1, 0]),
        s.scale([0.5 * t.width, 0.5 * t.height, 1]),
        s.multiplyRight(t.calculatePosMatrix(i.toUnwrapped()))
      );
    }
    function Po(e, t, i, s, r, n) {
      const o = (function (e, t, i) {
          if (e)
            for (const s of e) {
              const e = t[s];
              if (e && e.source === i && ('extrusion' === e.type || 'histogram' === e.type))
                return !0;
            }
          else
            for (const e in t) {
              const s = t[e];
              if (s.source === i && ('extrusion' === s.type || 'histogram' === s.type)) return !0;
            }
          return !1;
        })(s && s.layers, t, e.id),
        a = r.maxPitchScaleFactor(),
        l = e.tilesIn(i, a, o);
      l.sort(Ao);
      const h = [];
      for (const i of l)
        h.push({
          wrappedTileID: i.tileID.wrapped().key,
          queryResults: i.tile.queryRenderedFeatures(
            t,
            e._state,
            i.queryGeometry,
            i.cameraQueryGeometry,
            i.scale,
            s,
            r,
            a,
            Eo(r, i.tileID),
            n,
          ),
        });
      const c = (function (e) {
        const t = {},
          i = {};
        for (const s of e) {
          const e = s.queryResults,
            r = s.wrappedTileID,
            n = (i[r] = i[r] || {});
          for (const i in e) {
            const s = e[i],
              r = (n[i] = n[i] || {}),
              o = (t[i] = t[i] || []);
            for (const e of s)
              r[e.featureIndex] ||
                ((r[e.featureIndex] = !0),
                (e.feature.intersectionZ = e.intersectionZ),
                o.push(e.feature));
          }
        }
        return t;
      })(h);
      for (const t in c)
        c[t].forEach((t) => {
          const i = e.getFeatureState(t.layer['source-layer'], t.id);
          (t.source = t.layer.source),
            t.layer['source-layer'] && (t.sourceLayer = t.layer['source-layer']),
            (t.state = i);
        });
      return c;
    }
    function Mo(t, i, s, r, n) {
      const o = {};
      if (!r.layers) return {};
      for (let a = 0; a < r.layers.length; a++) {
        const l = r.layers[a];
        if ('extrusion' === i[l].type) {
          const r = t.tilesInOfSphereExtrusion(s, n, i[l]),
            a = [];
          let h,
            c = 1 / 0;
          const _ = e.getRay({ canvasX: s[0].x, canvasY: s[0].y, transform: n });
          r.map(
            (t) => (
              (t ? t.featureTriangles : []).map((t) => {
                const i = t.triangles;
                for (let s = 0; s < i.length; s++) {
                  const r = _.intersectTriangle(...i[s], !1, []);
                  if (r) {
                    const i = new e.Vector3(_.origin).distance(r);
                    i < c && ((c = i), (h = t.feature));
                  }
                }
                return null;
              }),
              null
            ),
          ),
            h && a.push({ feature: h, intersectionZ: c }),
            (o[`${l}`] = a);
        }
      }
      return o;
    }
    function Ao(e, t) {
      const i = e.tileID,
        s = t.tileID;
      return (
        i.overscaledZ - s.overscaledZ ||
        i.canonical.y - s.canonical.y ||
        i.wrap - s.wrap ||
        i.canonical.x - s.canonical.x
      );
    }
    function Ro() {
      return new e.window.Worker(Fg.workerUrl);
    }
    class Io {
      constructor() {
        this.active = {};
      }
      acquire(e) {
        if (!this.workers) {
          const e = Io.workerCount;
          for (this.workers = []; this.workers.length < e; ) this.workers.push(new Ro());
        }
        return (this.active[e] = !0), this.workers.slice();
      }
      release(e) {
        delete this.active[e],
          0 === Object.keys(this.active).length &&
            (this.workers.forEach((e) => {
              e.terminate();
            }),
            (this.workers = null));
      }
      isPreloaded() {
        return !!this.active.mapboxgl_preloaded_worker_pool;
      }
      numActive() {
        return Object.keys(this.active).length;
      }
    }
    const Oo = Math.floor(e.exported.hardwareConcurrency / 2) - 1;
    let Lo;
    function Do(t, i) {
      const s = {};
      for (const e in t) 'ref' !== e && (s[e] = t[e]);
      return (
        e.refProperties.forEach((e) => {
          e in i && (s[e] = i[e]);
        }),
        s
      );
    }
    function Bo(e) {
      e = e.slice();
      const t = Object.create(null);
      for (let i = 0; i < e.length; i++) t[e[i].id] = e[i];
      for (let i = 0; i < e.length; i++) 'ref' in e[i] && (e[i] = Do(e[i], t[e[i].ref]));
      return e;
    }
    Io.workerCount = Math.max(Math.min(Oo, 6), 1);
    const Vo = {
      setStyle: 'setStyle',
      addLayer: 'addLayer',
      removeLayer: 'removeLayer',
      setPaintProperty: 'setPaintProperty',
      setLayoutProperty: 'setLayoutProperty',
      setFilter: 'setFilter',
      addSource: 'addSource',
      removeSource: 'removeSource',
      setGeoJSONSourceData: 'setGeoJSONSourceData',
      setLayerZoomRange: 'setLayerZoomRange',
      setLayerProperty: 'setLayerProperty',
      setCenter: 'setCenter',
      setZoom: 'setZoom',
      setBearing: 'setBearing',
      setPitch: 'setPitch',
      setSprite: 'setSprite',
      setGlyphs: 'setGlyphs',
      setTransition: 'setTransition',
      setLight: 'setLight',
    };
    function No(e, t, i, s) {
      i.push({ command: Vo.addSource, args: [e, t[e], { isOriginal: s }] });
    }
    function ko(e, t, i) {
      t.push({ command: Vo.removeSource, args: [e] }), (i[e] = !0);
    }
    function Fo(e, t, i, s, r) {
      ko(e, i, s), No(e, t, i, r);
    }
    function Go(e, i, s) {
      let r;
      for (r in e[s]) if (e[s].hasOwnProperty(r) && 'data' !== r && !t(e[s][r], i[s][r])) return !1;
      for (r in i[s]) if (i[s].hasOwnProperty(r) && 'data' !== r && !t(e[s][r], i[s][r])) return !1;
      return !0;
    }
    function Uo(e, i, s, r, n, o) {
      let a;
      for (a in ((i = i || {}), (e = e || {})))
        e.hasOwnProperty(a) && (t(e[a], i[a]) || s.push({ command: o, args: [r, a, i[a], n] }));
      for (a in i)
        i.hasOwnProperty(a) &&
          !e.hasOwnProperty(a) &&
          (t(e[a], i[a]) || s.push({ command: o, args: [r, a, i[a], n] }));
    }
    function zo(e) {
      return e.id;
    }
    function Ho(e, t) {
      return (e[t.id] = t), e;
    }
    class Wo {
      constructor(e, t, i) {
        const s = (this.boxCells = []),
          r = (this.circleCells = []);
        (this.xCellCount = Math.ceil(e / i)), (this.yCellCount = Math.ceil(t / i));
        for (let e = 0; e < this.xCellCount * this.yCellCount; e++) s.push([]), r.push([]);
        (this.circleKeys = []),
          (this.boxKeys = []),
          (this.bboxes = []),
          (this.circles = []),
          (this.width = e),
          (this.height = t),
          (this.xScale = this.xCellCount / e),
          (this.yScale = this.yCellCount / t),
          (this.boxUid = 0),
          (this.circleUid = 0);
      }
      keysLength() {
        return this.boxKeys.length + this.circleKeys.length;
      }
      insert(e, t, i, s, r) {
        this._forEachCell(t, i, s, r, this._insertBoxCell, this.boxUid++),
          this.boxKeys.push(e),
          this.bboxes.push(t),
          this.bboxes.push(i),
          this.bboxes.push(s),
          this.bboxes.push(r);
      }
      insertCircle(e, t, i, s) {
        this._forEachCell(t - s, i - s, t + s, i + s, this._insertCircleCell, this.circleUid++),
          this.circleKeys.push(e),
          this.circles.push(t),
          this.circles.push(i),
          this.circles.push(s);
      }
      _insertBoxCell(e, t, i, s, r, n) {
        this.boxCells[r].push(n);
      }
      _insertCircleCell(e, t, i, s, r, n) {
        this.circleCells[r].push(n);
      }
      _query(e, t, i, s, r, n) {
        if (i < 0 || e > this.width || s < 0 || t > this.height) return !r && [];
        const o = [];
        if (e <= 0 && t <= 0 && this.width <= i && this.height <= s) {
          if (r) return !0;
          for (let e = 0; e < this.boxKeys.length; e++)
            o.push({
              key: this.boxKeys[e],
              x1: this.bboxes[4 * e],
              y1: this.bboxes[4 * e + 1],
              x2: this.bboxes[4 * e + 2],
              y2: this.bboxes[4 * e + 3],
            });
          for (let e = 0; e < this.circleKeys.length; e++) {
            const t = this.circles[3 * e],
              i = this.circles[3 * e + 1],
              s = this.circles[3 * e + 2];
            o.push({ key: this.circleKeys[e], x1: t - s, y1: i - s, x2: t + s, y2: i + s });
          }
          return n ? o.filter(n) : o;
        }
        return (
          this._forEachCell(
            e,
            t,
            i,
            s,
            this._queryCell,
            o,
            { hitTest: r, seenUids: { box: {}, circle: {} } },
            n,
          ),
          r ? o.length > 0 : o
        );
      }
      _queryCircle(e, t, i, s, r) {
        const n = e - i,
          o = e + i,
          a = t - i,
          l = t + i;
        if (o < 0 || n > this.width || l < 0 || a > this.height) return !s && [];
        const h = [];
        return (
          this._forEachCell(
            n,
            a,
            o,
            l,
            this._queryCellCircle,
            h,
            { hitTest: s, circle: { x: e, y: t, radius: i }, seenUids: { box: {}, circle: {} } },
            r,
          ),
          s ? h.length > 0 : h
        );
      }
      query(e, t, i, s, r) {
        return this._query(e, t, i, s, !1, r);
      }
      hitTest(e, t, i, s, r) {
        return this._query(e, t, i, s, !0, r);
      }
      hitTestCircle(e, t, i, s) {
        return this._queryCircle(e, t, i, !0, s);
      }
      _queryCell(e, t, i, s, r, n, o, a) {
        const l = o.seenUids,
          h = this.boxCells[r];
        if (null !== h) {
          const r = this.bboxes;
          for (const c of h)
            if (!l.box[c]) {
              l.box[c] = !0;
              const h = 4 * c;
              if (
                e <= r[h + 2] &&
                t <= r[h + 3] &&
                i >= r[h + 0] &&
                s >= r[h + 1] &&
                (!a || a(this.boxKeys[c]))
              ) {
                if (o.hitTest) return n.push(!0), !0;
                n.push({
                  key: this.boxKeys[c],
                  x1: r[h],
                  y1: r[h + 1],
                  x2: r[h + 2],
                  y2: r[h + 3],
                });
              }
            }
        }
        const c = this.circleCells[r];
        if (null !== c) {
          const r = this.circles;
          for (const h of c)
            if (!l.circle[h]) {
              l.circle[h] = !0;
              const c = 3 * h;
              if (
                this._circleAndRectCollide(r[c], r[c + 1], r[c + 2], e, t, i, s) &&
                (!a || a(this.circleKeys[h]))
              ) {
                if (o.hitTest) return n.push(!0), !0;
                {
                  const e = r[c],
                    t = r[c + 1],
                    i = r[c + 2];
                  n.push({ key: this.circleKeys[h], x1: e - i, y1: t - i, x2: e + i, y2: t + i });
                }
              }
            }
        }
      }
      _queryCellCircle(e, t, i, s, r, n, o, a) {
        const l = o.circle,
          h = o.seenUids,
          c = this.boxCells[r];
        if (null !== c) {
          const e = this.bboxes;
          for (const t of c)
            if (!h.box[t]) {
              h.box[t] = !0;
              const i = 4 * t;
              if (
                this._circleAndRectCollide(
                  l.x,
                  l.y,
                  l.radius,
                  e[i + 0],
                  e[i + 1],
                  e[i + 2],
                  e[i + 3],
                ) &&
                (!a || a(this.boxKeys[t]))
              )
                return n.push(!0), !0;
            }
        }
        const _ = this.circleCells[r];
        if (null !== _) {
          const e = this.circles;
          for (const t of _)
            if (!h.circle[t]) {
              h.circle[t] = !0;
              const i = 3 * t;
              if (
                this._circlesCollide(e[i], e[i + 1], e[i + 2], l.x, l.y, l.radius) &&
                (!a || a(this.circleKeys[t]))
              )
                return n.push(!0), !0;
            }
        }
      }
      _forEachCell(e, t, i, s, r, n, o, a) {
        const l = this._convertToXCellCoord(e),
          h = this._convertToYCellCoord(t),
          c = this._convertToXCellCoord(i),
          _ = this._convertToYCellCoord(s);
        for (let u = l; u <= c; u++)
          for (let l = h; l <= _; l++)
            if (r.call(this, e, t, i, s, this.xCellCount * l + u, n, o, a)) return;
      }
      _convertToXCellCoord(e) {
        return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)));
      }
      _convertToYCellCoord(e) {
        return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)));
      }
      _circlesCollide(e, t, i, s, r, n) {
        const o = s - e,
          a = r - t,
          l = i + n;
        return l * l > o * o + a * a;
      }
      _circleAndRectCollide(e, t, i, s, r, n, o) {
        const a = (n - s) / 2,
          l = Math.abs(e - (s + a));
        if (l > a + i) return !1;
        const h = (o - r) / 2,
          c = Math.abs(t - (r + h));
        if (c > h + i) return !1;
        if (l <= a || c <= h) return !0;
        const _ = l - a,
          u = c - h;
        return _ * _ + u * u <= i * i;
      }
    }
    const jo = 1e3;
    class qo {
      constructor(
        t,
        i,
        s = new Wo(i.width + 2e3, i.height + 2e3, 25),
        r = new Wo(i.width + 2e3, i.height + 2e3, 25),
      ) {
        (this.style = t),
          (this.transform = i),
          (this.grid = s),
          (this.ignoredGrid = r),
          (this.pitchfactor =
            Math.cos(i.getMapViewParams().pitch * e.CONSTS.TRANSFORM.DEG_TO_RAD) *
            i.cameraToCenterDistance),
          (this.screenRightBoundary = i.width + jo),
          (this.screenBottomBoundary = i.height + jo),
          (this.gridRightBoundary = i.width + 2e3),
          (this.gridBottomBoundary = i.height + 2e3);
      }
      placeCollisionBox(e, t, i, s, r) {
        const n = this.projectAndGetPerspectiveRatio(s, e.anchorPointX, e.anchorPointY),
          o = i * n.perspectiveRatio,
          a = e.x1 * o + n.point.x,
          l = e.y1 * o + n.point.y,
          h = e.x2 * o + n.point.x,
          c = e.y2 * o + n.point.y;
        return !this.isInsideGrid(a, l, h, c) || (!t && this.grid.hitTest(a, l, h, c, r))
          ? { box: [], offscreen: !1 }
          : { box: [a, l, h, c], offscreen: this.isOffscreen(a, l, h, c) };
      }
      approximateTileDistance(e, t, i, s, r) {
        const n = e.lastSegmentViewportDistance * i;
        return (
          e.prevTileDistance + n + ((r ? 1 : s / this.pitchfactor) - 1) * n * Math.abs(Math.sin(t))
        );
      }
      placeCollisionCircles(t, i, s, r, n, o, a, l, h, c, _, u, d, m) {
        const p = [],
          f = this.projectAnchor(c, o.anchorX, o.anchorY),
          g = h / 24,
          y = o.lineOffsetX * h,
          T = o.lineOffsetY * h,
          x = new e.pointGeometry3d(o.anchorX, o.anchorY),
          v = e.project(x, _).point,
          b = e.placeFirstAndLastGlyph(g, l, y, T, !1, v, x, o, a, _, {}, !0);
        let w = !1,
          C = !1,
          S = !0;
        const E = f.perspectiveRatio * r,
          P = 1 / (r * s);
        let M = 0,
          A = 0;
        b &&
          ((M = this.approximateTileDistance(
            b.first.tileDistance,
            b.first.angle,
            P,
            f.cameraDistance,
            d,
          )),
          (A = this.approximateTileDistance(
            b.last.tileDistance,
            b.last.angle,
            P,
            f.cameraDistance,
            d,
          )));
        for (let e = 0; e < t.length; e += 5) {
          const s = t[e],
            r = t[e + 1],
            n = t[e + 2],
            o = t[e + 3];
          if (!b || o < -M || o > A) {
            Xo(t, e, !1);
            continue;
          }
          const a = this.projectPoint(c, s, r),
            l = n * E;
          if (p.length > 0) {
            const i = a.x - p[p.length - 4],
              s = a.y - p[p.length - 3];
            if (l * l * 2 > i * i + s * s && e + 8 < t.length) {
              const i = t[e + 8];
              if (i > -M && i < A) {
                Xo(t, e, !1);
                continue;
              }
            }
          }
          p.push(a.x, a.y, l, e / 5), Xo(t, e, !0);
          const h = a.x - l,
            _ = a.y - l,
            d = a.x + l,
            f = a.y + l;
          if (
            ((S = S && this.isOffscreen(h, _, d, f)),
            (C = C || this.isInsideGrid(h, _, d, f)),
            !i && this.grid.hitTestCircle(a.x, a.y, l, m))
          ) {
            if (!u) return { circles: [], offscreen: !1 };
            w = !0;
          }
        }
        return { circles: w || !C ? [] : p, offscreen: S };
      }
      queryRenderedSymbols(t) {
        if (0 === t.length || (0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()))
          return {};
        const i = [];
        let s = 1 / 0,
          r = 1 / 0,
          n = -1 / 0,
          o = -1 / 0;
        for (const a of t) {
          const t = new e.pointGeometry3d(a.x + jo, a.y + jo);
          (s = Math.min(s, t.x)),
            (r = Math.min(r, t.y)),
            (n = Math.max(n, t.x)),
            (o = Math.max(o, t.y)),
            i.push(t);
        }
        const a = this.grid.query(s, r, n, o).concat(this.ignoredGrid.query(s, r, n, o)),
          l = {},
          h = {};
        for (const t of a) {
          const s = t.key;
          if (
            (void 0 === l[s.bucketInstanceId] && (l[s.bucketInstanceId] = {}),
            l[s.bucketInstanceId][s.featureIndex])
          )
            continue;
          const r = [
            new e.pointGeometry3d(t.x1, t.y1),
            new e.pointGeometry3d(t.x2, t.y1),
            new e.pointGeometry3d(t.x2, t.y2),
            new e.pointGeometry3d(t.x1, t.y2),
          ];
          e.polygonIntersectsPolygon(i, r) &&
            ((l[s.bucketInstanceId][s.featureIndex] = !0),
            void 0 === h[s.bucketInstanceId] && (h[s.bucketInstanceId] = []),
            h[s.bucketInstanceId].push(s.featureIndex));
        }
        return h;
      }
      insertCollisionBox(e, t, i, s, r) {
        (t ? this.ignoredGrid : this.grid).insert(
          { bucketInstanceId: i, featureIndex: s, collisionGroupID: r },
          e[0],
          e[1],
          e[2],
          e[3],
        );
      }
      insertCollisionCircles(e, t, i, s, r) {
        const n = t ? this.ignoredGrid : this.grid,
          o = { bucketInstanceId: i, featureIndex: s, collisionGroupID: r };
        for (let t = 0; t < e.length; t += 4) n.insertCircle(o, e[t], e[t + 1], e[t + 2]);
      }
      projectAnchor(t, i, s) {
        const r = [i, s, 0, 1];
        return (
          e.xyTransformMat4(r, r, t),
          {
            perspectiveRatio: 0.5 + (this.transform.cameraToCenterDistance / r[3]) * 0.5,
            cameraDistance: r[3],
          }
        );
      }
      projectPoint(t, i, s) {
        const r = [i, s, 0, 1];
        return (
          e.xyTransformMat4(r, r, t),
          new e.pointGeometry3d(
            ((r[0] / r[3] + 1) / 2) * this.transform.width + jo,
            ((-r[1] / r[3] + 1) / 2) * this.transform.height + jo,
          )
        );
      }
      projectAndGetPerspectiveRatio(t, i, s) {
        const r = [i, s, 0, 1];
        e.xyTransformMat4(r, r, t);
        const n = new e.pointGeometry3d(
            ((r[0] / r[3] + 1) / 2) * this.transform.width + jo,
            ((-r[1] / r[3] + 1) / 2) * this.transform.height + jo,
          ),
          o = 2 * Math.cos(this.transform.pitch * e.CONSTS.TRANSFORM.DEG_TO_RAD);
        let a = 3 - o;
        return (
          e.exported.devicePixelRatio - 1 < 0.1 && (a = 2.25 - 0.75 * o),
          (a *= 720 / this.transform.height),
          {
            point: n,
            perspectiveRatio: (0.5 + (this.transform.cameraToCenterDistance / r[3]) * 0.5) * a,
          }
        );
      }
      isOffscreen(e, t, i, s) {
        return i < jo || e >= this.screenRightBoundary || s < jo || t > this.screenBottomBoundary;
      }
      isInsideGrid(e, t, i, s) {
        return !0;
      }
    }
    function Xo(e, t, i) {
      e[t + 4] = i ? 1 : 0;
    }
    const Zo = e.properties.layout;
    class $o {
      constructor(e, t, i, s) {
        (this.opacity = e
          ? Math.max(0, Math.min(1, e.opacity + (e.placed ? t : -t)))
          : s && i
          ? 1
          : 0),
          (this.placed = i);
      }
      isHidden() {
        return 0 === this.opacity && !this.placed;
      }
    }
    class Ko {
      constructor(e, t, i, s, r) {
        (this.text = new $o(e ? e.text : null, t, i, r)),
          (this.icon = new $o(e ? e.icon : null, t, s, r));
      }
      isHidden() {
        return this.text.isHidden() && this.icon.isHidden();
      }
    }
    class Yo {
      constructor(e, t, i) {
        (this.text = e), (this.icon = t), (this.skipFade = i);
      }
    }
    class Qo {
      constructor(e, t, i, s, r) {
        (this.bucketInstanceId = e),
          (this.featureIndex = t),
          (this.sourceLayerIndex = i),
          (this.bucketIndex = s),
          (this.tileID = r);
      }
    }
    class Jo {
      constructor(e) {
        (this.crossSourceCollisions = e), (this.maxGroupID = 0), (this.collisionGroups = {});
      }
      get(e) {
        if (this.crossSourceCollisions) return { ID: 0, predicate: null };
        if (!this.collisionGroups[e]) {
          const t = ++this.maxGroupID;
          this.collisionGroups[e] = { ID: t, predicate: (e) => e.collisionGroupID === t };
        }
        return this.collisionGroups[e];
      }
    }
    class ea {
      constructor(e, t, i, s) {
        (this.style = e),
          (this.transform = t),
          (this.collisionIndex = new qo(this.style, this.transform)),
          (this.placements = {}),
          (this.opacities = {}),
          (this.stale = !1),
          (this.fadeDuration = i),
          (this.retainedQueryData = {}),
          (this.collisionGroups = new Jo(s));
      }
      placeLayerTile(t, i, s, r) {
        const n = i.getBucket(t),
          o = i.latestFeatureIndex;
        if (!n || !o || t.id !== n.layerIds[0]) return;
        const a = i.collisionBoxArray,
          l = n.layers[0].layout,
          h = Math.pow(2, this.style.map.transform.zoom - i.tileID.overscaledZ),
          c = i.tileSize / e.EXTENT,
          _ = this.transform.calculatePosMatrix(i.tileID.toUnwrapped()),
          u = e.getLabelPlaneMatrix(
            _,
            'map' === l.get('text-pitch-alignment'),
            'map' === l.get('text-rotation-alignment'),
            this.transform,
            e.pixelsToTileUnits(i, 1, this.style.getNearestTileZoom()),
          ),
          d = e.getLabelPlaneMatrix(
            _,
            'map' === l.get('icon-pitch-alignment'),
            'map' === l.get('icon-rotation-alignment'),
            this.transform,
            e.pixelsToTileUnits(i, 1, this.style.getNearestTileZoom()),
          );
        (this.retainedQueryData[n.bucketInstanceId] = new Qo(
          n.bucketInstanceId,
          o,
          n.sourceLayerIndex,
          n.index,
          i.tileID,
        )),
          this.placeLayerBucket(n, _, u, d, h, c, s, r, a);
      }
      placeLayerBucket(t, i, s, r, n, o, a, l, h) {
        const c = t.layers[0].layout,
          _ = e.evaluateSizeForZoom(
            t.textSizeData,
            this.style.getNearestTileZoom(),
            Zo && Zo.properties && Zo.properties['text-size'],
          ),
          u = c.get('text-optional'),
          d = c.get('icon-optional'),
          m = this.collisionGroups.get(t.sourceID);
        for (const r of t.symbolInstances)
          if (!l[r.crossTileID]) {
            let p = !1,
              f = !1,
              g = !0,
              y = null,
              T = null,
              x = null,
              v = 0,
              b = 0;
            r.collisionArrays ||
              (r.collisionArrays = t.deserializeCollisionBoxes(
                h,
                r.textBoxStartIndex,
                r.textBoxEndIndex,
                r.iconBoxStartIndex,
                r.iconBoxEndIndex,
              )),
              r.collisionArrays.textFeatureIndex && (v = r.collisionArrays.textFeatureIndex),
              r.collisionArrays.textBox &&
                ((y = this.collisionIndex.placeCollisionBox(
                  r.collisionArrays.textBox,
                  c.get('text-allow-overlap'),
                  o,
                  i,
                  m.predicate,
                )),
                (p = y.box.length > 0),
                (g = g && y.offscreen));
            const w = r.collisionArrays.textCircles;
            if (w) {
              const l = t.text.placedSymbolArray.get(r.placedTextSymbolIndices[0]),
                h = e.evaluateSizeForFeature(t.textSizeData, _, l);
              (T = this.collisionIndex.placeCollisionCircles(
                w,
                c.get('text-allow-overlap'),
                n,
                o,
                r.key,
                l,
                t.lineVertexArray,
                t.glyphOffsetArray,
                h,
                i,
                s,
                a,
                'map' === c.get('text-pitch-alignment'),
                m.predicate,
              )),
                (p = c.get('text-allow-overlap') || T.circles.length > 0),
                (g = g && T.offscreen);
            }
            r.collisionArrays.iconFeatureIndex && (b = r.collisionArrays.iconFeatureIndex),
              r.collisionArrays.iconBox &&
                ((x = this.collisionIndex.placeCollisionBox(
                  r.collisionArrays.iconBox,
                  c.get('icon-allow-overlap'),
                  o,
                  i,
                  m.predicate,
                )),
                (f = x.box.length > 0),
                (g = g && x.offscreen));
            const C = u || (0 === r.numGlyphVertices && 0 === r.numVerticalGlyphVertices),
              S = d || 0 === r.numIconVertices;
            C || S ? (S ? C || (f = f && p) : (p = f && p)) : (f = p = f && p),
              p &&
                y &&
                this.collisionIndex.insertCollisionBox(
                  y.box,
                  c.get('text-ignore-placement'),
                  t.bucketInstanceId,
                  v,
                  m.ID,
                ),
              f &&
                x &&
                this.collisionIndex.insertCollisionBox(
                  x.box,
                  c.get('icon-ignore-placement'),
                  t.bucketInstanceId,
                  b,
                  m.ID,
                ),
              p &&
                T &&
                this.collisionIndex.insertCollisionCircles(
                  T.circles,
                  c.get('text-ignore-placement'),
                  t.bucketInstanceId,
                  v,
                  m.ID,
                ),
              (this.placements[r.crossTileID] = new Yo(p, f, g || t.justReloaded)),
              (l[r.crossTileID] = !0);
          }
        t.justReloaded = !1;
      }
      commit(e, t) {
        this.commitTime = t;
        let i = !1;
        const s =
            e && 0 !== this.fadeDuration ? (this.commitTime - e.commitTime) / this.fadeDuration : 1,
          r = e ? e.opacities : {};
        for (const e in this.placements) {
          const t = this.placements[e],
            n = r[e];
          n
            ? ((this.opacities[e] = new Ko(n, s, t.text, t.icon)),
              (i = i || t.text !== n.text.placed || t.icon !== n.icon.placed))
            : ((this.opacities[e] = new Ko(null, s, t.text, t.icon, t.skipFade)),
              (i = i || t.text || t.icon));
        }
        for (const e in r) {
          const t = r[e];
          if (!this.opacities[e]) {
            const r = new Ko(t, s, !1, !1);
            r.isHidden() || ((this.opacities[e] = r), (i = i || t.text.placed || t.icon.placed));
          }
        }
        i
          ? (this.lastPlacementChangeTime = t)
          : 'number' != typeof this.lastPlacementChangeTime &&
            (this.lastPlacementChangeTime = e ? e.lastPlacementChangeTime : t);
      }
      updateLayerOpacities(e, t) {
        const i = {};
        for (const s of t) {
          const t = s.getBucket(e);
          t &&
            s.latestFeatureIndex &&
            e.id === t.layerIds[0] &&
            this.updateBucketOpacities(t, i, s.collisionBoxArray);
        }
      }
      updateBucketOpacities(t, i, s) {
        t.hasTextData() && t.text.opacityVertexArray.clear(),
          t.hasIconData() && t.icon.opacityVertexArray.clear(),
          t.hasCollisionBoxData() && t.collisionBox.collisionVertexArray.clear(),
          t.hasCollisionCircleData() && t.collisionCircle.collisionVertexArray.clear();
        const r = t.layers[0].layout,
          n = new Ko(null, 0, !1, !1, !0),
          o = new Ko(null, 0, r.get('text-allow-overlap'), r.get('icon-allow-overlap'), !0);
        for (let e = 0; e < t.symbolInstances.length; e++) {
          const r = t.symbolInstances[e],
            a = i[r.crossTileID];
          let l = this.opacities[r.crossTileID];
          a ? (l = n) : l || ((l = o), (this.opacities[r.crossTileID] = l)),
            (i[r.crossTileID] = !0);
          const h = r.numIconVertices > 0;
          if (r.numGlyphVertices > 0 || r.numVerticalGlyphVertices > 0) {
            const e = ha(l.text),
              i = (r.numGlyphVertices + r.numVerticalGlyphVertices) / 4;
            for (let s = 0; s < i; s++) t.text.opacityVertexArray.emplaceBack(e);
            for (const e of r.placedTextSymbolIndices)
              t.text.placedSymbolArray.get(e).hidden = l.text.isHidden();
          }
          if (h) {
            const i = ha(l.icon);
            for (let e = 0; e < r.numIconVertices / 4; e++)
              t.icon.opacityVertexArray.emplaceBack(i);
            t.icon.placedSymbolArray.get(e).hidden = l.icon.isHidden();
          }
          r.collisionArrays ||
            (r.collisionArrays = t.deserializeCollisionBoxes(
              s,
              r.textBoxStartIndex,
              r.textBoxEndIndex,
              r.iconBoxStartIndex,
              r.iconBoxEndIndex,
            ));
          const c = r.collisionArrays;
          if (c) {
            c.textBox &&
              t.hasCollisionBoxData() &&
              ta(t.collisionBox.collisionVertexArray, l.text.placed, !1),
              c.iconBox &&
                t.hasCollisionBoxData() &&
                ta(t.collisionBox.collisionVertexArray, l.icon.placed, !1);
            const e = c.textCircles;
            if (e && t.hasCollisionCircleData())
              for (let i = 0; i < e.length; i += 5)
                ta(t.collisionCircle.collisionVertexArray, l.text.placed, a || 0 === e[i + 4]);
          }
        }
        t.sortFeatures(this.transform.getMapViewParams().bearing * e.CONSTS.TRANSFORM.DEG_TO_RAD),
          this.retainedQueryData[t.bucketInstanceId] &&
            (this.retainedQueryData[t.bucketInstanceId].featureSortOrder = t.featureSortOrder),
          t.hasTextData() &&
            t.text.opacityVertexBuffer &&
            t.text.opacityVertexBuffer.updateData(t.text.opacityVertexArray),
          t.hasIconData() &&
            t.icon.opacityVertexBuffer &&
            t.icon.opacityVertexBuffer.updateData(t.icon.opacityVertexArray),
          t.hasCollisionBoxData() &&
            t.collisionBox.collisionVertexBuffer &&
            t.collisionBox.collisionVertexBuffer.updateData(t.collisionBox.collisionVertexArray),
          t.hasCollisionCircleData() &&
            t.collisionCircle.collisionVertexBuffer &&
            t.collisionCircle.collisionVertexBuffer.updateData(
              t.collisionCircle.collisionVertexArray,
            );
      }
      symbolFadeChange(e) {
        return 0 === this.fadeDuration ? 1 : (e - this.commitTime) / this.fadeDuration;
      }
      hasTransitions(e) {
        return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration;
      }
      stillRecent(e) {
        return 'undefined' !== this.commitTime && this.commitTime + this.fadeDuration > e;
      }
      setStale() {
        this.stale = !0;
      }
    }
    function ta(e, t, i) {
      e.emplaceBack(t ? 1 : 0, i ? 1 : 0),
        e.emplaceBack(t ? 1 : 0, i ? 1 : 0),
        e.emplaceBack(t ? 1 : 0, i ? 1 : 0),
        e.emplaceBack(t ? 1 : 0, i ? 1 : 0);
    }
    const ia = Math.pow(2, 25),
      sa = Math.pow(2, 24),
      ra = Math.pow(2, 17),
      na = Math.pow(2, 16),
      oa = Math.pow(2, 9),
      aa = Math.pow(2, 8),
      la = Math.pow(2, 1);
    function ha(e) {
      if (0 === e.opacity && !e.placed) return 0;
      if (1 === e.opacity && e.placed) return 4294967295;
      const t = e.placed ? 1 : 0,
        i = Math.floor(127 * e.opacity);
      return i * ia + t * sa + i * ra + t * na + i * oa + t * aa + i * la + t;
    }
    class ca {
      constructor() {
        (this._currentTileIndex = 0), (this._seenCrossTileIDs = {});
      }
      continuePlacement(e, t, i, s, r) {
        for (; this._currentTileIndex < e.length; )
          if (
            (t.placeLayerTile(s, e[this._currentTileIndex], i, this._seenCrossTileIDs),
            this._currentTileIndex++,
            r())
          )
            return !0;
      }
    }
    class _a {
      constructor(e, t, i, s, r, n, o) {
        (this.placement = new ea(e, t, n, o)),
          (this._currentPlacementIndex = i.length - 1),
          (this._forceFullPlacement = s),
          (this._showCollisionBoxes = r),
          (this._done = !1);
      }
      isDone() {
        return this._done;
      }
      continuePlacement(t, i, s) {
        const r = e.exported.now(),
          n = () => {
            const t = e.exported.now() - r;
            return !this._forceFullPlacement && t > 2;
          };
        for (; this._currentPlacementIndex >= 0; ) {
          const e = i[t[this._currentPlacementIndex]];
          if ('symbol' === e.type || 'symtracking' === e.type) {
            if (
              (this._inProgressLayer || (this._inProgressLayer = new ca()),
              this._inProgressLayer.continuePlacement(
                s[e.source],
                this.placement,
                this._showCollisionBoxes,
                e,
                n,
              ))
            )
              return;
            delete this._inProgressLayer;
          }
          this._currentPlacementIndex--;
        }
        this._done = !0;
      }
      commit(e, t) {
        return this.placement.commit(e, t), this.placement;
      }
    }
    const ua = 512 / e.EXTENT / 2,
      da = new Map([
        [-10, ua / 0.0009765625],
        [-9, ua / 0.001953125],
        [-8, ua / 0.00390625],
        [-7, ua / 0.0078125],
        [-6, ua / 0.015625],
        [-5, ua / 0.03125],
        [-4, ua / 0.0625],
        [-3, ua / 0.125],
        [-2, ua / 0.25],
        [-1, ua / 0.5],
        [0, ua / 1],
        [1, ua / 2],
        [2, ua / 4],
        [3, ua / 8],
        [4, ua / 16],
        [5, ua / 32],
        [6, ua / 64],
        [7, ua / 128],
        [8, ua / 256],
        [9, ua / 512],
        [10, ua / 1024],
      ]);
    class ma {
      constructor(e, t, i) {
        (this.tileID = e), (this.indexedSymbolInstances = {}), (this.bucketInstanceId = i);
        for (const i of t) {
          const t = i.key;
          this.indexedSymbolInstances[t] || (this.indexedSymbolInstances[t] = []),
            this.indexedSymbolInstances[t].push({
              crossTileID: i.crossTileID,
              coord: this.getScaledCoordinates(i, e),
            });
        }
      }
      getScaledCoordinates(t, i) {
        const s = da.get(i.canonical.z - this.tileID.canonical.z),
          r = t.anchor;
        return {
          x: Math.floor((i.canonical.x * e.EXTENT + r.x) * s),
          y: Math.floor((i.canonical.y * e.EXTENT + r.y) * s),
        };
      }
      findMatches(e, t, i) {
        const s =
          this.tileID.canonical.z < t.canonical.z
            ? 1
            : Math.pow(2, this.tileID.canonical.z - t.canonical.z);
        for (let r = 0; r < e.length; r++) {
          const n = e[r];
          if (n.crossTileID) continue;
          const o = this.indexedSymbolInstances[n.key];
          if (!o) continue;
          const a = this.getScaledCoordinates(n, t);
          for (let e = 0; e < o.length; e++) {
            const t = o[e];
            if (
              Math.abs(t.coord.x - a.x) <= s &&
              Math.abs(t.coord.y - a.y) <= s &&
              !i[t.crossTileID]
            ) {
              (i[t.crossTileID] = !0), (n.crossTileID = t.crossTileID);
              break;
            }
          }
        }
      }
    }
    class pa {
      constructor() {
        this.maxCrossTileID = 0;
      }
      generate() {
        return ++this.maxCrossTileID;
      }
    }
    class fa {
      constructor() {
        (this.indexes = {}), (this.usedCrossTileIDs = {}), (this.lng = 0);
      }
      handleWrapJump(e) {
        const t = Math.round((e - this.lng) / 360);
        if (0 !== t)
          for (const e in this.indexes) {
            const i = this.indexes[e],
              s = {};
            for (const e in i) {
              const r = i[e];
              (r.tileID = r.tileID.unwrapTo(r.tileID.wrap + t)), (s[r.tileID.key] = r);
            }
            this.indexes[e] = s;
          }
        this.lng = e;
      }
      addBucket(e, t, i) {
        if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
          if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === t.bucketInstanceId) return !1;
          this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]);
        }
        for (const e of t.symbolInstances) e.crossTileID = 0;
        this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
        const s = this.usedCrossTileIDs[e.overscaledZ];
        for (const i in this.indexes) {
          const r = this.indexes[i];
          if (Number(i) > e.overscaledZ)
            for (const i in r) {
              const n = r[i];
              n.tileID.isChildOf(e) && n.findMatches(t.symbolInstances, e, s);
            }
          else {
            const n = r[e.scaledTo(Number(i)).key];
            n && n.findMatches(t.symbolInstances, e, s);
          }
        }
        for (const e of t.symbolInstances)
          e.crossTileID || ((e.crossTileID = i.generate()), (s[e.crossTileID] = !0));
        return (
          void 0 === this.indexes[e.overscaledZ] && (this.indexes[e.overscaledZ] = {}),
          (this.indexes[e.overscaledZ][e.key] = new ma(e, t.symbolInstances, t.bucketInstanceId)),
          !0
        );
      }
      removeBucketCrossTileIDs(e, t) {
        for (const i in t.indexedSymbolInstances)
          for (const s of t.indexedSymbolInstances[i])
            delete this.usedCrossTileIDs[e][s.crossTileID];
      }
      removeStaleBuckets(e) {
        let t = !1;
        for (const i in this.indexes) {
          const s = this.indexes[i];
          for (const r in s)
            e[s[r].bucketInstanceId] ||
              (this.removeBucketCrossTileIDs(i, s[r]), delete s[r], (t = !0));
        }
        return t;
      }
    }
    class ga {
      constructor() {
        (this.layerIndexes = {}),
          (this.crossTileIDs = new pa()),
          (this.maxBucketInstanceId = 0),
          (this.bucketsInCurrentPlacement = {});
      }
      addLayer(e, t) {
        let i = this.layerIndexes[e.id];
        void 0 === i && (i = this.layerIndexes[e.id] = new fa());
        let s = !1;
        const r = {};
        for (const n of t) {
          const t = n.getBucket(e);
          t &&
            e.id === t.layerIds[0] &&
            (t.bucketInstanceId || (t.bucketInstanceId = ++this.maxBucketInstanceId),
            i.addBucket(n.tileID, t, this.crossTileIDs) && (s = !0),
            (r[t.bucketInstanceId] = !0));
        }
        return i.removeStaleBuckets(r) && (s = !0), s;
      }
      pruneUnusedLayers(e) {
        const t = {};
        e.forEach((e) => {
          t[e] = !0;
        });
        for (const e in this.layerIndexes) t[e] || delete this.layerIndexes[e];
      }
    }
    const ya = e.createLayout([
      { name: 'a_PositionHighAndSize', type: 'Float32', components: 4 },
      { name: 'a_PositionLowAndOutline', type: 'Float32', components: 4 },
      { name: 'a_CompressedAttribute0', type: 'Float32', components: 3 },
      { name: 'a_CompressedAttribute1', type: 'Float32', components: 4 },
      { name: 'a_ScaleByDistance', type: 'Float32', components: 4 },
      { name: 'a_DistanceDisplayCondition', type: 'Float32', components: 2 },
    ]);
    class Ta {
      constructor(t, i) {
        (t = e.defaultValue(t, 0)),
          (this._near = t),
          (i = e.defaultValue(i, Number.MAX_VALUE)),
          (this._far = i);
      }
      get near() {
        return this._near;
      }
      set near(e) {
        this._near = e;
      }
      get far() {
        return this._far;
      }
      set far(e) {
        this._far = e;
      }
      pack(t, i, s) {
        if (!e.defined(t)) throw new Error('value is required');
        if (!e.defined(i)) throw new Error('array is required');
        return (s = e.defaultValue(s, 0)), (i[s++] = t.near), (i[s] = t.far), i;
      }
      unpack(t, i, s) {
        if (!e.defined(t)) throw new Error('array is required');
        return (
          (i = e.defaultValue(i, 0)),
          e.defined(s) || (s = new Ta()),
          (s.near = t[i++]),
          (s.far = t[i]),
          s
        );
      }
      static equals(t, i) {
        return t === i || (e.defined(t) && e.defined(i) && t.near === i.near && t.far === i.far);
      }
      equals(e) {
        return Ta.equals(this, e);
      }
      static clone(t, i) {
        if (e.defined(t))
          return e.defined(i) || (i = new Ta()), (i.near = t.near), (i.far = t.far), i;
      }
      clone(e) {
        return Ta.clone(this, e);
      }
    }
    class xa {
      constructor(t, i, s, r) {
        (this.near = e.defaultValue(t, 0)),
          (this.nearValue = e.defaultValue(i, 0)),
          (this.far = e.defaultValue(s, 1)),
          (this.farValue = e.defaultValue(r, 0));
      }
      static clone(t, i) {
        if (e.defined(t))
          return e.defined(i)
            ? ((i.near = t.near),
              (i.nearValue = t.nearValue),
              (i.far = t.far),
              (i.farValue = t.farValue),
              i)
            : new xa(t.near, t.nearValue, t.far, t.farValue);
      }
      clone(e) {
        return xa.clone(this, e);
      }
      pack(t, i, s) {
        if (!e.defined(t)) throw new Error('value is required');
        if (!e.defined(i)) throw new Error('array is required');
        return (
          (s = e.defaultValue(s, 0)),
          (i[s++] = t.near),
          (i[s++] = t.nearValue),
          (i[s++] = t.far),
          (i[s] = t.farValue),
          i
        );
      }
      unpack(t, i, s) {
        if (!e.defined(t)) throw new Error('array is required');
        return (
          (i = e.defaultValue(i, 0)),
          e.defined(s) || (s = new xa()),
          (s.near = t[i++]),
          (s.nearValue = t[i++]),
          (s.far = t[i++]),
          (s.farValue = t[i]),
          s
        );
      }
      static equals(t, i) {
        return (
          t === i ||
          (e.defined(t) &&
            e.defined(i) &&
            t.near === i.near &&
            t.nearValue === i.nearValue &&
            t.far === i.far &&
            t.farValue === i.farValue)
        );
      }
      equals(e) {
        xa.equals(this, e);
      }
    }
    class va {
      constructor(t) {
        let i = (t = e.defaultValue(t, e.defaultValue.EMPTY_OBJECT)).translucencyByDistance,
          s = t.scaleByDistance,
          r = t.distanceDisplayCondition;
        if (e.defined(i)) {
          if (i.far <= i.near)
            throw new Error(
              'translucencyByDistance.far must be greater than translucencyByDistance.near.',
            );
          i = xa.clone(i);
        }
        if (e.defined(s)) {
          if (s.far <= s.near)
            throw new Error('scaleByDistance.far must be greater than scaleByDistance.near.');
          s = xa.clone(s);
        }
        if (e.defined(r)) {
          if (r.far <= r.near)
            throw new Error(
              'distanceDisplayCondition.far must be greater than distanceDisplayCondition.near.',
            );
          r = Ta.clone(r);
        }
        (this._show = e.defaultValue(t.show, !0)),
          (this._position = e.Vector3.clone(e.defaultValue(t.position, e.Vector3.ZERO))),
          (this._outlineColor = e.Color.clone(
            e.Color.parse(e.defaultValue(t.outlineColor, new e.Color(0, 0, 0, 0))),
          )),
          (this._color = e.Color.clone(
            e.Color.parse(e.defaultValue(t?.color, new e.Color(1, 1, 1, 1))),
          )),
          (this._outlineWidth = e.defaultValue(t.outlineWidth, 0)),
          (this._pixelSize = e.defaultValue(t.pixelSize, 10)),
          (this._scaleByDistance = s),
          (this._translucencyByDistance = i),
          (this._distanceDisplayCondition = r),
          (this.id = t.id),
          (this._index = -1);
      }
      get show() {
        return this._show;
      }
      set show(t) {
        if (!e.defined(t)) throw new Error('value is required.');
        this._show !== t && ((this._show = t), (this._pointPrimitiveCollection._dirty = !0));
      }
      get position() {
        return this._position;
      }
      set position(t) {
        if (!e.defined(t)) throw new Error('value is required.');
        if (!(t instanceof e.Vector3)) throw new Error('position is not the type of Vector3.');
        e.Vector3.equals(this._position, t) ||
          (e.Vector3.clone(t, this._position), (this._pointPrimitiveCollection._dirty = !0));
      }
      get scaleByDistance() {
        return this._scaleByDistance;
      }
      set scaleByDistance(t) {
        if (e.defined(t) && t.far <= t.near)
          throw new Error('far distance must be greater than near distance.');
        const i = this._scaleByDistance;
        xa.equals(i, t) ||
          ((this._scaleByDistance = xa.clone(t, i)), (this._pointPrimitiveCollection._dirty = !0));
      }
      get translucencyByDistance() {
        return this._translucencyByDistance;
      }
      set translucencyByDistance(t) {
        if (e.defined(t) && t.far <= t.near)
          throw new Error('far distance must be greater than near distance.');
        const i = this._translucencyByDistance;
        xa.equals(i, t) ||
          ((this._translucencyByDistance = xa.clone(t, i)),
          (this._pointPrimitiveCollection._dirty = !0));
      }
      get pixelSize() {
        return this._pixelSize;
      }
      set pixelSize(t) {
        if (!e.defined(t)) throw new Error('value is required.');
        this._pixelSize !== t &&
          ((this._pixelSize = t), (this._pointPrimitiveCollection._dirty = !0));
      }
      get color() {
        return this._color;
      }
      set color(t) {
        if (!e.defined(t)) throw new Error('value is required.');
        if (t instanceof e.Color || 'string' == typeof t) {
          const i = e.Color.parse(t);
          e.Color.equals(this._color, i) ||
            (e.Color.clone(i, this._color), (this._pointPrimitiveCollection._dirty = !0));
        }
      }
      get outlineColor() {
        return this._outlineColor;
      }
      set outlineColor(t) {
        if (!e.defined(t)) throw new Error('value is required.');
        if (t instanceof e.Color || 'string' == typeof t) {
          const i = e.Color.parse(t);
          e.Color.equals(this._outlineColor, i) ||
            (e.Color.clone(i, this._outlineColor), (this._pointPrimitiveCollection._dirty = !0));
        }
      }
      get outlineWidth() {
        return this._outlineWidth;
      }
      set outlineWidth(t) {
        if (!e.defined(t)) throw new Error('value is required.');
        this._outlineWidth !== t &&
          ((this._outlineWidth = t), (this._pointPrimitiveCollection._dirty = !0));
      }
      get distanceDisplayCondition() {
        return this._distanceDisplayCondition;
      }
      set distanceDisplayCondition(t) {
        if (e.defined(t) && t.far <= t.near) throw new Error('far must be greater than near');
        Ta.equals(this._distanceDisplayCondition, t) ||
          ((this._distanceDisplayCondition = Ta.clone(t, this._distanceDisplayCondition)),
          (this._pointPrimitiveCollection._dirty = !0));
      }
      destroy() {
        return (
          (this._show = void 0),
          (this._position = void 0),
          (this._color = void 0),
          (this._outlineColor = void 0),
          (this._outlineWidth = void 0),
          (this._pixelSize = void 0),
          (this._scaleByDistance = void 0),
          (this._translucencyByDistance = void 0),
          (this._distanceDisplayCondition = void 0),
          (this.id = void 0),
          (this._pointPrimitiveCollection = void 0),
          (this._index = void 0),
          e.destroyObject(this)
        );
      }
    }
    const ba = new e.EncodedVector3(),
      wa = 65536,
      Ca = 256;
    class Sa {
      constructor(t) {
        (t = e.defaultValue(t, e.defaultValue.EMPTY_OBJECT)),
          (this.id = e.defaultValue(t.id, e.uniqueId())),
          (this._depthTest = e.defaultValue(t.depthTest, !0)),
          (this._shaderSource = new e.ShaderSource({ type: 'point' })),
          (this._createVertexArray = !1),
          (this._pointPrimitives = []);
        const i = this;
        e.defaultValue(t.pointPrimitives, []).forEach((e) => {
          if (!(e instanceof va))
            throw new Error('pointPrimitives contains the type is not PointPrimitive!');
          i.add(e);
        }),
          (this._shaderScaleByDistance = !1),
          (this._shaderTranslucencyByDistance = !1),
          (this._shaderDistanceDisplayCondition = !1),
          (this._maxPixelSize = 1),
          (this._boundingSphere = new e.BoundingSphere()),
          (this._boundingBox = new e.OrientedBoundingBox()),
          (this.show = e.defaultValue(t.show, !0)),
          (this.modelMatrix = e.Matrix4.clone(e.defaultValue(t.modelMatrix, e.Matrix4.IDENTITY))),
          (this._modelMatrix = e.Matrix4.clone(e.Matrix4.IDENTITY)),
          (this._maxTotalPointSize = 1),
          (this._opaquePrimitives = []),
          (this._transLucentPrimitives = []),
          (this._vertexArray = new e.StructArrayLayout21f84()),
          (this._vertBuffer = void 0),
          (this._geometry = new e.Geometry({ type: 'pointCollection' })),
          (this._materialOpaque = new e.Material({
            type: 'point',
            renderState: {
              depthTest: this._depthTest
                ? e.renderStateEnum.enableDepthTest
                : e.renderStateEnum.disableDepthTest,
              depthMask: e.renderStateEnum.enableDepthMask,
            },
            defines: { OPAQUE: !0 },
          })),
          this._materialOpaque._uniforms.set('u_maxTotalPointSize', () => i._maxTotalPointSize),
          (this._materialTranslucent = new e.Material({
            type: 'point',
            renderState: {
              depthTest: this._depthTest
                ? e.renderStateEnum.enableDepthTest
                : e.renderStateEnum.disableDepthTest,
              depthMask: e.renderStateEnum.disableDepthMask,
              blending: e.renderStateEnum.enableBlending,
            },
          })),
          this._materialTranslucent._uniforms.set(
            'u_maxTotalPointSize',
            () => i._maxTotalPointSize,
          ),
          (this._opaquePrimitive = void 0),
          (this._translucentPrimitive = void 0),
          (this._dirty = !1);
      }
      get length() {
        return this._pointPrimitives.length;
      }
      add(e) {
        if (!(e instanceof va)) throw new Error('pointPrimitive is not type of PointPrimitive!');
        return (
          (e._pointPrimitiveCollection = this),
          (e._index = this._pointPrimitives.length),
          this._pointPrimitives.push(e),
          (this._createVertexArray = !0),
          e
        );
      }
      remove(e, t) {
        if (this.contains(e)) {
          this._pointPrimitives.splice(e._index, 1),
            (this._createVertexArray = !0),
            t && e.destroy();
          for (let e = 0, t = 0; e < this._pointPrimitives.length; ++e) {
            const i = this._pointPrimitives[e];
            i && (i._index = t++);
          }
          return !0;
        }
        return !1;
      }
      removeAll(e) {
        const t = this._pointPrimitives.length;
        for (let i = 0; i < t; ++i)
          this._pointPrimitives[i] && e && this._pointPrimitives[i].destroy();
        (this._pointPrimitives = []), (this._createVertexArray = !0);
      }
      contains(t) {
        return e.defined(t) && t._pointPrimitiveCollection === this;
      }
      get(t) {
        if (!e.defined(t)) throw new Error('index is required.');
        return this._pointPrimitives[t];
      }
      #R(t) {
        e.EncodedVector3.fromVector3(t.position, ba);
        const i = t.pixelSize,
          s = t.outlineWidth;
        this._maxPixelSize = Math.max(this._maxPixelSize, i + s);
        const r = ba.high,
          n = ba.low,
          o = t.color,
          a = t.outlineColor;
        let l = e.Color.floatToByte(o.r),
          h = e.Color.floatToByte(o.g),
          c = e.Color.floatToByte(o.b);
        const _ = l * wa + h * Ca + c;
        (l = e.Color.floatToByte(a.r)),
          (h = e.Color.floatToByte(a.g)),
          (c = e.Color.floatToByte(a.b));
        const u = l * wa + h * Ca + c,
          d = e.Color.floatToByte(o.a) * wa + e.Color.floatToByte(a.a) * Ca;
        let m = 0,
          p = 1,
          f = 1,
          g = 1;
        const y = t.translucencyByDistance;
        e.defined(y) &&
          ((m = y.near),
          (p = y.nearValue),
          (f = y.far),
          (g = y.farValue),
          (1 === p && 1 === g) || (this._shaderTranslucencyByDistance = !0));
        let T = t.show;
        0 === t.color.alpha && 0 === t.outlineColor.alpha && (T = !1),
          (p = e.CONSTS.CesiumMath.clamp(p, 0, 1)),
          (p = 1 === p ? 255 : (255 * p) | 0);
        const x = (T ? 1 : 0) * Ca + p;
        (g = e.CONSTS.CesiumMath.clamp(g, 0, 1)), (g = 1 === g ? 255 : (255 * g) | 0);
        const v = g;
        let b = 0,
          w = 1,
          C = 1,
          S = 1;
        const E = t.scaleByDistance;
        e.defined(E) &&
          ((b = E.near),
          (w = E.nearValue),
          (C = E.far),
          (S = E.farValue),
          (1 === w && 1 === S) || (this._shaderScaleByDistance = !0));
        let P = 0,
          M = Number.MAX_VALUE;
        const A = t.distanceDisplayCondition;
        e.defined(A) &&
          ((P = A.near),
          (M = A.far),
          (P *= P),
          (M *= M),
          (this._shaderDistanceDisplayCondition = !0)),
          this._vertexArray.emplaceBack(
            r.x,
            r.y,
            r.z,
            i,
            n.x,
            n.y,
            n.z,
            s,
            _,
            u,
            d,
            x,
            v,
            m,
            f,
            b,
            w,
            C,
            S,
            P,
            M,
          );
      }
      update(t) {
        const i = t.context;
        if (((this._opaquePrimitives = []), (this._transLucentPrimitives = []), !this.show)) return;
        this._maxTotalPointSize = e.ContextLimits.maximumAliasedPointSize;
        const s = this._pointPrimitives.length;
        if (
          (this._createVertexArray || this._dirty) &&
          ((this._createVertexArray = !1),
          (this._dirty = !1),
          e.defined(this._vertBuffer) && this._vertBuffer.destroy(),
          s > 0)
        ) {
          this._vertexArray = new e.StructArrayLayout21f84();
          let t = [];
          for (let e = 0; e < s; ++e)
            this.#R(this._pointPrimitives[e]), t.push(this._pointPrimitives[e].position);
          e.BoundingSphere.fromPoints(t, this._boundingSphere),
            e.OrientedBoundingBox.fromPoints(t, this._boundingBox),
            (t = []),
            this._shaderTranslucencyByDistance &&
              ((this._materialOpaque.defines = { EYE_DISTANCE_TRANSLUCENCY: !0 }),
              (this._materialTranslucent.defines = { EYE_DISTANCE_TRANSLUCENCY: !0 })),
            this._shaderScaleByDistance &&
              ((this._materialOpaque.defines = { EYE_DISTANCE_SCALING: !0 }),
              (this._materialTranslucent.defines = { EYE_DISTANCE_SCALING: !0 })),
            this._shaderDistanceDisplayCondition &&
              ((this._materialOpaque.defines = { DISTANCE_DISPLAY_CONDITION: !0 }),
              (this._materialTranslucent.defines = { DISTANCE_DISPLAY_CONDITION: !0 })),
            (this._vertBuffer = i.createVertexBuffer(this._vertexArray, ya.members, !1)),
            (this._geometry._vertBuffer = this._vertBuffer),
            (this._geometry.boundingSphere = this._boundingSphere),
            (this._geometry.boundingBox = this._boundingBox),
            (this._geometry._segmentVector = e.SegmentVector.simpleSegment(
              0,
              0,
              this._pointPrimitives.length,
              this._pointPrimitives.length,
            )),
            (this._geometry.primitiveType = e.WebGLConstants.POINTS),
            (this._opaquePrimitive = new e.Primitive({
              geometry: this._geometry,
              material: this._materialOpaque,
              modelMatrix: this.modelMatrix,
              name: 'pointCollection',
            })),
            (this._translucentPrimitive = new e.Primitive({
              geometry: this._geometry,
              material: this._materialTranslucent,
              modelMatrix: this.modelMatrix,
              name: 'pointCollection',
            }));
        }
        e.defined(this._vertBuffer) &&
          (this._opaquePrimitives.push(this._opaquePrimitive),
          this._transLucentPrimitives.push(this._translucentPrimitive));
      }
      getTranslucentPrimitives() {
        return this._transLucentPrimitives;
      }
      getOpaquePrimitives() {
        return this._opaquePrimitives;
      }
      set depthTest(t) {
        if (!e.isBoolean(t)) throw new Error("'depthTest' option must be a boolean value!");
        (this._depthTest = t),
          (this._materialOpaque.depthTest = t),
          (this._materialTranslucent.depthTest = t),
          (this._dirty = !0);
      }
      get depthTest() {
        return this._depthTest;
      }
      destroy() {
        return (
          this.removeAll(!0),
          (this._boundingBox = void 0),
          (this._boundingSphere = void 0),
          (this.id = void 0),
          this._shaderSource.destroy(),
          (this._shaderSource = void 0),
          (this._createVertexArray = void 0),
          (this._pointPrimitives = void 0),
          (this._shaderScaleByDistance = void 0),
          (this._shaderTranslucencyByDistance = void 0),
          (this._shaderDistanceDisplayCondition = void 0),
          (this._maxPixelSize = void 0),
          (this.show = void 0),
          (this.modelMatrix = void 0),
          (this._modelMatrix = void 0),
          (this._maxTotalPointSize = void 0),
          (this._opaquePrimitives = void 0),
          (this._transLucentPrimitives = void 0),
          (this._vertexArray = void 0),
          (this._vertBuffer = void 0),
          this._opaquePrimitive.destroy(),
          (this._materialOpaque = void 0),
          this._translucentPrimitive.destroy(),
          (this._materialTranslucent = void 0),
          (this._translucentPrimitive = void 0),
          (this._geometry = void 0),
          (this._dirty = void 0),
          e.destroyObject(this)
        );
      }
    }
    class Ea {
      constructor(e, t, i) {
        (this.item = e), (this.previous = t), (this.next = i);
      }
    }
    class Pa {
      constructor() {
        (this.head = null), (this.tail = null), (this._length = 0);
      }
      get length() {
        return this._length;
      }
      add(e) {
        const t = new Ea(e, this.tail, null);
        return (
          this.tail ? ((this.tail.next = t), (this.tail = t)) : ((this.head = t), (this.tail = t)),
          ++this._length,
          t
        );
      }
      remove(e) {
        e &&
          (e.previous && e.next
            ? ((e.previous.next = e.next), (e.next.previous = e.previous))
            : e.previous
            ? ((e.previous.next = null), (this.tail = e.previous))
            : e.next
            ? ((e.next.previous = null), (this.head = e.next))
            : ((this.head = null), (this.tail = null)),
          (e.next = null),
          (e.previous = null),
          --this._length);
      }
      splice(e, t) {
        e !== t && (this.remove(t), this._insert(e, t));
      }
      _insert(e, t) {
        const i = e.next;
        (e.next = t),
          this.tail === e ? (this.tail = t) : (i.previous = t),
          (t.next = i),
          (t.previous = e),
          ++this._length;
      }
    }
    function Ma(e) {
      return null != e;
    }
    class Aa {
      constructor() {
        (this._list = new Pa()),
          (this._sentinel = this._list.add('sentinel')),
          (this._trimTiles = !1);
      }
      reset() {
        this._list.splice(this._list.tail, this._sentinel);
      }
      touch(e) {
        const t = e._cacheNode;
        Ma(t) && this._list.splice(this._sentinel, t);
      }
      add(e, t, i) {
        Ma(t._cacheNode) || ((t._cacheNode = this._list.add(t)), i && i(e, t));
      }
      unloadTile(e, t, i) {
        const s = t._cacheNode;
        Ma(s) && (this._list.remove(s), (t._cacheNode = void 0), i && i(e, t));
      }
      unloadTiles(e, t) {
        const i = this._trimTiles;
        this._trimTiles = !1;
        const s = 1024 * e.maximumMemoryUsage * 1024,
          r = this._sentinel;
        let n = this._list.head;
        for (; n !== r && (e.gpuMemoryUsageInBytes > s || i); ) {
          const i = n.item;
          (n = n.next), this.unloadTile(e, i, t);
        }
      }
      trim() {
        this._trimTiles = !0;
      }
    }
    function Ra(e, t, i) {
      return {
        camera: { position: e.camerapos, direction: e.dir, up: e.up, fov: e.fov },
        viewport: e,
        height: i.height,
        cullingVolume: e.cullingVolume,
        frameNumber: t,
        sseDenominator: 1.15,
      };
    }
    new e.Vector3(),
      new e.Vector3(),
      new e.CullingVolume([
        new e.Plane(),
        new e.Plane(),
        new e.Plane(),
        new e.Plane(),
        new e.Plane(),
        new e.Plane(),
      ]);
    const Ia = 6356752.314245179,
      Oa = new e.Vector3(),
      La = 'I3S',
      Da = 'TILES3D',
      Ba = 'geometricError';
    function Va(e) {
      return null != e;
    }
    const Na = new e.Vector3();
    new e.Vector3(), new e.Vector3();
    const ka = new e.Rectangle();
    function Fa(t, i, s) {
      if ((P(t, '3D Tile: boundingVolume must be defined'), t.box))
        return (function (t, i, s) {
          const r = new e.Vector3(t[0], t[1], t[2]);
          i.transform(r, r);
          let n = [];
          if (10 === t.length) {
            const i = t.slice(3, 6),
              s = new e.Quaternion();
            s.fromArray(t, 6);
            const r = new e.Vector3([1, 0, 0]),
              o = new e.Vector3([0, 1, 0]),
              a = new e.Vector3([0, 0, 1]);
            r.transformByQuaternion(s),
              r.scale(i[0]),
              o.transformByQuaternion(s),
              o.scale(i[1]),
              a.transformByQuaternion(s),
              a.scale(i[2]),
              (n = [...r.toArray(), ...o.toArray(), ...a.toArray()]);
          } else n = [...t.slice(3, 6), ...t.slice(6, 9), ...t.slice(9, 12)];
          const o = i.transformAsVector(n.slice(0, 3)),
            a = i.transformAsVector(n.slice(3, 6)),
            l = i.transformAsVector(n.slice(6, 9)),
            h = new e.Matrix3([o[0], o[1], o[2], a[0], a[1], a[2], l[0], l[1], l[2]]);
          return Va(s) ? ((s.center = r), (s.halfAxes = h), s) : new e.OrientedBoundingBox(r, h);
        })(t.box, i, s);
      if (t.region) {
        (Va(t.region[0]) && Va(t.region[1]) && Va(t.region[2]) && Va(t.region[3])) ||
          (console.warn(
            '注意: 当前的3dtiles bounding region给出的异常，无法正常进行飞行的定位！',
            JSON.stringify(t.region),
          ),
          (t.region[0] = -Math.PI),
          (t.region[1] = Math.PI / 2),
          (t.region[2] = Math.PI),
          (t.region[3] = -Math.PI / 2));
        const i = e.Rectangle.unpack(t.region, 0, ka);
        return new e.TileBoundingRegion({
          rectangle: i,
          minimumHeight: t.region[4],
          maximumHeight: t.region[5],
        });
      }
      if (t.sphere)
        return (function (t, i, s) {
          const r = !Array.isArray(t),
            n = r ? new e.Vector3(t.center) : new e.Vector3(t[0], t[1], t[2]);
          i.transform(n, n);
          const o = i.getScale(Na),
            a = Math.max(Math.max(o[0], o[1]), o[2]),
            l = (r ? t.radius : t[3]) * a;
          return Va(s) ? ((s.center = n), (s.radius = l), s) : new e.BoundingSphere(n, l);
        })(t.sphere, i, s);
      throw new Error('3D Tile: boundingVolume must contain a sphere, region, or box');
    }
    new e.OrientedBoundingBox(), new e.Matrix4();
    const Ga = 6378137,
      Ua = Math.PI / 2;
    function za([t, i, s]) {
      const r = e.toRadians(t),
        n = e.toRadians(i),
        o = 1 + s / Ga,
        a = o * Math.cos(n);
      return [(t = a * Math.cos(r)), (i = a * Math.sin(r)), (s = o * Math.sin(n))];
    }
    function Ha([e, t, i = 0], [s, r, n = 0]) {
      const o = za([s, r, n]),
        a = za([e, t, i]),
        l = a[0] - o[0],
        h = a[1] - o[1],
        c = a[2] - o[2];
      return l * l + h * h + c * c;
    }
    function Wa(e, t) {
      const i = t.viewport,
        s = e.header.mbs[3],
        r = [e.header.mbs[0], e.header.mbs[1], e.header.mbs[2]],
        n = Ha(i.unprojectPosition(i.cameraPosition), r),
        o = s / Ga,
        a = n - o * o;
      if (a <= 0) return 170141175e30;
      let l = (function (e, t) {
        const { width: i, height: s, pixelProjectionMatrix: r } = t.viewport,
          n = Math.tan(Math.atan(Math.sqrt(1 / (r[0] * r[0]) + 1 / (r[5] * r[5]))));
        return Math.sqrt(s * s + i * i) / n;
      })(0, t);
      return (l *= o / Math.sqrt(a) / i.scale), l;
    }
    const ja = new e.Vector3();
    function qa(e) {
      return null != e;
    }
    class Xa {
      constructor(e, t, i, s, r, n) {
        P('object' == typeof t),
          (this.header = t),
          (this.tileset = e),
          (this.id = qa(r) ? r : t.id),
          (this.url = t.url),
          (this.parent = i),
          (this.refine = this._getRefine(t.refine)),
          (this.type = t.type),
          (this.transformRequest = n),
          (this._depth = 0),
          (this.contentUrl = t.contentUrl),
          (this.lodMetricType = null),
          (this.lodMetricValue = null),
          (this.boundingVolume = null),
          (this.content = null),
          (this.contentState = 0),
          (this.gpuMemoryUsageInBytes = 0),
          (this.children = []),
          (this.depth = 0),
          (this.viewportIds = []),
          (this._cacheNode = null),
          (this._frameNumber = null),
          (this._cacheNode = null),
          this._initializeLodMetric(t),
          this._initializeTransforms(t),
          this._initializeBoundingVolumes(t),
          this._initializeContent(t),
          this._initializeRenderingState(t),
          (this._lodJudge = null),
          (this._expireDate = null),
          (this._expiredContent = null),
          (this._getPriority = this._getPriority.bind(this)),
          (this.userData = {}),
          (this._updatedVisibilityFrame = 0),
          (this._shouldSelect = !1),
          (this._finalResolution = !0),
          (this._ancestorWithContent = void 0),
          (this._ancestorWithContentAvailable = void 0),
          (this._refines = !1),
          (this._priority = 0),
          (this._priorityHolder = this),
          (this._priorityProgressiveResolution = !1),
          (this._priorityProgressiveResolutionScreenSpaceErrorLeaf = !1),
          (this._priorityReverseScreenSpaceError = 0),
          (this._foveatedFactor = 0),
          (this._wasMinPriorityChild = !1),
          (this._screenSpaceErrorProgressiveResolution = 0),
          (this.priorityDeferred = !1),
          (this._isClipped = !1),
          Object.seal(this);
      }
      destroy() {
        this.header = null;
      }
      isDestroyed() {
        return null === this.header;
      }
      get selected() {
        return this._selectedFrame === this.tileset._frameNumber;
      }
      get isVisible() {
        return this._visible;
      }
      get isVisibleAndInRequestVolume() {
        return this._visible && this._inRequestVolume;
      }
      get hasRenderContent() {
        return !this.hasEmptyContent && !this.hasTilesetContent;
      }
      get hasChildren() {
        return (
          this.children.length > 0 || (this.header.children && this.header.children.length > 0)
        );
      }
      get contentReady() {
        return 3 === this.contentState || this.hasEmptyContent;
      }
      get contentAvailable() {
        return Boolean(
          (this.contentReady && this.hasRenderContent) ||
            (this._expiredContent && !this.contentFailed),
        );
      }
      get hasUnloadedContent() {
        return this.hasRenderContent && this.contentUnloaded;
      }
      get contentUnloaded() {
        return 0 === this.contentState;
      }
      get contentExpired() {
        return 4 === this.contentState;
      }
      get boundingSphere() {
        return this.boundingVolume.getBoundingSphere();
      }
      get contentFailed() {
        return 5 === this.contentState;
      }
      get extras() {
        return this.header.extras;
      }
      getScreenSpaceError(e, t) {
        switch (this.tileset.type) {
          case La:
            return Wa(this, e);
          case Da:
            return this.getTiles3DScreenSpaceError(this, e, t);
          default:
            throw new Error('Unsupported tileset type');
        }
      }
      getTiles3DScreenSpaceError(e, t, i) {
        const s = e.tileset,
          r = qa(e.parent) ? e.parent.lodMetricValue : s.lodMetricValue,
          n = i ? r : e.lodMetricValue;
        if (0 === n) return 0;
        const o = Math.max(e._distanceToCamera, 1e-7),
          { height: a, sseDenominator: l } = t;
        let h = (n * a) / (o * l);
        return (h -= this.getDynamicScreenSpaceError(s, o)), h;
      }
      fog(e, t) {
        const i = e * t;
        return 1 - Math.exp(-i * i);
      }
      getDynamicScreenSpaceError(e, t) {
        if (e.dynamicScreenSpaceError && e._dynamicScreenSpaceErrorComputedDensity) {
          const i = e.dynamicScreenSpaceErrorFactor;
          return this.fog(t, e._dynamicScreenSpaceErrorComputedDensity) * i;
        }
        return 0;
      }
      _getPriority() {
        const e = this.tileset._traverser;
        if (0 === this.contentState) return -1;
        if (this.tileset.frameNumber - this._touchedFrame >= 1) {
          const e = this.tileset._abortListMap.get(this.id);
          return e && e.abort(), -1;
        }
        const t = this.parent;
        return Math.max(
          (e.root ? e.root._screenSpaceError : 0) -
            (t && (0 === this._screenSpaceError || t.hasTilesetContent)
              ? t._screenSpaceError
              : this._screenSpaceError),
          0,
        );
      }
      async loadContent() {
        if (this.hasEmptyContent) return !1;
        if (this.content) return !0;
        this.contentExpired && (this._expireDate = null), (this.contentState = 1);
        const e = await this.tileset._requestScheduler.scheduleRequest(this.id, this._getPriority);
        if (!e) return (this.contentState = 0), !1;
        try {
          const e = this.tileset.getTileUrl(this.contentUrl),
            t = this.tileset.loader,
            i = {
              fetch: this.tileset.fetchOptions,
              [t.id]: { isTileset: 'json' === this.type, ...this._getLoaderSpecificOptions(t.id) },
              json: 'json' === this.type,
              transformRequest: this.transformRequest,
              context: this.tileset.options.context,
              useMipmap: this.tileset.options.useMipmap,
              clippingPlanes: this.tileset.clippingPlanes,
              allowPick: this.tileset.options.allowPick,
              nodeProperty: this.tileset.options.nodeProperty,
              dispatcher: this.tileset.options.dispatcher,
            };
          return (
            (i.fetch.isDestroyed = this.tileset._destroyed),
            (i.fetch._abortListMap = this.tileset._abortListMap),
            (this.content = await ut(e, t, i)),
            this.tileset._abortListMap.has(this.id) && this.tileset._abortListMap.delete(this.id),
            this._isTileset() &&
              this.tileset._initializeTileHeaders(this.content, this, ue(this.contentUrl)),
            (this.contentState = 3),
            this._onContentLoaded(),
            !0
          );
        } catch (e) {
          throw ((this.contentState = 5), e);
        } finally {
          e.done();
        }
      }
      unloadContent() {
        return (
          this.content && this.content.batchTable && this.content.batchTable.destroy(),
          this.content && this.content.featureTable && (this.content.featureTable = void 0),
          this.content && this.content.destroy && this.content.destroy(),
          this.content &&
            this.content.gltf &&
            e.getPrimitives(this.content.gltf).forEach((e) => {
              e?.destroy();
            }),
          (this.content = null),
          this.header.content && this.header.content.destroy && this.header.content.destroy(),
          (this.header.content = null),
          (this.contentState = 0),
          !0
        );
      }
      updateVisibility(t, i) {
        if (this._frameNumber === t.frameNumber) return;
        const s = this.parent,
          r = s ? s._visibilityPlaneMask : e.CullingVolume.MASK_INDETERMINATE;
        this._updateTransform(s ? s.computedTransform : this.tileset.modelMatrix),
          (this._distanceToCamera = this.distanceToTile(t)),
          (this._screenSpaceError = this.getScreenSpaceError(t, !1)),
          (this._visibilityPlaneMask = this.visibility(t, r)),
          (this._visible = this._visibilityPlaneMask !== e.CullingVolume.MASK_OUTSIDE),
          (this._inRequestVolume = this.insideViewerRequestVolume(t)),
          (this._frameNumber = t.frameNumber),
          (this.viewportIds = i);
      }
      visibility(e, t) {
        const { cullingVolume: i } = e,
          { boundingVolume: s } = this;
        return i.computeVisibilityWithPlaneMask(s, t);
      }
      contentVisibility(t) {
        return qa(this.boundingVolume)
          ? this._visibilityPlaneMask === e.CullingVolume.MASK_INSIDE
            ? 1
            : t.cullingVolume.computeVisibility(this.boundingVolume)
          : 1;
      }
      distanceToTile(t) {
        const i = this.boundingVolume;
        return i instanceof e.TileBoundingRegion
          ? i.distanceToCamera(t.camera)
          : Math.sqrt(Math.max(i.distanceSquaredTo(t.camera.position), 0));
      }
      cameraSpaceZDepth(e) {
        return ja.subVectors(this.boundingVolume.center, e.position), e.direction.dot(ja);
      }
      insideViewerRequestVolume(e) {
        const t = this._viewerRequestVolume;
        return !t || 0 === t.distanceToCamera(e.camera.position);
      }
      _initializeLodMetric(e) {
        (this.lodMetricType =
          'lodMetricType' in e
            ? e.lodMetricType
            : (this.parent && this.parent.lodMetricType) || this.tileset.lodMetricType),
          (this.lodMetricValue =
            'lodMetricValue' in e
              ? e.lodMetricValue
              : (this.parent && this.parent.lodMetricValue) || this.tileset.lodMetricValue);
      }
      _initializeTransforms(t) {
        this.transform = t.transform ? new e.Matrix4(t.transform) : new e.Matrix4();
        const i = this.parent,
          s = this.tileset,
          r = i && i.computedTransform ? i.computedTransform.clone() : s.modelMatrix.clone();
        this.computedTransform = new e.Matrix4(r).multiplyRight(this.transform);
        const n = i && i._initialTransform ? i._initialTransform.clone() : new e.Matrix4();
        this._initialTransform = new e.Matrix4(n).multiplyRight(this.transform);
      }
      _initializeBoundingVolumes(e) {
        (this._contentBoundingVolume = null),
          (this._viewerRequestVolume = null),
          this._updateBoundingVolume(e);
      }
      _initializeContent(e) {
        (this.content = { _tileset: this.tileset, _tile: this }),
          (this.hasEmptyContent = !0),
          (this.contentState = 0),
          (this.hasTilesetContent = !1),
          e.contentUrl && ((this.content = null), (this.hasEmptyContent = !1));
      }
      _initializeRenderingState(t) {
        (this.depth = t.level || (this.parent ? this.parent.depth + 1 : 0)),
          (this._shouldRefine = !1),
          (this._distanceToCamera = 0),
          (this._centerZDepth = 0),
          (this._screenSpaceError = 0),
          (this._visibilityPlaneMask = e.CullingVolume.MASK_INDETERMINATE),
          (this._visible = !1),
          (this._inRequestVolume = !1),
          (this._stackLength = 0),
          (this._selectionDepth = 0),
          (this._frameNumber = 0),
          (this._touchedFrame = 0),
          (this._visitedFrame = 0),
          (this._selectedFrame = 0),
          (this._requestedFrame = 0),
          (this._priority = 0);
      }
      _getRefine(e) {
        return e || (this.parent && this.parent.refine) || 2;
      }
      _isTileset() {
        return -1 !== this.contentUrl.indexOf('.json');
      }
      _onContentLoaded() {
        switch (this.content && this.content.type) {
          case 'vctr':
          case 'geom':
            this.tileset.traverser.disableSkipLevelOfDetail = !0;
        }
        this._isTileset() && (this.hasTilesetContent = !0);
      }
      _updateBoundingVolume(e) {
        this.boundingVolume = Fa(e.boundingVolume, this.computedTransform, this.boundingVolume);
        const t = e.content;
        t &&
          (t.boundingVolume &&
            (this._contentBoundingVolume = Fa(
              t.boundingVolume,
              this.computedTransform,
              this._contentBoundingVolume,
            )),
          e.viewerRequestVolume &&
            (this._viewerRequestVolume = Fa(
              e.viewerRequestVolume,
              this.computedTransform,
              this._viewerRequestVolume,
            )));
      }
      _updateTransform(t = new e.Matrix4()) {
        const i = t.clone().multiplyRight(this.transform);
        !i.equals(this.computedTransform) &&
          ((this.computedTransform = i), this._updateBoundingVolume(this.header));
      }
      _getLoaderSpecificOptions(e) {
        return 'i3s' === e
          ? {
              ...this.tileset.options.i3s,
              tile: this.header,
              tileset: this.tileset.tileset,
              isTileHeader: !1,
            }
          : { assetGltfUpAxis: ((t = this.tileset.tileset).asset && t.asset.gltfUpAxis) || 'Y' };
        var t;
      }
      updateExpiration() {
        if (qa(this._expireDate) && this.contentReady && !this.hasEmptyContent) {
          const e = Date.now();
          Date.lessThan(this._expireDate, e) &&
            ((this.contentState = 4), (this._expiredContent = this.content));
        }
      }
    }
    class Za {
      constructor(e = 0) {
        (this._array = new Array(e)), (this._map = new Map()), (this._length = e);
      }
      get length() {
        return this._length;
      }
      set length(e) {
        (this._length = e), e > this._array.length && (this._array.length = e);
      }
      get values() {
        return this._array;
      }
      get(e) {
        return P(e < this._array.length), this._array[e];
      }
      set(e, t) {
        P(e >= 0),
          e >= this.length && (this.length = e + 1),
          this._map.has(this._array[e]) && this._map.delete(this._array[e]),
          (this._array[e] = t),
          this._map.set(t, e);
      }
      delete(e) {
        const t = this._map.get(e);
        t >= 0 && (this._array.splice(t, 1), this._map.delete(e), this.length--);
      }
      peek() {
        return this._array[this._length - 1];
      }
      push(e) {
        if (!this._map.has(e)) {
          const t = this.length++;
          (this._array[t] = e), this._map.set(e, t);
        }
      }
      pop() {
        const e = this._array[--this.length];
        return this._map.delete(e), e;
      }
      reserve(e) {
        P(e >= 0), e > this._array.length && (this._array.length = e);
      }
      resize(e) {
        P(e >= 0), (this.length = e);
      }
      trim(e) {
        null == e && (e = this.length), (this._array.length = e);
      }
      reset() {
        (this._array = []), (this._map = new Map()), (this._length = 0);
      }
      find(e) {
        return this._map.has(e);
      }
    }
    class $a {
      constructor(e) {
        (this.options = { ...e }),
          (this.traversal = { stack: new Za(), stackMaximumLength: 0 }),
          (this.emptyTraversal = { stack: new Za(), stackMaximumLength: 0 }),
          (this.descendantTraversal = { stack: new Za(), stackMaximumLength: 0 }),
          (this.selectionTraversal = {
            stack: new Za(),
            stackMaximumLength: 0,
            ancestorStack: new Za(),
            ancestorStackMaximumLength: 0,
          }),
          (this.descendantSelectionDepth = 2),
          (this.selectedTiles = {}),
          (this.requestedTiles = {}),
          (this.loadTiles = []),
          (this.emptyTiles = {}),
          (this.root = void 0),
          (this._finalResolution = !0),
          (this._ancestorWithContent = void 0),
          (this._ancestorWithContentAvailable = void 0),
          (this._refines = !1),
          (this._priorityHolder = this),
          (this._priorityProgressiveResolution = !1),
          (this._priorityProgressiveResolutionScreenSpaceErrorLeaf = !1),
          (this._priorityReverseScreenSpaceError = 0),
          (this._foveatedFactor = 0),
          (this._wasMinPriorityChild = !1);
      }
      traverse(e, t, i) {
        if (
          ((this.options = { ...this.options, ...i }),
          (this.root = e.root),
          e.parent && e.parent.debugFreezeFrame)
        )
          return;
        this.reset(), (e._hasMixedContent = !1);
        const s = e.root;
        this.updateTile(e, s, t),
          this.isVisible(s)
            ? s.getScreenSpaceError(t, !0) <= e._maximumScreenSpaceError
              ? this.options.onTraversalEnd(t)
              : (this.skipLevelOfDetail(e)
                  ? e.immediatelyLoadDesiredLevelOfDetail
                    ? this.executeSkipTraversal(e, s, t)
                    : this.executeBaseAndSkipTraversal(e, s, t)
                  : this.executeBaseTraversal(e, s, t),
                this.traversal.stack.reset(),
                this.emptyTraversal.stack.reset(),
                this.descendantTraversal.stack.reset(),
                this.selectionTraversal.stack.reset(),
                this.selectionTraversal.ancestorStack.reset(),
                this.options.onTraversalEnd && this.options.onTraversalEnd(t))
            : this.options.onTraversalEnd(t);
      }
      reset() {
        (this.requestedTiles = {}),
          (this.selectedTiles = {}),
          (this.emptyTiles = {}),
          (this.loadTiles = []);
      }
      executeBaseTraversal(e, t, i) {
        this.executeTraversal(e, t, e._maximumScreenSpaceError, e._maximumScreenSpaceError, i);
      }
      executeSkipTraversal(e, t, i) {
        this.executeTraversal(e, t, Number.MAX_VALUE, e._maximumScreenSpaceError, i),
          this.traverseAndSelect(e, t, i);
      }
      executeBaseAndSkipTraversal(e, t, i) {
        this.executeTraversal(e, t, e.baseScreenSpaceError, e._maximumScreenSpaceError, i),
          this.traverseAndSelect(e, t, i);
      }
      skipLevelOfDetail(e) {
        return e.skipLevelOfDetail;
      }
      addEmptyTile(e, t) {
        this.emptyTiles[t.id] = t;
      }
      isVisible(e) {
        return e._visible && e._inRequestVolume;
      }
      selectTile(e, t, i) {
        -1 !== t.contentVisibility(i) &&
          ((t._selectedFrame = i.frameNumber), (this.selectedTiles[t.id] = t));
      }
      selectDescendants(e, t, i) {
        const s = this.descendantTraversal.stack;
        for (s.push(t); s.length > 0; ) {
          this.descendantTraversal.stackMaximumLength = Math.max(
            this.descendantTraversal.stackMaximumLength,
            s.length,
          );
          const r = s.pop().children,
            n = r.length;
          for (let o = 0; o < n; ++o) {
            const n = r[o];
            this.isVisible(n) &&
              (n.contentAvailable
                ? (this.updateTile(e, n, i), this.touchTile(e, n, i), this.selectTile(e, n, i))
                : n.depth - t.depth < this.descendantSelectionDepth && s.push(n));
          }
        }
      }
      selectDesiredTile(e, t, i) {
        if (!this.skipLevelOfDetail(e))
          return void (t.contentAvailable && this.selectTile(e, t, i));
        const s = t.contentAvailable ? t : t._ancestorWithContentAvailable;
        Ka(s) ? (s._shouldSelect = !0) : this.selectDescendants(e, t, i);
      }
      visitTile(e, t, i) {
        t._visitedFrame = i.frameNumber;
      }
      touchTile(e, t, i) {
        t._touchedFrame !== i.frameNumber &&
          (t.tileset._cache.touch(t), (t._touchedFrame = i.frameNumber));
      }
      updateMinimumMaximumPriority(e, t) {
        (e._maximumPriority.distance = Math.max(
          t._priorityHolder._distanceToCamera,
          e._maximumPriority.distance,
        )),
          (e._minimumPriority.distance = Math.min(
            t._priorityHolder._distanceToCamera,
            e._minimumPriority.distance,
          )),
          (e._maximumPriority.depth = Math.max(t.depth, e._maximumPriority.depth)),
          (e._minimumPriority.depth = Math.min(t.depth, e._minimumPriority.depth)),
          (e._maximumPriority.foveatedFactor = Math.max(
            t._priorityHolder._foveatedFactor,
            e._maximumPriority.foveatedFactor,
          )),
          (e._minimumPriority.foveatedFactor = Math.min(
            t._priorityHolder._foveatedFactor,
            e._minimumPriority.foveatedFactor,
          )),
          (e._maximumPriority.reverseScreenSpaceError = Math.max(
            t._priorityReverseScreenSpaceError,
            e._maximumPriority.reverseScreenSpaceError,
          )),
          (e._minimumPriority.reverseScreenSpaceError = Math.min(
            t._priorityReverseScreenSpaceError,
            e._minimumPriority.reverseScreenSpaceError,
          ));
      }
      isOnScreenLongEnough(e, t, i) {
        if (!e._cullRequestsWhileMoving) return !0;
        const s = Math.max(2 * t.boundingSphere.radius, 1),
          r = i.camera;
        return (
          (e.cullRequestsWhileMovingMultiplier *
            (0 !== r.positionWCDeltaMagnitude
              ? r.positionWCDeltaMagnitude
              : r.positionWCDeltaMagnitudeLastFrame)) /
            s <
          1
        );
      }
      loadTile(e, t, i) {
        t.id && this.loadTiles.push(t.id),
          t._requestedFrame !== i.frameNumber &&
            (this.hasUnloadedContent(t) || t.contentExpired) &&
            ((t._priority = this.getPriority(t)),
            (t._requestedFrame = i.frameNumber),
            (this.requestedTiles[t.id] = t));
      }
      updateVisibility(e, t, i) {
        if (t._updatedVisibilityFrame === e._updatedVisibilityFrame) return;
        const s = [];
        if (this.options.viewportTraversersMap)
          for (const e in this.options.viewportTraversersMap)
            this.options.viewportTraversersMap[e] === i.viewport.id && s.push(e);
        else s.push(i.viewport.id);
        t.updateVisibility(i, s), (t._updatedVisibilityFrame = e._updatedVisibilityFrame);
      }
      anyChildrenVisible(e, t, i) {
        let s = !1;
        const r = t.children,
          n = r.length;
        for (let t = 0; t < n; ++t) {
          const n = r[t];
          this.updateVisibility(e, n, i), (s = s || this.isVisible(n));
        }
        return s;
      }
      meetsScreenSpaceErrorEarly(e, t, i) {
        const s = t.parent;
        return (
          !(!Ka(s) || s.hasTilesetContent || 1 !== s.refine) &&
          t.getScreenSpaceError(i, !0) <= e._maximumScreenSpaceError
        );
      }
      updateTileVisibility(e, t, i) {
        if ((this.updateVisibility(e, t, i), !this.isVisible(t))) return;
        const s = t.children.length > 0;
        if (t.hasTilesetContent && s) {
          const s = t.children[0];
          return this.updateTileVisibility(e, s, i), void (t._visible = s._visible);
        }
        this.meetsScreenSpaceErrorEarly(e, t, i)
          ? (t._visible = !1)
          : 2 === t.refine && s && (this.anyChildrenVisible(e, t, i) || (t._visible = !1));
      }
      updateTile(e, t, i) {
        this.updateTileVisibility(e, t, i),
          t.updateExpiration(),
          (t._wasMinPriorityChild = !1),
          (t._priorityHolder = t),
          (t._shouldSelect = !1),
          (t._finalResolution = !0);
      }
      updateTileAncestorContentLinks(e, t) {
        (e._ancestorWithContent = void 0), (e._ancestorWithContentAvailable = void 0);
        const i = e.parent;
        if (Ka(i)) {
          const s = !this.hasUnloadedContent(i) || i._requestedFrame === t.frameNumber;
          (e._ancestorWithContent = s ? i : i._ancestorWithContent),
            (e._ancestorWithContentAvailable = i.contentAvailable
              ? i
              : i._ancestorWithContentAvailable);
        }
      }
      hasEmptyContent(e) {
        return e.hasEmptyContent || e.hasTilesetContent;
      }
      hasUnloadedContent(e) {
        return !this.hasEmptyContent(e) && e.contentUnloaded;
      }
      reachedSkippingThreshold(e, t) {
        const i = t._ancestorWithContent;
        return (
          !e.immediatelyLoadDesiredLevelOfDetail &&
          (t._priorityProgressiveResolutionScreenSpaceErrorLeaf ||
            (Ka(i) &&
              t._screenSpaceError < i._screenSpaceError / e.skipScreenSpaceErrorFactor &&
              t.depth > i.depth + e.skipLevels))
        );
      }
      updateAndPushChildren(e, t, i, s) {
        let r;
        const n = 2 === t.refine,
          o = t.children,
          a = o.length;
        for (r = 0; r < a; ++r) this.updateTile(e, o[r], s);
        o.sort(Ya);
        const l = !this.skipLevelOfDetail(e) && n && !this.hasEmptyContent(t);
        let h,
          c = !0,
          _ = !1;
        for (r = 0; r < a; ++r) {
          var u;
          (h = o[r]),
            this.isVisible(h)
              ? (i.push(h), (_ = !0))
              : (l || e.loadSiblings) && (this.loadTile(e, h, s), this.touchTile(e, h, s)),
            l &&
              ((u =
                !!h._inRequestVolume &&
                (this.hasEmptyContent(h)
                  ? this.executeEmptyTraversal(e, h, s)
                  : h.contentAvailable)),
              (c = c && u));
        }
        return _ || (c = !1), c;
      }
      inBaseTraversal(e, t, i) {
        return (
          !this.skipLevelOfDetail(e) ||
          (!e.immediatelyLoadDesiredLevelOfDetail &&
            (!Ka(t._ancestorWithContent) ||
              (0 === t._screenSpaceError
                ? t.parent._screenSpaceError > i
                : t._screenSpaceError > i)))
        );
      }
      canTraverse(e, t) {
        return (
          0 !== t.children.length &&
          (t.hasTilesetContent
            ? !t.contentExpired
            : t._screenSpaceError > e._maximumScreenSpaceError)
        );
      }
      executeTraversal(e, t, i, s, r) {
        const n = this.traversal.stack;
        for (n.push(t); n.length > 0; ) {
          this.traversal.stackMaximumLength = Math.max(this.traversal.stackMaximumLength, n.length);
          const t = n.pop();
          this.updateTileAncestorContentLinks(t, r);
          const s = this.inBaseTraversal(e, t, i),
            o = 1 === t.refine,
            a = 2 === t.refine,
            l = t.parent,
            h = !Ka(l) || l._refines;
          let c = !1;
          this.canTraverse(e, t) && (c = this.updateAndPushChildren(e, t, n, r) && h);
          const _ = !c && h;
          this.hasEmptyContent(t)
            ? (this.addEmptyTile(e, t),
              this.loadTile(e, t, r),
              _ && this.selectDesiredTile(e, t, r))
            : o
            ? (this.selectDesiredTile(e, t, r), this.loadTile(e, t, r))
            : a &&
              (s
                ? (this.loadTile(e, t, r), _ && this.selectDesiredTile(e, t, r))
                : _
                ? (this.selectDesiredTile(e, t, r), this.loadTile(e, t, r))
                : this.reachedSkippingThreshold(e, t) && this.loadTile(e, t, r)),
            this.visitTile(e, t, r),
            this.touchTile(e, t, r),
            (t._refines = c);
        }
      }
      executeEmptyTraversal(e, t, i) {
        let s = !0;
        const r = this.emptyTraversal.stack;
        for (r.push(t); r.length > 0; ) {
          this.emptyTraversal.stackMaximumLength = Math.max(
            this.emptyTraversal.stackMaximumLength,
            r.length,
          );
          const t = r.pop(),
            n = t.children,
            o = n.length,
            a = this.hasEmptyContent(t) && this.canTraverse(e, t);
          if (
            (a || t.contentAvailable || (s = !1),
            this.updateTile(e, t, i),
            this.isVisible(t) || (this.loadTile(e, t, i), this.touchTile(e, t, i)),
            a)
          )
            for (let e = 0; e < o; ++e) r.push(n[e]);
        }
        return s;
      }
      traverseAndSelect(e, t, i) {
        const s = this.selectionTraversal.stack,
          r = this.selectionTraversal.ancestorStack;
        let n;
        for (s.push(t); s.length > 0 || r.length > 0; ) {
          if (
            ((this.selectionTraversal.stackMaximumLength = Math.max(
              this.selectionTraversal.stackMaximumLength,
              s.length,
            )),
            (this.selectionTraversal.ancestorStackMaximumLength = Math.max(
              this.selectionTraversal.ancestorStackMaximumLength,
              r.length,
            )),
            r.length > 0)
          ) {
            const t = r.peek();
            if (t._stackLength === s.length) {
              r.pop(), t !== n && (t._finalResolution = !1), this.selectTile(e, t, i);
              continue;
            }
          }
          const t = s.pop();
          if (!Ka(t)) continue;
          const o = 1 === t.refine,
            a = t._shouldSelect,
            l = t.children,
            h = l.length,
            c = this.canTraverse(e, t);
          if (a)
            if (o) this.selectTile(e, t, i);
            else {
              if (
                ((t._selectionDepth = r.length),
                t._selectionDepth > 0 && (e._hasMixedContent = !0),
                (n = t),
                !c)
              ) {
                this.selectTile(e, t, i);
                continue;
              }
              r.push(t), (t._stackLength = s.length);
            }
          if (c)
            for (let e = 0; e < h; ++e) {
              const t = l[e];
              this.isVisible(t) && s.push(t);
            }
        }
      }
      getPriority(e) {
        const { options: t } = this;
        switch (e.refine) {
          case 1:
            return e._distanceToCamera;
          case 2:
            const { parent: i } = e;
            return (
              this.root._screenSpaceError -
              (!i || (t.skipLevelOfDetail && 0 !== e._screenSpaceError && !i.hasTilesetContent)
                ? e._screenSpaceError
                : i._screenSpaceError)
            );
          default:
            return assert(!1);
        }
      }
    }
    function Ka(e) {
      return null != e;
    }
    function Ya(e, t) {
      return 0 === t._distanceToCamera && 0 === e._distanceToCamera
        ? t._centerZDepth - e._centerZDepth
        : t._distanceToCamera - e._distanceToCamera;
    }
    const Qa = { loadSiblings: !1, skipLevelOfDetail: !1, maximumScreenSpaceError: 2 };
    class Ja {
      constructor(e) {
        (this.options = { ...Qa, ...e }),
          (this._traversalStack = new Za()),
          (this._emptyTraversalStack = new Za()),
          (this._frameNumber = null),
          (this.root = null),
          (this.selectedTiles = {}),
          (this.requestedTiles = {}),
          (this.emptyTiles = {});
      }
      traverse(e, t, i) {
        (this.root = e),
          (this.options = { ...this.options, ...i }),
          this.reset(),
          this.updateTile(e, t),
          (this._frameNumber = t.frameNumber),
          this.executeTraversal(e, t);
      }
      reset() {
        (this.requestedTiles = {}),
          (this.selectedTiles = {}),
          (this.emptyTiles = {}),
          this._traversalStack.reset(),
          this._emptyTraversalStack.reset();
      }
      executeTraversal(e, t) {
        const i = this._traversalStack;
        for (i.push(e); i.length > 0; ) {
          const e = i.pop();
          let s = !1;
          this.canTraverse(e, t) &&
            (this.updateChildTiles(e, t), (s = this.updateAndPushChildren(e, t, i)));
          const r = e.parent,
            n = Boolean(!r || r._shouldRefine),
            o = !s;
          e.hasRenderContent
            ? 1 === e.refine
              ? (this.loadTile(e, t), this.selectTile(e, t))
              : 2 === e.refine && (this.loadTile(e, t), o && this.selectTile(e, t))
            : ((this.emptyTiles[e.id] = e), this.loadTile(e, t), o && this.selectTile(e, t)),
            this.touchTile(e, t),
            (e._shouldRefine = s && n);
        }
        this.options.onTraversalEnd && this.options.onTraversalEnd(t);
      }
      updateChildTiles(e, t) {
        const i = e.children;
        for (const e of i) this.updateTile(e, t);
        return !0;
      }
      updateAndPushChildren(e, t, i) {
        const { loadSiblings: s, skipLevelOfDetail: r } = this.options,
          n = e.children;
        n.sort(this.compareDistanceToCamera);
        const o = !r && 2 === e.refine && e.hasRenderContent;
        let a = !1;
        for (const e of n)
          if (
            (e.isVisibleAndInRequestVolume
              ? (i.find(e) && i.delete(e), i.push(e), (a = !0))
              : (o || s) && (this.loadTile(e, t), this.touchTile(e, t)),
            o)
          ) {
            let i;
            if (
              ((i =
                !!e._inRequestVolume &&
                (e.hasRenderContent ? e.contentAvailable : this.executeEmptyTraversal(e, t))),
              !i)
            )
              return i;
          }
        return a;
      }
      updateTile(e, t) {
        this.updateTileVisibility(e, t);
      }
      selectTile(e, t) {
        this.shouldSelectTile(e, t) &&
          ((e._selectedFrame = t.frameNumber), (this.selectedTiles[e.id] = e));
      }
      loadTile(e, t) {
        this.shouldLoadTile(e, t) &&
          ((e._requestedFrame = t.frameNumber),
          (e._priority = this.getPriority(e)),
          (this.requestedTiles[e.id] = e));
      }
      touchTile(e, t) {
        e.tileset._cache.touch(e), (e._touchedFrame = t.frameNumber);
      }
      canTraverse(e, t, i = !1, s = !1) {
        return (
          !(!s && !e.isVisibleAndInRequestVolume) &&
          !!e.hasChildren &&
          (e.hasTilesetContent ? !e.contentExpired : this.shouldRefine(e, t, i))
        );
      }
      shouldLoadTile(e, t) {
        return e.hasUnloadedContent || e.contentExpired;
      }
      shouldSelectTile(e, t) {
        return e.contentAvailable && !this.options.skipLevelOfDetail;
      }
      shouldRefine(e, t, i) {
        let s = e._screenSpaceError;
        return i && (s = e.getScreenSpaceError(t, !0)), s > this.options.maximumScreenSpaceError;
      }
      updateTileVisibility(e, t) {
        const i = [];
        if (this.options.viewportTraversersMap)
          for (const e in this.options.viewportTraversersMap)
            this.options.viewportTraversersMap[e] === t.viewport.id && i.push(e);
        else i.push(t.viewport.id);
        e.updateVisibility(t, i);
      }
      compareDistanceToCamera(e, t) {
        return e._distanceToCamera - t._distanceToCamera;
      }
      getPriority(e) {
        const { options: t } = this;
        switch (e.refine) {
          case 1:
            return e._distanceToCamera;
          case 2:
            const { parent: i } = e;
            return (
              this.root._screenSpaceError -
              (!i || (t.skipLevelOfDetail && 0 !== e._screenSpaceError && !i.hasTilesetContent)
                ? e._screenSpaceError
                : i._screenSpaceError)
            );
          default:
            return P(!1);
        }
      }
      anyChildrenVisible(e, t) {
        let i = !1;
        for (const s of e.children) s.updateVisibility(t), (i = i || s.isVisibleAndInRequestVolume);
        return i;
      }
      executeEmptyTraversal(e, t) {
        let i = !0;
        const s = this._emptyTraversalStack;
        for (; s.length > 0; ) {
          const e = s.pop();
          this.updateTile(e, t),
            e.isVisibleAndInRequestVolume || (this.loadTile(e, t), this.touchTile(e, t));
          const r = !e.hasRenderContent && this.canTraverse(e, t, !1, !0);
          if ((r || e.contentAvailable || (i = !1), r)) {
            const t = e.children.filter((e) => e);
            for (const e of t) s.find(e) && s.delete(e), s.push(e);
          }
        }
        return i;
      }
    }
    class el {
      constructor() {
        this._statusMap = {};
      }
      add(e, t, i, s) {
        this._statusMap[t] ||
          ((this._statusMap[t] = {
            request: e,
            callback: i,
            key: t,
            frameState: s,
            status: 'REQUESTED',
          }),
          e()
            .then((e) => {
              (this._statusMap[t].status = 'COMPLETED'), this._statusMap[t].callback(e, s);
            })
            .catch((e) => {
              (this._statusMap[t].status = 'ERROR'), i(e);
            }));
      }
      update(e, t) {
        this._statusMap[e] && (this._statusMap[e].frameState = t);
      }
      find(e) {
        return this._statusMap[e];
      }
    }
    class tl extends Ja {
      constructor(e) {
        super(e), (this._tileManager = new el());
      }
      shouldRefine(e, t) {
        return (
          (e._lodJudge = (function (e, t) {
            const i = t.viewport,
              s = i.metersPerPixel,
              r = e.header.mbs[1],
              n = e.header.mbs[0],
              o = e.header.mbs[2],
              a = e.header.mbs[3],
              { height: l, width: h, latitude: c, longitude: _ } = i,
              u = [_, c],
              d = [n, r, o],
              m = [_, r],
              p = [n, c],
              f = Math.sqrt(l * l + h * h) * s[0],
              g = Ha(u, d),
              y = 0.5 * l + a / Ga,
              T = 0.5 * h + a / Ga;
            if (g > f + a / Ga) return 'OUT';
            if (Ha(u, m) > y) return 'OUT';
            if (Ha(u, p) > T) return 'OUT';
            if (0 === e.lodMetricValue) return 'DIG';
            let x = Wa(e, t);
            return (
              (x *= Ua),
              x < 0.5
                ? 'OUT'
                : !e.header.children || x <= e.lodMetricValue
                ? 'DRAW'
                : e.header.children
                ? 'DIG'
                : 'OUT'
            );
          })(e, t)),
          'DIG' === e._lodJudge
        );
      }
      updateChildTiles(e, t) {
        const i = e.header.children || [],
          s = e.children,
          r = e.tileset;
        for (const n of i) {
          const i = `${n.id}-${t.viewport.id}`,
            o = s && s.find((e) => e.id === i);
          if (o) o && this.updateTile(o, t);
          else {
            let s = () => this._loadTile(n.id, r);
            this._tileManager.find(i)
              ? this._tileManager.update(i, t)
              : (r.tileset.nodePages &&
                  (s = () => r.tileset.nodePagesTile.formTileFromNodePages(n.id)),
                this._tileManager.add(s, i, (t) => this._onTileLoad(t, e, i), t));
          }
        }
      }
      async _loadTile(e, t) {
        const { loader: i } = t,
          s = t.getTileUrl(`${t.url}/nodes/${e}`),
          r = { i3s: { ...t.fetchOptions, isTileHeader: !0, loadContent: !1 } };
        return await ut(s, i, r);
      }
      _onTileLoad(e, t, i) {
        const s = new Xa(t.tileset, e, t, this.options.basePath, i);
        t.children.push(s);
        const r = this._tileManager.find(s.id).frameState;
        this.updateTile(s, r), this._frameNumber === r.frameNumber && this.executeTraversal(s, r);
      }
    }
    const il = 'Tiles In Tileset(s)',
      sl = 'Tiles In Memory',
      rl = 'Tiles In View',
      nl = 'Tiles To Render',
      ol = 'Tiles Loaded',
      al = 'Tiles Loading',
      ll = 'Tiles Unloaded',
      hl = 'Failed Tile Loads',
      cl = 'Points',
      _l = 'Tile Memory Use',
      ul = /\/\/.*\.[0-9]{1,4}(:[\w]+)?/g,
      dl =
        /^((http:\/\/)|(https:\/\/))?([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,6}()/g,
      ml = {
        modelMatrix: new e.Matrix4(),
        throttleRequests: !0,
        maximumMemoryUsage: 32,
        onTileLoad: () => {},
        onTileUnload: () => {},
        onTileError: (e, t, i) => {},
        maximumScreenSpaceError: 8,
      };
    class pl {
      constructor(e, t = {}) {
        P(e),
          (this.options = { ...ml, ...t }),
          (this.subIPs = t.subIPs),
          (this.tileset = e),
          (this.loader = e.loader),
          (this.type = e.type),
          (this.url = e.url),
          (this.basePath = e.basePath || ue(this.url)),
          (this.modelMatrix = this.options.modelMatrix),
          (this.lodMetricType = e.lodMetricType),
          (this.lodMetricValue = e.lodMetricValue),
          (this.refine = e.root.refine),
          (this.fetchOptions = this.options.fetchOptions || {}),
          this.options.headers && (this.fetchOptions.headers = this.options.headers),
          this.options.token && (this.fetchOptions.token = this.options.token),
          (this.root = null),
          (this.roots = {}),
          (this.cartographicCenter = null),
          (this.cartesianCenter = null),
          (this.zoom = 1),
          (this.boundingVolume = null),
          (this._traverser = this._initializeTraverser()),
          (this._cache = new Aa()),
          (this._requestScheduler = new ve({
            throttleRequests: this.options.throttleRequests,
            maxRequests: this.options.maxRequests,
          })),
          (this._frameNumber = 0),
          (this._updateFrameNumber = 0),
          (this._pendingCount = 0),
          (this.selectedTiles = []),
          (this._emptyTiles = []),
          (this._requestedTiles = []),
          (this._selectedTilesToStyle = []),
          (this.frameStateData = {}),
          (this._queryParams = {}),
          (this._queryParamsString = null),
          (this.maximumMemoryUsage = this.options.maximumMemoryUsage),
          (this.gpuMemoryUsageInBytes = 0),
          (this.stats = new Te({ id: this.url })),
          this._initializeStats(),
          (this._hasMixedContent = !1),
          (this._maximumScreenSpaceError = this.options.maximumScreenSpaceError),
          (this._properties = void 0),
          (this._extensionsUsed = void 0),
          (this._gltfUpAxis = void 0),
          (this._dynamicScreenSpaceErrorComputedDensity = 0),
          (this.extras = null),
          (this.asset = {}),
          (this.credits = {}),
          (this.description = this.options.description),
          (this._defaultGeometrySchema = []),
          (this.loadSiblings = this.options.loadSiblings),
          (this.skipLevelOfDetail = this.options.skipLevelOfDetail),
          (this.baseScreenSpaceError = this.options.baseScreenSpaceError),
          (this._updatedVisibilityFrame = 0),
          (this.skipLevels = this.options.skipLevels),
          (this.skipScreenSpaceErrorFactor = this.options.skipScreenSpaceErrorFactor),
          (this.immediatelyLoadDesiredLevelOfDetail =
            this.options.immediatelyLoadDesiredLevelOfDetail),
          (this._hasMixedContent = !1),
          (this.clippingPlanes = this.options.clippingPlanes),
          (this.allowPick = this.options.allowPick),
          (this.nodeProperty = this.options.nodeProperty),
          (this._maximumPriority = {
            foveatedFactor: -Number.MAX_VALUE,
            depth: -Number.MAX_VALUE,
            distance: -Number.MAX_VALUE,
            reverseScreenSpaceError: -Number.MAX_VALUE,
          }),
          (this._minimumPriority = {
            foveatedFactor: Number.MAX_VALUE,
            depth: Number.MAX_VALUE,
            distance: Number.MAX_VALUE,
            reverseScreenSpaceError: Number.MAX_VALUE,
          }),
          (this.transformRequest = t.transformRequest),
          this._initializeTileSet(e, this.options),
          (this.cull = !1),
          (this._abortListMap = new Map()),
          (this._destroyed = !1),
          (this.parent = t.parent);
      }
      isLoaded() {
        return 0 === this._pendingCount;
      }
      destroy() {
        this._destroy();
      }
      get frameNumber() {
        return this._frameNumber;
      }
      setOptions(e) {
        this.options = { ...this.options, ...e };
      }
      getTileUrl(e) {
        if (e.startsWith('data:')) return e;
        if (((e = e.replace(/\+/g, '%2B')), this.subIPs && this.subIPs.length > 0)) {
          let t = '';
          return (
            ul.test(e) &&
              (t = `${e.replace(
                ul,
                `//${this.subIPs[Math.floor(Math.random() * this.subIPs.length)]}`,
              )}${this.queryParams}`),
            dl.test(e) &&
              (t = `${e.split('/')[0]}//${e.replace(
                dl,
                `${this.subIPs[Math.floor(Math.random() * this.subIPs.length)]}`,
              )}${this.queryParams}`),
            t
          );
        }
        return `${e}${this.queryParams}`;
      }
      update(e, t) {
        if ('loadTiles' in this.options && !this.options.loadTiles) return;
        if (this.traverseCounter > 0) return;
        e instanceof Array || (e = [e]),
          this._cache.reset(),
          this._frameNumber++,
          ++this._updatedVisibilityFrame,
          (this.traverseCounter = e.length);
        const i = [];
        for (const t of e) {
          const e = t.id;
          this._needTraverse(e) ? i.push(e) : this.traverseCounter--;
        }
        for (const s of e) {
          const e = s.id;
          if (
            (this.roots[e] ||
              (this.roots[e] = this._initializeTileHeaders(this.tileset, null, this.basePath)),
            !i.includes(e))
          )
            continue;
          const r = Ra(s, this._frameNumber, t);
          this._traverser.traverse(this.roots[e].tileset, r, this.options);
        }
      }
      _needTraverse(e) {
        let t = e;
        return (
          this.options.viewportTraversersMap && (t = this.options.viewportTraversersMap[e]), t === e
        );
      }
      _onTraversalEnd(e) {
        const t = e.viewport.id;
        this.frameStateData[t] ||
          (this.frameStateData[t] = { selectedTiles: [], _requestedTiles: [], _emptyTiles: [] });
        const i = this.frameStateData[t],
          s = Object.values(this._traverser.selectedTiles);
        (i.selectedTiles = s),
          (i._requestedTiles = Object.values(this._traverser.requestedTiles)),
          (i._emptyTiles = Object.values(this._traverser.emptyTiles)),
          (this.cull = !(s.length > 0)),
          this.traverseCounter--,
          this.traverseCounter > 0 || this._updateTiles();
      }
      _updateTiles() {
        (this.selectedTiles = []), (this._requestedTiles = []), (this._emptyTiles = []);
        for (const e in this.frameStateData) {
          const t = this.frameStateData[e];
          (this.selectedTiles = this.selectedTiles.concat(t.selectedTiles)),
            (this._requestedTiles = this._requestedTiles.concat(t._requestedTiles)),
            (this._emptyTiles = this._emptyTiles.concat(t._emptyTiles));
        }
        this._loadTiles(), this._unloadTiles(), this._updateStats();
      }
      _tilesChanged(e, t) {
        if (e.length !== t.length) return !0;
        const i = new Set(e.map((e) => e.id)),
          s = new Set(t.map((e) => e.id));
        let r = e.filter((e) => !s.has(e.id)).length > 0;
        return (r = r || t.filter((e) => !i.has(e.id)).length > 0), r;
      }
      _loadTiles() {
        this._requestedTiles.sort((e, t) => e._priority - t._priority);
        for (const e of this._requestedTiles) e.contentUnloaded && this._loadTile(e);
      }
      _unloadTiles() {
        this._cache.unloadTiles(this, (e, t) => e._unloadTile(t));
      }
      _updateStats() {
        let e = 0,
          t = 0;
        for (const i of this.selectedTiles)
          i.contentAvailable && (e++, i.content.pointCount && (t += i.content.pointCount));
        (this.stats.get(rl).count = this.selectedTiles.length),
          (this.stats.get(nl).count = e),
          (this.stats.get(cl).count = t);
      }
      _initializeTileSet(e) {
        (this.root = this._initializeTileHeaders(e, null, this.basePath)),
          this.type === Da && this._initializeCesiumTileset(e),
          this.type === La && this._initializeI3STileset(e),
          this._calculateViewProps();
      }
      _calculateViewProps() {
        const t = this.root,
          { center: i } = t.boundingVolume;
        if (!i) return (this.cartographicCenter = new e.Vector3()), void (this.zoom = 1);
        (this.cartographicCenter = e.Ellipsoid.WGS84.cartesianToCartographic(i, new e.Vector3())),
          (this.cartesianCenter = i),
          (this.zoom = (function (e) {
            const { halfAxes: t, radius: i, width: s, height: r } = e;
            if (t) {
              const e = (function (e) {
                e.getColumn(0, Oa);
                const t = e.getColumn(1),
                  i = e.getColumn(2);
                return Oa.add(t).add(i).len();
              })(t);
              return Math.log2(Ia / e);
            }
            return i
              ? Math.log2(Ia / i)
              : r && s
              ? (Math.log2(6378137 / s) + Math.log2(6378137 / r)) / 2
              : 1;
          })(t.boundingVolume));
      }
      _initializeStats() {
        this.stats.get(il),
          this.stats.get(al),
          this.stats.get(sl),
          this.stats.get(rl),
          this.stats.get(nl),
          this.stats.get(ol),
          this.stats.get(ll),
          this.stats.get(hl),
          this.stats.get(cl, 'memory'),
          this.stats.get(_l, 'memory');
      }
      _initializeTileHeaders(e, t, i) {
        const s = new Xa(this, e.root, t, i, void 0, this.transformRequest);
        if ((t && (t.children.push(s), (s.depth = t.depth + 1)), this.type === Da)) {
          const e = [];
          for (e.push(s); e.length > 0; ) {
            const t = e.pop();
            this.stats.get(il).incrementCount();
            const s = t.header.children || [];
            for (const r of s) {
              const s = new Xa(this, r, t, i, void 0, this.transformRequest);
              t.children.push(s), (s.depth = t.depth + 1), e.push(s);
            }
          }
        }
        return s;
      }
      _initializeTraverser() {
        let e;
        switch (this.type) {
          case Da:
            e = $a;
            break;
          case La:
            e = tl;
            break;
          default:
            e = Ja;
        }
        return new e({ basePath: this.basePath, onTraversalEnd: this._onTraversalEnd.bind(this) });
      }
      _destroyTileHeaders(e) {
        this._destroySubtree(e);
      }
      async _loadTile(e) {
        let t;
        try {
          this._onStartTileLoading(), (t = await e.loadContent());
        } catch (t) {
          this._onTileLoadError(e, t);
        } finally {
          this._onEndTileLoading(), this._onTileLoad(e, t);
        }
      }
      _onTileLoadError(e, t) {
        this.stats.get(hl).incrementCount();
        const i = t.message || t.toString(),
          s = e.contentUrl;
        console.error(`A 3D tile failed to load: ${e.contentUrl} ${i}`),
          this.options.onTileError(e, i, s);
      }
      _onTileLoad(t, i) {
        i &&
          (t &&
            t.content &&
            (function (t, i) {
              P(t), P(i);
              const {
                computedTransform: s,
                boundingVolume: { center: r },
              } = t;
              let n, o;
              if ('cmpt' === i.type) {
                for (const t of i.tiles) {
                  (o = t.rtcCenter), (n = t.gltfUpAxis);
                  let i = new e.Matrix4(s);
                  if (o) {
                    const t = new e.Matrix4().makeTranslation(o[0], o[1], o[2]);
                    i = i.multiplyRight(t);
                  }
                  if ('i3dm' !== t.type)
                    switch (n) {
                      case 'Z':
                        break;
                      case 'Y':
                        const t = new e.Matrix4().rotateX(Math.PI / 2);
                        i = i.multiplyRight(t);
                        break;
                      case 'X':
                        const s = new e.Matrix4().rotateY(-Math.PI / 2);
                        i = i.multiplyRight(s);
                    }
                  t.childModelMatrix = i;
                }
                return;
              }
              (o = i.rtcCenter), (n = i.gltfUpAxis);
              let a = new e.Matrix4(s);
              if ((o && a.translate(o), 'i3dm' !== i.type))
                switch (n) {
                  case 'Z':
                    break;
                  case 'Y':
                    const t = new e.Matrix4().rotateX(Math.PI / 2);
                    a = a.multiplyRight(t);
                    break;
                  case 'X':
                    const i = new e.Matrix4().rotateY(-Math.PI / 2);
                    a = a.multiplyRight(i);
                }
              const l = new e.Vector3(r);
              (i.cartesianModelMatrix = a), (i.cartesianOrigin = l);
              const h = e.Ellipsoid.WGS84.cartesianToCartographic(l, new e.Vector3()),
                c = e.Ellipsoid.WGS84.eastNorthUpToFixedFrame(l).invert();
              (i.cartographicModelMatrix = c.multiplyRight(a)),
                (i.cartographicOrigin = h),
                (i.modelMatrix = i.cartographicModelMatrix);
            })(t, t.content),
          this._addTileToCache(t),
          this.options.onTileLoad(t));
      }
      _onStartTileLoading() {
        this._pendingCount++, this.stats.get(al).incrementCount();
      }
      _onEndTileLoading() {
        this._pendingCount--, this.stats.get(al).decrementCount();
      }
      _addTileToCache(e) {
        this._cache.add(this, e, (t) => t._updateCacheStats(e));
      }
      _updateCacheStats(e) {
        this.stats.get(ol).incrementCount(),
          this.stats.get(sl).incrementCount(),
          (this.gpuMemoryUsageInBytes += e.content.byteLength || 0),
          (this.gpuMemoryUsageInBytes += e.content.gltf ? e.content.gltf.textureByteSize : 0),
          (this.stats.get(_l).count = this.gpuMemoryUsageInBytes);
      }
      _unloadTile(t) {
        e.defined(t.content) &&
          ((this.gpuMemoryUsageInBytes -= t.content.byteLength || 0),
          (this.gpuMemoryUsageInBytes -= t.content.gltf ? t.content.gltf.textureByteSize : 0),
          this.stats.get(sl).decrementCount(),
          this.stats.get(ll).incrementCount(),
          (this.stats.get(_l).count = this.gpuMemoryUsageInBytes),
          this.options.onTileUnload(t),
          t.unloadContent());
      }
      _destroy() {
        const e = [];
        for (this.root && e.push(this.root); e.length > 0; ) {
          const t = e.pop();
          for (const i of t.children) e.push(i);
          this._destroyTile(t);
        }
        this.root = null;
      }
      _destroySubtree(e) {
        const t = e,
          i = [];
        for (i.push(t); i.length > 0; ) {
          e = i.pop();
          for (const t of e.children) i.push(t);
          e !== t && this._destroyTile(e);
        }
        t.children = [];
      }
      _destroyTile(e) {
        this._cache.unloadTile(this, e), this._unloadTile(e), e.destroy();
      }
      _initializeCesiumTileset(e) {
        if (((this.asset = e.asset), !this.asset))
          throw new Error('Tileset must have an asset property.');
        if ('0.0' !== this.asset.version && '1.0' !== this.asset.version)
          throw new Error('The tileset must be 3D Tiles version 0.0 or 1.0.');
        'tilesetVersion' in this.asset && (this._queryParams.v = this.asset.tilesetVersion),
          (this.credits = { attributions: this.options.attributions || [] }),
          (this.description = this.options.description),
          (this.properties = e.properties),
          (this.geometricError = e.geometricError),
          (this._extensionsUsed = e.extensionsUsed),
          (this.extras = e.extras);
      }
      _initializeI3STileset(e) {
        'token' in this.options && (this._queryParams.token = this.options.token),
          (this._defaultGeometrySchema = e.store.defaultGeometrySchema);
      }
      hasExtension(e) {
        return Boolean(this._extensionsUsed && this._extensionsUsed.indexOf(e) > -1);
      }
      trimTiles() {
        this._cache.trim();
      }
      get queryParams() {
        return (
          this._queryParamsString ||
            (this._queryParamsString = (function (e) {
              const t = [];
              for (const i of Object.keys(e)) t.push(`${i}=${e[i]}`);
              switch (t.length) {
                case 0:
                  return '';
                case 1:
                  return `?${t[0]}`;
                default:
                  return `?${t.join('&')}`;
              }
            })(this._queryParams)),
          this._queryParamsString
        );
      }
    }
    const fl = 'undefined' != typeof __VERSION__ ? __VERSION__ : 'latest';
    function gl(e, t, i) {
      P(e instanceof ArrayBuffer);
      const s = new TextDecoder('utf8'),
        r = new Uint8Array(e.slice(t, t + i));
      return s.decode(r);
    }
    const yl = {
        BYTE: 5120,
        UNSIGNED_BYTE: 5121,
        SHORT: 5122,
        UNSIGNED_SHORT: 5123,
        INT: 5124,
        UNSIGNED_INT: 5125,
        FLOAT: 5126,
        DOUBLE: 5130,
      },
      Tl = {
        POINTS: 0,
        LINES: 1,
        LINE_LOOP: 2,
        LINE_STRIP: 3,
        TRIANGLES: 4,
        TRIANGLE_STRIP: 5,
        TRIANGLE_FAN: 6,
        ...yl,
      },
      xl = {
        [yl.DOUBLE]: Float64Array,
        [yl.FLOAT]: Float32Array,
        [yl.UNSIGNED_SHORT]: Uint16Array,
        [yl.UNSIGNED_INT]: Uint32Array,
        [yl.UNSIGNED_BYTE]: Uint8Array,
        [yl.BYTE]: Int8Array,
        [yl.SHORT]: Int16Array,
        [yl.INT]: Int32Array,
      },
      vl = {
        DOUBLE: yl.DOUBLE,
        FLOAT: yl.FLOAT,
        UNSIGNED_SHORT: yl.UNSIGNED_SHORT,
        UNSIGNED_INT: yl.UNSIGNED_INT,
        UNSIGNED_BYTE: yl.UNSIGNED_BYTE,
        BYTE: yl.BYTE,
        SHORT: yl.SHORT,
        INT: yl.INT,
      },
      bl = 'Failed to convert GL type';
    class wl {
      static fromTypedArray(e) {
        e = ArrayBuffer.isView(e) ? e.constructor : e;
        for (const t in xl) if (xl[t] === e) return t;
        throw new Error(bl);
      }
      static fromName(e) {
        const t = vl[e];
        if (!t) throw new Error(bl);
        return t;
      }
      static getArrayType(e, t = !1) {
        switch (e) {
          case yl.UNSIGNED_SHORT_5_6_5:
          case yl.UNSIGNED_SHORT_4_4_4_4:
          case yl.UNSIGNED_SHORT_5_5_5_1:
            return Uint16Array;
          default:
            const t = xl[e];
            if (!t) throw new Error(bl);
            return t;
        }
      }
      static getByteSize(e) {
        return wl.getArrayType(e).BYTES_PER_ELEMENT;
      }
      static validate(e) {
        return Boolean(wl.getArrayType(e));
      }
      static createTypedArray(e, t, i = 0, s) {
        return (
          void 0 === s && (s = (t.byteLength - i) / wl.getByteSize(e)),
          new (wl.getArrayType(e))(t, i, s)
        );
      }
    }
    function Cl(e, t = [0, 0, 0]) {
      const i = (e >> 5) & 63,
        s = 31 & e;
      return (t[0] = ((e >> 11) & 31) << 3), (t[1] = i << 2), (t[2] = s << 3), t;
    }
    class Sl {
      constructor(e, t) {
        (this.json = e),
          (this.buffer = t),
          (this.featuresLength = 0),
          (this._cachedTypedArrays = {});
      }
      getExtension(e) {
        return this.json.extensions && this.json.extensions[e];
      }
      hasProperty(e) {
        return Boolean(this.json[e]);
      }
      getGlobalProperty(e, t = Tl.UNSIGNED_INT, i = 1) {
        const s = this.json[e];
        return s && Number.isFinite(s.byteOffset)
          ? this._getTypedArrayFromBinary(e, t, i, 1, s.byteOffset)
          : s;
      }
      getPropertyArray(e, t, i) {
        const s = this.json[e];
        return s && Number.isFinite(s.byteOffset)
          ? ('componentType' in s && (t = wl.fromName(s.componentType)),
            this._getTypedArrayFromBinary(e, t, i, this.featuresLength, s.byteOffset))
          : this._getTypedArrayFromArray(e, t, s);
      }
      getProperty(e, t, i, s, r) {
        const n = this.json[e];
        if (!n) return n;
        const o = this.getPropertyArray(e, t, i);
        if (1 === i) return o[s];
        for (let e = 0; e < i; ++e) r[e] = o[i * s + e];
        return r;
      }
      _getTypedArrayFromBinary(e, t, i, s, r) {
        const n = this._cachedTypedArrays;
        let o = n[e];
        return (
          o ||
            ((o = wl.createTypedArray(t, this.buffer.buffer, this.buffer.byteOffset + r, s * i)),
            (n[e] = o)),
          o
        );
      }
      _getTypedArrayFromArray(e, t, i) {
        const s = this._cachedTypedArrays;
        let r = s[e];
        return r || ((r = wl.createTypedArray(t, i)), (s[e] = r)), r;
      }
    }
    const El = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
      Pl = {
        SCALAR: (e, t) => e[t],
        VEC2: (e, t) => [e[2 * t + 0], e[2 * t + 1]],
        VEC3: (e, t) => [e[3 * t + 0], e[3 * t + 1], e[3 * t + 2]],
        VEC4: (e, t) => [e[4 * t + 0], e[4 * t + 1], e[4 * t + 2], e[4 * t + 3]],
        MAT2: (e, t) => [e[4 * t + 0], e[4 * t + 1], e[4 * t + 2], e[4 * t + 3]],
        MAT3: (e, t) => [
          e[9 * t + 0],
          e[9 * t + 1],
          e[9 * t + 2],
          e[9 * t + 3],
          e[9 * t + 4],
          e[9 * t + 5],
          e[9 * t + 6],
          e[9 * t + 7],
          e[9 * t + 8],
        ],
        MAT4: (e, t) => [
          e[16 * t + 0],
          e[16 * t + 1],
          e[16 * t + 2],
          e[16 * t + 3],
          e[16 * t + 4],
          e[16 * t + 5],
          e[16 * t + 6],
          e[16 * t + 7],
          e[16 * t + 8],
          e[16 * t + 9],
          e[16 * t + 10],
          e[16 * t + 11],
          e[16 * t + 12],
          e[16 * t + 13],
          e[16 * t + 14],
          e[16 * t + 15],
        ],
      },
      Ml = {
        SCALAR: (e, t, i) => {
          t[i] = e;
        },
        VEC2: (e, t, i) => {
          (t[2 * i + 0] = e[0]), (t[2 * i + 1] = e[1]);
        },
        VEC3: (e, t, i) => {
          (t[3 * i + 0] = e[0]), (t[3 * i + 1] = e[1]), (t[3 * i + 2] = e[2]);
        },
        VEC4: (e, t, i) => {
          (t[4 * i + 0] = e[0]),
            (t[4 * i + 1] = e[1]),
            (t[4 * i + 2] = e[2]),
            (t[4 * i + 3] = e[3]);
        },
        MAT2: (e, t, i) => {
          (t[4 * i + 0] = e[0]),
            (t[4 * i + 1] = e[1]),
            (t[4 * i + 2] = e[2]),
            (t[4 * i + 3] = e[3]);
        },
        MAT3: (e, t, i) => {
          (t[9 * i + 0] = e[0]),
            (t[9 * i + 1] = e[1]),
            (t[9 * i + 2] = e[2]),
            (t[9 * i + 3] = e[3]),
            (t[9 * i + 4] = e[4]),
            (t[9 * i + 5] = e[5]),
            (t[9 * i + 6] = e[6]),
            (t[9 * i + 7] = e[7]),
            (t[9 * i + 8] = e[8]),
            (t[9 * i + 9] = e[9]);
        },
        MAT4: (e, t, i) => {
          (t[16 * i + 0] = e[0]),
            (t[16 * i + 1] = e[1]),
            (t[16 * i + 2] = e[2]),
            (t[16 * i + 3] = e[3]),
            (t[16 * i + 4] = e[4]),
            (t[16 * i + 5] = e[5]),
            (t[16 * i + 6] = e[6]),
            (t[16 * i + 7] = e[7]),
            (t[16 * i + 8] = e[8]),
            (t[16 * i + 9] = e[9]),
            (t[16 * i + 10] = e[10]),
            (t[16 * i + 11] = e[11]),
            (t[16 * i + 12] = e[12]),
            (t[16 * i + 13] = e[13]),
            (t[16 * i + 14] = e[14]),
            (t[16 * i + 15] = e[15]);
        },
      },
      Al = (e) => void 0 !== e;
    function Rl(e, t, i) {
      if (!e) return;
      const s = e.parentCounts;
      return e.parentIds
        ? i(e, t)
        : s > 0
        ? (function (e, t, i) {
            const s = e.parentCounts,
              r = e.parentIds,
              n = e.parentIndexes,
              o = scratchVisited;
            o.length = Math.max(o.length, e.classIds.length);
            const a = ++marker,
              l = scratchStack;
            for (l.length = 0, l.push(t); l.length > 0; ) {
              if (o[(t = l.pop())] === a) continue;
              o[t] = a;
              const h = i(e, t);
              if (Al(h)) return h;
              const c = s[t],
                _ = n[t];
              for (let e = 0; e < c; ++e) {
                const i = r[_ + e];
                i !== t && l.push(i);
              }
            }
            return null;
          })(e, t, i)
        : (function (e, t, i) {
            let s = !0;
            for (; s; ) {
              const r = i(e, t);
              if (Al(r)) return r;
              const n = e.parentIds[t];
              (s = n !== t), (t = n);
            }
            throw new Error('traverseHierarchySingleParent');
          })(e, t, i);
    }
    function Il(e, t, i) {
      const s = e.parentCounts,
        r = e.parentIds,
        n = e.parentIndexes,
        o = e.classIds.length;
      if (!Al(r)) return;
      assert(t < o, `Parent index ${t} exceeds the total number of instances: ${o}`),
        assert(-1 === i.indexOf(t), 'Circular dependency detected in the batch table hierarchy.'),
        i.push(t);
      const a = Al(s) ? s[t] : 1,
        l = Al(s) ? n[t] : t;
      for (let s = 0; s < a; ++s) {
        const n = r[l + s];
        n !== t && Il(e, n, i);
      }
      i.pop(t);
    }
    function Ol(t, i, s, r) {
      if ('function' == typeof t.fill) return t.fill(i, s, r);
      const n = t.length >>> 0,
        o = e.defaultValue(s, 0);
      let a = o < 0 ? Math.max(n + o, 0) : Math.min(o, n);
      const l = e.defaultValue(r, n),
        h = l < 0 ? Math.max(n + l, 0) : Math.min(l, n);
      for (; a < h; ) (t[a] = i), a++;
      return t;
    }
    class Ll {
      constructor(t) {
        const i = t.featuresLength;
        let s, r;
        if (
          ((this._showAlphaProperties = void 0),
          (this._batchValues = void 0),
          (this._batchValuesDirty = !1),
          (this._batchTexture = void 0),
          (this._defaultTexture = void 0),
          (this._pickTexture = void 0),
          (this._pickIds = []),
          i > 0)
        ) {
          const t = Math.min(i, e.ContextLimits.maximumTextureSize),
            n = Math.ceil(i / e.ContextLimits.maximumTextureSize),
            o = 1 / t,
            a = 0.5 * o,
            l = 1 / n,
            h = 0.5 * l;
          (s = new e.Vector2(t, n)), (r = new e.Vector4(o, a, l, h));
        }
        (this._translucentFeaturesLength = 0),
          (this._featuresLength = i),
          (this._textureDimensions = s),
          (this._textureStep = r),
          (this._owner = t.owner),
          (this._statistics = t.statistics),
          (this._colorChangedCallback = t.colorChangedCallback);
      }
      get translucentFeaturesLength() {
        return this._translucentFeaturesLength;
      }
      get textureDimensions() {
        return this._textureDimensions;
      }
      get textureStep() {
        return this._textureStep;
      }
      get batchTexture() {
        return this._batchTexture;
      }
      get defaultTexture() {
        return this._defaultTexture;
      }
      get pickTexture() {
        return this._pickTexture;
      }
      setShow(t, i) {
        if (i && !e.defined(this._showAlphaProperties)) return;
        const s = Nl(this),
          r = 2 * t,
          n = i ? 255 : 0;
        s[r] !== n &&
          ((s[r] = n), (Vl(this)[4 * t + 3] = i ? s[r + 1] : 0), (this._batchValuesDirty = !0));
      }
      setAllShow(e) {
        const t = this._featuresLength;
        for (let i = 0; i < t; ++i) this.setShow(i, e);
      }
      getShow(t) {
        return (
          kl(t, this._featuresLength),
          !e.defined(this._showAlphaProperties) || 255 === this._showAlphaProperties[2 * t]
        );
      }
      setColor(t, i) {
        if (
          (kl(t, this._featuresLength),
          e.Color.equals(i, Ll.DEFAULT_COLOR_VALUE) && !e.defined(this._batchValues))
        )
          return;
        const s = i.toBytes(Fl),
          r = s[3],
          n = Vl(this),
          o = 4 * t,
          a = Nl(this),
          l = 2 * t;
        if (n[o] !== s[0] || n[o + 1] !== s[1] || n[o + 2] !== s[2] || a[l + 1] !== r) {
          (n[o] = s[0]), (n[o + 1] = s[1]), (n[o + 2] = s[2]);
          const h = 255 !== a[l + 1];
          (n[o + 3] = 0 !== a[l] ? r : 0), (a[l + 1] = r);
          const c = 255 !== r;
          c && !h
            ? ++this._translucentFeaturesLength
            : !c && h && --this._translucentFeaturesLength,
            (this._batchValuesDirty = !0),
            e.defined(this._colorChangedCallback) && this._colorChangedCallback(t, i);
        }
      }
      setAllColor(e) {
        const t = this._featuresLength;
        for (let i = 0; i < t; ++i) this.setColor(i, e);
      }
      getColor(t, i) {
        if ((kl(t, this._featuresLength), !e.defined(this._batchValues)))
          return e.Color.clone(Ll.DEFAULT_COLOR_VALUE, i);
        const s = this._batchValues,
          r = 4 * t;
        return e.Color.fromBytes(s[r], s[r + 1], s[r + 2], this._showAlphaProperties[2 * t + 1], i);
      }
      getPickColor(e) {
        return kl(e, this._featuresLength), this._pickIds[e];
      }
      update(t) {
        const i = t.context;
        (this._defaultTexture = i.defaultTexture),
          (function (t, i) {
            const s = t._featuresLength;
            if (!e.defined(t._pickTexture) && s > 0) {
              const r = t._pickIds,
                n = Bl(t),
                o = new Uint8Array(n),
                a = t._owner;
              for (let t = 0; t < s; ++t) {
                const s = i.createPickId(a.getFeature(t, a.nodeProperty));
                r.push(s);
                const n = s.color,
                  l = 4 * t;
                (o[l] = e.Color.floatToByte(n.r)),
                  (o[l + 1] = e.Color.floatToByte(n.g)),
                  (o[l + 2] = e.Color.floatToByte(n.b)),
                  (o[l + 3] = e.Color.floatToByte(n.a));
              }
              t._pickTexture = Dl(t, i, o);
            }
          })(this, i),
          this._batchValuesDirty &&
            ((this._batchValuesDirty = !1),
            e.defined(this._batchTexture)
              ? (function (e) {
                  const t = e._textureDimensions;
                  e._batchTexture.copyFrom({
                    source: { width: t.x, height: t.y, arrayBufferView: e._batchValues },
                  });
                })(this)
              : (this._batchTexture = Dl(this, i, this._batchValues)));
      }
      destroy() {
        (this._batchTexture = this._batchTexture && this._batchTexture.destroy()),
          (this._pickTexture = this._pickTexture && this._pickTexture.destroy());
        const t = this._pickIds,
          i = t.length;
        for (let e = 0; e < i; ++e) t[e].destroy();
        return e.destroyObject(this);
      }
      getUniformMapCallback() {
        if (0 === this.featuresLength) return;
        const t = this;
        return function (i) {
          i?.has('batchTexture') && i.delete('batchTexture'),
            i?.has('batch_textureDimensions') && i.delete('batch_textureDimensions'),
            i?.has('batch_textureStep') && i.delete('batch_textureStep'),
            i?.has('pickColorTexture') && i.delete('pickColorTexture');
          const s = new Map([
            [
              'batchTexture',
              () => {
                const i = e.defaultValue(t.batchTexture, t.defaultTexture);
                return i.bind(e.TextureMagnificationFilter.NEAREST, e.TextureWrap.CLAMP_TO_EDGE), i;
              },
            ],
            ['batch_textureDimensions', () => t.textureDimensions],
            ['batch_textureStep', () => t.textureStep],
            [
              'pickColorTexture',
              () => (
                t.pickTexture.bind(
                  e.TextureMagnificationFilter.NEAREST,
                  e.TextureWrap.CLAMP_TO_EDGE,
                ),
                t.pickTexture
              ),
            ],
          ]);
          return e.combineInternalMap(i, s);
        };
      }
      static DEFAULT_COLOR_VALUE = e.Color.white;
      static DEFAULT_SHOW_VALUE = !0;
    }
    function Dl(t, i, s) {
      const r = t._textureDimensions;
      return new e.Texture({
        context: i,
        pixelFormat: e.PixelFormat.RGBA,
        pixelDatatype: e.PixelDatatype.UNSIGNED_BYTE,
        image: { width: r.x, height: r.y, arrayBufferView: s },
        flipY: !1,
      });
    }
    function Bl(e) {
      const t = e._textureDimensions;
      return t.x * t.y * 4;
    }
    function Vl(t) {
      if (!e.defined(t._batchValues)) {
        const e = Bl(t),
          i = new Uint8Array(e);
        Ol(i, 255), (t._batchValues = i);
      }
      return t._batchValues;
    }
    function Nl(t) {
      if (!e.defined(t._showAlphaProperties)) {
        const e = new Uint8Array(2 * t._featuresLength);
        Ol(e, 255), (t._showAlphaProperties = e);
      }
      return t._showAlphaProperties;
    }
    function kl(t, i) {
      if (!e.defined(t) || t < 0 || t >= i)
        throw new Error(`batchId is required and between zero and featuresLength - 1 (${i}` - NaN);
    }
    const Fl = new Array(4);
    class Gl {
      constructor(e, t, i) {
        (this._batchId = e), (this._nodeProperty = t), (this._content = i), (this._color = void 0);
      }
      get color() {
        return (
          e.defined(this._color) || (this._color = new e.Color()),
          this._content._batchTexture.getColor(this._batchId, this._color)
        );
      }
      set color(t) {
        e.defined(this._color) || (this._color = new e.Color()),
          (t[3] = 0 === t[3] ? 0.98 : t[3] < 1 ? 1 - t[3] : t[3]),
          this._color.set(t),
          this._content._batchTexture.setColor(this._batchId, this._color);
      }
      get show() {
        return this._content.getShow(this._batchId);
      }
      set show(e) {
        this._content._batchTexture.setShow(this._batchId, e);
      }
      hasProperty(e) {
        return this._content.hasProperty(this._batchId, e);
      }
      getPropertyNames(e) {
        return this._content.getPropertyNames(this._batchId, e);
      }
      getProperty(e) {
        return this._content.getProperty(this._batchId, e);
      }
      destroy() {
        (this._content = void 0), (this._batchId = void 0), (this._color = void 0);
      }
    }
    function Ul(e) {
      return null != e;
    }
    const zl = (e, t) => e,
      Hl = { HIERARCHY: !0, extensions: !0, extras: !0 };
    class Wl {
      constructor(e, t, i, s, r, n = {}) {
        P(i >= 0),
          (this.json = e || {}),
          (this.binary = t),
          (this.featureCount = i),
          (this._extensions = (this.json && this.json.extensions) || {}),
          (this.nodeProperty = r),
          (this._properties = {});
        for (const e in this.json) Hl[e] || (this._properties[e] = this.json[e]);
        (this._binaryProperties = this._initializeBinaryProperties()),
          n['3DTILES_batch_table_hierarchy'] &&
            (this._hierarchy = (function (e, t, i) {
              if (!t) return null;
              let s = e.getExtension('3DTILES_batch_table_hierarchy');
              const r = t.HIERARCHY;
              return (
                r &&
                  ((t.extensions = t.extensions || {}),
                  (t.extensions['3DTILES_batch_table_hierarchy'] = r),
                  (s = r)),
                s
                  ? (function (e, t) {
                      let i, s, r;
                      const n = e.instancesLength,
                        o = e.classes;
                      let a,
                        l = e.classIds,
                        h = e.parentCounts,
                        c = e.parentIds,
                        _ = n;
                      if (
                        (Al(l.byteOffset) &&
                          ((l.componentType = defaultValue(l.componentType, GL.UNSIGNED_SHORT)),
                          (l.type = AttributeType.SCALAR),
                          (r = getBinaryAccessor(l)),
                          (l = r.createArrayBufferView(t.buffer, t.byteOffset + l.byteOffset, n))),
                        Al(h))
                      )
                        for (
                          Al(h.byteOffset) &&
                            ((h.componentType = defaultValue(h.componentType, GL.UNSIGNED_SHORT)),
                            (h.type = AttributeType.SCALAR),
                            (r = getBinaryAccessor(h)),
                            (h = r.createArrayBufferView(
                              t.buffer,
                              t.byteOffset + h.byteOffset,
                              n,
                            ))),
                            a = new Uint16Array(n),
                            _ = 0,
                            i = 0;
                          i < n;
                          ++i
                        )
                          (a[i] = _), (_ += h[i]);
                      Al(c) &&
                        Al(c.byteOffset) &&
                        ((c.componentType = defaultValue(c.componentType, GL.UNSIGNED_SHORT)),
                        (c.type = AttributeType.SCALAR),
                        (r = getBinaryAccessor(c)),
                        (c = r.createArrayBufferView(t.buffer, t.byteOffset + c.byteOffset, _)));
                      const u = o.length;
                      for (i = 0; i < u; ++i) {
                        const e = o[i].instances,
                          s = getBinaryProperties(o[i].length, e, t);
                        o[i].instances = combine(s, e);
                      }
                      const d = new Array(u).fill(0),
                        m = new Uint16Array(n);
                      for (i = 0; i < n; ++i) (s = l[i]), (m[i] = d[s]), ++d[s];
                      const p = {
                        classes: o,
                        classIds: l,
                        classIndexes: m,
                        parentCounts: h,
                        parentIndexes: a,
                        parentIds: c,
                      };
                      return (
                        (function (e) {
                          const t = e.classIds.length;
                          for (let i = 0; i < t; ++i) Il(e, i, stack);
                        })(p),
                        p
                      );
                    })(s, i)
                  : null
              );
            })(this, this.json, this.binary)),
          (this._batchTexture = new Ll({ featuresLength: i, owner: this })),
          (this._features = void 0),
          (this._url = s);
      }
      getExtension(e) {
        return this.json && this.json.extensions && this.json.extensions[e];
      }
      memorySizeInBytes() {
        return 0;
      }
      isClass(e, t) {
        return (
          this._checkBatchId(e),
          P('string' == typeof t, t),
          !!this._hierarchy &&
            Ul(Rl(this._hierarchy, e, (e, i) => e.classes[e.classIds[i]].name === t))
        );
      }
      isExactClass(e, t) {
        return P('string' == typeof t, t), this.getExactClassName(e) === t;
      }
      getExactClassName(e) {
        if ((this._checkBatchId(e), this._hierarchy))
          return this._hierarchy.classes[this._hierarchy.classIds[e]].name;
      }
      hasProperty(e, t) {
        return (
          this._checkBatchId(e),
          P('string' == typeof t, t),
          Ul(this._properties[t]) || this._hasPropertyInHierarchy(e, t)
        );
      }
      getPropertyNames(e, t) {
        this._checkBatchId(e), ((t = Ul(t) ? t : []).length = 0);
        const i = Object.keys(this._properties);
        return t.push(...i), this._hierarchy && this._getPropertyNamesInHierarchy(e, t), t;
      }
      getProperty(e, t) {
        if ((this._checkBatchId(e), P('string' == typeof t, t), this._binaryProperties)) {
          const i = this._binaryProperties[t];
          if (Ul(i)) return this._getBinaryProperty(i, e);
        }
        const i = this._properties[t];
        if (Ul(i)) return zl(i[e]);
        if (this._hierarchy) {
          const i = this._getHierarchyProperty(e, t);
          if (Ul(i)) return i;
        }
      }
      setProperty(e, t, i) {
        const s = this.featureCount;
        if ((this._checkBatchId(e), P('string' == typeof t, t), this._binaryProperties)) {
          const s = this._binaryProperties[t];
          if (s) return void this._setBinaryProperty(s, e, i);
        }
        if (this._hierarchy && this._setHierarchyProperty(this, e, t, i)) return;
        let r = this._properties[t];
        Ul(r) || ((this._properties[t] = new Array(s)), (r = this._properties[t])), (r[e] = zl(i));
      }
      _checkBatchId(e) {
        if (!(e >= 0 && e < this.featureCount))
          throw new Error('batchId not in range [0, featureCount - 1].');
      }
      _getBinaryProperty(e, t) {
        return e.unpack(e.typedArray, t);
      }
      _setBinaryProperty(e, t, i) {
        e.pack(i, e.typedArray, t);
      }
      _initializeBinaryProperties() {
        let e = null;
        for (const t in this._properties) {
          const i = this._initializeBinaryProperty(t, this._properties[t]);
          i && ((e = e || {}), (e[t] = i));
        }
        return e;
      }
      _initializeBinaryProperty(e, t) {
        if ('byteOffset' in t) {
          const i = t;
          P(this.binary, `Property ${e} requires a batch table binary.`),
            P(i.type, `Property ${e} requires a type.`);
          const s = (function (e, t, i, s) {
            const { componentType: r } = e;
            P(e.componentType);
            const n = 'string' == typeof r ? wl.fromName(r) : r,
              o = El[e.type],
              a = Pl[e.type],
              l = Ml[e.type];
            return {
              values: wl.createTypedArray(n, t, (i += e.byteOffset), o * s),
              type: n,
              size: o,
              unpacker: a,
              packer: l,
            };
          })(i, this.binary.buffer, 0 | this.binary.byteOffset, this.featureCount);
          return {
            typedArray: s.values,
            componentCount: s.size,
            unpack: s.unpacker,
            pack: s.packer,
          };
        }
        return null;
      }
      _hasPropertyInHierarchy(e, t) {
        if (!this._hierarchy) return !1;
        const i = Rl(this._hierarchy, e, (e, i) => Ul(e.classes[e.classIds[i]].instances[t]));
        return Ul(i);
      }
      _getPropertyNamesInHierarchy(e, t) {
        Rl(this._hierarchy, e, (e, i) => {
          const s = e.classes[e.classIds[i]].instances;
          for (const e in s) s.hasOwnProperty(e) && -1 === t.indexOf(e) && t.push(e);
        });
      }
      _getHierarchyProperty(e, t) {
        return Rl(this._hierarchy, e, (e, i) => {
          const s = e.classIndexes[i],
            r = e.classes[e.classIds[i]].instances[t];
          return Ul(r) ? (Ul(r.typedArray) ? this._getBinaryProperty(r, s) : zl(r[s])) : null;
        });
      }
      _setHierarchyProperty(e, t, i, s) {
        const r = Rl(this._hierarchy, t, (e, r) => {
          const n = e.classIndexes[r],
            o = e.classes[e.classIds[r]].instances[i];
          return (
            !!Ul(o) &&
            (P(r === t, `Inherited property "${i}" is read-only.`),
            Ul(o.typedArray) ? this._setBinaryProperty(o, n, s) : (o[n] = zl(s)),
            !0)
          );
        });
        return Ul(r);
      }
      getFeature(e, t) {
        const i = this.featuresLength;
        if (!Ul(e) || e < 0 || e >= i)
          throw new Error(
            `batchId is required and between zero and featuresLength - 1 (${i - 1}).`,
          );
        return (
          (function (e, t) {
            const i = t.featureCount;
            if (!Ul(t._features) && i > 0) {
              const s = new Array(i);
              for (let r = 0; r < i; ++r) s[r] = new Gl(r, e, t);
              t._features = s;
            }
          })(t, this),
          this._features[e]
        );
      }
      update(e, t) {
        this._batchTexture.update(e, t);
      }
      destroy() {
        (this._hierarchy = void 0),
          (this.json = void 0),
          (this.binary = void 0),
          (this.featureCount = 0),
          (this._properties = void 0),
          (this._extensions = void 0),
          (this._binaryProperties = void 0),
          this._batchTexture.destroy();
      }
    }
    const jl = 4;
    function ql(e, t, i = 0) {
      const s = new DataView(t);
      if (
        ((e.magic = s.getUint32(i, !0)),
        (e.version = s.getUint32((i += jl), !0)),
        (e.byteLength = s.getUint32((i += jl), !0)),
        (i += jl),
        1 !== e.version)
      )
        throw new Error(`3D Tile Version ${e.version} not supported`);
      return i;
    }
    const Xl = 4;
    function Zl(e, t, i) {
      const s = new DataView(t);
      return (
        (e.header = e.header || {}),
        (e.header.featureTableJsonByteLength = s.getUint32(i, !0)),
        (e.header.featureTableBinaryByteLength = s.getUint32((i += Xl), !0)),
        (e.header.batchTableJsonByteLength = s.getUint32((i += Xl), !0)),
        (e.header.batchTableBinaryByteLength = s.getUint32((i += Xl), !0)),
        i + Xl
      );
    }
    function $l(e, t, i, s) {
      return (
        (i = (function (e, t, i, s) {
          const { featureTableJsonByteLength: r, featureTableBinaryByteLength: n } = e.header;
          if (((e.featureTableJson = { BATCH_LENGTH: 0 }), r > 0)) {
            const s = gl(t, i, r);
            e.featureTableJson = JSON.parse(s);
          }
          return (i += r), (e.featureTableBinary = new Uint8Array(t.slice(i, i + n))), i + n;
        })(e, t, i)),
        (i = (function (e, t, i, s) {
          const { batchTableJsonByteLength: r, batchTableBinaryByteLength: n } = e.header;
          if (r > 0) {
            const s = gl(t, i, r);
            (e.batchTableJson = JSON.parse(s)),
              (i += r),
              n > 0 &&
                ((e.batchTableBinary = new Uint8Array(t.slice(i, i + n))),
                (e.batchTableBinary = new Uint8Array(e.batchTableBinary)),
                (i += n));
          }
          return i;
        })(e, t, i)),
        i
      );
    }
    function Kl(e, t, i) {
      if (!(t || (e && e.batchIds && i))) return null;
      const { isRGB565: s, pointCount: r } = e;
      if (s) {
        const e = new Uint8ClampedArray(3 * r);
        for (let i = 0; i < r; i++) {
          const s = Cl(t[i]);
          (e[3 * i] = s[0]), (e[3 * i + 1] = s[1]), (e[3 * i + 2] = s[2]);
        }
        return { type: Tl.FLOAT, value: Float32Array.from(t), size: 3, normalized: !0 };
      }
      if (t && t.length === 3 * r) {
        const e = Float32Array.from(t).map((e) => e / 255);
        return { type: Tl.FLOAT, value: e, size: 3, normalized: !0 };
      }
      if (t && t.length === 4 * r) {
        const e = Float32Array.from(t).map((e) => e / 255);
        return { type: Tl.FLOAT, value: e, size: 4, normalized: !0 };
      }
      const n = new Float32Array(3 * r);
      for (let e = 0; e < r; e++) (n[3 * e] = 0), (n[3 * e + 1] = 0), (n[3 * e + 2] = 0);
      return { type: Tl.FLOAT, value: n, size: 3, normalized: !0 };
    }
    const Yl = new e.Vector3();
    const Ql = { URI: 0, EMBEDDED: 1 };
    function Jl(t, i, s, r) {
      t.rotateYtoZ = !0;
      const n = t.byteOffset + t.byteLength - s;
      if (0 === n) throw new Error('glTF byte length must be greater than 0.');
      return (
        (t.gltfUpAxis =
          r['3d-tiles'] && r['3d-tiles'].assetGltfUpAxis ? r['3d-tiles'].assetGltfUpAxis : 'Y'),
        (t.gltfArrayBuffer = (function (t, i, s) {
          return (function (t, i, s) {
            let r;
            try {
              r = e.defined(s) && s + i <= t.length ? t.slice(i, i + s) : t.slice(i);
            } catch (e) {
              console.log(e);
            } finally {
              return r || new Uint8Array().buffer;
            }
          })(t, i, s);
        })(i, s, n)),
        (t.gltfByteOffset = 0),
        (t.gltfByteLength = n),
        t.byteOffset + t.byteLength
      );
    }
    async function eh(e, t, i, s) {
      const r = i['3d-tiles'] || {};
      if (
        ((function (e, t, i) {
          switch (t) {
            case Ql.URI:
              const t = new Uint8Array(e.gltfArrayBuffer.slice(e.gltfByteOffset)),
                i = new TextDecoder().decode(t);
              (e.gltfUrl = i.replace(/[\s\0]+$/, '')),
                delete e.gltfArrayBuffer,
                delete e.gltfByteOffset,
                delete e.gltfByteLength;
              break;
            case Ql.EMBEDDED:
              break;
            default:
              throw new Error('b3dm: Illegal glTF format field');
          }
        })(e, t),
        r.loadGLTF)
      ) {
        const { parse: t, fetch: r } = s;
        e.gltfUrl && ((e.gltfArrayBuffer = await r(e.gltfUrl, i)), (e.gltfByteOffset = 0)),
          e.gltfArrayBuffer &&
            (e.instances && (i.instances = e.instances),
            (e.gltf = await t(e.gltfArrayBuffer, _r, i, s)),
            delete e.gltfArrayBuffer,
            delete e.gltfByteOffset,
            delete e.gltfByteLength);
      }
    }
    function th(t, i, s) {
      return (
        (i = i || 0), s || (s = new e.Vector3()), (s.x = t[i++]), (s.y = t[i++]), (s.z = t[i]), s
      );
    }
    function ih(t, i, s, r) {
      r || (r = new e.Matrix4());
      const n = s.x,
        o = s.y,
        a = s.z,
        l = i.x * i.x,
        h = i.x * i.y,
        c = i.x * i.z,
        _ = i.x * i.w,
        u = i.y * i.y,
        d = i.y * i.z,
        m = i.y * i.w,
        p = i.z * i.z,
        f = i.z * i.w,
        g = i.w * i.w,
        y = 2 * (h - f),
        T = 2 * (c + m),
        x = 2 * (h + f),
        v = -l + u - p + g,
        b = 2 * (d - _),
        w = 2 * (c - m),
        C = 2 * (d + _),
        S = -l - u + p + g;
      return (
        (r[0] = (l - u - p + g) * n),
        (r[1] = x * n),
        (r[2] = w * n),
        (r[3] = 0),
        (r[4] = y * o),
        (r[5] = v * o),
        (r[6] = C * o),
        (r[7] = 0),
        (r[8] = T * a),
        (r[9] = b * a),
        (r[10] = S * a),
        (r[11] = 0),
        (r[12] = t.x),
        (r[13] = t.y),
        (r[14] = t.z),
        (r[15] = 1),
        r
      );
    }
    async function sh(t, i = 0, s, r, n = {}) {
      switch (
        ((n.byteOffset = i),
        (n.type = (function (e, t = 0) {
          const i = new DataView(e);
          return `${String.fromCharCode(i.getUint8(t + 0))}${String.fromCharCode(
            i.getUint8(t + 1),
          )}${String.fromCharCode(i.getUint8(t + 2))}${String.fromCharCode(i.getUint8(t + 3))}`;
        })(t, i)),
        n.type)
      ) {
        case 'cmpt':
          return await (async function (e, t, i, s, r, n) {
            i = ql(e, t, i);
            const o = new DataView(t);
            for (
              e.tilesLength = o.getUint32(i, !0), i += 4, e.tiles = [];
              e.tiles.length < e.tilesLength;

            ) {
              const o = {};
              e.tiles.push(o), (i = await n(t, i, s, r, o));
            }
            return i;
          })(n, t, i, s, r, sh);
        case 'b3dm':
          return await (async function (e, t, i, s, r) {
            (i = (function (e, t, i, s, r) {
              i = Jl(e, t, (i = $l(e, t, (i = Zl(e, t, (i = ql(e, t, i)))))), s);
              const n = new Sl(e.featureTableJson, e.featureTableBinary);
              (e.rtcCenter = n.getGlobalProperty('RTC_CENTER', Tl.FLOAT, 3)), (e.featureTable = n);
              const o = n.getGlobalProperty('BATCH_LENGTH');
              return (
                (e.batchTable = new Wl(
                  e.batchTableJson,
                  e.batchTableBinary,
                  o,
                  r.url,
                  s.nodeProperty,
                )),
                delete e.featureTableJson,
                delete e.featureTableBinary,
                delete e.batchTableJson,
                delete e.batchTableBinary,
                i
              );
            })(e, t, i, s, r)),
              await eh(e, Ql.EMBEDDED, s, r);
            const { extensions: n } = e.gltf || {};
            return n && n.CESIUM_RTC && (e.rtcCenter = n.CESIUM_RTC.center), i;
          })(n, t, i, s, r);
        case 'i3dm':
          return await (async function (t, i, s, r, n) {
            return (
              (s = (function (t, i, s, r, n) {
                if (((s = ql(t, i, s)), 1 !== t.version))
                  throw new Error(`Instanced 3D Model version ${t.version} is not supported`);
                s = Zl(t, i, s);
                const o = new DataView(i);
                if (
                  ((t.gltfFormat = o.getUint32(s, !0)),
                  (s = Jl(t, i, (s = $l(t, i, (s += 4))), r)),
                  0 === t.featureTableJsonByteLength)
                )
                  throw new Error('i3dm parser: featureTableJsonByteLength is zero.');
                const a = new Sl(t.featureTableJson, t.featureTableBinary),
                  l = a.getGlobalProperty('INSTANCES_LENGTH');
                if (((a.featuresLength = l), !Number.isFinite(l)))
                  throw new Error('i3dm parser: INSTANCES_LENGTH must be defined');
                (t.eastNorthUp = a.getGlobalProperty('EAST_NORTH_UP')),
                  (t.rtcCenter = a.getGlobalProperty('RTC_CENTER', Tl.FLOAT, 3));
                const h = new Wl(t.batchTableJson, t.batchTableBinary, l, n.url);
                return (
                  (h._url = n.url),
                  (function (t, i, s, r) {
                    const n = new Array(r),
                      o = new e.Vector3(),
                      a = new e.Vector3(),
                      l = new e.Vector3(),
                      h = new e.Vector3(),
                      c = new e.Matrix3(),
                      _ = new e.Quaternion(),
                      u = new e.Vector3(),
                      d = {},
                      m = new e.Matrix4(),
                      p = [],
                      f = [],
                      g = new e.Vector3(),
                      y = new e.Vector3();
                    for (let s = 0; s < r; s++) {
                      let r;
                      if (i.hasProperty('POSITION'))
                        r = i.getProperty('POSITION', Tl.FLOAT, 3, s, o);
                      else if (i.hasProperty('POSITION_QUANTIZED')) {
                        r = i.getProperty('POSITION_QUANTIZED', Tl.UNSIGNED_SHORT, 3, s, o);
                        const e = i.getGlobalProperty('QUANTIZED_VOLUME_OFFSET', Tl.FLOAT, 3, g);
                        if (!e)
                          throw new Error(
                            'i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.',
                          );
                        const t = i.getGlobalProperty('QUANTIZED_VOLUME_SCALE', Tl.FLOAT, 3, y);
                        if (!t)
                          throw new Error(
                            'i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.',
                          );
                        const n = 65535;
                        for (let i = 0; i < 3; i++) r[i] = (r[i] / n) * t[i] + e[i];
                      }
                      if (!r)
                        throw new Error(
                          'i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.',
                        );
                      if (
                        (o.copy(r),
                        (d.translation = o),
                        (t.normalUp = i.getProperty('NORMAL_UP', Tl.FLOAT, 3, s, p)),
                        (t.normalRight = i.getProperty('NORMAL_RIGHT', Tl.FLOAT, 3, s, f)),
                        t.normalUp)
                      ) {
                        if (!t.normalRight)
                          throw new Error(
                            'i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.',
                          );
                        th(t.normalUp, 0, l),
                          th(t.normalRight, 0, a),
                          (t.hasCustomOrientation = !0);
                      } else {
                        if (
                          ((t.octNormalUp = i.getProperty(
                            'NORMAL_UP_OCT32P',
                            Tl.UNSIGNED_SHORT,
                            2,
                            p,
                          )),
                          (t.octNormalRight = i.getProperty(
                            'NORMAL_RIGHT_OCT32P',
                            Tl.UNSIGNED_SHORT,
                            2,
                            f,
                          )),
                          t.octNormalUp)
                        ) {
                          if (!t.octNormalRight)
                            throw new Error(
                              'i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P',
                            );
                          throw new Error('i3dm: oct-encoded orientation not implemented');
                        }
                        t.eastNorthUp
                          ? (e.Ellipsoid.WGS84.eastNorthUpToFixedFrame(o, m),
                            m.getRotationMatrix3(c))
                          : c.identity();
                      }
                      t.hasCustomOrientation &&
                        (h.copy(a).cross(l).normalize(),
                        c.setColumn(0, a),
                        c.setColumn(1, l),
                        c.setColumn(2, h)),
                        _.fromMatrix3(c),
                        (d.rotation = _),
                        u.set(1, 1, 1);
                      const T = i.getProperty('SCALE', Tl.FLOAT, 1, s);
                      Number.isFinite(T) && u.multiplyByScalar(T);
                      const x = i.getProperty('SCALE_NON_UNIFORM', Tl.FLOAT, 3, s, p);
                      x && u.scale(x), (d.scale = u);
                      let v = i.getProperty('BATCH_ID', Tl.UNSIGNED_SHORT, 1, s);
                      void 0 === v && (v = s);
                      const b = ih(d.translation, d.rotation, d.scale, new e.Matrix4()).clone();
                      n[s] = { modelMatrix: b, batchId: v };
                    }
                    t.instances = n;
                  })(t, a, 0, l),
                  (t.featureTable = a),
                  (t.batchTable = h),
                  delete t.featureTableJson,
                  delete t.featureTableBinary,
                  delete t.batchTableJson,
                  delete t.batchTableBinary,
                  s
                );
              })(t, i, s, r, n)),
              await eh(t, t.gltfFormat, r, n),
              s
            );
          })(n, t, i, s, r);
        case 'pnts':
          return await (async function (t, i, s, r, n) {
            (s = $l(t, i, (s = Zl(t, i, (s = ql(t, i, s)))))),
              (function (e) {
                (e.attributes = { positions: null, colors: null, normals: null, batchIds: null }),
                  (e.isQuantized = !1),
                  (e.isTranslucent = !1),
                  (e.isRGB565 = !1),
                  (e.isOctEncoded16P = !1);
              })(t);
            const { featureTable: o, batchTable: a } = (function (e, t) {
              const i = new Sl(e.featureTableJson, e.featureTableBinary),
                s = i.getGlobalProperty('POINTS_LENGTH');
              if (!Number.isFinite(s)) throw new Error('POINTS_LENGTH must be defined');
              (i.featuresLength = s),
                (e.featuresLength = s),
                (e.pointsLength = s),
                (e.pointCount = s),
                (e.rtcCenter = i.getGlobalProperty('RTC_CENTER', Tl.FLOAT, 3));
              const r = (function (e, t, i) {
                let s = null;
                if (
                  !e.batchIds &&
                  t.hasProperty('BATCH_ID') &&
                  ((e.batchIds = t.getPropertyArray('BATCH_ID', Tl.UNSIGNED_SHORT, 1)), e.batchIds)
                ) {
                  const r = t.getGlobalProperty('BATCH_LENGTH');
                  if (!r)
                    throw new Error(
                      'Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.',
                    );
                  const { batchTableJson: n, batchTableBinary: o } = e;
                  s = new Wl(n, o, r, i.url);
                }
                return s;
              })(e, i, t);
              return { featureTable: i, batchTable: r };
            })(t, n);
            return (
              await (async function (t, i, s, r, n) {
                let o, a, l;
                const h =
                  t.batchTableJson &&
                  t.batchTableJson.extensions &&
                  t.batchTableJson.extensions['3DTILES_draco_point_compression'];
                h && (l = h.properties);
                const c = i.getExtension('3DTILES_draco_point_compression');
                if (c) {
                  a = c.properties;
                  const e = c.byteOffset,
                    i = c.byteLength;
                  if (!a || !Number.isFinite(e) || !i)
                    throw new Error('Draco properties, byteOffset, and byteLength must be defined');
                  (o = t.featureTableBinary.slice(e, e + i)),
                    (t.hasPositions = Number.isFinite(a.POSITION)),
                    (t.hasColors = Number.isFinite(a.RGB) || Number.isFinite(a.RGBA)),
                    (t.hasNormals = Number.isFinite(a.NORMAL)),
                    (t.hasBatchIds = Number.isFinite(a.BATCH_ID)),
                    (t.isTranslucent = Number.isFinite(a.RGBA));
                }
                if (!o) return !0;
                const _ = {
                    buffer: o,
                    properties: { ...a, ...l },
                    featureTableProperties: a,
                    batchTableProperties: l,
                    dequantizeInShader: !1,
                  },
                  u = await (async function (t, i, s, r) {
                    const { parse: n } = r,
                      o = {
                        ...s,
                        draco: { ...s.draco, extraAttributes: i.batchTableProperties || {} },
                      };
                    delete o['3d-tiles'], delete o.context;
                    const a = await n(i.buffer, Qi, o),
                      l = a.attributes.POSITION && a.attributes.POSITION.value,
                      h = a.attributes.COLOR_0 && a.attributes.COLOR_0.value,
                      c = a.attributes.NORMAL && a.attributes.NORMAL.value,
                      _ = a.attributes.BATCH_ID && a.attributes.BATCH_ID.value,
                      u = c && a.attributes.NORMAL.value.quantization;
                    if (l && a.attributes.POSITION.value.quantization) {
                      const i = a.POSITION.data.quantization,
                        s = i.range;
                      (t.quantizedVolumeScale = new e.Vector3(s, s, s)),
                        (t.quantizedVolumeOffset = new e.Vector3(i.minValues)),
                        (t.quantizedRange = (1 << i.quantizationBits) - 1),
                        (t.isQuantizedDraco = !0);
                    }
                    u &&
                      ((t.octEncodedRange = (1 << a.NORMAL.data.quantization.quantizationBits) - 1),
                      (t.isOctEncodedDraco = !0));
                    const d = {};
                    if (i.batchTableProperties)
                      for (const e of Object.keys(i.batchTableProperties))
                        a.attributes[e] &&
                          a.attributes[e].value &&
                          (d[e.toLowerCase()] = a.attributes[e].value);
                    t.attributes = {
                      positions: { type: Tl.FLOAT, value: l, size: 3, normalized: !0 },
                      colors: Kl(t, h),
                      normals: c,
                      batchIds: _,
                      ...d,
                    };
                  })(t, _, r, n);
                return u;
              })(t, o, 0, r, n),
              (function (t, i, s) {
                if (!t.attributes.positions)
                  if (i.hasProperty('POSITION'))
                    t.attributes.positions = {
                      type: Tl.FLOAT,
                      value: i.getPropertyArray('POSITION', Tl.FLOAT, 3),
                      size: 3,
                      normalized: !0,
                    };
                  else if (i.hasProperty('POSITION_QUANTIZED')) {
                    const r = i.getPropertyArray('POSITION_QUANTIZED', Tl.UNSIGNED_SHORT, 3);
                    if (
                      ((t.isQuantized = !0),
                      (t.quantizedRange = 65535),
                      (t.quantizedVolumeScale = i.getGlobalProperty(
                        'QUANTIZED_VOLUME_SCALE',
                        Tl.FLOAT,
                        3,
                      )),
                      !t.quantizedVolumeScale)
                    )
                      throw new Error(
                        'QUANTIZED_VOLUME_SCALE must be defined for quantized positions.',
                      );
                    if (
                      ((t.quantizedVolumeOffset = i.getGlobalProperty(
                        'QUANTIZED_VOLUME_OFFSET',
                        Tl.FLOAT,
                        3,
                      )),
                      !t.quantizedVolumeOffset)
                    )
                      throw new Error(
                        'QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.',
                      );
                    t.attributes.positions = (function (t, i, s) {
                      return t.isQuantized
                        ? s['3d-tiles'] && s['3d-tiles'].decodeQuantizedPositions
                          ? ((t.isQuantized = !1),
                            (function (t, i) {
                              const s = new e.Vector3(),
                                r = new Float32Array(3 * t.pointCount);
                              for (let e = 0; e < t.pointCount; e++)
                                s.set(i[3 * e], i[3 * e + 1], i[3 * e + 2])
                                  .scale(1 / t.quantizedRange)
                                  .multiply(t.quantizedVolumeScale)
                                  .add(t.quantizedVolumeOffset)
                                  .toArray(r, 3 * e);
                              return r;
                            })(t, i))
                          : { type: Tl.UNSIGNED_SHORT, value: i, size: 3, normalized: !0 }
                        : { type: Tl.FLOAT, value: i, size: 3, normalized: !0 };
                    })(t, r, s);
                  }
                if (!t.attributes.positions)
                  throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');
              })(t, o, r),
              (function (e, t, i) {
                if (!e.attributes.colors) {
                  let s = null;
                  t.hasProperty('RGBA')
                    ? ((s = t.getPropertyArray('RGBA', Tl.UNSIGNED_BYTE, 4)),
                      (e.isTranslucent = !0))
                    : t.hasProperty('RGB')
                    ? (s = t.getPropertyArray('RGB', Tl.UNSIGNED_BYTE, 3))
                    : t.hasProperty('RGB565') &&
                      ((s = t.getPropertyArray('RGB565', Tl.UNSIGNED_SHORT, 1)), (e.isRGB565 = !0)),
                    (e.attributes.colors = Kl(e, s, i));
                }
                if (t.hasProperty('CONSTANT_RGBA')) {
                  const i = t.getGlobalProperty('CONSTANT_RGBA', Tl.UNSIGNED_BYTE, 4);
                  e.constantRGBA = i.map((e) => e / 255);
                }
              })(t, o, a),
              (function (t, i) {
                if (!t.attributes.normals) {
                  let s = null;
                  i.hasProperty('NORMAL')
                    ? (s = i.getPropertyArray('NORMAL', Tl.FLOAT, 3))
                    : i.hasProperty('NORMAL_OCT16P') &&
                      ((s = i.getPropertyArray('NORMAL_OCT16P', Tl.UNSIGNED_BYTE, 2)),
                      (t.isOctEncoded16P = !0)),
                    (t.attributes.normals = (function (t, i) {
                      if (!i) return null;
                      if (t.isOctEncoded16P) {
                        const s = new Float32Array(3 * t.pointsLength);
                        for (let r = 0; r < t.pointsLength; r++)
                          e.octDecode(i[2 * r], i[2 * r + 1], Yl), Yl.toArray(s, 3 * r);
                        return { type: Tl.FLOAT, size: 2, value: s };
                      }
                      return { type: Tl.FLOAT, size: 2, value: i };
                    })(t, s));
                }
              })(t, o),
              s
            );
          })(n, t, i, s, r);
        default:
          throw new Error(`3DTileLoader: unknown type ${n.type}`);
      }
    }
    function rh(e, t) {
      return (
        e && e.content && (e.contentUrl = `${t.basePath}/${e.content.uri || e.content.url}`),
        (e.id = e.contentUrl),
        (e.lodMetricType = Ba),
        (e.lodMetricValue = e.geometricError),
        (e.transformMatrix = e.transform),
        (e.type = (function (e) {
          if (!e.contentUrl) return 'empty';
          const t = e.contentUrl.split('.').pop();
          switch (t) {
            case 'pnts':
              return 'pointcloud';
            case 'i3dm':
            case 'b3dm':
              return 'scenegraph';
            default:
              return t;
          }
        })(e)),
        (e.refine = (function (e) {
          switch (e) {
            case 'REPLACE':
            case 'replace':
              return 2;
            case 'ADD':
            case 'add':
              return 1;
            default:
              return e;
          }
        })(e.refine)),
        e
      );
    }
    const nh = {
        id: '3d-tiles',
        name: '3D Tiles',
        module: '3d-tiles',
        version: fl,
        extensions: ['cmpt', 'pnts', 'b3dm', 'i3dm'],
        mimeTypes: ['application/octet-stream'],
        tests: ['cmpt', 'pnts', 'b3dm', 'i3dm'],
        parse: async function (e, t, i, s) {
          const r = t['3d-tiles'] || {};
          let n;
          return (
            (n = 'auto' === r.isTileset ? i.url && -1 !== i.url.indexOf('.json') : r.isTileset),
            (e = n
              ? await (async function (e, t, i) {
                  const s = JSON.parse(new TextDecoder().decode(e));
                  return (
                    (s.loader = t.loader || nh),
                    (s.url = i.url),
                    (s.basePath = ue(s.url)),
                    (s.root = (function (e) {
                      const t = e.basePath,
                        i = rh(e.root, e);
                      e.gltfUpAxis = e?.asset?.gltfUpAxis || 'Y';
                      const s = [];
                      for (s.push(i); s.length > 0; ) {
                        const e = s.pop().children || [];
                        for (const i of e) rh(i, { basePath: t }), s.push(i);
                      }
                      return i;
                    })(s)),
                    (s.type = Da),
                    (s.lodMetricType = Ba),
                    s.geometricError
                      ? (s.lodMetricValue = s.geometricError)
                      : ((s.geometricError = s.root.geometricError),
                        (s.lodMetricValue = s.root.lodMetricValue)),
                    s
                  );
                })(e, t, i)
              : await (async function (e, t, i) {
                  const s = { content: { segmentationData: null } };
                  return await sh(e, 0, t, i, s.content), s.content;
                })(e, t, i)),
            e
          );
        },
        options: {
          '3d-tiles': {
            loadGLTF: !0,
            decodeQuantizedPositions: !1,
            isTileset: 'auto',
            assetGltfUpAxis: null,
          },
        },
      },
      oh = 'https://api.cesium.com/v1/assets',
      ah = {
        ...nh,
        id: 'cesium-ion',
        name: 'Cesium Ion',
        preload: async function (e, t = {}) {
          t = t['cesium-ion'] || {};
          const { accessToken: i } = t;
          let s = t.assetId;
          if (!Number.isFinite(s)) {
            const t = e.match(/\/([0-9]+)\/tileset.json/);
            s = t && t[1];
          }
          return (async function (e, t) {
            if (!t) {
              const i = await (async function (e) {
                P(e);
                const t = oh,
                  i = { Authorization: `Bearer ${e}` },
                  s = await ze(t, { headers: i, throws: !0 });
                return await s.json();
              })(e);
              for (const e of i.items) '3DTILES' === e.type && (t = e.id);
            }
            const i = await (async function (e, t) {
                P(e, t);
                const i = { Authorization: `Bearer ${e}` },
                  s = `${oh}/${t}`;
                let r = await ze(`${s}`, { headers: i, throws: !0 }),
                  n = await r.json();
                r = await ze(`${s}/endpoint`, { headers: i, throws: !0 });
                const o = await r.json();
                return (n = { ...n, ...o }), n;
              })(e, t),
              { type: s, url: r } = i;
            return (
              P('3DTILES' === s && r), (i.headers = { Authorization: `Bearer ${i.accessToken}` }), i
            );
          })(i, s);
        },
        parse: async (e, t, i, s) => (
          (t['3d-tiles'] = t['cesium-ion']), (t.loader = ah), nh.parse(e, t, i)
        ),
        options: { 'cesium-ion': { ...nh.options['3d-tiles'], accessToken: null } },
      };
    class lh {
      get length() {
        return this._values.length;
      }
      get values() {
        return this._values;
      }
      constructor() {
        (this._values = []), (this._hash = {});
      }
      contains(t) {
        if ('string' != typeof t && 'number' != typeof t)
          throw new Error('key is required to be a string or number.');
        return e.defined(this._hash[t]);
      }
      set(e, t) {
        if ('string' != typeof e && 'number' != typeof e)
          throw new Error('key is required to be a string or number.');
        return (
          t !== this._hash[e] && (this.remove(e), (this._hash[e] = t), this._values.push(t)), t
        );
      }
      get(e) {
        if ('string' != typeof e && 'number' != typeof e)
          throw new Error('key is required to be a string or number.');
        return this._hash[e];
      }
      remove(t) {
        if (e.defined(t) && 'string' != typeof t && 'number' != typeof t)
          throw new Error('key is required to be a string or number.');
        const i = this._hash[t];
        if (e.defined(i)) {
          const e = this._values;
          e.splice(e.indexOf(i), 1), delete this._hash[t];
        }
        return i;
      }
      removeAll() {
        const e = this._values;
        e.length > 0 && ((this._hash = {}), (e.length = 0));
      }
      getAll() {
        return this._hash;
      }
    }
    class hh {
      constructor(e, t, i) {
        (this.attributes = i), (this.context = e), (this.buffers = {}), this._parsePntsObject(t);
      }
      getBuffers() {
        return this.buffers;
      }
      bind() {
        this.bindPerAttibuteBufferAndPointer();
      }
      updateData(e) {
        const t = this.context.gl;
        this.bind(), t.bufferSubData(t.ARRAY_BUFFER, 0, e);
      }
      enableAttributes(e, t) {
        this.bindPerAttibuteBufferAndPointer(e, t);
      }
      setVertexAttribPointers() {}
      bindPerAttibuteBufferAndPointer(e, t) {
        for (let i = 0; i < this.attributes.length; i++) {
          const s = this.attributes[i];
          this.context.bindVertexBuffer.set(this.buffers[s.name]);
          const r = t.attributes[s.name];
          void 0 !== r &&
            (e.enableVertexAttribArray(r),
            e.vertexAttribPointer(r, s.components, s.type, !1, s.byteStride, s.offset)),
            this.context.bindVertexBuffer.set(null);
        }
      }
      _parsePntsObject(e) {
        const t = this.context.gl;
        let i = {};
        for (let s = 0; s < this.attributes.length; s++) {
          const r = this.attributes[s],
            n = r.bufferName,
            o = r.name;
          if (i[n]) this.buffers[o] = i[n];
          else {
            const s = t.createBuffer();
            this.context.bindVertexBuffer.set(s),
              t.bufferData(t.ARRAY_BUFFER, e[n], t.STATIC_DRAW),
              (i[n] = s),
              (this.buffers[o] = s);
          }
        }
        i = null;
      }
      destroy() {
        const e = this.context.gl;
        for (const t in this.buffers) e.deleteBuffer(this.buffers[t]), delete this.buffers[t];
        this.context = null;
      }
    }
    const ch = {
      BYTE: 5120,
      UNSIGNED_BYTE: 5121,
      SHORT: 5122,
      UNSIGNED_SHORT: 5123,
      UNSIGNED_INT: 5125,
      FLOAT: 5126,
    };
    class _h {
      process(t) {
        const { content: i, context: s, customizedColor: r, pointSize: n } = t;
        (this.usesNormals = !1),
          (this.isOctEncoded16P = i.isOctEncoded16P),
          (this.isQuantized = i.isQuantized),
          (this.isRGB565 = i.isRGB565),
          (this.isTranslucent = i.isTranslucent),
          (this.isQuantizedDraco = i.isQuantizedDraco),
          (this.isOctEncodedDraco = i.isOctEncodedDraco),
          (this.usesCustomizedColor = !1),
          (this.customizedColor = r);
        const o = i.attributes.positions.value,
          a = [];
        i.attributes.normals && (this.usesNormals = !0),
          i.featureTableJson.POSITION
            ? a.push({
                name: 'a_POSITION',
                type: i.attributes.positions.type,
                components: 3,
                offset: i.featureTableJson.POSITION.byteOffset,
                byteStride: 3 * e.WebGLSizes[i.attributes.positions.type],
                bufferName: 'vertexBuf',
              })
            : i.featureTableJson.POSITION_QUANTIZED &&
              a.push({
                name: 'a_POSITION',
                type: i.attributes.positions.type,
                components: 3,
                offset: 0,
                byteStride: 3 * e.WebGLSizes[i.attributes.positions.type],
                bufferName: 'vertexBuf',
              });
        let l = null;
        i.attributes.colors &&
          ((this.colorSize = i.attributes.colors.size),
          (l = i.attributes.colors.value),
          a.push({
            name: 'a_RGB',
            type: i.attributes.colors.type,
            components: i.attributes.colors.size,
            offset: 0,
            byteStride: i.attributes.colors.size * e.WebGLSizes[i.attributes.colors.type],
            bufferName: 'colorBuf',
          })),
          (this.attributesForVertexShader = '');
        const h = i.batchTableBinary;
        for (const t in i.batchTableJson) {
          const s = i.batchTableJson[t];
          if (s.byteOffset) {
            const i = `a_${t}`;
            (this.attributesForVertexShader += `attribute ${
              e.WebGLComponentToShaderVariableType[s.type]
            } ${i}; \n`),
              a.push({
                name: i,
                type: ch[s.componentType],
                components: e.WebGLComponentCounts[s.type],
                offset: s.byteOffset,
                byteStride:
                  ((c = s.type),
                  (_ = ch[s.componentType] || 5126),
                  e.WebGLComponentCounts[c] * e.WebGLSizes[_]),
                bufferName: 'propertyBuf',
              });
          }
          this.customizedColor &&
            t === this.customizedColor.property &&
            (this.usesCustomizedColor = !0);
        }
        var c, _;
        this.customizedColor &&
          !this.usesCustomizedColor &&
          console.warn(`Point cloud does not have property named ${this.customizedColor.property}`);
        const u = e.createLayoutPnts(a),
          d = new hh(s, { propertyBuf: h, vertexBuf: o, colorBuf: l }, u.members),
          m = {
            segmentVector: e.SegmentVector.simpleSegment(0, 0, i.pointCount, i.pointCount),
            layoutVertexBuffer: d,
            mode: e.WebGLConstants.POINTS,
            count: i.pointCount,
            u_PointSize: n,
          };
        if (this.isQuantized) {
          const t = i.featureTableJson.QUANTIZED_VOLUME_SCALE,
            s = i.featureTableJson.QUANTIZED_VOLUME_OFFSET;
          (m.u_QuantizedOffset = new e.Vector3(s[0], s[1], s[2])),
            (m.u_QuantizedVolumeScaleAndOctEncodedRange = new e.Vector4(t[0], t[1], t[2], 255));
        }
        if (!i.attributes.colors)
          if (i.constantRGBA) {
            const t = i.constantRGBA;
            m.u_ConstantColor = new e.Color(t[0], t[1], t[2], t[3]);
          } else m.u_ConstantColor = new e.Color(0, 0, 0, 1);
        return m;
      }
      genPropertyFunction() {}
      static genShaderScript(t, i) {
        let s =
          'precision highp float;\nprecision highp int;\nattribute vec3 a_POSITION; \nvarying vec4 v_color; \nuniform vec4 u_ConstantColor; \nuniform vec4 u_HighlightColor; \nuniform mat4 u_ModelMatrix; \nuniform bool u_InShadow;\nuniform mat4 u_ModelViewProjectionMatrix; \n';
        return (
          (s += 'uniform float u_PointSize; \n'),
          (s += t.attributesForVertexShader),
          (t.isQuantized || t.isQuantizedDraco || t.isOctEncodedDraco) &&
            ((s += 'uniform vec4 u_QuantizedVolumeScaleAndOctEncodedRange; \n'),
            (s += 'uniform vec3 u_QuantizedOffset; \n')),
          t.colorSize &&
            (s += 3 === t.colorSize ? 'attribute vec3 a_RGB; \n' : 'attribute vec4 a_RGB; \n'),
          (s += '#include <fn_getExponentialInterpColor>\n'),
          (s += 'void main() \n{ \n'),
          t.isQuantized
            ? ((s += '    const float inv65535=1.0/65535.0;\n'),
              (s +=
                '    vec3 position = a_POSITION * u_QuantizedVolumeScaleAndOctEncodedRange.xyz / 65535.0  + u_QuantizedOffset;\n'),
              (s +=
                '    vec3 posOri = a_POSITION * u_QuantizedVolumeScaleAndOctEncodedRange.xyz / 65535.0 + u_QuantizedOffset;\n'))
            : ((s += '    vec3 position = a_POSITION; \n'),
              (s += '    vec3 posOri = a_POSITION; \n')),
          (s += '    vec3 position_absolute = vec3(u_ModelMatrix * vec4(position, 1.0)); \n'),
          (s += '    vec3 normal = vec3(1.0); \n'),
          (s += '    gl_PointSize = u_PointSize; \n'),
          t.customizedColor
            ? ((s += e.genColorBarScript(t.customizedColor, !0)), (s += '    v_color = color; \n'))
            : (s += t.colorSize
                ? 3 === t.colorSize
                  ? '    v_color = vec4(a_RGB, 1.0); \n'
                  : '    v_color = a_RGB; \n'
                : '    v_color = u_ConstantColor; \n'),
          i && (s += i),
          (s += '    const float EPS=12.0;\n'),
          (s +=
            '    if(u_InShadow==true){gl_Position=u_ModelViewProjectionMatrix*vec4(posOri,1.0);}\n'),
          (s += '    else {gl_Position=u_ModelViewProjectionMatrix*vec4(position,1.0);}\n'),
          (s += '} \n'),
          { vs: s, fs: 'varying vec4 v_color;\n\nvoid main() {\n    gl_FragColor = v_color;\n}' }
        );
      }
    }
    class uh extends e.Material {
      constructor(t) {
        super(t),
          (this._color = t.u_ConstantColor || new e.Color(0, 0, 0)),
          (this.u_PointSize = t.u_PointSize || 1),
          (this.u_QuantizedOffset = t.u_QuantizedOffset),
          (this.u_QuantizedVolumeScaleAndOctEncodedRange =
            t.u_QuantizedVolumeScaleAndOctEncodedRange),
          this.updateRenderState(),
          this.createUniforms(),
          this.buildDefines();
      }
      update(e, t, i = {}) {
        super.update(e, t, i), this.updateRenderState();
      }
      updateRenderState() {
        this.renderState = {
          depthTest: { enabled: !0, func: e.WebGLConstants.LESS },
          blending: {
            enabled: !0,
            color: { red: 0, green: 0, blue: 0, alpha: 0 },
            equationRgb: e.WebGLConstants.FUNC_ADD,
            equationAlpha: e.WebGLConstants.FUNC_ADD,
            functionSourceRgb: e.WebGLConstants.SRC_ALPHA,
            functionSourceAlpha: e.WebGLConstants.ONE,
            functionDestinationRgb: e.WebGLConstants.ONE_MINUS_SRC_ALPHA,
            functionDestinationAlpha: e.WebGLConstants.ONE_MINUS_SRC_ALPHA,
          },
        };
      }
      createUniforms() {
        e.defined(this._color) &&
          (this._uniforms.set('u_ConstantColor', () => {
            let t = !1;
            return (
              (this._color.r > 1 || this._color.g > 1 || this._color.b > 1) && (t = !0),
              e.Vector4.fromColor(this._color, t)
            );
          }),
          this._uniforms.set('u_HighlightColor', () => {
            let t = !1;
            return (
              (this._color.r > 1 || this._color.g > 1 || this._color.b > 1) && (t = !0),
              e.Vector4.fromColor(this._color, t)
            );
          }),
          this._uniforms.set('u_PointSize', () => this.u_PointSize),
          this._uniforms.set(
            'u_QuantizedVolumeScaleAndOctEncodedRange',
            () => this.u_QuantizedVolumeScaleAndOctEncodedRange,
          ),
          this._uniforms.set('u_QuantizedOffset', () => this.u_QuantizedOffset));
      }
      buildDefines() {
        const t = { USE_RGBA_COLOR: e.defined(this._color) };
        this.defines = t;
      }
      destroy() {}
    }
    class dh {
      constructor(t) {
        const { tileID: i, boundingVolume: s, customizedColor: r, pointSize: n } = t;
        (this.tileID = i),
          (this.uid = e.uniqueId()),
          (this.uses = 0),
          (this.boundingVolume = s),
          (this.state = 'loading'),
          (this.content = {}),
          (this.tileType = 'tiles'),
          (this.customizedColor = r),
          (this.pointSize = n);
      }
      loadVectorData(e) {
        (this.content = e), (this.state = 'data-down-finished');
      }
      unloadVectorData() {
        for (let e = 0; e < this.primitives.length; e++) this.primitives[e].destroy();
        (this.state = 'unloaded'),
          (this.primitives = []),
          (this.content = void 0),
          (this.state = 'unloaded'),
          (this.boundingVolume = null);
      }
      upload(t, i, s) {
        this.source = s;
        const r = new _h(),
          n = r.process({
            content: t,
            context: i,
            customizedColor: this.customizedColor,
            pointSize: this.pointSize,
          }),
          o = _h.genShaderScript(r);
        this.primitives = [
          new e.Primitive({
            modelMatrix: t.cartesianModelMatrix,
            geometry: e.Geometry.fromPointCloudData(n),
            material: new uh({
              type: 'geometry-point-cloud-pnts',
              vertexSource: e.reduceComma(o.vs),
              fragmentSource: e.reduceComma(o.fs),
              ...n,
            }),
          }),
        ];
      }
      fire(e) {
        this.source.fire(e);
      }
    }
    class mh {
      constructor(t) {
        let i;
        (this._url = e.defaultValue(t.url, void 0)), (this._urls = e.defaultValue(t.urls, []));
        try {
          if (((i = this._getSourceUrls(this._urls, this._url)), !i.length))
            throw new Error('urls 和 url 参数至少配置一个');
        } catch (e) {
          throw new Error('urls 或 url参数不规范，请检查');
        }
        const { translation: s } = t;
        if (e.defined(s) && !(s instanceof e.Vector3) && !Array.isArray(s))
          throw new Error('options.translation is unKnown type!');
        if (
          ((this.translation = e.defaultValue(new e.Vector3(s), void 0)),
          e.defined(t.clippingPlanes) && !(t.clippingPlanes instanceof e.ClippingPlaneCollection))
        )
          throw new Error('options.clippingPlanes is unKnown type!');
        if (
          ((this._clippingPlanes = e.defaultValue(t.clippingPlanes, void 0)),
          (this._maximumScreenSpaceError = e.defaultValue(t.maximumScreenSpaceError, 16)),
          (this._maximumMemoryUsage = e.defaultValue(t.maximumMemoryUsage, 64)),
          (this._subIPs = e.defaultValue(t.subIPs, void 0)),
          (this._loadSiblings = e.defaultValue(t.loadSiblings, !1)),
          (this.skipLevelOfDetail = e.defaultValue(t.skipLevelOfDetail, !1)),
          (this.baseScreenSpaceError = e.defaultValue(t.baseScreenSpaceError, 1024)),
          (this.skipLevels = e.defaultValue(t.skipLevels, 1)),
          (this.skipScreenSpaceErrorFactor = e.defaultValue(t.skipScreenSpaceErrorFactor, 16)),
          (this.immediatelyLoadDesiredLevelOfDetail = e.defaultValue(
            t.immediatelyLoadDesiredLevelOfDetail,
            !1,
          )),
          (this.useMipmap = e.defaultValue(t.useMipmap, !1)),
          (this.pointSize = e.defaultValue(t.pointSize, 1)),
          (this._allowPick = e.defaultValue(t.allowPick, !0)),
          (this.customizedColor = e.defaultValue(t.customizedColor, void 0)),
          (this._lightingModel = e.defaultValue(t.lightingModel, e.LightingModelType.NONE)),
          (this.classificationType = t.classificationType),
          e.defined(t.sourceLoaded) && !(t.sourceLoaded instanceof Function))
        )
          throw new Error('options.sourceLoaded is not a function!');
        (this.sourceLoadedCallback = e.defaultValue(t.sourceLoaded, void 0)),
          (this._geoBoundsOptions = e.defaultValue(t.geoBoundsOptions, { index: 0, combine: !1 })),
          (this.id = t.id),
          (this._show = e.defaultValue(t.show, !0)),
          (this.map = t.map),
          (this._ready = !1),
          (this._selectedTiles = []),
          (this._opaqueList = []),
          (this._translucentList = []),
          (this._minMax3dtileBoundHeight = { minimumHeight: void 0, maximumHeight: void 0 }),
          (this._cacheTile = new lh()),
          (this._debugFreezeFrame = e.defaultValue(t.debugFreezeFrame, !1)),
          (this._activeCamera = new n()),
          (this.backCulling = e.defaultValue(t.backCulling, !1)),
          this.loadTileset(i),
          (this.visibility = 'visible'),
          (this.minzoom = e.defaultValue(t.minzoom, 0)),
          (this.maxzoom = t.maxzoom),
          (this.opacity = e.defaultValue(t.opacity, 1));
      }
      get clippingPlanes() {
        return this._clippingPlanes;
      }
      set clippingPlanes(t) {
        this._clippingPlanes = t instanceof e.ClippingPlaneCollection ? t : void 0;
      }
      get debugFreezeFrame() {
        return this._debugFreezeFrame;
      }
      set debugFreezeFrame(t) {
        e.isBoolean(t) &&
          null != this.tileset3d &&
          ((this._debugFreezeFrame = t), (this.tileset3d.traverseCounter = 0));
      }
      get lightingModel() {
        return this._lightingModel;
      }
      set lightingModel(t) {
        Object.values(e.LightingModelType).includes(t)
          ? (this._lightingModel = t)
          : console.warn(`不支持该值的光照模型: ${t}`);
      }
      get show() {
        return this._show;
      }
      set show(t) {
        e.isBoolean(t) &&
          ((this._show = t),
          (this._opaqueList = []),
          (this._translucentList = []),
          this.map.triggerRepaint());
      }
      get allowPick() {
        return this._allowPick;
      }
      set allowPick(e) {
        this._allowPick = e;
        let t = [];
        t = t.concat(this._translucentList, this._opaqueList);
        for (let i = 0; i < t.length; i++) t[i].allowPick = e;
      }
      getBounds() {
        let t;
        if (this._geoBounds.length > 0) {
          const i = this._geoBoundsOptions.index,
            s = this._geoBoundsOptions.combine;
          if (e.defined(i))
            t = e.defined(this._geoBounds[i]) ? this._geoBounds[i] : this._geoBounds[0];
          else if (s) {
            t = new e.LngLatBounds(this._geoBounds[0].sw, this._geoBounds[0].ne);
            for (let e = this._geoBounds.length - 1; e > 0; e--) t.extend(this._geoBounds[e]);
          }
        }
        return t;
      }
      buildGltfTile(t) {
        const i = t.type;
        if ('cmpt' === i) {
          const i = new e.GltfTile({
            tileID: t.id,
            boundingVolume: t.boundingVolume,
            minemap3DType: t.type,
            instances: t.instances || [],
            normalRight: t.normalRight || [],
            normalUp: t.normalUp || [],
            relativeCenter: t.relativeCenter || [],
            clippingPlaneCollection: this._clippingPlaneCollection,
          });
          this._cacheTile.set(t.id, i);
          const s = t.content.tiles;
          for (let r = 0; r < s.length; r++) {
            const n = s[r],
              o = new e.GltfTile({
                tileID: t.id + r,
                boundingVolume: t.boundingVolume,
                minemap3DType: n.type,
                instances: n.instances || [],
                normalRight: n.normalRight || [],
                normalUp: n.normalUp || [],
                relativeCenter: t.relativeCenter || [],
                clippingPlaneCollection: this._clippingPlaneCollection,
              });
            e.defined(n.cartesianModelMatrix) ||
              (n.cartesianModelMatrix = t.content.cartesianModelMatrix),
              e.defined(n.content)
                ? (n.content.extra = {
                    featureTable: n.featureTable,
                    batchTable: n.batchTable,
                    selectionDepth: n._selectionDepth,
                    depth: t.depth,
                    finalResolution: t._finalResolution,
                    markAsRoot: t.userData.markAsRoot,
                  })
                : (n.extra = {
                    featureTable: n.featureTable,
                    batchTable: n.batchTable,
                    selectionDepth: n._selectionDepth,
                    depth: t.depth,
                    finalResolution: t._finalResolution,
                    markAsRoot: t.userData.markAsRoot,
                  }),
              o.upload(n, this.map.painter.context, { type: '3d-tiles' }),
              this._selectedTiles.push(o),
              i.childTiles.push(o);
          }
        } else {
          let s;
          (s =
            'pointcloud' === i || 'pnts' === t.content.type
              ? new dh({
                  tileID: t.id,
                  boundingVolume: t.boundingVolume,
                  minemap3DType: t.content.type,
                  instances: t.instances || [],
                  normalRight: t.normalRight || [],
                  normalUp: t.normalUp || [],
                  relativeCenter: t.relativeCenter || [],
                  clippingPlaneCollection: this._clippingPlaneCollection,
                  customizedColor: this.customizedColor,
                  pointSize: this.pointSize,
                })
              : new e.GltfTile({
                  tileID: t.id,
                  boundingVolume: t.boundingVolume,
                  minemap3DType: t.content.type,
                  instances: t.instances || [],
                  normalRight: t.normalRight || [],
                  normalUp: t.normalUp || [],
                  relativeCenter: t.relativeCenter || [],
                  clippingPlaneCollection: this._clippingPlaneCollection,
                  customizedColor: this.customizedColor,
                })),
            this._cacheTile.set(t.id, s),
            e.defined(t.content) &&
              (t.content.extra = {
                featureTable: t.content.featureTable,
                batchTable: t.content.batchTable,
                selectionDepth: t._selectionDepth,
                depth: t.depth,
                finalResolution: t._finalResolution,
                markAsRoot: t.userData.markAsRoot,
              }),
            s.upload(t.content, this.map.painter.context, { type: '3d-tiles' }),
            this._selectedTiles.push(s);
        }
      }
      _removeTile(t) {
        const i = this._cacheTile._hash[t];
        i &&
          (e.defined(i.childTiles) &&
            i.childTiles.length > 0 &&
            i.childTiles.forEach((e) => {
              e.unloadVectorData();
            }),
          i.unloadVectorData(),
          this._cacheTile.remove(t));
      }
      _unloadTiles(e) {
        this._removeTile(e.id);
      }
      async loadTileset(t) {
        const i = [];
        for (let e = 0; e < t.length; e++)
          i.push(
            await ut(xr(t[e].url), nh, {
              transformRequest: this.map._transformRequest,
              json: !0,
              dispatcher: this.map.style.dispatcher,
            }),
          );
        if (0 == i.length) throw new Error('Error getting tileset data');
        {
          const t = this._unionBoundingVolume(i);
          this.translation && this._shiftBoundingVolume(t, this.translation),
            (this.tileset3d = new pl(t, {
              onTileLoad: () => {
                this.map.repaint || (this.update(), this.map.triggerRepaint());
              },
              onTileUnload: (e) => {
                this._unloadTiles(e);
              },
              subIPs: this._subIPs,
              maximumScreenSpaceError: this._maximumScreenSpaceError,
              throttleRequests: !0,
              maximumMemoryUsage: this._maximumMemoryUsage,
              loadSiblings: this._loadSiblings,
              skipLevelOfDetail: this.skipLevelOfDetail,
              baseScreenSpaceError: this.baseScreenSpaceError,
              skipLevels: this.skipLevels,
              skipScreenSpaceErrorFactor: this.skipScreenSpaceErrorFactor,
              immediatelyLoadDesiredLevelOfDetail: this.immediatelyLoadDesiredLevelOfDetail,
              context: this.map.painter.context,
              useMipmap: this.useMipmap,
              maxRequests:
                e.defined(this.subIPs) && e.defined(this.subIPs.length)
                  ? 6 * this.subIPs.length
                  : 6,
              modelMatrix: e.Matrix4.IDENTITY,
              transformRequest: this.map._transformRequest,
              allowPick: this.allowPick,
              parent: this,
              dispatcher: this.map.style.dispatcher,
            })),
            (this.tileset3d.root.boundingVolume = t.root.boundingVolume.sphere),
            (this._geoCenters = t.tileCenters),
            (this._geoBounds = t.tileBounds),
            (this._ready = !0),
            e.defined(this.sourceLoadedCallback) && this.sourceLoadedCallback(this),
            this.map.repaint || (this.update(), this.map.triggerRepaint());
        }
      }
      _getSourceUrls(e, t) {
        const i = e.filter((e) => e.url);
        return t && !i.find((e) => e.url === t) && i.push({ url: t }), i;
      }
      _shiftBoundingVolume(t, i) {
        const s = new e.Vector3(
          e.defined(t.tileCenters[0]) ? t.tileCenters[0] : t.boundingVolume.sphere.center,
        );
        s.z = 0;
        const r = e.Ellipsoid.WGS84.cartographicToCartesian(s, new e.Vector3()),
          n = e.Transforms.eastNorthUpToFixedFrame(r);
        let o = e.Matrix4.multiplyByVector(n, new e.Vector4(i.x, i.y, i.z, 1), new e.Vector4());
        o = new e.Vector3(o[0], o[1], o[2]);
        const a = o.subVectors(o, r),
          l = e.Matrix4.fromRotationTranslation(e.Matrix3.IDENTITY, a, new e.Matrix4());
        (t.root.transform = l), (t.root.transformMatrix = l);
        const h = new e.Vector4(t.root.boundingVolume.sphere.center);
        (h.w = 1),
          e.Matrix4.multiplyByVector(l, h, h),
          (t.root.boundingVolume.sphere.center = new e.Vector3(h[0], h[1], h[2]));
      }
      _unionBoundingVolume(t) {
        const i = {
          asset: {
            version: '0.0',
            tilesetVersion: 'minemap-top-merge',
            gltfUpAxis: t[0].gltfUpAxis || 'Y',
          },
          geometricError: 1 / 0,
          root: {
            children: [],
            transform: [],
            boundingVolume: { sphere: null },
            geometricError: 1 / 0,
            refine: 'REPLACE',
          },
          tileCenters: [],
          tileBounds: [],
        };
        let s,
          r = 0;
        for (let n = 0; n < t.length; n++) {
          r = Math.max(r, t[n].geometricError);
          const o = new e.Matrix4(t[n].root.transform);
          let a, l;
          const h = Fa(t[n].root.boundingVolume, o);
          if (e.defined(h.halfAxes)) {
            const t = new e.OrientedBoundingBox(h.center, h.halfAxes);
            (l = t.getBoundingMaximum(3)), (a = t.getBoundingSphere());
          } else
            h instanceof e.TileBoundingRegion
              ? ((l = h.boundingVolume.getBoundingMaximum()), (a = h._boundingSphere))
              : ((a = h), (l = a.getBoundingMaximum()));
          if (((s = 0 === n ? new e.BoundingSphere(a.center, a.radius) : s.union(a)), l)) {
            const t = e.Transforms.DefaultEllipsoid.cartesianToCartographic(l.boundingMaxValue),
              s = e.Transforms.DefaultEllipsoid.cartesianToCartographic(l.boundingMinValue),
              r = new e.LngLatBounds([s[0], s[1]], [t[0], t[1]]);
            i.tileBounds.push(r);
          }
          i.tileCenters.push(e.Transforms.DefaultEllipsoid.cartesianToCartographic(a.center)),
            i.root.children.push(t[n].root);
        }
        return (
          (i.root.geometricError = r),
          (i.root.boundingVolume.sphere = s),
          (i.root.id = void 0),
          (i.root.lodMetricType = t[0].root.lodMetricType),
          (i.root.lodMetricValue = r),
          (i.root.refine = void 0),
          (i.root.transform = new e.Matrix4()),
          (i.root.transformMatrix = new e.Matrix4()),
          (i.root.type = t[0].root.type),
          (i.geometricError = r),
          (i.basePath = t[0].basePath),
          (i.loader = t[0].loader),
          (i.lodMetricType = t[0].lodMetricType),
          (i.lodMetricValue = r),
          (i.type = t[0].type),
          (i.url = t[0].url),
          i
        );
      }
      _calcActiveCamera() {
        const e = this.map.transform;
        return (
          this._activeCamera.updatePerspectiveOptions({
            fov: e.fov,
            aspect: e.width / e.height,
            near: 0.1,
            far: e.far,
          }),
          this._activeCamera.setMatrix(e.activeCamera.matrixWorld.clone()),
          this._activeCamera
        );
      }
      update() {
        if (!this._ready || !this._show) return;
        const e = this._calcActiveCamera();
        if (
          (this.tileset3d.update(e.frustumCrate, {
            width: this.map.transform.width,
            height: this.map.transform.height,
          }),
          void 0 !== this.minzoom && void 0 !== this.maxzoom
            ? (this.map.getZoom() < this.minzoom || this.map.getZoom() > this.maxzoom) &&
              (this.tileset3d.selectedTiles = [])
            : void 0 !== this.minzoom
            ? this.map.getZoom() < this.minzoom && (this.tileset3d.selectedTiles = [])
            : void 0 !== this.maxzoom &&
              this.map.getZoom() > this.maxzoom &&
              (this.tileset3d.selectedTiles = []),
          (this._selectedTiles = []),
          this.tileset3d.selectedTiles.length > 0)
        ) {
          let e;
          const t = this.tileset3d.selectedTiles.filter((e) => e._finalResolution),
            i = this.tileset3d.selectedTiles.filter((e) => !e._finalResolution),
            s = t.concat(i);
          for (let t = 0; t < s.length; ++t) {
            e = s[t];
            const i = this._cacheTile.get(e.id);
            if (i)
              if (i.childTiles?.length > 0) {
                const t = e;
                i.childTiles.forEach((e) => {
                  (e.extra.selectionDepth = t._selectionDepth),
                    (e.extra.depth = t.depth),
                    (e.extra.finalResolution = t._finalResolution),
                    i.extra
                      ? (i.extra.markAsRoot = t.userData.markAsRoot)
                      : (e.extra.markAsRoot = t.userData.markAsRoot),
                    this._selectedTiles.push(e);
                });
              } else
                i.extra &&
                  ((i.extra.selectionDepth = e._selectionDepth),
                  (i.extra.depth = e.depth),
                  (i.extra.finalResolution = e._finalResolution),
                  (i.extra.markAsRoot = e.userData.markAsRoot)),
                  this._selectedTiles.push(i);
            else this.buildGltfTile(e);
          }
        }
        (this._opaqueList = []), (this._translucentList = []);
        const t = this;
        this._selectedTiles.forEach((e) => {
          e.primitives.forEach((i) => {
            (i._material.clippingPlanes = t.clippingPlanes),
              (i._material.backCulling = this.backCulling),
              (i._material._opacity = this.opacity),
              i._material.isTranslucent
                ? ((i.boundingVolume = e.boundingVolume),
                  (i.tileUid = e.uid),
                  t._translucentList.push(i))
                : t._opaqueList.push(i),
              ph(i, this);
          });
        });
      }
      loaded() {
        return (
          !!this.tileset3d &&
          this.tileset3d &&
          0 === this.tileset3d.stats.get('Tiles Loading').count
        );
      }
      destroy() {
        return e.defined(this.tileset3d) && this.tileset3d._destroy(), e.destroyObject(this);
      }
    }
    function ph(t, i) {
      i.lightingModel === e.LightingModelType.PBR
        ? ((t._material.defines.USE_PBR = !0), (t._material.defines.USE_IBL = !0))
        : ((t._material.defines.USE_PBR = !1), (t._material.defines.USE_IBL = !1)),
        (t._material.defines.PHONG_LIGHT = i.lightingModel == e.LightingModelType.PHONG);
    }
    class fh extends e.Evented {
      constructor(e, t, i) {
        super(),
          (this.id = e),
          (this.dispatcher = i),
          (this._firstLoadingTilesFlag = !0),
          (this._minMax3dtileBoundHeight = { minimumHeight: void 0, maximumHeight: void 0 }),
          this.on('data', (e) => {
            'cesium-tile' === e.dataType && this.map && this.update();
          }),
          this.on('error', () => {
            this._sourceErrored = !0;
          });
        const s = So(e, t, i, this);
        (this._source = s),
          (this._tiles = {}),
          (this._timers = {}),
          (this._cacheTimers = {}),
          (this._maxTileCacheSize = null),
          (this.idealTileIDs = []),
          (this._cesiumGltfTileObj = {}),
          (this._cesiumTiles = []),
          (this._preCesiumTiles = []),
          (this._cacheTile = new lh()),
          (this._geoCenters = []),
          (this._geoBounds = []),
          (this.lastFrameHasMixedContent = void 0),
          (this.sourceOptions = t),
          (this._activeCamera = new n());
      }
      _verifiableSourceUrls(e, t) {
        const i = [];
        if ((t && i.push({ url: t }), e && e.length))
          for (let s = 0; s < e.length; s++) {
            const r = e[s];
            t !== r.url && r.url && i.push(r);
          }
        return i.length ? i : { msg: 'urls 和 url 参数至少配置一个' };
      }
      #I(e, t) {
        const i = t || [];
        return e && i.push({ url: e }), !i.filter((e) => e.url.indexOf('https') > -1).length;
      }
      async loadTileset(t) {
        const {
            url: i,
            urls: s,
            maximumScreenSpaceError: r,
            maximumMemoryUsage: n,
            loadSiblings: o,
            skipLevelOfDetail: a,
            baseScreenSpaceError: l,
            skipLevels: h,
            skipScreenSpaceErrorFactor: c,
            immediatelyLoadDesiredLevelOfDetail: _,
            sourceLoaded: u,
            viewFrustum: d,
            subIPs: m,
            useMipmap: p,
            clippingPlanes: f,
            allowPick: g,
            translation: y,
          } = this.sourceOptions,
          T = [],
          x = this._verifiableSourceUrls(s, i);
        if (!(x instanceof Array)) throw new Error(x.msg);
        for (let e = 0; e < x.length; e++)
          T.push(
            await ut(xr(x[e].url), nh, {
              transformRequest: this.map._transformRequest,
              json: !0,
              dispatcher: this.map.style.dispatcher,
            }),
          );
        if (0 == T.length) throw new Error('Error getting tileset data');
        {
          const i = this._unionBoundingVolume(T);
          y && this._shiftBoundingVolume(i, y),
            (this.tileset3d = new pl(i, {
              onTileLoad: () => {
                this.update();
              },
              onTileUnload: (e) => {
                this._unloadTiles(e);
              },
              subIPs: m,
              maximumScreenSpaceError: r || 16,
              throttleRequests: !0,
              maximumMemoryUsage: n || 64,
              loadSiblings: o || !1,
              skipLevelOfDetail: a || !1,
              baseScreenSpaceError: l || 1024,
              skipLevels: h || 1,
              skipScreenSpaceErrorFactor: c || 16,
              immediatelyLoadDesiredLevelOfDetail: _ || !1,
              context: this.map.painter.context,
              useMipmap: p || !1,
              maxRequests: m?.length ? 6 * m.length : 6,
              modelMatrix: e.Matrix4.IDENTITY,
              transformRequest: this.map._transformRequest,
              clippingPlanes: f,
              allowPick: g,
              nodeProperty: { sourceId: t, sourceOptions: this.sourceOptions },
              dispatcher: this.dispatcher,
            })),
            (this.tileset3d.root.boundingVolume = i.root.boundingVolume.sphere),
            (this._geoCenters = i.tileCenters),
            (this._geoBounds = i.tileBounds),
            (this.sourceLoadedCallback = u),
            this.sourceLoadedCallback && this.sourceLoadedCallback(this),
            (this._viewFrustum = d || null),
            this.update(),
            this.map.triggerRepaint();
        }
      }
      _setViewFrustum(e) {
        this._viewFrustum = e;
      }
      update() {
        if (this._paused || !this.used) return;
        const e = this._calcActiveCamera();
        this.tileset3d &&
          e.frustumCrate &&
          (this.tileset3d.update(e.frustumCrate, {
            width: this.map.transform.width,
            height: this.map.transform.height,
          }),
          this.traversalTileRootToFindTopMergeTile());
      }
      _calcActiveCamera() {
        const e = this.map.transform;
        return (
          this._activeCamera.updatePerspectiveOptions({
            fov: e.fov,
            aspect: e.width / e.height,
            near: 0.1,
            far: e.far,
          }),
          this._activeCamera.setMatrix(e.activeCamera.matrixWorld.clone()),
          this._activeCamera
        );
      }
      _unloadTiles(e) {
        this._removeTile(e.id);
      }
      prepare(e) {
        this._source.prepare && this._source.prepare(), this._context || (this._context = e);
      }
      get tilesForRender() {
        if (((this._cesiumTiles = []), this?.tileset3d?.selectedTiles)) {
          let e;
          const t = this.tileset3d.selectedTiles.filter((e) => e._finalResolution),
            i = this.tileset3d.selectedTiles.filter((e) => !e._finalResolution),
            s = t.concat(i);
          for (let t = 0; t < s.length; ++t) {
            e = s[t];
            const i = this._cacheTile.get(e.id);
            i
              ? i.childTiles?.length > 0
                ? i.childTiles.forEach((t) => {
                    (t.extra.selectionDepth = e._selectionDepth),
                      (t.extra.depth = e.depth),
                      (t.extra.finalResolution = e._finalResolution),
                      i.extra
                        ? (i.extra.markAsRoot = e.userData.markAsRoot)
                        : (t.extra.markAsRoot = e.userData.markAsRoot),
                      this._cesiumTiles.push(t);
                  })
                : (i.extra &&
                    ((i.extra.selectionDepth = e._selectionDepth),
                    (i.extra.depth = e.depth),
                    (i.extra.finalResolution = e._finalResolution),
                    (i.extra.markAsRoot = e.userData.markAsRoot)),
                  this._cesiumTiles.push(i))
              : this.buildCesiumGltfTile(e);
          }
        }
        return (
          this.tileset3d &&
            0 != this.tileset3d.stats.get('Tiles Loading').count &&
            ((this.lastFrameHasMixedContent = this.tileset3d._hasMixedContent),
            this.fire(new e.Event('data', { dataType: 'cesium-tile' }))),
          null != this.lastFrameHasMixedContent &&
            this.tileset3d._hasMixedContent &&
            !this.lastFrameHasMixedContent &&
            this.fire(new e.Event('data', { dataType: 'cesium-tile' })),
          this._cesiumTiles
        );
      }
      traversalTileRootToFindTopMergeTile() {
        this.tileset3d && this.tileset3d.skipLevelOfDetail && yh(this.tileset3d.root.children, 0);
      }
      tilesIn() {
        return this._cesiumTiles;
      }
      onAdd(e) {
        (this.map = e),
          (this._maxTileCacheSize = e ? e._maxTileCacheSize : null),
          this._source && (this._source.onAdd(e), this.loadTileset(this.id));
      }
      buildCesiumGltfTile(t) {
        const i = t.type;
        if ('cmpt' === i) {
          const i = new e.GltfTile({
            tileID: t.id,
            modelFolder: this._source.modelFolder,
            boundingVolume: t.boundingVolume,
            minemap3DType: t.type,
            instances: t.instances || [],
            normalRight: t.normalRight || [],
            normalUp: t.normalUp || [],
            relativeCenter: t.relativeCenter || [],
            clippingPlaneCollection: this._clippingPlaneCollection,
          });
          this._cacheTile.set(t.id, i);
          const s = t.content.tiles;
          for (let r = 0; r < s.length; r++) {
            const n = s[r],
              o = new e.GltfTile({
                tileID: t.id + r,
                modelFolder: this._source.modelFolder,
                boundingVolume: t.boundingVolume,
                minemap3DType: n.type,
                instances: n.instances || [],
                normalRight: n.normalRight || [],
                normalUp: n.normalUp || [],
                relativeCenter: t.relativeCenter || [],
                clippingPlaneCollection: this._clippingPlaneCollection,
              });
            void 0 === n.cartesianModelMatrix &&
              (n.cartesianModelMatrix = t.content.cartesianModelMatrix),
              n?.content
                ? (n.content.extra = {
                    featureTable: n.featureTable,
                    batchTable: n.batchTable,
                    selectionDepth: n._selectionDepth,
                    depth: t.depth,
                    finalResolution: t._finalResolution,
                    markAsRoot: t.userData.markAsRoot,
                  })
                : (n.extra = {
                    featureTable: n.featureTable,
                    batchTable: n.batchTable,
                    selectionDepth: n._selectionDepth,
                    depth: t.depth,
                    finalResolution: t._finalResolution,
                    markAsRoot: t.userData.markAsRoot,
                  }),
              o.upload(n, this._context, this._source),
              this._cesiumTiles.push(o),
              i.childTiles.push(o);
          }
        } else {
          let s;
          (s =
            'pointcloud' === i || 'pnts' === t.content.type
              ? new dh({
                  tileID: t.id,
                  modelFolder: this._source.modelFolder,
                  boundingVolume: t.boundingVolume,
                  minemap3DType: t.content.type,
                  instances: t.instances || [],
                  normalRight: t.normalRight || [],
                  normalUp: t.normalUp || [],
                  relativeCenter: t.relativeCenter || [],
                  clippingPlaneCollection: this._clippingPlaneCollection,
                  customizedColor: this.customizedColor,
                })
              : new e.GltfTile({
                  tileID: t.id,
                  modelFolder: this._source.modelFolder,
                  boundingVolume: t.boundingVolume,
                  minemap3DType: t.content.type,
                  instances: t.instances || [],
                  normalRight: t.normalRight || [],
                  normalUp: t.normalUp || [],
                  relativeCenter: t.relativeCenter || [],
                  clippingPlaneCollection: this._clippingPlaneCollection,
                  customizedColor: this.customizedColor,
                })),
            this._cacheTile.set(t.id, s),
            t?.content &&
              (t.content.extra = {
                featureTable: t.content.featureTable,
                batchTable: t.content.batchTable,
                selectionDepth: t._selectionDepth,
                depth: t.depth,
                finalResolution: t._finalResolution,
                markAsRoot: t.userData.markAsRoot,
              }),
            s.upload(t.content, this._context, this._source),
            this._cesiumTiles.push(s);
        }
      }
      onRemove(e) {
        this._source && this._source.onRemove && this._source.onRemove(e);
      }
      loaded() {
        return (
          !!this.tileset3d &&
          this.tileset3d &&
          0 === this.tileset3d.stats.get('Tiles Loading').count
        );
      }
      getSource() {
        return this._source;
      }
      pause() {
        this._paused = !0;
      }
      resume() {
        if (!this._paused) return;
        const e = this._shouldReloadOnResume;
        (this._paused = !1),
          (this._shouldReloadOnResume = !1),
          e && this.reload(),
          this.map && this.update();
      }
      serialize() {
        return this._source.serialize();
      }
      reload() {}
      updateCacheSize(e) {}
      hasTransition() {
        return !1;
      }
      setFeatureState(e, t, i) {}
      getFeatureState(e, t) {}
      clearTiles() {
        if (((this._shouldReloadOnResume = !1), (this._paused = !1), this.tileset3d)) {
          this.tileset3d._destroyed = !0;
          for (const e in this._cacheTile._hash) this._removeTile(e);
          this.tileset3d._abortListMap.forEach((e, t) => {
            e.abort(), this.tileset3d._abortListMap.delete(t);
          });
        }
      }
      _removeTile(e) {
        const t = this._cacheTile._hash[e];
        t &&
          (t.childTiles &&
            t.childTiles.length > 0 &&
            t.childTiles.forEach((e) => {
              e.unloadVectorData();
            }),
          t.unloadVectorData(),
          this._cacheTile.remove(e));
      }
      getTilesSourceConfig(t, i = 'name') {
        if (this._geoCenters.length) {
          const { urls: s = [], url: r } = this._source._options,
            n = this.map.transform;
          r && (s.filter((e) => e.url === r).length || s.push({ name: 'custom-tiles', url: r }));
          const o = s.map((t, i) => {
            let s = e.getZoomFromDistance(
              n._fov,
              this._geoCenters[i][2] + e.CONSTS.TRANSFORM.R + 1e3,
              e.CONSTS.TRANSFORM.R,
            );
            return (
              (s = isNaN(s) ? n._maxZoom - 1 : s),
              {
                center: this._geoCenters[i],
                bounds: this._geoBounds.length ? this._geoBounds[i] : null,
                zoom: s,
                ...t,
              }
            );
          });
          return t && 'string' == typeof t ? o.filter((e) => e[i] === t) : o;
        }
      }
      _unionBoundingVolume(t) {
        const i = {
          asset: {
            version: '0.0',
            tilesetVersion: 'minemap-top-merge',
            gltfUpAxis: t[0].gltfUpAxis || 'Y',
          },
          geometricError: 1 / 0,
          root: {
            children: [],
            transform: [],
            boundingVolume: { sphere: null },
            geometricError: 1 / 0,
            refine: 'REPLACE',
          },
          tileCenters: [],
          tileBounds: [],
        };
        let s,
          r = 0;
        for (let n = 0; n < t.length; n++) {
          r = Math.max(r, t[n].geometricError);
          const o = new e.Matrix4(t[n].root.transform);
          let a, l;
          const h = Fa(t[n].root.boundingVolume, o);
          if (h.halfAxes) {
            const t = new e.OrientedBoundingBox(h.center, h.halfAxes);
            (l = t.getBoundingMaximum(3)), (a = t.getBoundingSphere());
          } else (a = h), (l = null);
          if ((0 === n ? (s = new e.BoundingSphere(a.center, a.radius)) : s.union(a), l)) {
            const t = e.Transforms.DefaultEllipsoid.cartesianToCartographic(l.boundingMaxValue),
              s = e.Transforms.DefaultEllipsoid.cartesianToCartographic(l.boundingMinValue),
              r = new e.LngLatBounds([s[0], s[1]], [t[0], t[1]]);
            i.tileBounds.push(r);
          }
          i.tileCenters.push(e.Transforms.DefaultEllipsoid.cartesianToCartographic(a.center)),
            i.root.children.push(t[n].root);
        }
        return (
          (i.root.geometricError = r),
          (i.root.boundingVolume.sphere = s),
          (i.root.id = void 0),
          (i.root.lodMetricType = t[0].root.lodMetricType),
          (i.root.lodMetricValue = r),
          (i.root.refine = void 0),
          (i.root.transform = new e.Matrix4()),
          (i.root.transformMatrix = new e.Matrix4()),
          (i.root.type = t[0].root.type),
          (i.geometricError = r),
          (i.basePath = t[0].basePath),
          (i.loader = t[0].loader),
          (i.lodMetricType = t[0].lodMetricType),
          (i.lodMetricValue = r),
          (i.type = t[0].type),
          (i.url = t[0].url),
          i
        );
      }
      getTranslucentPrimitives(t, i, s) {
        const r = [];
        if (!(i = i || e.checkIsDepthSupportDataType)(s.classificationType)) return r;
        const n = this.clippingPlanes;
        return (
          this.tilesForRender.forEach((e) => {
            e.primitives.forEach((t) => {
              t._material.isTranslucent &&
                ((t.boundingVolume = e.boundingVolume),
                (t.tileUid = e.uid),
                (t._material.clippingPlanes = n),
                fh.setLightDefines(t, s),
                r.push(t)),
                ph(t, this._source);
            });
          }),
          r
        );
      }
      static setLightDefines(t, i) {
        i && i.lightingModel === e.LightingModelType.PBR
          ? ((t._material.defines.USE_PBR = !0), (t._material.defines.USE_IBL = !0))
          : ((t._material.defines.USE_PBR = !1), (t._material.defines.USE_IBL = !1)),
          (t._material.defines.PHONG_LIGHT = i.lightingModel == e.LightingModelType.PHONG);
      }
      getOpaquePrimitives(t, i, s) {
        const r = [];
        if (!(i = i || e.checkIsDepthSupportDataType)(s.classificationType)) return r;
        const n = this.clippingPlanes;
        return (
          this.tilesForRender.forEach((e) => {
            e.primitives.forEach((t) => {
              t._material.isTranslucent ||
                ((t.boundingVolume = e.boundingVolume),
                (t.tileUid = e.uid),
                (t._material.clippingPlanes = n),
                fh.setLightDefines(t, s),
                r.push(t));
            });
          }),
          r
        );
      }
      addClippingPlanes(e) {
        this.clippingPlanes = e;
      }
      addCustomizedStyle(e) {
        this.customizedColor = e.get('point-cloud-color').value._parameters;
      }
      _shiftBoundingVolume(t, i) {
        const s = new e.Vector3(t?.tileCenters[0] || t.boundingVolume.sphere.center);
        s.z = 0;
        const r = e.Ellipsoid.WGS84.cartographicToCartesian(s, new e.Vector3()),
          n = e.Transforms.eastNorthUpToFixedFrame(r);
        let o = e.Matrix4.multiplyByVector(n, new e.Vector4(i[0], i[1], i[2], 1), new e.Vector4());
        o = new e.Vector3(o[0], o[1], o[2]);
        const a = o.subVectors(o, r),
          l = e.Matrix4.fromRotationTranslation(e.Matrix3.IDENTITY, a, new e.Matrix4());
        (t.root.transform = l), (t.root.transformMatrix = l);
        const h = new e.Vector4(t.root.boundingVolume.sphere.center);
        (h.w = 1),
          e.Matrix4.multiplyByVector(l, h, h),
          (t.root.boundingVolume.sphere.center = new e.Vector3(h[0], h[1], h[2]));
      }
    }
    const gh = 3;
    function yh(e, t) {
      for (let i = 0; i < e.length; i++) {
        const s = e[i];
        'scenegraph' == s.type
          ? ((s.userData.markAsRoot = !0), t + 1 <= gh && yh(s.children, t + 1))
          : t < gh && yh(s.children, t);
      }
    }
    (fh.maxOverzooming = 10), (fh.maxUnderzooming = 3);
    class Th extends e.Evented {
      constructor(e, t, i) {
        super(),
          (this.id = e),
          (this.dispatcher = i),
          this.on('data', (e) => {
            'cesium-tile' === e.dataType && this.transform && this.update(this.transform);
          }),
          this.on('error', () => {
            this._sourceErrored = !0;
          });
        const s = So(e, t, i, this);
        (this._source = s),
          (this._tiles = {}),
          (this._timers = {}),
          (this._cacheTimers = {}),
          (this._maxTileCacheSize = null),
          (this.idealTileIDs = []),
          (this._cesiumTiles = []),
          (this._preCesiumTiles = []),
          (this._cacheTile = new lh()),
          (this._geoCenter = []);
      }
      update(e) {
        this.transform || (this.transform = e);
      }
      _unloadTiles(e) {
        const t = this._cacheTile.get(e.id);
        t &&
          (t.childTiles.length > 0 &&
            t.childTiles.forEach((e) => {
              t.unloadVectorData();
            }),
          t.unloadVectorData(),
          this._cacheTile.remove(e.id));
      }
      prepare(e) {
        this._source.prepare && this._source.prepare(), this._context || (this._context = e);
      }
      get tilesForRender() {
        return this._cesiumTiles;
      }
      tilesIn() {
        return this._cesiumTiles;
      }
      onAdd(t) {
        (this.map = t),
          this._source &&
            this._source.onAdd &&
            this._source.onAdd(t, (t, i) => {
              if (t) throw new Error('请求出错，请检查model路径问题、跨域问题或者资源是否存在');
              this.buildCesiumGltfTile({
                content: { gltf: i, cartographicOrigin: [], type: '3d-model' },
                id: e.uniqueId(),
                instances: null,
                normalRight: null,
                normalUp: null,
                relativeCenter: null,
              }),
                this._cesiumTiles.forEach((e) => {
                  e.primitives.forEach((e) => {
                    ph(e, this._source);
                  });
                });
            });
      }
      buildCesiumGltfTile(t) {
        const i = new e.GltfTile({
          tileID: t.id,
          modelFolder: this._source.modelFolder,
          boundingVolume: t.boundingVolume,
          minemap3DType: t.content.type,
          instances: t.instances || [],
          normalRight: t.normalRight || [],
          normalUp: t.normalUp || [],
          relativeCenter: t.relativeCenter || [],
        });
        this._cacheTile.set(t.id, i),
          t?.content &&
            (t.content.extra = {
              featureTable: t.featureTable || void 0,
              batchTable: t.batchTable || void 0,
              selectionDepth: t._selectionDepth || void 0,
              depth: t.depth || 0,
              finalResolution: t._finalResolution || !1,
            }),
          i.upload(t.content, this._context, this._source),
          this._cesiumTiles.push(i),
          this.fire(new e.Event('data', { dataType: 'cesium-tile' }));
      }
      onRemove(e) {
        this._source && this._source.onRemove && this._source.onRemove(e);
      }
      loaded() {
        return (
          !!this.tileset3d &&
          this.tileset3d &&
          0 === this.tileset3d.stats.get('Tiles Loading').count
        );
      }
      getSource() {
        return this._source;
      }
      pause() {
        this._paused = !0;
      }
      resume() {
        if (!this._paused) return;
        const e = this._shouldReloadOnResume;
        (this._paused = !1),
          (this._shouldReloadOnResume = !1),
          e && this.reload(),
          this.transform && this.update(this.transform);
      }
      serialize() {
        return this._source.serialize();
      }
      reload() {}
      updateCacheSize(e) {}
      hasTransition() {
        return !1;
      }
      setFeatureState(e, t, i) {}
      getFeatureState(e, t) {}
      clearTiles() {
        (this._shouldReloadOnResume = !1), (this._paused = !1);
      }
      getLocation(e) {
        const { urls: t, url: i } = this._source._options;
        if (t) {
          const i = t.map((e, t) => ({ center: this._geoCenter[t], ...e }));
          return 'string' != typeof e ? i : i.filter((t) => t.name === e);
        }
        return [{ center: this._geoCenter[0], url: i }];
      }
      getTranslucentPrimitives(t, i, s) {
        const r = [];
        return (i = i || e.checkIsDepthSupportDataType)(s.classificationType)
          ? (this.tilesForRender.forEach((i) => {
              i.primitives.forEach((i) => {
                i._material.isTranslucent &&
                  (i.tileUid || (i.tileUid = `3d-model${this._source.id}${Math.random()}`),
                  t
                    ? t.computeVisibility(i.boundingVolume) !== e.INTERSECTION.OUTSIDE && r.push(i)
                    : r.push(i));
              });
            }),
            r)
          : r;
      }
      getOpaquePrimitives(t, i, s) {
        const r = [];
        return (i = i || e.checkIsDepthSupportDataType)(s.classificationType)
          ? (this.tilesForRender.forEach((i) => {
              i.primitives.forEach((i) => {
                i._material.isTranslucent ||
                  (i.tileUid || (i.tileUid = `3d-model${this._source.id}${Math.random()}`),
                  t
                    ? t.computeVisibility(i.boundingVolume) !== e.INTERSECTION.OUTSIDE && r.push(i)
                    : r.push(i));
              });
            }),
            r)
          : r;
      }
    }
    (Th.maxOverzooming = 10), (Th.maxUnderzooming = 3);
    class xh extends e.Evented {
      constructor(e, t, i) {
        super(),
          (this.id = e),
          (this.dispatcher = i),
          this.on('data', (e) => {
            'source' === e.dataType && 'metadata' === e.sourceDataType && (this._sourceLoaded = !0),
              this._sourceLoaded &&
                !this._paused &&
                'source' === e.dataType &&
                'content' === e.sourceDataType &&
                (this.reload(), this.map.transform && this.update(this.map.transform));
          }),
          this.on('error', () => {
            this._sourceErrored = !0;
          });
        const s = So(e, t, i, this);
        (this._source = s),
          (this._tiles = {}),
          (this._cache = new oo(0, this._unloadTile.bind(this))),
          (this._timers = {}),
          (this._cacheTimers = {}),
          (this._maxTileCacheSize = null),
          (this._isIdRenderable = this._isIdRenderable.bind(this)),
          (this._coveredTiles = {}),
          (this._state = new Ln()),
          (this.sourceType = t.type),
          (this._loadedParentTiles = {});
      }
      onAdd(e) {
        (this.map = e),
          (this._maxTileCacheSize = e ? e._maxTileCacheSize : null),
          this._source && this._source.onAdd && this._source.onAdd(e);
      }
      onRemove(e) {
        this._source && this._source.onRemove && this._source.onRemove(e);
      }
      loaded() {
        if (this._sourceErrored) return !0;
        if (!this._sourceLoaded) return !1;
        for (const e in this._tiles) {
          const t = this._tiles[e];
          if ('loaded' !== t.state && 'errored' !== t.state) return !1;
        }
        return !0;
      }
      getSource() {
        return this._source;
      }
      pause() {
        this._paused = !0;
      }
      resume() {
        if (!this._paused) return;
        const e = this._shouldReloadOnResume;
        (this._paused = !1),
          (this._shouldReloadOnResume = !1),
          e && this.reload(),
          this.map && this.update();
      }
      _loadTile(e, t) {
        return t();
      }
      _unloadTile(e) {
        e.unloadVectorData();
      }
      _abortTile(e) {
        if (this._source.abortTile) return this._source.abortTile(e, () => {});
      }
      serialize() {
        return this._source.serialize();
      }
      prepare(e) {
        this._source.prepare && this._source.prepare(),
          this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
        for (const t in this._tiles)
          this._tiles[t].upload(e),
            this._tiles[t].prepare(this.map.style.imageManager, this.map.style.terrainSourceCache);
      }
      getIds() {
        return Object.keys(this._tiles)
          .map(String)
          .sort((e, t) => this._tiles[e].tileID.overscaledZ - this._tiles[t].tileID.overscaledZ);
      }
      getRenderableIds() {
        return this.getIds().filter(this._isIdRenderable);
      }
      hasRenderableParent(e) {
        const t = this.findLoadedParent(e, 0);
        return !!t && this._isIdRenderable(t.tileID.key);
      }
      _isIdRenderable(e) {
        return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e];
      }
      reload(e) {
        if (this._paused) this._shouldReloadOnResume = !0;
        else if ((this._cache.reset(), e))
          for (const e in this._tiles)
            'errored' !== this._tiles[e].state && this._reloadTile(e, 'expired');
        else
          for (const e in this._tiles)
            'errored' !== this._tiles[e].state && this._reloadTile(e, 'reloading');
      }
      _reloadTile(e, t) {
        const i = this._tiles[e];
        i &&
          ('loading' !== i.state && (i.state = t),
          this._loadTile(i, this._tileLoaded.bind(this, i, e, t)));
      }
      _tileLoaded(t, i, s, r) {
        (t.state = 'loading'),
          (t.timeAdded = e.exported.now()),
          'expired' === s && (t.refreshedUponExpiration = !0),
          this._setTileReloadTimer(i, t),
          this._source.fire(new e.Event('data', { dataType: 'source', tile: t, coord: t.tileID }));
      }
      getTile(e) {
        return this.getTileByID(e.key);
      }
      getTileByID(e) {
        return this._tiles[e];
      }
      getZoom(e) {
        return (
          this.map.style.getNearestTileZoom() + e.scaleZoom(e.tileSize / this._source.tileSize)
        );
      }
      _retainLoadedChildren(e, t, i, s) {
        for (const r in this._tiles) {
          let n = this._tiles[r];
          if (s[r] || !n.hasData() || n.tileID.overscaledZ <= t || n.tileID.overscaledZ > i)
            continue;
          let o = n.tileID;
          for (; n && n.tileID.overscaledZ > t + 1; ) {
            const e = n.tileID.scaledTo(n.tileID.overscaledZ - 1);
            (n = this._tiles[e.key]), n && n.hasData() && (o = e);
          }
          let a = o;
          for (; a.overscaledZ > t; )
            if (((a = a.scaledTo(a.overscaledZ - 1)), e[a.key])) {
              s[o.key] = o;
              break;
            }
        }
      }
      findLoadedParent(e, t) {
        if (e.key in this._loadedParentTiles) {
          const i = this._loadedParentTiles[e.key];
          return i && i.tileID.overscaledZ >= t ? i : null;
        }
        for (let i = e.overscaledZ - 1; i >= t; i--) {
          const t = e.scaledTo(i),
            s = this._getLoadedTile(t);
          if (s) return s;
        }
      }
      updateCacheSize() {
        this._cache.setMaxSize(2 * this.quadtree?.getOverscaledTileIDs().length || 64);
      }
      createQuadtree() {
        if (e.defined(this.quadtree)) return;
        const t = this.map.style.terrainSourceCache.isTerrain();
        this.quadtree = ho({
          isLngLat: this.map.transform.projection === e.ProjectionType.LATLON,
          tileSize: 512,
          hasTerrainLayerFlag: t,
          drawingBufferHeight: this.map.painter.context.gl.drawingBufferHeight,
          spaceErrorScale: this.map.spaceErrorScale,
          tileMinZoom: 0,
          tileMaxZoom: 17,
          type: this.sourceType,
        });
      }
      coveringTiles() {
        return (
          this.createQuadtree(),
          this.quadtree.tilesIn(this.map.transform.activeCamera),
          this.quadtree.getOverscaledTileIDs()
        );
      }
      update() {
        this.updateCacheSize(), (this._coveredTiles = {});
        const t = this.coveringTiles(),
          i = this._updateRetainedTiles(t),
          s = e.keysDifference(this._tiles, i);
        for (let e = 0; e < s.length; e++) this._removeTile(s[e]);
        this._updateLoadedParentTileCache();
      }
      _updateLoadedParentTileCache() {
        this._loadedParentTiles = {};
        for (const e in this._tiles) {
          const t = [];
          let i,
            s = this._tiles[e].tileID;
          for (; s.overscaledZ > 0; ) {
            if (s.key in this._loadedParentTiles) {
              i = this._loadedParentTiles[s.key];
              break;
            }
            t.push(s.key);
            const e = s.scaledTo(s.overscaledZ - 1);
            if (((i = this._getLoadedTile(e)), i)) break;
            s = e;
          }
          for (const e of t) this._loadedParentTiles[e] = i;
        }
      }
      _getLoadedTile(e) {
        const t = this._tiles[e.key];
        return t && t.hasData()
          ? t
          : this._cache.getByKey(
              this._source.reparseOverscaled ? e.wrapped().key : e.canonical.key,
            );
      }
      _updateRetainedTiles(e) {
        const t = {};
        if (0 === e.length) return t;
        const i = {},
          s = e.reduce((e, t) => Math.min(e, t.overscaledZ), 1 / 0),
          r = e[0].overscaledZ,
          n = Math.max(r - xh.maxOverzooming, this._source.minzoom),
          o = Math.max(r + xh.maxUnderzooming, this._source.minzoom),
          a = {};
        for (const i of e) {
          const e = this._addTile(i);
          (t[i.key] = i), e.hasData() || (s < this._source.maxzoom && (a[i.key] = i));
        }
        this._retainLoadedChildren(a, s, o, t);
        for (const s of e) {
          let e = this._tiles[s.key];
          if (e.hasData()) continue;
          if (s.canonical.z >= this._source.maxzoom) {
            const e = s.children(this._source.maxzoom)[0],
              i = this.getTile(e);
            if (i && i.hasData()) {
              t[e.key] = e;
              continue;
            }
          } else {
            const e = s.children(this._source.maxzoom);
            if (t[e[0].key] && t[e[1].key] && t[e[2].key] && t[e[3].key]) continue;
          }
          let r = e.wasRequested();
          for (let o = s.overscaledZ - 1; o >= n; --o) {
            const n = s.scaledTo(o);
            if (i[n.key]) break;
            if (
              ((i[n.key] = !0),
              (e = this.getTile(n)),
              !e && r && (e = this._addTile(n)),
              e && ((t[n.key] = n), (r = e.wasRequested()), e.hasData()))
            )
              break;
          }
        }
        return t;
      }
      _addTile(t) {
        let i = this._tiles[t.key];
        if (i) return (i.tileID = t), i;
        (i = this._cache.getAndRemove(t)),
          i &&
            (this._setTileReloadTimer(t.key, i),
            (i.tileID = t),
            this._state.initializeTileState(i, this.map ? this.map.painter : null),
            this._cacheTimers[t.key] &&
              (clearTimeout(this._cacheTimers[t.key]),
              delete this._cacheTimers[t.key],
              this._setTileReloadTimer(t.key, i)));
        const s = Boolean(i);
        return (
          s ||
            ((i = new no({
              tileID: t,
              tileSize: 512 * t.overscaleFactor(),
              projType: this.map.projection,
              tilePrimitiveType: 'background',
              sourceId: this._source.id,
              style: this.map.style,
            })),
            this._loadTile(i, this._tileLoaded.bind(this, i, t.key, i.state))),
          i
            ? (i.uses++,
              (this._tiles[t.key] = i),
              s ||
                this._source.fire(
                  new e.Event('dataloading', { tile: i, coord: i.tileID, dataType: 'source' }),
                ),
              i)
            : null
        );
      }
      _setTileReloadTimer(e, t) {
        e in this._timers && (clearTimeout(this._timers[e]), delete this._timers[e]);
        const i = t.getExpiryTimeout();
        i &&
          (this._timers[e] = setTimeout(() => {
            this._reloadTile(e, 'expired'), delete this._timers[e];
          }, i));
      }
      _removeTile(e) {
        const t = this._tiles[e];
        t &&
          (t.uses--,
          delete this._tiles[e],
          this._timers[e] && (clearTimeout(this._timers[e]), delete this._timers[e]),
          t.uses > 0 ||
            (t.hasData()
              ? this._cache.add(t.tileID, t, t.getExpiryTimeout())
              : ((t.aborted = !0), this._abortTile(t), this._unloadTile(t))));
      }
      clearTiles() {
        (this._shouldReloadOnResume = !1), (this._paused = !1);
        for (const e in this._tiles) this._removeTile(e);
        this._cache && this._cache.reset(),
          this._source.unloadGPUData && this._source.unloadGPUData();
      }
      tilesIn(t, i, s) {
        const r = [],
          n = this.map.transform;
        if (!n) return r;
        const o = s ? n.getCameraQueryGeometry(t) : t,
          a = t.map((e) => n.pointCoordinate(e)).filter((e) => e),
          l = o.map((e) => n.pointCoordinate(e)).filter((e) => e);
        if (0 == a.length) return [];
        const h = this.getIds();
        let c = 1 / 0,
          _ = 1 / 0,
          u = -1 / 0,
          d = -1 / 0;
        const m = a[0].zoom;
        for (const e of l)
          (c = Math.min(c, e.column)),
            (_ = Math.min(_, e.row)),
            (u = Math.max(u, e.column)),
            (d = Math.max(d, e.row));
        for (let t = 0; t < h.length; t++) {
          const s = this._tiles[h[t]],
            n = s.tileID,
            o = Math.pow(2, this.map.style.getNearestTileZoom() - s.tileID.overscaledZ),
            p = (i * s.queryPadding * e.EXTENT) / s.tileSize / o,
            f = [vh(n, new e.Coordinate(c, _, m)), vh(n, new e.Coordinate(u, d, m))];
          if (
            f[0].x - p < e.EXTENT &&
            f[0].y - p < e.EXTENT &&
            f[1].x + p >= 0 &&
            f[1].y + p >= 0
          ) {
            const t = a.map((t) => {
                const i = t.zoomTo(n.canonical.z);
                return n.getTilePoint(new e.pointGeometry3d(i.column, i.row));
              }),
              i = l.map((t) => {
                const i = t.zoomTo(n.canonical.z);
                return n.getTilePoint(new e.pointGeometry3d(i.column, i.row));
              });
            r.push({ tile: s, tileID: n, queryGeometry: t, cameraQueryGeometry: i, scale: o });
          }
        }
        return r;
      }
      getVisibleCoordinates() {
        return this.getRenderableIds().map((e) => this._tiles[e].tileID);
      }
      hasTransition() {
        return !1;
      }
      setFeatureState(e, t, i) {
        this._state.updateState((e = e || '_geojsonTileLayer'), t, i);
      }
      removeFeatureState(e, t, i) {
        this._state.removeFeatureState((e = e || '_geojsonTileLayer'), t, i);
      }
      getFeatureState(e, t) {
        return this._state.getState((e = e || '_geojsonTileLayer'), t);
      }
      setDependencies(e, t, i) {
        const s = this._tiles[e];
        s && s.setDependencies(t, i);
      }
      reloadTilesForDependencies(e, t) {
        for (const i in this._tiles)
          this._tiles[i].hasDependency(e, t) && this._reloadTile(i, 'reloading');
        this._cache.filter((i) => !i.hasDependency(e, t));
      }
      resetQuadtree() {
        this.quadtree?.destroy(), delete this.quadtree, this.clearTiles(), this.map._update();
      }
    }
    function vh(t, i) {
      const s = i.zoomTo(t.canonical.z);
      return new e.pointGeometry3d(
        (s.column - (t.canonical.x + t.wrap * Math.pow(2, t.canonical.z))) * e.EXTENT,
        (s.row - t.canonical.y) * e.EXTENT,
      );
    }
    (xh.maxOverzooming = 10), (xh.maxUnderzooming = 3);
    const bh = function (e, t, i) {
      return '3d-tiles' === t.type
        ? new fh(e, t, i)
        : '3d-model' === t.type
        ? new Th(e, t, i)
        : 'terrain' === t.type
        ? new wo(e, t, i)
        : 'background' === t.type
        ? new xh(e, t, i)
        : new ao(e, t, i);
    };
    class wh {
      constructor(t) {
        (this.options = t || {}),
          (this.requestPerformanceManager = new e.RequestPerformanceManger({})),
          (this.updateSourceCaches = []);
      }
      prepare() {
        const e = this.options.style;
        (this.savedZoom = this.options.style.getNearestTileZoom()), (this.updateSourceCaches = []);
        let t = [];
        for (const i in e.sourceCaches) {
          const s = e.sourceCaches[i],
            r = s._source;
          0 === this.updateSourceCaches.length ? t.push(s) : (t = []),
            r.priorityRequest && this.updateSourceCaches.push(s);
        }
        0 === this.updateSourceCaches.length && (this.updateSourceCaches = t);
      }
      run() {
        this._updateLoop();
      }
      beforeStop() {
        const e = this.options.style;
        this.updateSourceCaches = [];
        for (const t in e.sourceCaches) this.updateSourceCaches.push(e.sourceCaches[t]);
      }
      _updateLoop() {
        this.options.style.terrainSourceCache.update(),
          this.options.style.backgroundSourceCache.update();
        for (const e of this.updateSourceCaches) e.update();
      }
      stop() {
        this._updateLoop();
      }
      clearUpdateSourceCaches() {
        this.updateSourceCaches = [];
      }
    }
    class Ch {
      constructor(t) {
        (this._style = t),
          (this.status = 3),
          (this.resourcePerformaceManager = new wh({
            style: this._style,
            mode: e.CONSTS.PERFORMANCE.MODE.MANUAL,
          })),
          (this.previousTime = Date.now());
      }
      startAction() {
        0 !== Object.keys(this._style.sourceCaches).length &&
          (2 !== this.status
            ? ((this.status = 1),
              this.resourcePerformaceManager.prepare(),
              (this.previousTime = Date.now()),
              this.animateAction())
            : ((this.previousTime = Date.now()), this.animateAction()));
      }
      animateAction() {
        (this.status = 2), this.resourcePerformaceManager.run();
      }
      isStopped() {
        return 3 === this.status;
      }
      stopAction() {
        (this.status = 3),
          this.resourcePerformaceManager.beforeStop(),
          this.resourcePerformaceManager.stop();
      }
    }
    class Sh {
      constructor() {
        (this._data = new Map()), (this._orders = []);
      }
      add(e) {}
      get(e) {
        return this._data.get(e);
      }
      getAll() {
        const e = [];
        for (let t = 0; t < this._orders.length; t++) {
          const i = this.get(this._orders[t]);
          e.push(i);
        }
        return e;
      }
      has(e) {
        return this._data.has(e);
      }
      sort(e) {
        this._orders.sort(e);
      }
      remove(e, t) {
        if (this.has(e)) {
          if (t) {
            const t = this.get(e);
            t.destroy && t._loaded && t.destroy();
          }
          this._data.delete(e);
          const i = this._orders.indexOf(e);
          this._orders.splice(i, 1);
        }
      }
      removeAll(e) {
        for (; this._orders.length > 0; ) this.remove(this._orders[0], e);
      }
      getIgnoreClassificationPrimitiveObject(t) {
        return {
          opaque: this.getOpaquePrimitives(t, e.checkIsIgnoreClassificationDataType),
          translucent: this.getTranslucentPrimitives(t, e.checkIsIgnoreClassificationDataType),
        };
      }
      getTranslucentPrimitives() {}
      getOpaquePrimitives() {}
      getIndependentPrimitiveObject(t) {
        return {
          opaque: this.getOpaquePrimitives(t, e.checkIsDepthSupportDataType),
          translucent: this.getTranslucentPrimitives(t, e.checkIsDepthSupportDataType),
        };
      }
      getClassificationPrimitiveObject(t) {
        return {
          opaque: this.getOpaquePrimitives(t, e.checkIsVectorShadowVolumeDataType),
          translucent: this.getTranslucentPrimitives(t, e.checkIsVectorShadowVolumeDataType),
        };
      }
      get keys() {
        return this._orders;
      }
      get size() {
        return this._data.size;
      }
      loaded() {
        return !0;
      }
    }
    Sh.RENDER_TYPE = { OPAQUE_TYPE: 'OPAQUE_TYPE', TRANSLUCENT_TYPE: 'TRANSLUCENT_TYPE' };
    class Eh extends Sh {
      constructor(e) {
        super(), (this.type = e.type);
      }
      add(e) {
        if (this.has(e.id))
          throw new Error(`There is already a sceneComponent with this ID: ${e.id}`);
        return this._orders.push(e.id), this._data.set(e.id, e), e;
      }
      getTranslucentPrimitives(t, i) {
        i = i || e.checkIsDepthSupportDataType;
        let s = [];
        for (let r = 0; r < this._orders.length; r++) {
          const n = this.get(this._orders[r]);
          if (i(n.classificationType))
            if (n instanceof mh) s = s.concat(n._translucentList);
            else if (t)
              if (e.defined(n.modelInstanceCollection))
                t.computeVisibility(n.modelInstanceCollection.boundingVolume) !==
                  e.INTERSECTION.OUTSIDE && (s = s.concat(n.translucentList));
              else
                for (let i = 0; i < n.translucentList.length; i++) {
                  const r = n.translucentList[i];
                  t.computeVisibility(r.boundingVolume) !== e.INTERSECTION.OUTSIDE && s.push(r);
                }
            else s = s.concat(n.translucentList);
        }
        return s;
      }
      getOpaquePrimitives(t, i) {
        i = i || e.checkIsDepthSupportDataType;
        let s = [];
        for (let r = 0; r < this._orders.length; r++) {
          const n = this.get(this._orders[r]);
          if (i(n.classificationType))
            if (n instanceof mh) s = s.concat(n._opaqueList);
            else if (t)
              if (e.defined(n.modelInstanceCollection))
                t.computeVisibility(n.modelInstanceCollection.boundingVolume) !==
                  e.INTERSECTION.OUTSIDE && (s = s.concat(n.opaqueList));
              else
                for (let i = 0; i < n.opaqueList.length; i++) {
                  const r = n.opaqueList[i];
                  t.computeVisibility(r.boundingVolume) !== e.INTERSECTION.OUTSIDE && s.push(r);
                }
            else s = s.concat(n.opaqueList);
        }
        return s;
      }
      update(e) {
        for (let t = 0; t < this._orders.length; t++) this.get(this._orders[t]).update(e);
      }
      serialize() {
        if ('3d-model' === this.type || '3d-model-instance' === this.type) {
          const t = [];
          return (
            this._data.forEach((i) => {
              const s = {
                id: i.id,
                data: i._data,
                modelFolder: i.modelFolder,
                backCulling: i.backCulling,
                lightingModel: i.lightingModel,
                activeAnimation: i.activeAnimation,
                classificationType: i.classificationType,
              };
              if (e.defined(i.modelInstanceCollection)) {
                s.type = '3d-model-instance';
                const t = [],
                  r = [],
                  n = [],
                  o = [],
                  a = [],
                  l = [];
                i.modelInstanceCollection._instances.forEach((i) => {
                  const s = e.Cartographic.fromVector3(i.position);
                  (s.x *= e.CONSTS.CesiumMath.DEGREES_PER_RADIAN),
                    (s.y *= e.CONSTS.CesiumMath.DEGREES_PER_RADIAN),
                    t.push([s.x, s.y, s.z]),
                    r.push({
                      heading: i.rotation.heading,
                      pitch: i.rotation.pitch,
                      roll: i.rotation.roll,
                    }),
                    n.push(e.Vector3.pack(i.scale, new Array(3))),
                    o.push(i.instanceName),
                    a.push(e.Color.pack(i.color, new Array(4))),
                    l.push(i.show);
                }),
                  (s.positions = t),
                  (s.rotations = r),
                  (s.scales = n),
                  (s.instanceNames = o),
                  (s.colors = a),
                  (s.shows = l);
              } else
                (s.type = '3d-model'),
                  e.defined(i._options.scale) && (s.scale = i._options.scale),
                  e.defined(i._options.position) && (s.position = i._options.position),
                  (s.rotation = i._rotation);
              e.defined(i.clippingPlanes) && (s.clippingPlanes = i.clippingPlanes.serialize()),
                t.push(s);
            }),
            t.length > 0 ? t : void 0
          );
        }
        if ('3d-tiles' === this.type) {
          const t = [];
          return (
            this._data.forEach((i) => {
              const s = {
                id: i.id,
                type: '3d-tiles',
                show: i.show,
                translation: e.defined(i.translation)
                  ? e.Vector3.pack(i.translation, new Array(3))
                  : void 0,
                skipLevelOfDetail: i.skipLevelOfDetail,
                maximumScreenSpaceError: i._maximumScreenSpaceError,
                useMipmap: i.useMipmap,
                allowPick: i.allowPick,
                lightingModel: i.lightingModel,
                geoBoundsOptions: i._geoBoundsOptions,
                clippingPlanes: e.defined(i.clippingPlanes) ? i.clippingPlanes.serialize() : void 0,
                backCulling: i.backCulling,
                classificationType: i.classificationType,
              };
              e.defined(i._url) && (s.url = i._url),
                i._urls.length > 0 && (s.urls = i._urls),
                e.defined(i.clippingPlanes) && (s.clippingPlanes = i.clippingPlanes.serialize()),
                t.push(s);
            }),
            t.length > 0 ? t : void 0
          );
        }
      }
      loaded() {
        for (let e = 0; e < this._orders.length; e++)
          if (!this._data.get(this._orders[e]).loaded()) return !1;
        return !0;
      }
      destroy() {
        return this.removeAll(!0), e.destroyObject(this);
      }
    }
    class Ph extends Sh {
      constructor() {
        super();
      }
      add(e) {
        if (this.has(e.id))
          throw new Error(`There is already a sceneComponent with this ID: ${e.id}`);
        this._data.set(e.id, e), this._orders.push(e.id);
      }
      getTranslucentPrimitives(t, i) {
        let s = [];
        i = i || e.checkIsDepthSupportDataType;
        for (let e = 0; e < this._orders.length; e++) {
          const t = this.get(this._orders[e]);
          i(t.classificationType) && (s = s.concat(t.getTranslucentPrimitives()));
        }
        return s;
      }
      getOpaquePrimitives(t, i) {
        let s = [];
        i = i || e.checkIsDepthSupportDataType;
        for (let e = 0; e < this._orders.length; e++) {
          const t = this.get(this._orders[e]);
          i(t.classificationType) && (s = s.concat(t.getOpaquePrimitives()));
        }
        return s;
      }
      update(e) {
        this._data.forEach((t) => {
          t.update(e);
        });
      }
      destroy() {
        return this.removeAll(!0), e.destroyObject(this);
      }
    }
    class Mh extends Sh {
      constructor() {
        super(), (this._data = new Map());
      }
      add(e) {
        if (this.has(e.id))
          throw new Error(`There is already a sceneComponent with this ID: ${e.id}`);
        this._data.set(e.id, e), this._orders.push(e.id);
      }
      getTranslucentPrimitives(t, i) {
        i = i || e.checkIsDepthSupportDataType;
        const s = [];
        for (let r = 0; r < this._orders.length; r++) {
          const n = this.get(this._orders[r]);
          i(n.classificationType) &&
            n._material.isTranslucent &&
            (!t ||
              !n.boundingVolume ||
              (t && t.computeVisibility(n.boundingVolume) !== e.INTERSECTION.OUTSIDE)) &&
            s.push(n);
        }
        return s;
      }
      getOpaquePrimitives(t, i) {
        const s = [];
        i = i || e.checkIsDepthSupportDataType;
        for (let r = 0; r < this._orders.length; r++) {
          const n = this.get(this._orders[r]);
          i(n.classificationType) &&
            (n._material.isTranslucent ||
              ((!t ||
                !n.boundingVolume ||
                (t && t.computeVisibility(n.boundingVolume) !== e.INTERSECTION.OUTSIDE)) &&
                s.push(n)));
        }
        return s;
      }
      update(e) {
        for (let t = 0; t < this._orders.length; t++) {
          const i = this.get(this._orders[t]);
          i.updateAnimation && i.updateAnimation(e);
        }
      }
      serialize() {
        const t = [];
        return (
          this._data.forEach((i) => {
            const s = i.serialize();
            e.defined(s) && t.push(s);
          }),
          t.length > 0 ? t : void 0
        );
      }
      destroy() {
        return this.removeAll(!0), e.destroyObject(this);
      }
    }
    class Ah extends e.Geometry {
      constructor(e) {
        super(e), (this.type = 'SkyBoxGeometry'), this.parse(e);
      }
      parse({ context: t }) {
        (this._vertexArray = new e.StructArrayLayout3f12()),
          (this._indices = new e.StructArrayLayout3ui6());
        const i = [
          -1, -1, 1, 1, -1, 1, -1, 1, 1, 1, 1, 1, -1, -1, -1, 1, -1, -1, -1, 1, -1, 1, 1, -1,
        ];
        for (let e = 0; e < i.length; e += 3)
          this._vertexArray.emplaceBack(i[e], i[e + 1], i[e + 2]);
        const s = [
          5, 1, 3, 3, 7, 5, 6, 2, 0, 0, 4, 6, 2, 6, 7, 7, 3, 2, 5, 4, 0, 0, 1, 5, 0, 2, 3, 3, 1, 0,
          7, 6, 4, 4, 5, 7,
        ];
        for (let e = 0; e < s.length; e += 3) this._indices.emplaceBack(s[e], s[e + 1], s[e + 2]);
        (this._vertBuffer = t.createVertexBuffer(this._vertexArray, pn.members, !1)),
          (this._indexBuffer = t.createIndexBuffer(this._indices, !1)),
          (this._segmentVector = e.SegmentVector.simpleSegment(0, 0, 36, 12)),
          (this.primitiveType = e.WebGLConstants.TRIANGLES);
      }
      destroy() {
        super.destroy(), (this.type = void 0);
      }
    }
    class Rh {
      constructor(t) {
        (this.context = t.context),
          (this.pixelFormat = t.pixelFormat),
          (this.texture = this.context.gl.createTexture()),
          (this._powerOfTwoCalculated = !1),
          (this.powerOfTwoNoneSquareFlag = !1),
          (this.flipY = !(!t || !t.flipY)),
          (this._target = t.target || e.WebGLConstants.TEXTURE_CUBE_MAP),
          (this._fboTextureParameter = t.fboTextureParameter),
          t.texture ? (this.texture = t.texture) : this.update(t);
      }
      update(t) {
        const { images: i } = t,
          { context: s } = this,
          { gl: r } = s;
        s.pixelStoreUnpackFlipY.set(this.flipY),
          s.pixelStoreUnpack.set(1),
          s.pixelStoreUnpackPremultiplyAlpha.set(!(!t || !t.premultiply)),
          r.bindTexture(this._target, this.texture);
        const n = e.CONSTS.SOURCE.TEXTURE_CUBE_KEYS;
        for (let t = 0; t < 6; t++)
          void 0 === i && this._fboTextureParameter
            ? r.texImage2D(
                e.WebGLConstants.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                0,
                e.WebGLConstants.RGBA,
                this._fboTextureParameter.width,
                this._fboTextureParameter.height,
                0,
                e.WebGLConstants.RGBA,
                e.WebGLConstants.UNSIGNED_BYTE,
                null,
              )
            : r.texImage2D(
                e.WebGLConstants.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                0,
                e.WebGLConstants.RGBA,
                e.WebGLConstants.RGBA,
                e.WebGLConstants.UNSIGNED_BYTE,
                i[n[t]],
              );
        r.texParameteri(this._target, e.WebGLConstants.TEXTURE_MAG_FILTER, e.WebGLConstants.LINEAR),
          r.texParameteri(
            this._target,
            e.WebGLConstants.TEXTURE_MIN_FILTER,
            e.WebGLConstants.LINEAR,
          ),
          r.texParameteri(
            this._target,
            e.WebGLConstants.TEXTURE_WRAP_S,
            e.WebGLConstants.CLAMP_TO_EDGE,
          ),
          r.texParameteri(
            this._target,
            e.WebGLConstants.TEXTURE_WRAP_T,
            e.WebGLConstants.CLAMP_TO_EDGE,
          ),
          r.bindTexture(this._target, null);
      }
      bind(t) {
        const { context: i } = this,
          { gl: s } = i;
        s.bindTexture(this._target, this.texture),
          s.texParameteri(
            this._target,
            e.WebGLConstants.TEXTURE_MAG_FILTER,
            e.WebGLConstants.LINEAR,
          ),
          s.texParameteri(
            this._target,
            e.WebGLConstants.TEXTURE_MIN_FILTER,
            e.WebGLConstants.LINEAR,
          ),
          s.texParameteri(
            this._target,
            e.WebGLConstants.TEXTURE_WRAP_S,
            e.WebGLConstants.CLAMP_TO_EDGE,
          ),
          s.texParameteri(
            this._target,
            e.WebGLConstants.TEXTURE_WRAP_T,
            e.WebGLConstants.CLAMP_TO_EDGE,
          ),
          t || s.bindTexture(this._target, null);
      }
      destroy() {
        if (!this.context) return;
        const { gl: e } = this.context;
        e.deleteTexture(this.texture), (this.texture = null), (this.context = null);
      }
    }
    class Ih extends e.Material {
      constructor(e) {
        super(e),
          (this._opacity = 1),
          (this._fboTextureCube = void 0),
          (this._renderState = this.createRenderState()),
          this.createUniforms(),
          (this._transformValues = {});
      }
      createRenderState() {
        const t = {};
        return (
          (t.depthTest = e.renderStateEnum.disableDepthTest),
          (t.depthMask = e.renderStateEnum.disableDepthMask),
          (t.stencilTest = e.renderStateEnum.disableStencilTest),
          t
        );
      }
      buildDefines() {
        const t = {
          HAS_STARRY_SKY_MAP: e.defined(this.starrySkyTexture),
          HAS_DAY_MAP: e.defined(this.dayTexture),
        };
        this.defines = t;
      }
      update(t, i, s = {}) {
        let r;
        super.update(t, i, s),
          (this._transformValues = {
            _fov: t.transform._fov,
            aspect: t.width / t.height,
            width: t.width,
            height: t.height,
            pitch: t.transform.getMapViewParams().pitch * e.CONSTS.TRANSFORM.DEG_TO_RAD,
            heading: -t.transform.hpr.heading,
            lng: t.transform.getMapViewParams().center.lng,
          }),
          (r =
            null == t.frameState.sunLight
              ? 12
              : new Date(t.frameState.sunLight.timestamp).getHours()),
          this.updateOpacity(t.style.getNearestTileZoom(), r),
          this._uniforms.set('u_matrixSkyBox', () => {
            const i = new e.Vector3(),
              s = new e.Matrix4().scale([1, -1, 1]),
              r = this._transformValues.pitch,
              n = -this._transformValues.heading;
            s.rotateX(r).rotateZ(n + this._transformValues.lng * (Math.PI / 180));
            const o = new e.Matrix4([0]).perspective({
                fov: this._transformValues._fov,
                aspect: this._transformValues.aspect,
                near: 1,
                far: 100,
              }),
              a =
                (Math.PI / 2 - r) *
                (this._transformValues.height / this._transformValues._fov) *
                0.1;
            (o[8] = (2 * -i.x) / this._transformValues.width),
              (o[9] = (2 * (i.y + a)) / this._transformValues.height);
            let l = new e.Matrix4();
            return (
              null != t.frameState.sunLight &&
                (l = e.Transforms.computeTemeToPseudoFixedMatrix(
                  new Date(t.frameState.sunLight.timestamp),
                )),
              e.Matrix4.multiply(new e.Matrix4(), s.multiplyLeft(o), l)
            );
          });
      }
      upload() {
        this._program && this._program._setUniforms(this._uniforms);
      }
      updateOpacity(t, i) {
        const s = [0, 0.3, 1],
          r = [0, 5, 15],
          n = e.smoothstep(7, 8, t);
        this._opacity =
          (function () {
            const i = r.length;
            if (t <= r[0]) return s[0];
            if (t >= r[i - 1]) return s[i - 1];
            const n = e.findStopLessThanOrEqualTo(r, t),
              o = e.Interpolate.interpolationFactor({ name: 'linear' }, t, r[n], r[n + 1]);
            return e.number(s[n], s[n + 1], o);
          })() *
          n *
          (function (e) {
            return e > 6 && e < 18 ? 1 : 0.02;
          })(i);
      }
      createUniforms() {
        this._uniforms.set('u_cubemap', () => this._fboTextureCube),
          this._uniforms.set('u_dayTextureMap', () => this.dayTexture),
          this._uniforms.set('u_starrySkyTextureMap', () => this.starrySkyTexture),
          this._uniforms.set('u_Opacity', () => this._opacity);
      }
      destroy() {}
    }
    class Oh extends e.Material {
      constructor(e) {
        super(e), (this._renderState = this.createRenderState()), this.createUniforms();
      }
      createRenderState() {
        const t = {};
        return (
          (t.depthTest = e.renderStateEnum.disableDepthTest),
          (t.stencilTest = e.renderStateEnum.disableStencilTest),
          (t.blending = e.renderStateEnum.disableBlending),
          t
        );
      }
      setMatrixByFaces(t) {
        switch (((this._faceRotate = new e.Matrix4()), t)) {
          case e.CONSTS.SOURCE.TEXTURE_CUBE_KEYS[0]:
            this._faceRotate.identity(), this._faceRotate.rotateY(0.5 * -Math.PI);
            break;
          case e.CONSTS.SOURCE.TEXTURE_CUBE_KEYS[1]:
            this._faceRotate.identity(), this._faceRotate.rotateY(0.5 * Math.PI);
            break;
          case e.CONSTS.SOURCE.TEXTURE_CUBE_KEYS[2]:
            this._faceRotate.identity(), this._faceRotate.rotateX(0.5 * -Math.PI);
            break;
          case e.CONSTS.SOURCE.TEXTURE_CUBE_KEYS[3]:
            this._faceRotate.identity(), this._faceRotate.rotateX(0.5 * Math.PI);
            break;
          case e.CONSTS.SOURCE.TEXTURE_CUBE_KEYS[4]:
            this._faceRotate.identity();
            break;
          case e.CONSTS.SOURCE.TEXTURE_CUBE_KEYS[5]:
            this._faceRotate.identity(), this._faceRotate.rotateY(Math.PI);
        }
      }
      update(e, t, i = {}) {
        super.update(e, t, i);
      }
      createUniforms() {
        this._uniforms.set('u_matrix_3f', () => {
          const t = new e.Matrix3();
          return (
            t.set(
              this._faceRotate[0],
              this._faceRotate[1],
              this._faceRotate[2],
              this._faceRotate[4],
              this._faceRotate[5],
              this._faceRotate[6],
              this._faceRotate[8],
              this._faceRotate[9],
              this._faceRotate[10],
            ),
            t
          );
        }),
          this._uniforms.set('u_color_tint_r', () => new e.Vector4(1, 1, 1, 1)),
          this._uniforms.set('u_color_tint_m', () => new e.Vector4(1, 1, 1, 1)),
          this._uniforms.set('u_luminance', () => 5e-5);
      }
    }
    class Lh {
      constructor(t) {
        (t = t || {}),
          (this.type = 'scene-object'),
          (this.starrySkyTextureUrls = t.starrySkyTextureUrls),
          (this.dayTextureUrls = t.dayTextureUrls),
          (this.id = `skybox-${e.uniqueId()}`),
          this.checkInputTextureExists(t) && (this._ready = !0),
          (this.isSceneObject = !0),
          (this.initialized = !1);
      }
      checkInputTextureExists(e) {
        return !(!e.starrySkyTextureUrls || 6 !== Object.keys(e.starrySkyTextureUrls).length);
      }
      init(t) {
        const { painter: i } = t,
          { context: s } = i;
        (this.geometry = new Ah({ context: s })),
          (this._skyMaterial = new Ih({ type: 'skybox' })),
          (this._cubeMapRenderingMaterial = new Oh({ type: 'skyboxCapture' })),
          (this.primitive = new e.Primitive({
            material: this._skyMaterial,
            geometry: this.geometry,
            allowPick: !1,
          })),
          (this.primitiveToGenerateTexture = new e.Primitive({
            material: this._cubeMapRenderingMaterial,
            geometry: this.geometry,
            allowPick: !1,
          })),
          this._prepareTextures(i).then(() => {
            this._skyMaterial.buildDefines(), (this.initialized = !0);
          });
      }
      getPrimitiveForPass() {
        return this.primitiveToGenerateTexture;
      }
      updateSkyCubeTexture(e) {
        (this._skyMaterial._fboTextureCube = e), (this.ready = !0);
      }
      async _requestBoxImages(t, i) {
        const s = e.CONSTS.SOURCE.TEXTURE_CUBE_KEYS,
          r = [];
        for (let n = 0; n < 6; n++) {
          const o = new Promise((r, o) => {
            e.getImage(t._map._transformRequest(i[s[n]], e.ResourceType.Image), (e, t) => {
              e && o(e), r(t);
            });
          });
          r.push(o);
        }
        const n = await Promise.all(r),
          o = {};
        for (let e = 0; e < s.length; e++) o[s[e]] = n[e];
        return this._createTexture(t, o);
      }
      async _requestSingleImage(t, i) {
        const s = new Promise((s, r) => {
            e.getImage(t._map._transformRequest(i, e.ResourceType.Image), (e, t) => {
              e && r(e), s(t);
            });
          }),
          r = await s;
        return this._createTexture(t, r);
      }
      async _createTexture(t, i) {
        const s = new Rh({
          context: t.context,
          images: i,
          pixelFormat: e.WebGLConstants.RGBA,
          flipY: !0,
        });
        return s.bind(e.WebGLConstants.LINEAR, e.WebGLConstants.CLAMP_TO_EDGE), s;
      }
      async _prepareTextures(e) {
        this.starrySkyTextureUrls &&
          (this._skyMaterial.starrySkyTexture = await this._requestBoxImages(
            e,
            this.starrySkyTextureUrls,
          )),
          this.dayTextureUrls &&
            (this._skyMaterial.dayTexture = await this._requestBoxImages(e, this.dayTextureUrls));
      }
      prepare(e) {
        e.shaderProgramManager.setGlobalMacroDefinition({ SKYBOX_CUBE_MAP_G: this.isCubeMap }),
          (this._ready = !0);
      }
      get ready() {
        return this._ready;
      }
      set ready(e) {
        this._ready = e;
      }
      onAdd(e) {
        this.init({ painter: e.painter });
      }
      serialize() {
        const t = {};
        return (
          e.defined(this.starrySkyTextureUrls) &&
            (t.starrySkyTextureUrls = this.starrySkyTextureUrls),
          e.defined(this.dayTextureUrls) && (t.dayTextureUrls = this.dayTextureUrls),
          t
        );
      }
      destroy() {
        this.primitive.destroy(), this.primitiveToGenerateTexture.destroy();
      }
      loaded() {
        return this._ready;
      }
      collect() {
        return this._ready ? [this.primitive] : [];
      }
    }
    class Dh {
      constructor() {}
      static area(t) {
        if (!(t instanceof Array)) throw new Error('positions is not type of Array!');
        if (t.length < 3) throw new Error("positions's length must be greater than 3!");
        const i = [];
        t.forEach((t) => {
          if (!(t instanceof e.Vector3))
            throw new Error("positions's item contains the type of not Vector3!");
          i.push(t.x), i.push(t.y), i.push(t.z);
        });
        const s = new e.PolygonGeometry({
            polygonHierarchy: { positions: e.Vector3.fromDegreesArrayHeights(i) },
            perPositionHeight: !0,
          }),
          r = s.vertices,
          n = s.indices,
          o = [];
        let a = 0;
        for (let t = 0; t < r.length / 3; t++) {
          const i = new e.Vector3();
          i.set(r[3 * t], r[3 * t + 1], r[3 * t + 2]), o.push(i);
        }
        let l = [];
        for (let t = 0; t < n.length / 3; t++) {
          (l = []), l.push(o[n[3 * t]], o[n[3 * t + 1]], o[n[3 * t + 2]]);
          const i = e.Vector3.distance(l[0], l[1]),
            s = e.Vector3.distance(l[0], l[2]),
            r = e.Vector3.distance(l[1], l[2]),
            h = (i + s + r) / 2;
          a += Math.sqrt(h * (h - i) * (h - r) * (h - s));
        }
        return s.destroy(), a.toFixed(2);
      }
      static distance(t) {
        if (!(t instanceof Array)) throw new Error('positions is not type of Array!');
        if (t.length < 2) throw new Error("positions's length must be greater than 2!");
        let i = [];
        t.forEach((t) => {
          if (!(t instanceof e.Vector3))
            throw new Error("positions's item contains the type of not Vector3!");
          i = i.concat(e.Vector3.fromDegreesArrayHeights(t));
        });
        let s = 0;
        for (let t = 0; t < i.length - 1; t++) s += e.Vector3.distance(i[t], i[t + 1]);
        return s.toFixed(2);
      }
      static height(t, i) {
        if (!(t instanceof e.Vector3)) throw new Error('startPoint is not type of Vector3!');
        if (!(i instanceof e.Vector3)) throw new Error('endPoint is not type of Vector3!');
        const s = t.x,
          r = t.y,
          n = i.x,
          o = i.y,
          a = i.z,
          l = e.Vector3.fromDegrees(s, r, t.z),
          h = e.Vector3.fromDegrees(n, o, a),
          c = e.Vector3.distance(l, e.Vector3.fromDegrees(s, r, a)),
          _ = e.Vector3.distance(h, e.Vector3.fromDegrees(s, r, a)),
          u = e.Vector3.distance(l, h);
        return {
          horizontalDistance: parseFloat(_.toFixed(2)),
          verticalHeight: parseFloat(c.toFixed(2)),
          spatialDistance: parseFloat(u.toFixed(2)),
        };
      }
    }
    class Bh {
      constructor(t) {
        if (((this.type = 'scene-object'), !e.defined(t.data)))
          throw new Error('options.data is required.');
        if (
          ((this._ready = !1),
          (this.data = t.data),
          (this.width = e.defined(t['airline-width']) ? t['airline-width'] : 1),
          (this.segGroup = e.defined(t['airline-seg-group']) ? t['airline-seg-group'] : 5),
          (this.speed = e.defined(t['airline-speed']) ? t['airline-speed'] : 60),
          (this.opacity = e.defined(t['airline-opacity']) ? t['airline-opacity'] : 1),
          null != t['airline-color'])
        ) {
          if (
            ((this.steps = t['airline-color'].steps),
            (this.colorIndex = t['airline-color']['color-index']),
            null == this.steps || null == this.colorIndex)
          )
            throw new Error(
              'options.airline-color.steps and options.airline-color.color-index are both required.',
            );
          if (this.colorIndex > t.data[0].length)
            throw new Error('options.airline-color.color-index 不可以超过传入数据的范围');
          this.steps.forEach((t) => {
            t.push(e.Color.parse(t[1]).toVector3());
          });
        }
        (this.id = e.defined(t.id) ? t.id : e.uuid()),
          (this.minzoom = 1),
          (this.maxzoom = 18),
          (this.visible = !0),
          (this.positions = []),
          (this.lineSegmentation = []),
          (this.colorArray = []),
          this.parse(t.data),
          this.getGeometry(),
          (this.material = new e.PolylineMaterial({ opacity: this.opacity })),
          (this.material.defines.VERTEX_COLOR = !0);
      }
      onAdd(t) {
        this.painter = t.painter;
        const i = new e.Primitive({
            material: this.material,
            geometry: this.staticGeometry,
            modelMatrix: new e.Matrix4(),
          }),
          s = new e.Primitive({
            material: this.material,
            geometry: this.dynamicGeometry,
            modelMatrix: new e.Matrix4(),
          });
        (this.primitive = [i, s]), (this._ready = !0);
      }
      collect() {
        let e = !0;
        const t = this.painter.style.getNearestTileZoom();
        return (
          t < this.minzoom && (e = !1),
          t > this.maxzoom && (e = !1),
          this.visible && e ? [this.primitive] : []
        );
      }
      parse(e) {
        let t = 0;
        const i = [];
        e.forEach((e) => {
          i.push(t);
          const s = this.getColor(e[this.colorIndex - 1]);
          this.getBSRPoints(e[0], e[1], e[2], e[3], 1e4 * e[4]).map((e) => {
            this.positions.push(...e), this.colorArray.push(s), t++;
          });
        }),
          i.push(t);
        for (let e = 0; e < i.length - 1; e++)
          this.lineSegmentation.push([i[e], i[e + 1], i[e], i[e + 1]]);
      }
      getGeometry() {
        (this.staticGeometry = new e.PolylineGeometry({
          positions: e.Vector3.fromDegreesArrayHeights(this.positions),
          width: this.width,
          arcType: e.ARCTYPE.GEODESIC,
          lineSegmentation: this.lineSegmentation,
          colorArray: this.colorArray,
        })),
          (this.dynamicGeometry = new e.PolylineGeometry({
            positions: e.Vector3.fromDegreesArrayHeights(this.positions),
            width: this.width + 2,
            arcType: e.ARCTYPE.GEODESIC,
            lineSegmentation: this.lineSegmentation,
            colorArray: this.colorArray,
            speed: this.speed,
            segGroup: this.segGroup,
            dynamicAirLine: !0,
          }));
      }
      getColor(t) {
        if (null == this.steps) return this.getRandomColor();
        {
          const i = this.steps.length;
          if (t <= this.steps[0][0])
            return [this.steps[0][2][0], this.steps[0][2][1], this.steps[0][2][2]];
          if (t >= this.steps[i - 1][0])
            return [this.steps[i - 1][2][0], this.steps[i - 1][2][1], this.steps[i - 1][2][2]];
          for (let s = 0; s < i - 1; s++)
            if (t <= this.steps[s + 1][0] && t >= this.steps[s][0]) {
              const i = (t - this.steps[s][0]) / (this.steps[s + 1][0] - this.steps[s][0]),
                r = e.Vector3.add(
                  e.Vector3.multiplyByScalar(this.steps[s + 1][2], i),
                  e.Vector3.multiplyByScalar(this.steps[s][2], 1 - i),
                );
              return [r[0], r[1], r[2]];
            }
        }
      }
      getRandomColor() {
        return [Math.random(), Math.random(), Math.random()];
      }
      loaded() {
        return this._ready;
      }
      destroy() {
        this.primitive.destroy();
      }
      getBSRPoints(t, i, s, r, n) {
        const o = [i, 0],
          a = [(r + i) / 2, n],
          l = [r, 0],
          h = Dh.distance([new e.Vector3(t, i, 0), new e.Vector3(s, r, 0)]),
          c = this.getBSR(o, a, l, h),
          _ = [];
        for (const e in c) _.push([((s - t) * (c[e][0] - i)) / (r - i) + t, c[e][0], c[e][1]]);
        return _;
      }
      getBSR(e, t, i, s) {
        return this.createBezierPoints(
          [
            { x: e[0], y: e[1] },
            { x: t[0], y: t[1] },
            { x: i[0], y: i[1] },
          ],
          Math.floor(s / 14e3),
        );
      }
      createBezierPoints(e, t) {
        const i = [];
        for (let s = 0; s < t; s++) {
          const r = this.multiPointBezier(e, s / (t - 1));
          i.push([r.x, r.y]);
        }
        return i;
      }
      multiPointBezier(e, t) {
        const i = e.length;
        let s = 0,
          r = 0;
        const n = function (e, t) {
          let i = 1,
            s = 1;
          for (; t > 0; ) (i *= e), (s *= t), e--, t--;
          return i / s;
        };
        for (let o = 0; o < i; o++) {
          const a = e[o];
          (s += a.x * Math.pow(1 - t, i - 1 - o) * Math.pow(t, o) * n(i - 1, o)),
            (r += a.y * Math.pow(1 - t, i - 1 - o) * Math.pow(t, o) * n(i - 1, o));
        }
        return { x: s, y: r };
      }
    }
    class Vh extends Sh {
      constructor() {
        super(), (this._hasSkyBox = !1), (this._hasEarthCrate = !1), (this._skyOrders = []);
      }
      add(e) {
        if (e.id.indexOf('skybox-') > -1 && this._hasSkyBox)
          console.error('The current map instance has added sky box. Please do not add it again!');
        else {
          if (!(e.id.indexOf('earthCrate-') > -1 && this._hasEarthCrate)) {
            if (this.has(e.id))
              throw new Error(`There is already a sceneComponent with this ID: ${e.id}`);
            return (
              -1 !== e.id.indexOf('skybox-')
                ? this._skyOrders.unshift(e.id)
                : -1 !== e.id.indexOf('earthCrate-')
                ? this._skyOrders.push(e.id)
                : this._orders.push(e.id),
              e.id.indexOf('skybox-') > -1 && (this._hasSkyBox = !0),
              e.id.indexOf('earthCrate-') > -1 && (this._hasEarthCrate = !0),
              this._data.set(e.id, e),
              e
            );
          }
          console.error('The current map instance has added map skin. Please do not add it again!');
        }
      }
      getSkyAndEarthPrimitives(t, i) {
        i = i || e.checkIsDepthSupportDataType;
        let s = [];
        for (let e = 0; e < this._skyOrders.length; e++) {
          const t = this.get(this._skyOrders[e]);
          i(t.classificationType) && (s = s.concat(t.collect()));
        }
        return s;
      }
      getTranslucentPrimitives(t, i) {
        i = i || e.checkIsDepthSupportDataType;
        const s = [];
        for (let r = 0; r < this._orders.length; r++) {
          const n = this.get(this._orders[r]).primitive;
          for (let r = 0; r < n.length; r++) {
            const o = n[r];
            i(o.classificationType) &&
              o._material.isTranslucent &&
              (!t ||
                !o.boundingVolume ||
                (t && t.computeVisibility(o.boundingVolume) !== e.INTERSECTION.OUTSIDE)) &&
              s.push(o);
          }
        }
        return s;
      }
      getOpaquePrimitives(t, i) {
        const s = [];
        i = i || e.checkIsDepthSupportDataType;
        for (let r = 0; r < this._orders.length; r++) {
          const n = this.get(this._orders[r]).primitive;
          for (let r = 0; r < n.length; r++) {
            const o = n[r];
            i(o.classificationType) &&
              (o._material.isTranslucent ||
                ((!t ||
                  !o.boundingVolume ||
                  (t && t.computeVisibility(o.boundingVolume) !== e.INTERSECTION.OUTSIDE)) &&
                  s.push(o)));
          }
        }
        return s;
      }
      removeAll(e) {
        for (super.removeAll(e); this._skyOrders.length > 0; )
          this.removeSky(this._skyOrders[0], e);
      }
      serialize() {
        const e = [];
        for (let t = 0; t < this._orders.length; t++) {
          const i = this.get(this._orders[t]);
          i instanceof Bh &&
            e.push({
              type: 'airLine',
              data: i.data,
              'airline-seg-group': i.segGroup,
              'airline-width': i.width,
              'airline-speed': i.speed,
              'airline-opacity': i.opacity,
              'airline-color': { steps: i.steps, 'color-index': i.colorIndex },
              id: i.id,
            });
        }
        return e.length > 0 ? e : void 0;
      }
      removeSky(e, t) {
        if (this.has(e)) {
          if (t) {
            const t = this.get(e);
            t.destroy && t._loaded && t.destroy();
          }
          this._data.delete(e);
          const i = this._skyOrders.indexOf(e);
          this._skyOrders.splice(i, 1);
        }
      }
      loaded() {
        for (let e = 0; e < this._orders.length; e++)
          if (!this._data.get(this._orders[e]).loaded()) return !1;
        for (let e = 0; e < this._skyOrders.length; e++)
          if (!this._data.get(this._skyOrders[e]).loaded()) return !1;
        return !0;
      }
      destroy() {
        return this.removeAll(!0), e.destroyObject(this);
      }
    }
    class Nh extends Sh {
      constructor() {
        super(), (this._data = new Map());
      }
      add(e) {
        this.has(e.id) || (this._data.set(e.id, e), this._orders.push(e.id));
      }
      getAllPrimitives() {
        const e = [];
        for (let t = 0; t < this._orders.length; t++) {
          const i = this.get(this._orders[t]);
          e.push(i);
        }
        return e;
      }
      getPrimitiveById(e) {
        if (!this.has(e)) return this.get(this._orders[e]);
      }
      remove(e) {
        this.get(e) && this.get(e).destroy(), super.remove(e);
      }
      removeAll(e) {
        for (; this._orders.length > 0; ) this.remove(this._orders[0], e);
      }
      getAllNeedRenderPrimitive() {
        return this.getAllPrimitives();
      }
      removeNeedRenderPrimitiveList() {
        this.removeAll(!0);
      }
      destroy() {
        return this.removeAll(!0), e.destroyObject(this);
      }
    }
    const kh = (t, i) =>
        e.emitValidationErrors(t, i && i.filter((e) => 'source.canvas' !== e.identifier)),
      Fh = e.pick(Vo, [
        'addLayer',
        'removeLayer',
        'setPaintProperty',
        'setLayoutProperty',
        'setFilter',
        'addSource',
        'removeSource',
        'setLayerZoomRange',
        'setLight',
        'setTransition',
        'setGeoJSONSourceData',
      ]),
      Gh = e.pick(Vo, ['setCenter', 'setZoom', 'setBearing', 'setPitch']),
      Uh = (function () {
        const t = {},
          i = e.spec.$version;
        for (const s in e.spec.$root) {
          const r = e.spec.$root[s];
          if (r.required) {
            let e = null;
            (e = 'version' === s ? i : 'array' === r.type ? [] : {}), null != e && (t[s] = e);
          }
        }
        return t;
      })();
    class zh extends e.Evented {
      constructor(t, i = {}) {
        super(),
          (this.map = t),
          (this.dispatcher = new rn((Lo || (Lo = new Io()), Lo), this)),
          (this.imageManager = new Yr()),
          this.imageManager.setEventedParent(this),
          (this.glyphManager = new tn(t._transformRequest, i.localIdeographFontFamily)),
          (this.lineAtlas = new sn(256, 512)),
          (this.crossTileSymbolIndex = new ga()),
          (this.classificationLayer = []),
          (this._layers = {}),
          (this._order = []),
          (this.sourceCaches = {}),
          (this.zoomHistory = new e.ZoomHistory()),
          (this._loaded = !1),
          (this.firstClassificationTypeId = void 0),
          (this._availableImages = []),
          (this._originalSource = []),
          (this._originalLayer = []),
          (this._videoSource = void 0),
          (this.hasTerrainLayerFlag = !1),
          this._resetUpdates(),
          this.dispatcher.broadcast('setReferrer', e.getReferrer());
        const s = this;
        (this._rtlTextPluginCallback = zh.registerForPluginStateChange((t) => {
          s.dispatcher.broadcast(
            'syncRTLPluginState',
            { pluginStatus: t.pluginStatus, pluginURL: t.pluginURL },
            (t, i) => {
              if ((e.triggerPluginCompletionEvent(t), i && i.every((e) => e)))
                for (const e in s.sourceCaches) s.sourceCaches[e].reload();
            },
          );
        })),
          (this.modelCollection = new Eh({ type: '3d-model' })),
          (this.tilesetCollection = new Eh({ type: '3d-tiles' })),
          (this.scenePointPrimitiveCollection = new Ph()),
          (this.primitiveCollection = new Mh()),
          (this.primitivePreRenderCollection = new Mh()),
          (this.sceneObjectCollection = new Vh()),
          (this.debugBoundingBoxPrimitiveCollection = new Nh()),
          this.changWorkerProjection(i.projection || e.ProjectionType.MERCATOR),
          (this.performanceManager = new Ch(this)),
          this.on('data', (e) => {
            if ('source' !== e.dataType || 'metadata' !== e.sourceDataType) return;
            const t = this.sourceCaches[e.sourceId];
            if (!t) return;
            const i = t.getSource();
            if (i && i.vectorLayerIds)
              for (const e in this._layers) {
                const t = this._layers[e];
                t.source === i.id && this._validateLayer(t);
              }
          }),
          (this._performanceManagerEvent = this._performanceManagerEvent.bind(this)),
          this.map.on && this.map.on('moveend', this._performanceManagerEvent),
          this.map.on && this.map.on('handler-moveend', this._performanceManagerEvent),
          this.once('load', () => {
            this.performanceManager.stopAction();
          }),
          this._addTerrainSourceCache(),
          this._addBackgroundSourceCache(),
          this._addBackgroundLayerForDepthDraw();
      }
      _addBackgroundLayerForDepthDraw() {
        (this.backgroundDepthRenderLayer = e.createStyleLayer({
          id: ro,
          type: 'background',
          'depth-test': !0,
          'show-depth': !0,
          layout: {},
          paint: {},
        })),
          this.backgroundDepthRenderLayer.setEventedParent(this, { layer: { id: ro } });
      }
      _performanceManagerEvent() {
        (this.performanceManager.forceServericeRequest = !0), this.performanceManager.stopAction();
      }
      changWorkerProjection(e) {
        this.dispatcher.broadcast('setProjection', { projection: e }, () => {});
      }
      loadURL(t, i = {}) {
        this.fire(new e.Event('dataloading', { dataType: 'style' })),
          (i.validate = 'boolean' == typeof i.validate ? i.validate : !yr(t)),
          (t = Tr(t, i.key, i.appKey));
        const s = this.map._transformRequest(t, e.ResourceType.Style);
        this._request = e.getJSON(s, (t, s) => {
          (this._request = null), t ? this.fire(new e.ErrorEvent(t)) : s && this._load(s, i);
        });
      }
      loadJSON(t, i = {}) {
        this.fire(new e.Event('dataloading', { dataType: 'style' })),
          (this._request = e.exported.frame(() => {
            (this._request = null), (i.validate = !1 !== i.validate), this._load(t, i);
          }));
      }
      loadEmpty() {
        this.fire(new e.Event('dataloading', { dataType: 'style' })), this._load(Uh, !1);
      }
      markOriginalStyle(e) {
        for (const t in e.sourceCaches)
          this._originalSource.push(t), (e.sourceCaches[t]._original_style = !0);
        for (const t in e._layers) this._originalLayer.push(t), (e._layers[t]._original_style = !0);
      }
      hasTerrainLayer() {
        return this.terrainSourceCache.isTerrain();
      }
      registCommonQuadtree(e) {
        this.commonQuadtree = e;
      }
      synchronizeTileTerrainBounding(e, t, i) {
        const s = e.scaledTo(e.canonical.z - Math.log2(512 / t));
        for (const e in this.sourceCaches) {
          const t = this.sourceCaches[e];
          if (!t.quadtree) continue;
          t.quadtree.hasTerrainLayerFlag = this.hasTerrainLayerFlag;
          const r = t.quadtree.getQuadtreeTileByTileKey(s.key);
          r &&
            this.hasTerrainLayerFlag &&
            ((r.terrainData = { minimumHeight: i.minimumHeight, maximumHeight: i.maximumHeight }),
            On(r));
        }
        if (this.backgroundSourceCache) {
          const e = this.backgroundSourceCache;
          if (e.quadtree) {
            e.quadtree.hasTerrainLayerFlag = this.hasTerrainLayerFlag;
            const t = e.quadtree.getQuadtreeTileByTileKey(s.key);
            t &&
              this.hasTerrainLayerFlag &&
              ((t.terrainData = { minimumHeight: i.minimumHeight, maximumHeight: i.maximumHeight }),
              On(t));
          }
        }
        this.map.triggerRepaint();
      }
      set commonQuadtree(e) {
        this._commonQuadtree = e;
      }
      get commonQuadtree() {
        return (
          this._commonQuadtree ||
            (this._commonQuadtree = ho({
              tileSize: 512,
              isLngLat: this.map.transform.projection === e.ProjectionType.LATLON,
              drawingBufferHeight: this.map.painter.context.gl.drawingBufferHeight,
              hasTerrainLayerFlag: this.hasTerrainLayerFlag,
              spaceErrorScale: this.map.spaceErrorScale,
            })),
          this._commonQuadtree
        );
      }
      coveringTiles(e, t) {
        return (
          this.commonQuadtree.tilesIn(this.map.transform.activeCamera, t),
          this.commonQuadtree.getOverscaledTileIDs()
        );
      }
      _load(t, i) {
        if (i.validate && kh(this, e.validateStyle(t))) return;
        (this._loaded = !0), (this.stylesheet = t);
        for (const e in t.sources) this.addSource(e, t.sources[e], { validate: !1 });
        t.sprite
          ? this._loadSprite(t.sprite)
          : (this.imageManager.setLoaded(!0), this.dispatcher.broadcast('spriteLoaded', !0)),
          this.glyphManager.setURL(t.glyphs);
        const s = Bo(this.stylesheet.layers);
        (this._order = s.map((e) => e.id)), (this._layers = {});
        for (let t of s)
          (t = e.createStyleLayer(t)),
            t.setEventedParent(this, { layer: { id: t.id } }),
            (this._layers[t.id] = t);
        this.dispatcher.broadcast('setLayers', this._serializeLayers(this._order)),
          this.markOriginalStyle(this),
          this.fire(new e.Event('data', { dataType: 'style' })),
          this.fire(new e.Event('style.load')),
          this.fire(
            new e.Event('processStyleJson', {
              dataType: 'style',
              styleJsonData: t,
              diff: i.diff,
              keepUserInfo: i.keepUserInfo,
              useCustomCamera: i.useCustomCamera,
            }),
          );
      }
      _validateLayer(t) {
        const i = this.sourceCaches[t.source];
        if (!i) return;
        const s = t.sourceLayer;
        if (!s) return;
        const r = i.getSource();
        ('geojson' === r.type || (r.vectorLayerIds && -1 === r.vectorLayerIds.indexOf(s))) &&
          this.fire(
            new e.ErrorEvent(
              new Error(
                `Source layer "${s}" does not exist on source "${r.id}" as specified by style layer "${t.id}"`,
              ),
            ),
          );
      }
      _loadSprite(t) {
        this._spriteRequest = (function (t, i, s) {
          const r = [],
            n = e.exported.devicePixelRatio > 1 ? '@2x' : '',
            o = ((e) => {
              const { url: t } = e;
              if (!yr(t)) return t;
              const i = Pr(t);
              return (i.path = `${pr.SRC_URL}/sprite/sprite`), i.path;
            })({ url: t, format: n }),
            a = Array.isArray(pr.spriteUrl) ? pr.spriteUrl : [pr.spriteUrl];
          pr.spriteUrl = a ? Array.from(new Set([...a])) : o;
          for (let e = 0; e < pr.spriteUrl.length; e++)
            ((e) => {
              if ('string' == typeof t) r.push({}), l(e, t);
              else if (t instanceof Array)
                for (let i = 0; i < t.length; i++) r.push({}), l(e + i, t[i]);
              else console.log(`不支持当前格式的sprite${t}`);
            })(e);
          function l(t, o) {
            const a = wr({ url: o, format: n, extension: '.json', index: t });
            e.getJSON(i(a, e.ResourceType.SpriteJSON), (e, i) => {
              (r[t].json = i), r[t].error || (r[t].error = e), $r(r, pr.spriteUrl.length, s);
            });
            const l = wr({ url: o, format: n, extension: '.png', index: t });
            e.getImage(i(l, e.ResourceType.SpriteImage), (e, i) => {
              (r[t].image = i), r[t].error || (r[t].error = e), $r(r, pr.spriteUrl.length, s);
            });
          }
        })(t, this.map._transformRequest, (t, i) => {
          if (((this._spriteRequest = null), t)) this.fire(new e.ErrorEvent(t));
          else if (i) for (const e in i) this.imageManager.addImage(e, i[e]);
          this.imageManager.setLoaded(!0),
            (this._availableImages = this.imageManager.listImages()),
            this.dispatcher.broadcast('setImages', this._availableImages),
            this.dispatcher.broadcast('spriteLoaded', !0),
            this.fire(new e.Event('data', { dataType: 'style' }));
        });
      }
      loaded() {
        if (!this._loaded) return !1;
        if (Object.keys(this._updatedSources).length) return !1;
        for (const e in this.sourceCaches) if (!this.sourceCaches[e].loaded()) return !1;
        if (!this.imageManager.isLoaded()) return !1;
        for (const t in this._layers)
          if (Object.hasOwnProperty.call(this._layers, t)) {
            const i = this._layers[t];
            if (
              !(
                i.lightingModel !== e.LightingModelType.PBR ||
                ('3d-model' !== i.type && '3d-tiles' !== i.type) ||
                (this.map._iBLtextures && this.map._iBLtextures.isLoaded)
              )
            )
              return !1;
          }
        return !0;
      }
      _serializeLayers(e) {
        const t = [];
        for (const i of e) {
          const e = this._layers[i];
          'custom' !== e.type && t.push(e.serialize());
        }
        return t;
      }
      hasTransitions() {
        for (const e in this.sourceCaches) if (this.sourceCaches[e].hasTransition()) return !0;
        for (const e in this._layers) if (this._layers[e].hasTransition()) return !0;
        return !1;
      }
      _checkLoaded() {
        if (!this._loaded) throw new Error('Style is not done loading');
      }
      update(t) {
        if (this._loaded) {
          if (this._changed) {
            const i = Object.keys(this._updatedLayers),
              s = Object.keys(this._removedLayers);
            (i.length || s.length) && this._updateWorkerLayers(i, s);
            for (const e in this._updatedSources) {
              const t = this._updatedSources[e];
              'reload' === t ? this._reloadSource(e) : 'clear' === t && this._clearSource(e);
            }
            for (const e in this._updatedPaintProps) this._layers[e].updateTransitions(t);
            this._resetUpdates(), this.fire(new e.Event('data', { dataType: 'style' }));
          }
          for (const e in this.sourceCaches) this.sourceCaches[e].used = !1;
          for (const e of this._order) {
            const i = this._layers[e];
            i.recalculate(t, this._availableImages),
              i.source && (i.isHiddenByMapZoom(this.z) || (this.sourceCaches[i.source].used = !0));
          }
          this.backgroundDepthRenderLayer.recalculate(t, this._availableImages), (this.z = t.zoom);
        }
      }
      _updateTilesForChangedImages() {
        const e = Object.keys(this._changedImages);
        if (e.length) {
          for (const t in this.sourceCaches)
            this.sourceCaches[t].reloadTilesForDependencies(['icons', 'patterns'], e);
          this._changedImages = {};
        }
      }
      _updateWorkerLayers(e, t) {
        this.dispatcher.broadcast('updateLayers', {
          layers: this._serializeLayers(e),
          removedIds: t,
        });
      }
      _resetUpdates() {
        (this._changed = !1),
          (this._updatedLayers = {}),
          (this._removedLayers = {}),
          (this._updatedSources = {}),
          (this._updatedPaintProps = {}),
          (this._changedImages = {});
      }
      setState(i, s) {
        if ((this._checkLoaded(), kh(this, e.validateStyle(i)))) return !1;
        (i = e.clone(i)).layers = Bo(i.layers);
        const r = (function (e, i, s) {
          if (!e) return [{ command: Vo.setStyle, args: [i] }];
          let r = [];
          try {
            if (!t(e.version, i.version)) return [{ command: Vo.setStyle, args: [i] }];
            t(e.center, i.center) || r.push({ command: Vo.setCenter, args: [i.center] }),
              t(e.zoom, i.zoom) || r.push({ command: Vo.setZoom, args: [i.zoom] }),
              t(e.bearing, i.bearing) || r.push({ command: Vo.setBearing, args: [i.bearing] }),
              t(e.pitch, i.pitch) || r.push({ command: Vo.setPitch, args: [i.pitch] }),
              t(e.sprite, i.sprite),
              t(e.glyphs, i.glyphs) || r.push({ command: Vo.setGlyphs, args: [i.glyphs] }),
              t(e.transition, i.transition) ||
                r.push({ command: Vo.setTransition, args: [i.transition] });
            const n = {};
            i.layers.forEach((e) => {
              e._original_style = !0;
            });
            for (const e in i.sources) i.sources[e]._original_style = !0;
            const o = [];
            !(function (e, i, s, r, n) {
              let o;
              for (o in ((i = i || {}), (e = e || {})))
                e.hasOwnProperty(o) &&
                  ((n && !e[o]._original_style) || i.hasOwnProperty(o) || ko(o, s, r));
              for (o in i)
                i.hasOwnProperty(o) &&
                  (e.hasOwnProperty(o)
                    ? t(e[o], i[o]) ||
                      ('geojson' === e[o].type && 'geojson' === i[o].type && Go(e, i, o)
                        ? s.push({ command: Vo.setGeoJSONSourceData, args: [o, i[o].data] })
                        : Fo(o, i, s, r, i[o]._original_style))
                    : No(o, i, s, !!i[o]._original_style));
            })(e.sources, i.sources, o, n, s);
            const a = [];
            e.layers &&
              e.layers.forEach((e) => {
                n[e.source] ? r.push({ command: Vo.removeLayer, args: [e.id] }) : a.push(e);
              }),
              (r = r.concat(o)),
              s &&
                a.forEach((e) => {
                  e._original_style || i.layers.push(e);
                }),
              (function (e, i, s, r) {
                i = i || [];
                const n = (e = e || []).map(zo),
                  o = i.map(zo),
                  a = e.reduce(Ho, {}),
                  l = i.reduce(Ho, {}),
                  h = n.slice(),
                  c = Object.create(null);
                let _, u, d, m, p, f, g;
                for (_ = 0, u = 0; _ < n.length; _++)
                  (d = n[_]),
                    (r && a.hasOwnProperty(d) && !a[d]._original_style) || l.hasOwnProperty(d)
                      ? u++
                      : (s.push({ command: Vo.removeLayer, args: [d] }),
                        h.splice(h.indexOf(d, u), 1));
                for (_ = 0, u = 0; _ < o.length; _++)
                  (d = o[o.length - 1 - _]),
                    h[h.length - 1 - _] !== d &&
                      (a.hasOwnProperty(d)
                        ? (s.push({ command: Vo.removeLayer, args: [d] }),
                          h.splice(h.lastIndexOf(d, h.length - u), 1))
                        : u++,
                      (f = h[h.length - _]),
                      s.push({
                        command: Vo.addLayer,
                        args: [l[d], f, { isOriginal: l[d]._original_style }],
                      }),
                      h.splice(h.length - _, 0, d),
                      (c[d] = !0));
                for (_ = 0; _ < o.length; _++)
                  if (((d = o[_]), (m = a[d]), (p = l[d]), !c[d] && !t(m, p)))
                    if (
                      t(m.source, p.source) &&
                      t(m['source-layer'], p['source-layer']) &&
                      t(m.type, p.type)
                    ) {
                      for (g in (Uo(m.layout, p.layout, s, d, null, Vo.setLayoutProperty),
                      Uo(m.paint, p.paint, s, d, null, Vo.setPaintProperty),
                      t(m.filter, p.filter) ||
                        s.push({ command: Vo.setFilter, args: [d, p.filter] }),
                      (t(m.minzoom, p.minzoom) && t(m.maxzoom, p.maxzoom)) ||
                        s.push({ command: Vo.setLayerZoomRange, args: [d, p.minzoom, p.maxzoom] }),
                      m))
                        m.hasOwnProperty(g) &&
                          'layout' !== g &&
                          'paint' !== g &&
                          'filter' !== g &&
                          'metadata' !== g &&
                          'minzoom' !== g &&
                          'maxzoom' !== g &&
                          (0 === g.indexOf('paint.')
                            ? Uo(m[g], p[g], s, d, g.slice(6), Vo.setPaintProperty)
                            : t(m[g], p[g]) ||
                              s.push({ command: Vo.setLayerProperty, args: [d, g, p[g]] }));
                      for (g in p)
                        p.hasOwnProperty(g) &&
                          !m.hasOwnProperty(g) &&
                          'layout' !== g &&
                          'paint' !== g &&
                          'filter' !== g &&
                          'metadata' !== g &&
                          'minzoom' !== g &&
                          'maxzoom' !== g &&
                          (0 === g.indexOf('paint.')
                            ? Uo(m[g], p[g], s, d, g.slice(6), Vo.setPaintProperty)
                            : t(m[g], p[g]) ||
                              s.push({ command: Vo.setLayerProperty, args: [d, g, p[g]] }));
                    } else
                      s.push({ command: Vo.removeLayer, args: [d] }),
                        (f = h[h.lastIndexOf(d) + 1]),
                        s.push({
                          command: Vo.addLayer,
                          args: [p, f, { isOriginal: l[d]._original_style }],
                        });
              })(a, i.layers, r, s);
          } catch (e) {
            r = [{ command: Vo.setStyle, args: [i] }];
          }
          return r;
        })(this.roughSerialize(), i, s).filter((e) => !(e.command in Gh));
        if (0 === r.length) return !1;
        const n = r.filter((e) => !(e.command in Fh));
        if (n.length > 0) throw new Error(`Unimplemented: ${n.map((e) => e.command).join(', ')}.`);
        return (
          r.forEach((e) => {
            'setTransition' !== e.command && this[e.command].apply(this, e.args);
          }),
          (this.stylesheet = i),
          !0
        );
      }
      updateImage(e, t) {
        this.imageManager.updateImage(e, t);
      }
      addImage(t, i) {
        if (this.getImage(t))
          return this.fire(new e.ErrorEvent(new Error('An image with this name already exists.')));
        this.imageManager.addImage(t, i), this._afterImageUpdated(t);
      }
      getImage(e) {
        return this.imageManager.getImage(e);
      }
      removeImage(t) {
        if (!this.getImage(t))
          return this.fire(new e.ErrorEvent(new Error('No image with this name exists.')));
        this.imageManager.removeImage(t),
          this._afterImageUpdated(t),
          this.fire(new e.Event('data', { dataType: 'style' }));
      }
      listImages() {
        return this._checkLoaded(), this._availableImages.slice();
      }
      _afterImageUpdated(t) {
        (this._availableImages = this.imageManager.listImages()),
          (this._changedImages[t] = !0),
          (this._changed = !0),
          this.dispatcher.broadcast('setImages', this._availableImages),
          this.fire(new e.Event('data', { dataType: 'style' }));
      }
      addSceneComponent(e) {
        let t;
        switch (e.type) {
          case '3d-model':
            t = this.addSceneModel(e);
            break;
          case '3d-tiles':
            t = this.addSceneTileset(e);
            break;
          case 'scene-object':
            t = this.addSceneObject(e);
        }
        return t;
      }
      addSceneModel(e) {
        e.map = this.map;
        const t = new Ar(e);
        return t.load(), this.modelCollection.add(t);
      }
      addSceneTileset(e) {
        return (e.map = this.map), this.tilesetCollection.add(new mh(e));
      }
      addSceneObject(e) {
        e instanceof Lh && (this._skybox = e), e.onAdd(this.map), this.sceneObjectCollection.add(e);
      }
      getSceneComponent(e) {
        return (
          this.modelCollection.get(e) ||
          this.sceneObjectCollection.get(e) ||
          this.tilesetCollection.get(e)
        );
      }
      removeSceneComponent(e) {
        if (!this.getSceneComponent(e))
          throw new Error(`There is no one sceneComponent with this ID: ${e}`);
        this.modelCollection.remove(e, !0),
          this.sceneObjectCollection.remove(e, !0),
          this.tilesetCollection.remove(e, !0);
      }
      addPrimitive(e) {
        return (
          e instanceof Sa
            ? this.scenePointPrimitiveCollection.add(e)
            : this.primitiveCollection.add(e),
          e
        );
      }
      removePrimitive(t) {
        if (t instanceof Sa) return this.scenePointPrimitiveCollection.remove(t.id);
        if (!(t instanceof e.Primitive)) throw new Error('There is not a primitive!');
        this.primitiveCollection.remove(t.id);
      }
      removePrimitiveById(e) {
        this.primitiveCollection.has(e) && this.primitiveCollection.remove(e);
      }
      getPrimitiveById(e) {
        if (this.primitiveCollection.has(e)) return this.primitiveCollection.get(e);
      }
      addPrimitiveForPreRender(e) {
        this.primitivePreRenderCollection.add(e);
      }
      removePrimitiveForPreRender(t) {
        if (!(t instanceof e.Primitive)) throw new Error('There is not a primitive!');
        this.primitivePreRenderCollection.remove(t.id);
      }
      _addTerrainSourceCache() {
        if (this.terrainSourceCache)
          return void console.error('当前添加多个terrainSourceCache是不允许的！');
        const e = bh(
          Qn,
          { type: 'terrain', requestInterval: this.map._requestInterval },
          this.dispatcher,
        );
        (e.style = this),
          e.setEventedParent(this, () => ({
            isSourceLoaded: this.loaded(),
            source: e.serialize(),
            sourceId: Qn,
          })),
          e.onAdd(this.map),
          (this.terrainSourceCache = e);
      }
      _addBackgroundSourceCache() {
        if (this.backgroundSourceCache)
          return void console.error('当前添加多个backgroundSourceCache是不允许的！');
        const e = bh(so, { type: 'background', minzoom: 0, maxzoom: 17 }, this.dispatcher);
        (e.style = this),
          e.setEventedParent(this, () => ({
            isSourceLoaded: this.loaded(),
            source: e.serialize(),
            sourceId: Qn,
          })),
          e.onAdd(this.map),
          (this.backgroundSourceCache = e);
      }
      addSource(e, t, i) {
        if ((this._checkLoaded(), void 0 !== this.sourceCaches[e]))
          throw new Error('There is already a source with this ID');
        if (!t.type)
          throw new Error(
            `The type property must be defined, but the only the following properties were given: ${Object.keys(
              t,
            ).join(', ')}.`,
          );
        this.map && this.map._collectResourceTiming && (t.collectResourceTiming = !0);
        const s = (this.sourceCaches[e] = bh(e, t, this.dispatcher));
        i && i.isOriginal && (this.sourceCaches[e]._original_style = !0),
          (s.style = this),
          s.setEventedParent(this, () => ({
            isSourceLoaded: this.loaded(),
            source: s.serialize(),
            sourceId: e,
          })),
          s.onAdd(this.map),
          (this._changed = !0);
      }
      removeSource(t) {
        if ((this._checkLoaded(), void 0 === this.sourceCaches[t]))
          throw new Error('There is no source with this ID');
        for (const i in this._layers)
          if (this._layers[i].source === t)
            return this.fire(
              new e.ErrorEvent(
                new Error(`Source "${t}" cannot be removed while layer "${i}" is using it.`),
              ),
            );
        const i = this.sourceCaches[t];
        delete this.sourceCaches[t],
          delete this._updatedSources[t],
          i.fire(
            new e.Event('data', { sourceDataType: 'metadata', dataType: 'source', sourceId: t }),
          ),
          i.setEventedParent(null),
          i.clearTiles(),
          i.onRemove && i.onRemove(this.map),
          (this._changed = !0);
      }
      setGeoJSONSourceData(e, t) {
        this._checkLoaded(), this.sourceCaches[e].getSource().setData(t), (this._changed = !0);
      }
      getSource(e) {
        return this.sourceCaches[e] && this.sourceCaches[e].getSource();
      }
      addLayer(t, i, s) {
        this._checkLoaded();
        const r = t.id;
        if (this.getLayer(r))
          return void this.fire(
            new e.ErrorEvent(new Error(`Layer with id "${r}" already exists on this map`)),
          );
        let n;
        if ('custom' === t.type) n = e.createStyleLayer(t);
        else {
          if (
            ('object' == typeof t.source &&
              (this.addSource(r, t.source), (t = e.clone(t)), (t = e.extend(t, { source: r }))),
            this._validate(e.validateStyle.layer, `layers.${r}`, t, { arrayIndex: -1 }, s))
          )
            return;
          (n = e.createStyleLayer(t)),
            this._validateLayer(n),
            n.setEventedParent(this, { layer: { id: r } });
        }
        n.uuid = e.uuid();
        const o = i ? this._order.indexOf(i) : this._order.length;
        if (i && -1 === o)
          this.fire(
            new e.ErrorEvent(new Error(`Layer with id "${i}" does not exist on this map.`)),
          );
        else {
          if (
            (null != t.lightingModel && (n.lightingModel = t.lightingModel),
            e.checkIsVectorShadowVolumeDataType(n.classificationType)
              ? this.classificationLayer.indexOf(r) < 0 && this.classificationLayer.push(r)
              : this._order.splice(o, 0, r),
            this.classificationLayer.length > 0 &&
              (this.classificationLayer.forEach((e) => {
                const t = this._order.indexOf(e);
                t > -1 && this._order.splice(t, 1);
              }),
              (this._order = this._order.concat(this.classificationLayer))),
            (this._layerOrderChanged = !0),
            (this._layers[r] = n),
            s && s.isOriginal && (this._layers[r]._original_style = !0),
            this._removedLayers[r] && n.source && 'custom' !== n.type)
          ) {
            const e = this._removedLayers[r];
            delete this._removedLayers[r],
              e.type !== n.type
                ? (this._updatedSources[n.source] = 'clear')
                : ((this._updatedSources[n.source] = 'reload'),
                  this.sourceCaches[n.source].pause());
          }
          this._updateLayer(n), n.onAdd && n.onAdd(this.map);
        }
      }
      updateHasTerrainFlag() {
        (this.hasTerrainLayerFlag = this.terrainSourceCache.isTerrain()),
          (this.map.transform.terrainRender = this.hasTerrainLayerFlag),
          (this.map.transform.terrainSupplier = this.terrainSourceCache.supplier);
      }
      resetSourceQuadtree() {
        this.backgroundSourceCache.resetQuadtree();
        for (const e in this.sourceCaches)
          this.sourceCaches[e].resetQuadtree && this.sourceCaches[e].resetQuadtree();
      }
      getId(e) {
        return this._order[e];
      }
      moveLayer(t, i) {
        if ((this._checkLoaded(), (this._changed = !0), !this._layers[t]))
          return void this.fire(
            new e.ErrorEvent(
              new Error(`The layer '${t}' does not exist in the map's style and cannot be moved.`),
            ),
          );
        if (t === i) return;
        const s = this._order.indexOf(t);
        this._order.splice(s, 1);
        const r = i ? this._order.indexOf(i) : this._order.length;
        i && -1 === r
          ? this.fire(
              new e.ErrorEvent(new Error(`Layer with id "${i}" does not exist on this map.`)),
            )
          : (this._order.splice(r, 0, t), (this._layerOrderChanged = !0));
      }
      upwordMoveLayer(t, i) {
        if ((this._checkLoaded(), (this._changed = !0), !this._layers[t]))
          return void this.fire(
            new e.ErrorEvent(
              new Error(`The layer '${t}' does not exist in the map's style and cannot be moved.`),
            ),
          );
        if (t === i) return;
        const s = this._order.indexOf(t);
        this._order.splice(s, 1);
        const r = i ? this._order.indexOf(i) : this._order.length;
        i && -1 === r
          ? this.fire(
              new e.ErrorEvent(new Error(`Layer with id "${i}" does not exist on this map.`)),
            )
          : (this._order.splice(r + 1, 0, t), (this._layerOrderChanged = !0));
      }
      removeLayer(t) {
        this._checkLoaded();
        const i = this._layers[t];
        if (!i)
          return void this.fire(
            new e.ErrorEvent(
              new Error(
                `The layer '${t}' does not exist in the map's style and cannot be removed.`,
              ),
            ),
          );
        this.classificationLayer.length > 0 &&
          (this.classificationLayer = this.classificationLayer.filter((e) => e != t)),
          i.setEventedParent(null);
        const s = this._order.indexOf(t);
        if (
          (this._order.splice(s, 1),
          (this._layerOrderChanged = !0),
          (this._changed = !0),
          (this._removedLayers[t] = i),
          delete this._layers[t],
          delete this._updatedLayers[t],
          delete this._updatedPaintProps[t],
          'raster' === i.type)
        )
          i.onRemove && i.onRemove(this.map);
        else if ('background' === i.type) {
          for (const e in this.backgroundSourceCache._tiles)
            this.backgroundSourceCache._tiles[e].primitiveMap.delete(i.id);
          this.backgroundSourceCache._cache.reset();
        }
      }
      getLayer(e) {
        return this._layers[e];
      }
      setLayerZoomRange(t, i, s) {
        this._checkLoaded();
        const r = this.getLayer(t);
        r
          ? (r.minzoom === i && r.maxzoom === s) ||
            (null != i && (r.minzoom = i), null != s && (r.maxzoom = s), this._updateLayer(r))
          : this.fire(
              new e.ErrorEvent(
                new Error(
                  `The layer '${t}' does not exist in the map's style and cannot have zoom extent.`,
                ),
              ),
            );
      }
      setSourceFilter(e, t) {
        const i = this.getSource(e);
        i && (i.setFilter(t), this._reloadSource(e));
      }
      setFilter(i, s) {
        this._checkLoaded();
        const r = this.getLayer(i);
        if (r) {
          if (!t(r.filter, s))
            return null == s
              ? ((r.filter = void 0), void this._updateLayer(r))
              : void (
                  this._validate(e.validateStyle.filter, `layers.${r.id}.filter`, s) ||
                  ((r.filter = e.clone(s)), this._updateLayer(r))
                );
        } else this.fire(new e.ErrorEvent(new Error(`The layer '${i}' does not exist in the map's style and cannot be filtered.`)));
      }
      getFilter(t) {
        return e.clone(this.getLayer(t).filter);
      }
      setLayoutProperty(i, s, r) {
        this._checkLoaded();
        const n = this.getLayer(i);
        n
          ? t(n.getLayoutProperty(s), r) || (n.setLayoutProperty(s, r), this._updateLayer(n))
          : this.fire(
              new e.ErrorEvent(
                new Error(
                  `The layer '${i}' does not exist in the map's style and cannot be styled.`,
                ),
              ),
            );
      }
      getLayoutProperty(t, i) {
        const s = this.getLayer(t);
        if (s) return s.getLayoutProperty(i);
        this.fire(
          new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style.`)),
        );
      }
      setPaintProperty(i, s, r) {
        this._checkLoaded();
        const n = this.getLayer(i);
        n
          ? t(n.getPaintProperty(s), r) ||
            (n.setPaintProperty(s, r) && this._updateLayer(n),
            (this._changed = !0),
            (this._updatedPaintProps[i] = !0))
          : this.fire(
              new e.ErrorEvent(
                new Error(
                  `The layer '${i}' does not exist in the map's style and cannot be styled.`,
                ),
              ),
            );
      }
      getPaintProperty(e, t) {
        return this.getLayer(e).getPaintProperty(t);
      }
      setFeatureState(t, i) {
        this._checkLoaded();
        const s = t.source,
          r = t.sourceLayer,
          n = this.getSource(s);
        if (void 0 === n)
          return void this.fire(
            new e.ErrorEvent(new Error(`The source '${s}' does not exist in the map's style.`)),
          );
        const o = n.type;
        'geojson' === o && r
          ? this.fire(
              new e.ErrorEvent(new Error('GeoJSON sources cannot have a sourceLayer parameter.')),
            )
          : 'vector' !== o || r
          ? (void 0 === t.id &&
              this.fire(new e.ErrorEvent(new Error('The feature id parameter must be provided.'))),
            this.sourceCaches[s].setFeatureState(r, t.id, i))
          : this.fire(
              new e.ErrorEvent(
                new Error('The sourceLayer parameter must be provided for vector source types.'),
              ),
            );
      }
      removeFeatureState(t, i) {
        this._checkLoaded();
        const s = t.source,
          r = this.getSource(s);
        if (void 0 === r)
          return void this.fire(
            new e.ErrorEvent(new Error(`The source '${s}' does not exist in the map's style.`)),
          );
        const n = r.type,
          o = 'vector' === n ? t.sourceLayer : void 0;
        'vector' !== n || o
          ? i && 'string' != typeof t.id && 'number' != typeof t.id
            ? this.fire(
                new e.ErrorEvent(
                  new Error('A feature id is required to remove its specific state property.'),
                ),
              )
            : this.sourceCaches[s].removeFeatureState(o, t.id, i)
          : this.fire(
              new e.ErrorEvent(
                new Error('The sourceLayer parameter must be provided for vector source types.'),
              ),
            );
      }
      getFeatureState(t) {
        this._checkLoaded();
        const i = t.source,
          s = t.sourceLayer,
          r = this.getSource(i);
        if (void 0 !== r) {
          if ('vector' !== r.type || s)
            return (
              void 0 === t.id &&
                this.fire(
                  new e.ErrorEvent(new Error('The feature id parameter must be provided.')),
                ),
              this.sourceCaches[i].getFeatureState(s, t.id)
            );
          this.fire(
            new e.ErrorEvent(
              new Error('The sourceLayer parameter must be provided for vector source types.'),
            ),
          );
        } else this.fire(new e.ErrorEvent(new Error(`The source '${i}' does not exist in the map's style.`)));
      }
      getTransition() {
        return e.extend({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
      }
      serialize() {
        const t = this.map.getCameraPosition();
        return e.filterObject(
          {
            version: this.stylesheet.version,
            name: this.stylesheet.name,
            metadata: e.combine(this.stylesheet.metadata, {
              nearDetection: this.map._nearDetection,
              enableNormal: this.map._enableNormal,
              resolvePass: this.map._resolvePass,
            }),
            sprite: this.stylesheet.sprite,
            glyphs: this.stylesheet.glyphs,
            transition: this.stylesheet.transition,
            sources: e.mapObject(this.sourceCaches, (e) => e.serialize()),
            layers: this._serializeLayers(this._order),
            IBL: this.stylesheet.IBL,
            animations: e.defined(this.map.animationManager.serialize())
              ? this.map.animationManager.serialize().contents
              : void 0,
            camera: {
              position: [t.x, t.y, t.z],
              pitch: this.map.getCameraPitch(),
              bearing: this.map.getCameraBearing(),
              roll: this.map.getCameraRoll(),
            },
            projection: this.map.projection,
            postProcess: this.map.postProcessStages.serialize(),
            videoProjection: this.map.videoManager.serialize(),
            analysis: {
              cutFill: this.map.analysis.cutFillCollection.serialize(),
              viewDome: this.map.analysis.viewDomeCollection.serialize(),
              viewshed: this.map.analysis.viewshed3DCollection.serialize(),
              sightLine: this.map.analysis.sightlineCollection.serialize(),
              excavation: this.map.analysis.excavationCollection.serialize(),
              highlight: this.map.analysis.highlightCollection.serialize(),
            },
            lights: this.map.painter.frameState.lightSerialize(),
            sceneComponent: {
              sceneModels: this.modelCollection.serialize(),
              sceneTilesets: this.tilesetCollection.serialize(),
              primitives: this.primitiveCollection.serialize(),
              sceneObjects: this.sceneObjectCollection.serialize(),
              skybox: e.defined(this.skybox) ? this.skybox.serialize() : void 0,
            },
            terrain: this.terrainSourceCache.serialize(),
            particleSystem: {},
          },
          (e) => void 0 !== e,
        );
      }
      roughSerialize() {
        return e.filterObject(
          {
            version: this.stylesheet.version,
            name: this.stylesheet.name,
            metadata: this.stylesheet.metadata,
            center: this.stylesheet.center,
            zoom: this.stylesheet.zoom,
            bearing: this.stylesheet.bearing,
            pitch: this.stylesheet.pitch,
            sprite: this.stylesheet.sprite,
            glyphs: this.stylesheet.glyphs,
            transition: this.stylesheet.transition,
            sources: this.sourceCaches,
            layers: this._serializeLayers(this._order),
          },
          (e) => void 0 !== e,
        );
      }
      _updateLayer(e) {
        (this._updatedLayers[e.id] = !0),
          e.source &&
            !this._updatedSources[e.source] &&
            ((this._updatedSources[e.source] = 'reload'), this.sourceCaches[e.source].pause()),
          (this._changed = !0);
      }
      _flattenRenderedFeatures(e) {
        const t = [],
          i = [];
        for (let s = this._order.length - 1; s >= 0; s--) {
          const r = this._order[s];
          for (const s of e) {
            const e = s[r],
              n = this._layers[r].type;
            if (e)
              if (
                'extrusion' === n ||
                'histogram' === n ||
                '3d-tiles' === n ||
                '3d-model' === n ||
                'raster' === n
              )
                for (const t of e) i.push(t);
              else for (const i of e) t.push(i);
          }
        }
        i.sort((e, t) => e.intersectionZ - t.intersectionZ);
        for (const e of i) t.push(e);
        return t;
      }
      queryRenderedFeatures(t, i, s, r) {
        i &&
          i.filter &&
          this._validate(e.validateStyle.filter, 'queryRenderedFeatures.filter', i.filter);
        const n = {};
        if (i && i.layers) {
          if (!Array.isArray(i.layers))
            return (
              this.fire(new e.ErrorEvent(new Error('parameters.layers must be an Array.'))), []
            );
          for (const e of i.layers) {
            const t = this._layers[e];
            if (!t) return [];
            n[t.source] = !0;
          }
        }
        const o = [];
        (i.availableImages = this._availableImages),
          (this.ray = this.map.painter.getPickRay(t[0])),
          this.fire(new e.Event('data', {}));
        for (const e in this.sourceCaches) {
          if (i.layers && !n[e]) continue;
          const a = this.sourceCaches[e].getSource().type;
          '3d-tiles' === a ||
            '3d-model' === a ||
            (o.push(Mo(this.sourceCaches[e], this._layers, t, i, s)),
            i.modelHighlight || o.push(Po(this.sourceCaches[e], this._layers, t, i, s, r)));
        }
        return (
          this.placement &&
            o.push(
              (function (e, t, i, s, r) {
                const n = {},
                  o = r.getFeatureByGPUPick(i[0]);
                if (o && o.isSymbolData) {
                  const e = o.evaluate();
                  -1 !== s.layers.indexOf(e.layer.id) && (n[e.layer.id] = [e]);
                }
                for (const i in n)
                  n[i].forEach((s) => {
                    const r = t[e[i].source].getFeatureState(s.layer['source-layer'], s.id);
                    (s.source = s.layer.source),
                      s.layer['source-layer'] && (s.sourceLayer = s.layer['source-layer']),
                      (s.state = r);
                  });
                return n;
              })(this._layers, this.sourceCaches, t, i, this.map.painter),
            ),
          this._flattenRenderedFeatures(o)
        );
      }
      querySourceFeatures(t, i) {
        i &&
          i.filter &&
          this._validate(e.validateStyle.filter, 'querySourceFeatures.filter', i.filter);
        const s = this.sourceCaches[t];
        return s
          ? (function (e, t) {
              const i = e.getRenderableIds().map((t) => e.getTileByID(t)),
                s = [],
                r = {};
              for (let e = 0; e < i.length; e++) {
                const n = i[e],
                  o = n.tileID.canonical.key;
                r[o] || ((r[o] = !0), n.querySourceFeatures(s, t));
              }
              return s;
            })(s, i)
          : [];
      }
      addSourceType(e, t, i) {
        return zh.getSourceType(e)
          ? i(new Error(`A source type called "${e}" already exists.`))
          : (zh.setSourceType(e, t),
            t.workerSourceURL
              ? void this.dispatcher.broadcast(
                  'loadWorkerSource',
                  { name: e, url: t.workerSourceURL },
                  i,
                )
              : i(null, null));
      }
      _validate(t, i, s, r, n) {
        return (
          (!n || !1 !== n.validate) &&
          kh(
            this,
            t.call(
              e.validateStyle,
              e.extend({ key: i, style: this.serialize(), value: s, styleSpec: e.spec }, r),
            ),
          )
        );
      }
      _remove() {
        this._request && (this._request.cancel(), (this._request = null)),
          this._spriteRequest && (this._spriteRequest.cancel(), (this._spriteRequest = null)),
          e.evented.off('pluginStateChange', this._rtlTextPluginCallback);
        for (const e in this._layers)
          this._layers[e].setEventedParent(null), delete this._layers[e];
        for (const e in this.sourceCaches)
          this.sourceCaches[e].clearTiles(),
            this.sourceCaches[e].setEventedParent(null),
            delete this.sourceCaches[e];
        this.performanceManager.resourcePerformaceManager.updateSourceCaches.length > 0 &&
          (this.map.off('moveend', this._performanceManagerEvent),
          this.map.off('handler-moveend', this._performanceManagerEvent),
          (this.performanceManager = null)),
          this.imageManager.setEventedParent(null),
          this.setEventedParent(null),
          this.dispatcher.remove(),
          this.backgroundDepthRenderLayer.setEventedParent(null),
          this.backgroundSourceCache.clearTiles(),
          this.debugBoundingBoxPrimitiveCollection.removeAll(!0),
          this.imageManager.destroy(),
          this.lineAtlas.destroy(),
          this.primitiveCollection.destroy(),
          this.primitivePreRenderCollection.destroy(),
          this.sceneObjectCollection.destroy(),
          this.scenePointPrimitiveCollection.destroy(),
          (this.stylesheet = void 0),
          this.terrainSourceCache.setEventedParent(null),
          this.terrainSourceCache.clearTiles(null),
          (this._availableImages = []),
          (this._order = []),
          (this._originalLayer = []),
          this.tilesetCollection.destroy(),
          e.defined(this.skybox) && this.skybox.destroy();
      }
      _clearSource(e) {
        this.sourceCaches[e].clearTiles();
      }
      _reloadSource(e) {
        this.sourceCaches[e].resume(), this.sourceCaches[e].reload();
      }
      _updateSources() {
        this.map.manageRequestPerformance.enabled
          ? (this.performanceManager.startAction(),
            this.pmTimeout && (clearTimeout(this.pmTimeout), (this.pmTimeout = null)),
            (this.pmTimeout = setTimeout(() => {
              this.performanceManager &&
                !this.performanceManager.isStopped() &&
                this.performanceManager.stopAction();
            }, this.map.manageRequestPerformance.duration)))
          : this.performanceManager.stopAction();
      }
      _generateCollisionBoxes() {
        for (const e in this.sourceCaches) this._reloadSource(e);
      }
      _updatePlacement(t, i, s, r, n = !1) {
        let o = !1,
          a = !1;
        const l = {};
        for (const e of this._order) {
          const t = this._layers[e];
          if ('symbol' !== t.type && 'symtracking' !== t.type) continue;
          if (!l[t.source]) {
            const e = this.sourceCaches[t.source];
            l[t.source] = e
              .getRenderableIds()
              .map((t) => e.getTileByID(t))
              .sort(
                (e, t) =>
                  ('string' != typeof e.tileID && 'string' != typeof t.tileID
                    ? t.tileID.overscaledZ - e.tileID.overscaledZ
                    : 0) ||
                  ('string' != typeof e.tileID &&
                  'string' != typeof t.tileID &&
                  e.tileID.isLessThan(t.tileID)
                    ? -1
                    : 1),
              );
          }
          const i = this.crossTileSymbolIndex.addLayer(t, l[t.source]);
          o = o || i;
        }
        if (
          (this.crossTileSymbolIndex.pruneUnusedLayers(this._order),
          ((n = n || this._layerOrderChanged || 0 === s) ||
            !this.pauseablePlacement ||
            (this.pauseablePlacement.isDone() && !this.placement.stillRecent(e.exported.now()))) &&
            ((this.pauseablePlacement = new _a(this, t, this._order, n, i, s, r)),
            (this._layerOrderChanged = !1)),
          this.pauseablePlacement.isDone()
            ? this.placement.setStale()
            : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l),
              this.pauseablePlacement.isDone() &&
                ((this.placement = this.pauseablePlacement.commit(
                  this.placement,
                  e.exported.now(),
                )),
                (a = !0)),
              o && this.pauseablePlacement.placement.setStale()),
          a || o)
        )
          for (const e of this._order) {
            const t = this._layers[e];
            ('symbol' !== t.type && 'symtracking' !== t.type) ||
              this.placement.updateLayerOpacities(t, l[t.source]);
          }
        return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(e.exported.now());
      }
      _releaseSymbolFadeTiles() {
        for (const e in this._sourceCaches) this._sourceCaches[e].releaseSymbolFadeTiles();
      }
      getImages(e, t, i) {
        this.imageManager.getImages(t.icons, i), this._updateTilesForChangedImages();
        const s = this.sourceCaches[t.source];
        s && s.setDependencies(t.tileID.key, t.type, t.icons);
      }
      getGlyphs(e, t, i) {
        this.glyphManager.getGlyphs(t.stacks, i);
      }
      getResource(t, i, s) {
        return e.makeRequest(i, s);
      }
      clearWorkerCaches() {
        this.dispatcher.broadcast('clearCaches');
      }
      get skybox() {
        return this._skybox;
      }
      get isSkyboxReady() {
        return this._skybox && this._skybox.ready;
      }
      getNearestTileZoom() {
        return this.map.transform.zoom;
      }
    }
    (zh.getSourceType = function (e) {
      return Co[e];
    }),
      (zh.setSourceType = function (e, t) {
        Co[e] = t;
      }),
      (zh.registerForPluginStateChange = e.registerForPluginStateChange);
    class Hh {
      constructor(e) {
        (this.context = e), (this.default = null), (this.current = this.default), (this.dirty = !1);
      }
      get() {
        return this.current;
      }
      setDefault() {
        this.set(this.default);
      }
      set(e) {
        (this.current === e && !0 !== this.dirty) ||
          (this.context.gl.useProgram(e), (this.current = e), (this.dirty = !1));
      }
    }
    class Wh {
      constructor(t) {
        (this.context = t),
          (this.default = e.CONSTS.GL_CONST.MODEL_TEXTURE_UNIT1.VALUE),
          (this.current = this.default),
          (this.dirty = !1);
      }
      get() {
        return this.current;
      }
      setDefault() {
        this.set(this.default);
      }
      set(e) {
        (this.current === e && !0 !== this.dirty) ||
          (this.context.gl.activeTexture(e), (this.current = e), (this.dirty = !1));
      }
    }
    class jh {
      constructor(e) {
        (this.context = e), (this.default = null), (this.current = this.default), (this.dirty = !1);
      }
      get() {
        return this.current;
      }
      setDefault() {
        this.set(this.default);
      }
      set(t) {
        (this.current === t && !0 !== this.dirty) ||
          (this.context.gl.bindFramebuffer(e.WebGLConstants.FRAMEBUFFER, t),
          (this.current = t),
          (this.dirty = !1));
      }
    }
    class qh {
      constructor(e) {
        (this.context = e), (this.default = null), (this.current = this.default), (this.dirty = !1);
      }
      get() {
        return this.current;
      }
      setDefault() {
        this.set(this.default);
      }
      set(t) {
        (this.current === t && !0 !== this.dirty) ||
          (this.context.gl.bindRenderbuffer(e.WebGLConstants.RENDERBUFFER, t),
          (this.current = t),
          (this.dirty = !1));
      }
    }
    class Xh {
      constructor(e) {
        (this.context = e), (this.default = null), (this.current = this.default), (this.dirty = !1);
      }
      get() {
        return this.current;
      }
      setDefault() {
        this.set(this.default);
      }
      set(t) {
        (this.current === t && !0 !== this.dirty) ||
          (this.context.gl.bindTexture(e.WebGLConstants.TEXTURE_2D, t),
          (this.current = t),
          (this.dirty = !1));
      }
    }
    class Zh {
      constructor(e) {
        (this.context = e), (this.default = null), (this.current = this.default), (this.dirty = !1);
      }
      get() {
        return this.current;
      }
      setDefault() {
        this.set(this.default);
      }
      set(t) {
        (this.current === t && !0 !== this.dirty) ||
          (this.context.gl.bindBuffer(e.WebGLConstants.ARRAY_BUFFER, t),
          (this.current = t),
          (this.dirty = !1));
      }
    }
    class $h {
      constructor(e) {
        (this.context = e), (this.default = null), (this.current = this.default), (this.dirty = !1);
      }
      get() {
        return this.current;
      }
      setDefault() {
        this.set(this.default);
      }
      set(t) {
        this.context.gl.bindBuffer(e.WebGLConstants.ELEMENT_ARRAY_BUFFER, t),
          (this.current = t),
          (this.dirty = !1);
      }
    }
    class Kh {
      constructor(e) {
        (this.context = e), (this.default = null), (this.current = this.default), (this.dirty = !1);
      }
      get() {
        return this.current;
      }
      setDefault() {
        this.set(this.default);
      }
      set(e) {
        ((this.current !== e && this.context.extVertexArrayObject) || !0 === this.dirty) &&
          (this.context.extVertexArrayObject.bindVertexArrayOES(e),
          (this.current = e),
          (this.dirty = !1));
      }
    }
    class Yh {
      constructor(e) {
        (this.context = e), (this.default = 4), (this.current = this.default), (this.dirty = !1);
      }
      get() {
        return this.current;
      }
      setDefault() {
        this.set(this.default);
      }
      set(t) {
        (this.current === t && !0 !== this.dirty) ||
          (this.context.gl.pixelStorei(e.WebGLConstants.UNPACK_ALIGNMENT, t),
          (this.current = t),
          (this.dirty = !1));
      }
    }
    class Qh {
      constructor(e) {
        (this.context = e), (this.default = !1), (this.current = this.default), (this.dirty = !1);
      }
      get() {
        return this.current;
      }
      setDefault() {
        this.set(this.default);
      }
      set(t) {
        (this.current === t && !0 !== this.dirty) ||
          (this.context.gl.pixelStorei(e.WebGLConstants.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t),
          (this.current = t),
          (this.dirty = !1));
      }
    }
    class Jh {
      constructor(e) {
        (this.context = e), (this.default = !1), (this.current = this.default), (this.dirty = !1);
      }
      get() {
        return this.current;
      }
      setDefault() {
        this.set(this.default);
      }
      set(t) {
        (this.current === t && !0 !== this.dirty) ||
          (this.context.gl.pixelStorei(e.WebGLConstants.UNPACK_FLIP_Y_WEBGL, t),
          (this.current = t),
          (this.dirty = !1));
      }
    }
    class ec {
      constructor(e) {
        (this.context = e),
          (this.default = { red: !0, green: !0, blue: !0, alpha: !0 }),
          (this.current = this.default),
          (this.dirty = !1);
      }
      get() {
        return this.current;
      }
      setDefault() {
        this.set(this.default);
      }
      set(e) {
        const t = this.current;
        (e.red === t.red &&
          e.green === t.green &&
          e.blue === t.blue &&
          e.alpha === t.alpha &&
          !0 !== this.dirty) ||
          (this.context.gl.colorMask(e.red, e.green, e.blue, e.alpha),
          (this.current = e),
          (this.dirty = !1));
      }
    }
    class tc {
      constructor(e) {
        (this.context = e), (this.default = 255), (this.current = this.default), (this.dirty = !1);
      }
      get() {
        return this.current;
      }
      setDefault() {
        this.set(this.default);
      }
      set(e) {
        (this.current === e && !0 !== this.dirty) ||
          (this.context.gl.stencilMask(e), (this.current = e), (this.dirty = !1));
      }
    }
    class ic {
      constructor(e) {
        (this.context = e), (this.default = !0), (this.current = this.default), (this.dirty = !1);
      }
      get() {
        return this.current;
      }
      setDefault() {
        this.set(this.default);
      }
      set(e) {
        (this.current === e && !0 !== this.dirty) ||
          (this.context.gl.depthMask(e), (this.current = e), (this.dirty = !1));
      }
    }
    class sc {
      constructor(e) {
        (this.context = e),
          (this.default = { near: 0, far: 1 }),
          (this.current = this.default),
          (this.dirty = !1);
      }
      get() {
        return this.current;
      }
      setDefault() {
        this.set(this.default);
      }
      set(e) {
        const t = this.current;
        (e.near === t.near && e.far === t.far && !0 !== this.dirty) ||
          (this.context.gl.depthRange(e.near, e.far), (this.current = e), (this.dirty = !1));
      }
    }
    class rc {
      constructor(t) {
        (this.context = t),
          (this.default = { enabled: !1, face: e.WebGLConstants.BACK }),
          (this.current = this.default),
          (this.dirty = !1);
      }
      get() {
        return this.current;
      }
      setDefault() {
        this.set(this.default);
      }
      set(e) {
        if (
          this.current.enabled !== e.enabled ||
          this.current.face !== e.face ||
          !0 === this.dirty
        ) {
          const t = this.context.gl;
          dc(t, t.CULL_FACE, e.enabled),
            e.enabled && t.cullFace(e.face),
            (this.current = e),
            (this.dirty = !1);
        }
      }
    }
    class nc {
      constructor(e) {
        (this.context = e),
          (this.current = this.context.gl.CCW),
          (this.default = this.context.gl.CCW),
          (this.dirty = !1);
      }
      set(e) {
        e !== this.current && (this.context.gl.frontFace(e), (this.current = e));
      }
      get() {
        return this.current || this.context.gl.CCW;
      }
      setDefault() {
        this.set(this.default);
      }
    }
    class oc {
      constructor(e) {
        this.context = e;
        const t = this.context.gl;
        (this.default = { x: 0, y: 0, width: t.drawingBufferWidth, height: t.drawingBufferHeight }),
          (this.current = this.default),
          (this.dirty = !1);
      }
      get() {
        return this.current;
      }
      setDefault() {
        this.set(this.default);
      }
      set(e) {
        const t = this.current;
        (e.x === t.x &&
          e.y === t.y &&
          e.width === t.width &&
          e.height === t.height &&
          !0 !== this.dirty) ||
          (this.context.gl.viewport(e.x, e.y, e.width, e.height), (this.dirty = !1)),
          (this.current = e);
      }
    }
    class ac {
      constructor(e) {
        this.context = e;
        const t = this.context.gl;
        (this.default = { x: 0, y: 0, width: t.drawingBufferWidth, height: t.drawingBufferHeight }),
          (this.current = this.default),
          (this.dirty = !1);
      }
      get() {
        return this.current;
      }
      setDefault() {
        this.set(this.default);
      }
      set(e) {
        const t = this.current,
          i = this.context.gl;
        (e.x === t.x &&
          e.y === t.y &&
          e.width === t.width &&
          e.height === t.height &&
          !0 !== this.dirty) ||
          (dc(i, i.SCISSOR_TEST, e.enabled),
          e.enabled &&
            i.scissor(e.rectangle.x, e.rectangle.y, e.rectangle.width, e.rectangle.height),
          (this.current = e));
      }
    }
    class lc {
      constructor(t) {
        (this.context = t),
          (this.default = {
            enabled: !1,
            color: { red: 0, green: 0, blue: 0, alpha: 0 },
            equationRgb: e.WebGLConstants.FUNC_ADD,
            equationAlpha: e.WebGLConstants.FUNC_ADD,
            functionSourceRgb: e.WebGLConstants.ONE,
            functionSourceAlpha: e.WebGLConstants.ONE,
            functionDestinationRgb: e.WebGLConstants.ZERO,
            functionDestinationAlpha: e.WebGLConstants.ZERO,
          }),
          (this.current = this.default),
          (this.dirty = !1);
      }
      get() {
        return this.current;
      }
      setDefault() {
        this.set(this.default);
      }
      set(e) {
        const t = this.current,
          i = this.context.gl;
        (e.enabled == t.enabled &&
          e.equationRgb == t.equationRgb &&
          e.equationAlpha == t.equationAlpha &&
          e.functionSourceRgb == t.functionSourceRgb &&
          e.functionSourceAlpha == t.functionSourceAlpha &&
          e.functionDestinationRgb == t.functionDestinationRgb &&
          e.functionDestinationAlpha == t.functionDestinationAlpha &&
          e.color.red == t.color.red &&
          e.color.green == t.color.green &&
          e.color.blue == t.color.blue &&
          e.color.alpha == t.color.alpha &&
          !0 !== this.dirty) ||
          (dc(i, i.BLEND, e.enabled),
          e.enabled &&
            (i.blendColor(e.color.red, e.color.green, e.color.blue, e.color.alpha),
            i.blendEquationSeparate(e.equationRgb, e.equationAlpha),
            i.blendFuncSeparate(
              e.functionSourceRgb,
              e.functionDestinationRgb,
              e.functionSourceAlpha,
              e.functionDestinationAlpha,
            )),
          (this.current = e));
      }
    }
    class hc {
      constructor(t) {
        (this.context = t),
          (this.default = {
            enabled: !1,
            frontFunction: e.WebGLConstants.ALWAYS,
            backFunction: e.WebGLConstants.ALWAYS,
            reference: 0,
            mask: -1,
            frontOperation: {
              fail: e.WebGLConstants.KEEP,
              zFail: e.WebGLConstants.KEEP,
              zPass: e.WebGLConstants.KEEP,
            },
            backOperation: {
              fail: e.WebGLConstants.KEEP,
              zFail: e.WebGLConstants.KEEP,
              zPass: e.WebGLConstants.KEEP,
            },
          }),
          (this.current = this.default),
          (this.dirty = !1);
      }
      get() {
        return this.current;
      }
      setDefault() {
        this.set(this.default);
      }
      set(e) {
        const t = this.current,
          i = this.context.gl;
        if (
          e.enabled !== t.enabled ||
          e.frontOperation.fail !== t.frontOperation.fail ||
          e.frontOperation.zFail !== t.frontOperation.zFail ||
          e.frontOperation.zPass !== t.frontOperation.zPass ||
          e.backOperation.fail !== t.backOperation.fail ||
          e.backOperation.zFail !== t.backOperation.zFail ||
          e.backOperation.zPass !== t.backOperation.zPass ||
          e.frontFunction !== t.frontFunction ||
          e.backFunction !== t.backFunction ||
          e.reference !== t.reference ||
          e.mask !== t.mask ||
          !0 === this.dirty
        ) {
          if ((dc(i, i.STENCIL_TEST, e.enabled), e.enabled)) {
            const t = e.frontFunction,
              s = e.backFunction,
              r = e.reference,
              n = e.mask;
            i.stencilFunc(t, r, n),
              i.stencilFuncSeparate(i.BACK, s, r, n),
              i.stencilFuncSeparate(i.FRONT, t, r, n);
            const o = e.frontOperation;
            i.stencilOpSeparate(i.FRONT, o.fail, o.zFail, o.zPass);
            const a = e.backOperation;
            i.stencilOpSeparate(i.BACK, a.fail, a.zFail, a.zPass);
          }
          this.current = e;
        }
      }
    }
    class cc {
      constructor(t) {
        (this.context = t),
          (this.default = { enabled: !1, func: e.WebGLConstants.LESS }),
          (this.current = this.default),
          (this.dirty = !1);
      }
      get() {
        return this.current;
      }
      setDefault() {
        this.set(this.default);
      }
      set(e) {
        const t = this.current,
          i = this.context.gl;
        (e.enabled === t.enabled && e.func === t.func && !0 !== this.dirty) ||
          (dc(i, i.DEPTH_TEST, e.enabled), e.enabled && i.depthFunc(e.func), (this.current = e));
      }
    }
    class _c {
      constructor(e) {
        (this.context = e),
          (this.default = { enabled: !1, factor: 0, units: 0 }),
          (this.current = this.default),
          (this.dirty = !1);
      }
      get() {
        return this.current;
      }
      setDefault() {
        this.set(this.default);
      }
      set(e) {
        const t = this.current,
          i = this.context.gl;
        (e.enabled === t.enabled &&
          e.factor === t.factor &&
          e.units === t.units &&
          !0 !== this.dirty) ||
          (dc(i, i.POLYGON_OFFSET_FILL, e.enabled),
          e.enabled && i.polygonOffset(e.factor, e.units),
          (this.current = e));
      }
    }
    class uc {
      constructor(e) {
        (this.context = e),
          (this.default = { enabled: !1, value: 1, invert: !1 }),
          (this.current = this.default),
          (this.dirty = !1);
      }
      get() {
        return this.current;
      }
      setDefault() {
        this.set(this.default);
      }
      set(e) {
        const t = this.current,
          i = this.context.gl;
        (e.enabled === t.enabled &&
          e.invert === t.invert &&
          e.value === t.value &&
          !0 !== this.dirty) ||
          (dc(this.context, i.SAMPLE_COVERAGE, e.enabled),
          e.enabled && i.sampleCoverage(e.value, e.invert),
          (this.current = e));
      }
    }
    function dc(e, t, i) {
      i ? e.enable(t) : e.disable(t);
    }
    class mc {
      constructor(t, i) {
        (this.painter = i),
          (this.gl = t),
          (this._logDepth = !1),
          (this.program = new Hh(this)),
          (this.activeTexture = new Wh(this)),
          (this.bindFramebuffer = new jh(this)),
          (this.bindRenderbuffer = new qh(this)),
          (this.bindTexture = new Xh(this)),
          (this.bindVertexBuffer = new Zh(this)),
          (this.bindElementBuffer = new $h(this)),
          (this.bindVertexArrayOES = new Kh(this)),
          (this.pixelStoreUnpack = new Yh(this)),
          (this.pixelStoreUnpackPremultiplyAlpha = new Qh(this)),
          (this.pixelStoreUnpackFlipY = new Jh(this)),
          (this._pickObjects = {}),
          (this._nextPickColor = new Uint32Array(1)),
          (this._Program = void 0),
          (this.supportPBR = !0),
          (e.ContextLimits._maximumCombinedTextureImageUnits = t.getParameter(
            t.MAX_COMBINED_TEXTURE_IMAGE_UNITS,
          )),
          (e.ContextLimits._maximumCubeMapSize = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE)),
          (e.ContextLimits._maximumFragmentUniformVectors = t.getParameter(
            t.MAX_FRAGMENT_UNIFORM_VECTORS,
          )),
          (e.ContextLimits._maximumTextureImageUnits = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)),
          (e.ContextLimits._maximumRenderbufferSize = t.getParameter(t.MAX_RENDERBUFFER_SIZE)),
          (e.ContextLimits._maximumTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE)),
          (e.ContextLimits._maximumVaryingVectors = t.getParameter(t.MAX_VARYING_VECTORS)),
          (e.ContextLimits._maximumVertexAttributes = t.getParameter(t.MAX_VERTEX_ATTRIBS)),
          (e.ContextLimits._maximumVertexTextureImageUnits = t.getParameter(
            t.MAX_VERTEX_TEXTURE_IMAGE_UNITS,
          )),
          (e.ContextLimits._maximumVertexUniformVectors = t.getParameter(
            t.MAX_VERTEX_UNIFORM_VECTORS,
          ));
        const s = t.getParameter(t.ALIASED_LINE_WIDTH_RANGE);
        (e.ContextLimits._minimumAliasedLineWidth = s[0]),
          (e.ContextLimits._maximumAliasedLineWidth = s[1]);
        const r = t.getParameter(t.ALIASED_POINT_SIZE_RANGE);
        (e.ContextLimits._minimumAliasedPointSize = r[0]),
          (e.ContextLimits._maximumAliasedPointSize = r[1]);
        const n = t.getParameter(t.MAX_VIEWPORT_DIMS);
        (e.ContextLimits._maximumViewportWidth = n[0]),
          (e.ContextLimits._maximumViewportHeight = n[1]);
        const o = t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT);
        e.ContextLimits._highpFloatSupported = 0 !== o.precision;
        const a = t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_INT);
        (e.ContextLimits._highpIntSupported = 0 !== a.rangeMax),
          (this.extVertexArrayObject = this.gl.getExtension('OES_vertex_array_object')),
          (this.extTextureFilterAnisotropic =
            t.getExtension('EXT_texture_filter_anisotropic') ||
            t.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
            t.getExtension('WEBKIT_EXT_texture_filter_anisotropic')),
          this.extTextureFilterAnisotropic
            ? ((this.extTextureFilterAnisotropicMax = t.getParameter(
                this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT,
              )),
              (e.ContextLimits._maximumTextureFilterAnisotropy =
                this.extTextureFilterAnisotropicMax))
            : (e.ContextLimits._maximumTextureFilterAnisotropy = 1),
          (this.drawBuffers = fc(t, ['WEBGL_draw_buffers'])),
          (e.ContextLimits._maximumDrawBuffers = this.drawBuffers
            ? t.getParameter(e.WebGLConstants.MAX_DRAW_BUFFERS)
            : 1),
          (e.ContextLimits._maximumColorAttachments = this.drawBuffers
            ? t.getParameter(e.WebGLConstants.MAX_COLOR_ATTACHMENTS)
            : 1),
          (this.extDebugShaders = fc(t, ['WEBGL_debug_shaders'])),
          (this.extTextureFloat = !!fc(t, ['OES_texture_float'])),
          (this.extTextureHalfFloat = t.getExtension('OES_texture_half_float')),
          this.extTextureHalfFloat && t.getExtension('OES_texture_half_float_linear'),
          (this.extTextureFloatLinear = !!fc(t, ['OES_texture_float_linear'])),
          (this.extColorBufferFloat = !!fc(t, [
            'EXT_color_buffer_float',
            'WEBGL_color_buffer_float',
          ])),
          (this.extFloatBlend = !!fc(t, ['EXT_float_blend'])),
          (this.extColorBufferHalfFloat = !!fc(t, ['EXT_color_buffer_half_float'])),
          (this.hasDerivativesExt = t.getExtension('OES_standard_derivatives')),
          null == this.hasDerivativesExt &&
            ((this.supportPBR = !1), e.warnOnce('OES_standard_Derivatives are not supported')),
          (this.drawInstance = t.getExtension('ANGLE_instanced_arrays')),
          null == this.drawInstance && e.warnOnce('ANGLE_instanced_arraysd'),
          null == t.getExtension('EXT_SRGB') &&
            ((this.supportPBR = !1), e.warnOnce('EXT_SRGB are not supported')),
          (this.hasLODExtension = t.getExtension('EXT_shader_texture_lod')),
          null == this.hasLODExtension &&
            ((this.supportPBR = !1), e.warnOnce('EXT_shader_texture_lod are not supported')),
          (this.extDepthTexture = !!fc(t, ['WEBGL_depth_texture', 'WEBKIT_WEBGL_depth_texture'])),
          (this.extBlendMinmax = !!fc(t, ['EXT_blend_minmax'])),
          this.extElementIndexUint || t.getExtension('OES_element_index_uint');
        const l = t.getSupportedExtensions();
        for (let e = 0; e < l.length; e++)
          'EXT_frag_depth' === l[e] && (this.extFragDepth = t.getExtension('EXT_frag_depth'));
        (this.maxTextureSize = t.getParameter(e.WebGLConstants.MAX_TEXTURE_SIZE)),
          (this._s3tc = !!fc(t, [
            'WEBGL_compressed_texture_s3tc',
            'MOZ_WEBGL_compressed_texture_s3tc',
            'WEBKIT_WEBGL_compressed_texture_s3tc',
          ])),
          (this._pvrtc = !!fc(t, [
            'WEBGL_compressed_texture_pvrtc',
            'WEBKIT_WEBGL_compressed_texture_pvrtc',
          ])),
          (this._etc1 = !!fc(t, ['WEBGL_compressed_texture_etc1'])),
          (this._astc = !!fc(t, ['WEBGL_compressed_texture_astc'])),
          (this._etc = !!fc(t, ['WEBG_compressed_texture_etc'])),
          (this._bc7 = !!fc(t, ['EXT_texture_compression_bptc'])),
          (this._colorMask = new ec(this)),
          (this._stencilMask = new tc(this)),
          (this._depthMask = new ic(this)),
          (this._depthRange = new sc(this)),
          (this._cullFace = new rc(this)),
          (this._frontFace = new nc(this)),
          (this.viewport = new oc(this)),
          (this._viewport = this.viewport),
          (this._scissorTest = new ac(this)),
          (this._blending = new lc(this)),
          (this._stencilTest = new hc(this)),
          (this._depthTest = new cc(this)),
          (this._polygonOffset = new _c(this)),
          (this._sampleCoverage = new uc(this)),
          (this._defaultTexture = void 0),
          (this._maxFrameTextureUnitIndex = 0),
          (this._clearDepth = 1),
          (this._enableNormal = !1);
      }
      get defaultTexture() {
        return (
          this._defaultTexture ||
            (this._defaultTexture = new e.Texture({
              context: this,
              source: {
                width: 1,
                height: 1,
                arrayBufferView: new Uint8Array([255, 255, 255, 255]),
              },
              flipY: !1,
            })),
          this._defaultTexture
        );
      }
      get drawingBufferHeight() {
        return this.gl.drawingBufferHeight;
      }
      get floatingPointTexture() {
        return this.extTextureFloat;
      }
      get drawingBufferWidth() {
        return this.gl.drawingBufferWidth;
      }
      setDirty() {
        (this.program.dirty = !0),
          (this.activeTexture.dirty = !0),
          (this.bindFramebuffer.dirty = !0),
          (this.bindRenderbuffer.dirty = !0),
          (this.bindTexture.dirty = !0),
          (this.bindVertexBuffer.dirty = !0),
          (this.bindElementBuffer.dirty = !0),
          this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = !0),
          (this.pixelStoreUnpack.dirty = !0),
          (this.pixelStoreUnpackPremultiplyAlpha.dirty = !0),
          (this.pixelStoreUnpackFlipY.dirty = !0);
      }
      createIndexBuffer(e, t) {
        return new Ns(this, e, t);
      }
      createVertexBuffer(t, i, s) {
        return new e.VertexBuffer({ context: this, array: t, attributes: i, dynamicDraw: s });
      }
      createRenderbuffer(t, i, s) {
        const r = this.gl,
          n = r.createRenderbuffer();
        return (
          this.bindRenderbuffer.set(n),
          r.renderbufferStorage(e.WebGLConstants.RENDERBUFFER, t, i, s),
          this.bindRenderbuffer.set(null),
          n
        );
      }
      createFramebuffer(t, i) {
        return new e.Framebuffer({
          context: this,
          width: t,
          height: i,
          colorTextures: [
            new e.Texture({
              image: null,
              context: this,
              width: t,
              height: i,
              pixelFormat: e.WebGLConstants.RGBA,
            }),
          ],
          depthStencilTexture: new e.Texture({
            context: this,
            width: t,
            height: i,
            pixelFormat: e.PixelFormat.DEPTH_STENCIL,
            pixelDatatype: e.PixelDatatype.UNSIGNED_INT_24_8,
            sampler: e.Sampler.NEAREST,
          }),
        });
      }
      draw(t) {
        const {
            painter: i,
            layer: s,
            framebuffer: r,
            clearStates: n,
            frameState: o,
            material: { renderState: a, _uniforms: l, _shaderSource: h, _programConfiguration: c },
            geometry: {
              primitiveType: _,
              _vertBuffer: u,
              _indexBuffer: d,
              _segmentVector: m,
              dynamicLayoutBuffer1: p,
              dynamicLayoutBuffer2: f,
              dynamicLayoutBuffer3: g,
              animationVertexBuffers: y,
              instanceVerterBuffers: T,
            },
          } = t,
          x = i.useProgram(h, c);
        if (
          (this.bindFramebuffer.set(r),
          this.setRenderState(a, n, i),
          c &&
            c.setUniforms(this, x.binderUniforms, s.paint, { zoom: i.style.getNearestTileZoom() }),
          x._setUniforms(
            e.defined(t.material.getMinimumUniforms) ? t.material.getMinimumUniforms(o) : l,
          ),
          !e.defined(u) || !e.defined(u.context))
        )
          return;
        let v,
          b = _,
          w = d;
        if (e.defined(s.drawMode)) (b = s.drawMode), (w = t.geometry.wireframeIndexBuffer), (v = 3);
        else if (Array.isArray(s))
          for (let i = 0; i < s.length; i++)
            if (e.defined(s[i].drawMode)) {
              (b = s[i].drawMode), (w = t.geometry.wireframeIndexBuffer), (v = 3);
              break;
            }
        x.draw({
          context: this,
          drawMode: b,
          layerID: s.id,
          layoutVertexBuffer: u,
          indexBuffer: w,
          segments: m,
          configuration: c,
          dynamicLayoutBuffer: p,
          dynamicLayoutBuffer2: f,
          dynamicLayoutBuffer3: g,
          animationVertexBuffers: y,
          instanceVerterBuffers: T,
          numScaleForWireframe: v,
        });
      }
      clear({ color: t, depth: i, stencil: s }) {
        const r = this.gl;
        let n = 0;
        t && ((n |= e.WebGLConstants.COLOR_BUFFER_BIT), r.clearColor(t.r, t.g, t.b, t.a)),
          e.defined(i) &&
            (i !== this._clearDepth && ((this._clearDepth = i), r.clearDepth(i)),
            (n |= e.WebGLConstants.DEPTH_BUFFER_BIT)),
          void 0 !== s && ((n |= e.WebGLConstants.STENCIL_BUFFER_BIT), r.clearStencil(s)),
          r.clear(n);
      }
      setRenderState(t, i, s) {
        (t = t instanceof e.RenderState ? t : e.RenderState.fromCache(t)),
          e.RenderState.applyRenderState(this, t, s),
          e.defined(i) && this.clear({ color: i.color, depth: i.depth, stencil: i.stencil });
      }
      unbindVAO() {
        this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
      }
      createPickId(t) {
        ++this._nextPickColor[0];
        const i = this._nextPickColor[0];
        if (0 === i) throw new Error('Out of unique Pick IDs.');
        return (this._pickObjects[i] = t), new pc(this._pickObjects, i, e.Color.fromRgba(i));
      }
      removePickId(e) {
        e.destroy();
      }
      getObjectByPickColor(e) {
        return this._pickObjects[e.toRgba()];
      }
    }
    class pc {
      constructor(e, t, i) {
        (this._pickObject = e), (this.key = t), (this.color = i);
      }
      get pickObject() {
        return this._pickObject[this.key];
      }
      set pickObject(e) {
        this._pickObject[this.key] = e;
      }
      destroy() {
        (this._pickObject[this.key] = void 0),
          (this._pickObject = void 0),
          (this.color = void 0),
          (this.key = void 0);
      }
    }
    function fc(e, t) {
      const i = t.length;
      for (let s = 0; s < i; ++s) {
        const i = e.getExtension(t[s]);
        if (i) return i;
      }
    }
    const {
        HTMLImageElement: gc,
        HTMLCanvasElement: yc,
        HTMLVideoElement: Tc,
        ImageData: xc,
      } = e.window,
      vc = /uniform\s+sampler2D\s+depthTexture/g;
    class bc {
      constructor(t) {
        const i =
            (t = e.defaultValue(t, e.defaultValue.EMPTY_OBJECT)).vertexShader ||
            e.shaders.screen.vertexSource,
          s = t.fragmentShader,
          r = e.defaultValue(t.textureScale, 1),
          n = e.defaultValue(t.pixelFormat, e.PixelFormat.RGBA);
        if (i.constructor !== String) throw new Error('options.vertexShader must be string!');
        if (s.constructor !== String) throw new Error('options.fragmentShader must be string!');
        if (r <= 0) throw new Error('options.textureScale must be greater than 0!');
        if (r > 1) throw new Error('options.textureScale must be less than 1!');
        if (!e.PixelFormat.isColorFormat(n))
          throw new Error('options.pixelFormat must be a color format.');
        (this._vertexShader = i),
          (this._fragmentShader = s),
          (this._uniforms = t.uniforms),
          (this._textureScale = r),
          (this._forcePowerOfTwo = e.defaultValue(t.forcePowerOfTwo, !1)),
          (this._sampleMode = e.defaultValue(t.sampleMode, 0)),
          (this._pixelFormat = n),
          (this._pixelDatatype = e.defaultValue(t.pixelDatatype, e.PixelDatatype.UNSIGNED_BYTE)),
          (this._clearColor = e.defaultValue(t.clearColor, e.Color.black)),
          (this._command = void 0),
          (this.shaderSource = new e.ShaderSource({
            type: t.name,
            vertexSource: this._vertexShader,
            fragmentSource: this._fragmentShader,
          })),
          (this._colorTexture = void 0),
          (this._depthTexture = void 0),
          (this._idTexture = void 0),
          (this._actualUniforms = {}),
          (this._dirtyUniforms = []),
          (this._texturesToRelease = []),
          (this._texturesToCreate = []),
          (this._texturePromise = void 0);
        const o = {};
        (o.scissorTest = {
          enabled: !0,
          rectangle: e.defined(t.scissorRectangle)
            ? e.BoundingRectangle.clone(t.scissorRectangle)
            : new e.BoundingRectangle(),
        }),
          (this._passState = o),
          (this._renderState = { blending: e.renderStateEnum.disableBlending }),
          (this._ready = !1);
        let a = t.name;
        e.defined(a) || (a = e.uuid()),
          (this._name = a),
          (this._logDepthChanged = void 0),
          (this._useLogDepth = void 0),
          (this._selectedIdTexture = void 0),
          (this._selected = void 0),
          (this._selectedShadow = void 0),
          (this._parentSelected = void 0),
          (this._parentSelectedShadow = void 0),
          (this._combinedSelected = void 0),
          (this._combinedSelectedShadow = void 0),
          (this._selectedLength = 0),
          (this._parentSelectedLength = 0),
          (this._selectedDirty = !0),
          (this._textureCache = void 0),
          (this._index = void 0),
          (this.enabled = !0),
          (this._enabled = !0);
      }
      get ready() {
        return this._ready;
      }
      get name() {
        return this._name;
      }
      get fragmentShader() {
        return this._fragmentShader;
      }
      get uniforms() {
        return this._uniforms;
      }
      get textureScale() {
        return this._textureScale;
      }
      get forcePowerOfTwo() {
        return this._forcePowerOfTwo;
      }
      get sampleMode() {
        return this._sampleMode;
      }
      get pixelFormat() {
        return this._pixelFormat;
      }
      get pixelDatatype() {
        return this._pixelDatatype;
      }
      get clearColor() {
        return this._clearColor;
      }
      get scissorRectangle() {
        return this._passState.scissorTest.rectangle;
      }
      get outputTexture() {
        if (e.defined(this._textureCache)) {
          const t = this._textureCache.getFramebuffer(this._name);
          if (e.defined(t)) return t.getColorTexture(0);
        }
      }
      get selected() {
        return this._selected;
      }
      set selected(e) {
        this._selected = e;
      }
      get parentSelected() {
        return this._parentSelected;
      }
      set parentSelected(e) {
        this._parentSelected = e;
      }
      _isSupported(e) {
        return !vc.test(this._fragmentShader) || e.extDepthTexture;
      }
      update(t, i) {
        if (
          (this.enabled === this._enabled || this.enabled || Pc(this),
          (this._enabled = this.enabled),
          !this._enabled)
        )
          return;
        if (
          ((this._logDepthChanged = i !== this._useLogDepth),
          (this._useLogDepth = i),
          (this._selectedDirty = (function (t) {
            let i = e.defined(t._selected) ? t._selected.length : 0;
            const s = e.defined(t._parentSelected) ? t._parentSelected : 0;
            let r = t._selected !== t._selectedShadow || i !== t._selectedLength;
            if (
              ((r =
                r ||
                t._parentSelected !== t._parentSelectedShadow ||
                s !== t._parentSelectedLength),
              (t._combinedSelected =
                e.defined(t._selected) && e.defined(t._parentSelected)
                  ? t._selected.concat(t._parentSelected)
                  : e.defined(t._parentSelected)
                  ? t._parentSelected
                  : t._selected),
              !r && e.defined(t._combinedSelected))
            ) {
              if (!e.defined(t._combinedSelectedShadow)) return !0;
              i = t._combinedSelected.length;
              for (let e = 0; e < i; ++e)
                if (t._combinedSelected[e] !== t._combinedSelectedShadow[e]) return !0;
            }
            return r;
          })(this)),
          (this._selectedShadow = this._selected),
          (this._parentSelectedShadow = this._parentSelected),
          (this._combinedSelectedShadow = this._combinedSelected),
          (this._selectedLength = e.defined(this._selected) ? this._selected.length : 0),
          (this._parentSelectedLength = e.defined(this._parentSelected)
            ? this._parentSelected.length
            : 0),
          (function (t, i) {
            if (!t._selectedDirty) return;
            (t._selectedIdTexture = t._selectedIdTexture && t._selectedIdTexture.destroy()),
              (t._selectedIdTexture = void 0);
            const s = t._combinedSelected;
            if (!e.defined(s)) return;
            let r,
              n,
              o = 0;
            const a = s.length;
            for (r = 0; r < a; ++r)
              (n = s[r]),
                e.defined(n.pickIds) ? (o += n.pickIds.length) : e.defined(n.pickId) && ++o;
            if (0 === a || 0 === o) {
              const s = new Uint8Array(4);
              return (
                (s[0] = 255),
                (s[1] = 255),
                (s[2] = 255),
                (s[3] = 255),
                void (t._selectedIdTexture = new e.Texture({
                  context: i,
                  pixelFormat: e.PixelFormat.RGBA,
                  pixelDatatype: e.PixelDatatype.UNSIGNED_BYTE,
                  source: { arrayBufferView: s, width: 1, height: 1 },
                  sampler: e.Sampler.NEAREST,
                }))
              );
            }
            let l,
              h = 0;
            const c = new Uint8Array(4 * o);
            for (r = 0; r < a; ++r)
              if (((n = s[r]), e.defined(n.pickIds))) {
                const t = n.pickIds,
                  i = t.length;
                for (let s = 0; s < i; ++s)
                  (l = t[s].color),
                    (c[h] = e.Color.floatToByte(l.red)),
                    (c[h + 1] = e.Color.floatToByte(l.green)),
                    (c[h + 2] = e.Color.floatToByte(l.blue)),
                    (c[h + 3] = e.Color.floatToByte(l.alpha)),
                    (h += 4);
              } else
                e.defined(n.pickId) &&
                  ((l = n.pickId.color),
                  (c[h] = e.Color.floatToByte(l.red)),
                  (c[h + 1] = e.Color.floatToByte(l.green)),
                  (c[h + 2] = e.Color.floatToByte(l.blue)),
                  (c[h + 3] = e.Color.floatToByte(l.alpha)),
                  (h += 4));
            t._selectedIdTexture = new e.Texture({
              context: i,
              pixelFormat: e.PixelFormat.RGBA,
              pixelDatatype: e.PixelDatatype.UNSIGNED_BYTE,
              source: { arrayBufferView: c, width: o, height: 1 },
              sampler: e.Sampler.NEAREST,
            });
          })(this, t),
          (function (t, i) {
            if (e.defined(t._uniformMap)) return;
            const s = new Map(),
              r = {},
              n = t._uniforms,
              o = t._actualUniforms;
            for (const i in n)
              if (n.hasOwnProperty(i)) {
                'function' != typeof n[i]
                  ? (s.set(i, Cc(t, i)), (r[i] = wc(t, n, i)))
                  : (s.set(i, n[i]), (r[i] = n[i])),
                  (o[i] = n[i]);
                const a = s.get(i);
                ('string' == typeof a ||
                  a instanceof e.Texture ||
                  a instanceof gc ||
                  a instanceof yc ||
                  a instanceof Tc) &&
                  (s[`${i}Dimensions`] = Sc(s, i));
              }
            (t._uniforms = {}),
              Object.defineProperties(t._uniforms, r),
              (t._uniformMap = e.combineInternalMap(
                s,
                new Map([
                  [
                    'u_ModelViewProjectionMatrix',
                    () =>
                      new e.Matrix4().ortho({
                        left: 0,
                        right: i.drawingBufferWidth,
                        bottom: i.drawingBufferHeight,
                        top: 0,
                        near: 0,
                        far: 1,
                      }),
                  ],
                  ['u_World', () => new e.Vector2(i.drawingBufferWidth, i.drawingBufferHeight)],
                  ['u_Resolution', () => new e.Vector2(i.painter.width, i.painter.height)],
                  ['colorTexture', () => t._colorTexture],
                  ['colorTextureDimensions', () => t._colorTexture.dimensions],
                  ['depthTexture', () => t._depthTexture],
                  ['u_depthTexture', () => t._depthTexture],
                  ['depthTextureDimensions', () => t._depthTexture.dimensions],
                  ['idTexture', () => t._idTexture],
                  ['czm_selectedIdTexture', () => t._selectedIdTexture],
                  ['czm_selectedIdTextureStep', () => 1 / t._selectedIdTexture.width],
                  [
                    'u_Viewport',
                    () => {
                      const t = i.viewport.current;
                      return new e.Vector4(t.x, t.y, t.width, t.height);
                    },
                  ],
                  ['u_FrameNumber', () => Date.now()],
                  ['u_PixelRatio', () => e.exported.devicePixelRatio],
                  [
                    'u_ViewportTransformation',
                    () => {
                      const t = i.viewport.current,
                        s = new e.Matrix4();
                      return e.Matrix4.computeViewportTransformation(t, 0, 1, s), s;
                    },
                  ],
                  [
                    'u_FrustumPlanes',
                    () =>
                      new e.Vector4(
                        i.painter.frameState.camera.frustumCrate.frustum._offCenterFrustum.top,
                        i.painter.frameState.camera.frustumCrate.frustum._offCenterFrustum.bottom,
                        i.painter.frameState.camera.frustumCrate.frustum._offCenterFrustum.left,
                        i.painter.frameState.camera.frustumCrate.frustum._offCenterFrustum.right,
                      ),
                  ],
                  [
                    'u_CurrentFrustum',
                    () => new e.Vector2(i.painter.transform.near, i.painter.transform.far),
                  ],
                  [
                    'u_InverseProjection',
                    () => i.painter.frameState.camera.projectionMatrixInverse,
                  ],
                ]),
              ));
          })(this, t),
          (function (t, i) {
            let s, r, n;
            const o = t._texturesToRelease;
            let a = o.length;
            for (s = 0; s < a; ++s) (r = o[s]), (r = r && r.destroy());
            o.length = 0;
            const l = t._texturesToCreate;
            for (a = l.length, s = 0; s < a; ++s) {
              const r = l[s];
              (n = r.name),
                (t._actualUniforms[n] = new e.Texture({ context: i, source: r.source }));
            }
            l.length = 0;
            const h = t._dirtyUniforms;
            if (0 === h.length && !e.defined(t._texturePromise)) return void (t._ready = !0);
            if (0 === h.length || e.defined(t._texturePromise)) return;
            a = h.length;
            const c = t._uniforms,
              _ = [];
            for (s = 0; s < a; ++s) {
              n = h[s];
              const i = c[n],
                r = t._textureCache.getStageByName(i);
              e.defined(r)
                ? (t._actualUniforms[n] = Ec(t, i))
                : 'string' == typeof i
                ? _.push(
                    new Promise((t, s) => {
                      e.getImage({ url: i }, (e, i) => {
                        e && s(e), t(i);
                      });
                    }),
                  )
                : t._texturesToCreate.push({ name: n, source: i });
            }
            (h.length = 0),
              _.length > 0
                ? ((t._ready = !1),
                  (t._texturePromise = Promise.all(_).then(() => {
                    (t._ready = !0), (t._texturePromise = void 0);
                  })))
                : (t._ready = !0);
          })(this, t),
          (function (t, i) {
            if (e.defined(t._command) && !t._logDepthChanged && !t._selectedDirty) return;
            let s = t._fragmentShader;
            if (e.defined(t._selectedIdTexture)) {
              const e = t._selectedIdTexture.width;
              (s = s.replace(/varying\s+vec2\s+v_TexCoord;/g, '')),
                (s = `#define CZM_SELECTED_FEATURE \nuniform sampler2D idTexture; \nuniform sampler2D czm_selectedIdTexture; \nuniform float czm_selectedIdTextureStep; \nvarying vec2 v_TexCoord; \nbool czm_selected(vec2 offset) \n{ \n    bool selected = false;\n    vec4 id = texture2D(idTexture, v_TexCoord + offset); \n    for (int i = 0; i < ${e}; ++i) \n    { \n        vec4 selectedId = texture2D(czm_selectedIdTexture, vec2((float(i) + 0.5) * czm_selectedIdTextureStep, 0.5)); \n        if (all(equal(id, selectedId))) \n        { \n            return true; \n        } \n    } \n    return false; \n} \n\nbool czm_selected() \n{ \n    return czm_selected(vec2(0.0)); \n} \n\n${s}`);
            }
            (t.shaderSource.fragmentSource = e.reduceComma(s)),
              -1 !== t.shaderSource.fragmentSource.indexOf('#include') &&
                console.error(
                  '检查着色器文件，里面的#include <>没有被正确替换。请将其前面和后面输入换行符\r\n或者\n，因为它没有被当成一行可以替换的代码。',
                ),
              (t._command = {
                painter: i.painter,
                framebuffer: void 0,
                layer: { id: 'postprocess' },
                geometry: new e.ViewportQuadGeometry(i.painter),
                material: {
                  renderState: t._renderState,
                  _uniforms: t._uniformMap,
                  _shaderSource: t.shaderSource,
                },
              });
          })(this, t),
          (function (t) {
            let i, s;
            1 === t._sampleMode
              ? ((i = e.TextureMinificationFilter.LINEAR),
                (s = e.TextureMagnificationFilter.LINEAR))
              : ((i = e.TextureMinificationFilter.NEAREST),
                (s = e.TextureMagnificationFilter.NEAREST));
            const r = t._sampler;
            (e.defined(r) && r.minificationFilter === i && r.magnificationFilter === s) ||
              (t._sampler = new e.Sampler({
                wrapS: e.TextureWrap.CLAMP_TO_EDGE,
                wrapT: e.TextureWrap.CLAMP_TO_EDGE,
                minificationFilter: i,
                magnificationFilter: s,
              }));
          })(this),
          (this._selectedDirty = !1),
          !this._ready)
        )
          return;
        const s = this._textureCache.getFramebuffer(this._name);
        if (((this._command.framebuffer = s.framebuffer), !e.defined(s))) return;
        const r = s.getColorTexture(0);
        let n;
        const [o, a] = r.size;
        (o === t.drawingBufferWidth && a === t.drawingBufferHeight) ||
          ((n = this._renderState),
          (e.defined(n) && o === n.viewport.width && a === n.viewport.height) ||
            (this._renderState = e.RenderState.fromCache({
              viewport: new e.BoundingRectangle(0, 0, o, a),
            }))),
          (this._command.material.renderState = n);
      }
      execute(t, i, s, r) {
        if (!e.defined(this._command) || !this._ready || !this._enabled) return;
        (this._colorTexture = i),
          (this._depthTexture = s),
          (this._idTexture = r),
          e.Sampler.equals(this._colorTexture.sampler, this._sampler) ||
            ((this._colorTexture.sampler = this._sampler),
            (this._depthTexture.sampler = this._sampler));
        const n =
          this.scissorRectangle.width > 0 && this.scissorRectangle.height > 0
            ? this._passState
            : void 0;
        e.defined(n) && e.RenderState.applyRenderState(t, n), t.draw(this._command);
      }
      isDestroyed() {
        return !1;
      }
      destroy() {
        return Pc(this), e.destroyObject(this);
      }
    }
    function wc(t, i, s) {
      const r = i[s];
      return (
        ('string' == typeof r ||
          r instanceof yc ||
          r instanceof gc ||
          r instanceof Tc ||
          r instanceof xc) &&
          t._dirtyUniforms.push(s),
        {
          get: () => i[s],
          set(r) {
            const n = i[s];
            i[s] = r;
            const o = t._actualUniforms,
              a = o[s];
            e.defined(a) &&
              a !== n &&
              a instanceof e.Texture &&
              !e.defined(t._textureCache.getStageByName(s)) &&
              (t._texturesToRelease.push(a), delete o[s], delete o[`${s}Dimensions`]),
              n instanceof e.Texture && t._texturesToRelease.push(n),
              'string' == typeof r ||
              r instanceof yc ||
              r instanceof gc ||
              r instanceof Tc ||
              r instanceof xc
                ? t._dirtyUniforms.push(s)
                : (o[s] = r);
          },
        }
      );
    }
    function Cc(e, t) {
      return function () {
        const i = e._actualUniforms[t];
        return 'function' == typeof i ? i() : i;
      };
    }
    function Sc(t, i) {
      return function () {
        const s = t[i]();
        if (e.defined(s)) return s.dimensions;
      };
    }
    function Ec(e, t) {
      return function () {
        return e._textureCache.getOutputTexture(t);
      };
    }
    function Pc(t) {
      e.defined(t._command) && (t._command = void 0),
        (t._selectedIdTexture = t._selectedIdTexture && t._selectedIdTexture.destroy());
      const i = t._textureCache;
      if (!e.defined(i)) return;
      const s = t._uniforms,
        r = t._actualUniforms;
      for (const n in r)
        r.hasOwnProperty(n) &&
          r[n] instanceof e.Texture &&
          (e.defined(i.getStageByName(s[n])) || r[n].destroy(), t._dirtyUniforms.push(n));
    }
    class Mc {
      constructor(t) {
        if (!t.stages) throw new Error('options.stages must be defined!');
        if (t.stages.length <= 0) throw new Error('options.stages length must greater than 0!');
        (this._stages = t.stages),
          (this._inputPreviousStageTexture = e.defaultValue(t.inputPreviousStageTexture, !0));
        let i = t.name;
        e.defined(i) || (i = e.uuid()),
          (this._name = i),
          (this._uniforms = t.uniforms),
          (this._textureCache = void 0),
          (this._index = void 0),
          (this._selected = void 0),
          (this._selectedShadow = void 0),
          (this._parentSelected = void 0),
          (this._parentSelectedShadow = void 0),
          (this._combinedSelected = void 0),
          (this._combinedSelectedShadow = void 0),
          (this._selectedLength = 0),
          (this._parentSelectedLength = 0),
          (this._selectedDirty = !0);
      }
      get ready() {
        const e = this._stages,
          t = e.length;
        for (let i = 0; i < t; ++i) if (!e[i].ready) return !1;
        return !0;
      }
      get name() {
        return this._name;
      }
      get enabled() {
        return this._stages[0].enabled;
      }
      set enabled(e) {
        const t = this._stages,
          i = t.length;
        for (let s = 0; s < i; ++s) t[s].enabled = e;
      }
      get uniforms() {
        return this._uniforms;
      }
      get inputPreviousStageTexture() {
        return this._inputPreviousStageTexture;
      }
      get length() {
        return this._stages.length;
      }
      get selected() {
        return this._selected;
      }
      set selected(e) {
        this._selected = e;
      }
      get parentSelected() {
        return this._parentSelected;
      }
      set parentSelected(e) {
        this._parentSelected = e;
      }
      _isSupported(e) {
        const t = this._stages,
          i = t.length;
        for (let s = 0; s < i; ++s) if (!t[s]._isSupported(e)) return !1;
        return !0;
      }
      get(e) {
        if (e < 0) throw new Error('index must be greater than 0!');
        if (e >= this.length) throw new Error('index must be less than stages length!');
        return this._stages[e];
      }
      update(t, i) {
        (this._selectedDirty = (function (t) {
          let i = e.defined(t._selected) ? t._selected.length : 0;
          const s = e.defined(t._parentSelected) ? t._parentSelected : 0;
          let r = t._selected !== t._selectedShadow || i !== t._selectedLength;
          if (
            ((r =
              r || t._parentSelected !== t._parentSelectedShadow || s !== t._parentSelectedLength),
            (t._combinedSelected =
              e.defined(t._selected) && e.defined(t._parentSelected)
                ? t._selected.concat(t._parentSelected)
                : e.defined(t._parentSelected)
                ? t._parentSelected
                : t._selected),
            !r && e.defined(t._combinedSelected))
          ) {
            if (!e.defined(t._combinedSelectedShadow)) return !0;
            i = t._combinedSelected.length;
            for (let e = 0; e < i; ++e)
              if (t._combinedSelected[e] !== t._combinedSelectedShadow[e]) return !0;
          }
          return r;
        })(this)),
          (this._selectedShadow = this._selected),
          (this._parentSelectedShadow = this._parentSelected),
          (this._combinedSelectedShadow = this._combinedSelected),
          (this._selectedLength = e.defined(this._selected) ? this._selected.length : 0),
          (this._parentSelectedLength = e.defined(this._parentSelected)
            ? this._parentSelected.length
            : 0);
        const s = this._stages,
          r = s.length;
        for (let e = 0; e < r; ++e) {
          const r = s[e];
          this._selectedDirty && (r.parentSelected = this._combinedSelected), r.update(t, i);
        }
      }
      destroy() {
        const t = this._stages,
          i = t.length;
        for (let e = 0; e < i; ++e) t[e].destroy();
        return e.destroyObject(this);
      }
    }
    class Ac {
      constructor(t) {
        (t = e.defaultValue(t, e.defaultValue.EMPTY_OBJECT)),
          (this.color = t.color),
          (this.depth = t.depth),
          (this.stencil = t.stencil),
          (this.renderState = t.renderState),
          (this.framebuffer = t.framebuffer),
          (this.owner = t.owner);
      }
      static ALL = Object.freeze(new Ac({ color: new e.Color(0, 0, 0, 0), depth: 1, stencil: 0 }));
      execute(e) {
        e.clear(this);
      }
    }
    class Rc {
      constructor(t) {
        const i = (t = e.defaultValue(t, e.defaultValue.EMPTY_OBJECT)).context,
          s = t.height;
        (this._width = t.width), (this._height = s);
        const r = t.colorRenderbuffers,
          n = t.colorTextures;
        if (e.defined(r) !== e.defined(n))
          throw new Error('Both color renderbuffer and texture attachments must be provided.');
        const o = t.depthStencilRenderbuffer,
          a = t.depthStencilTexture;
        if (e.defined(o) !== e.defined(a))
          throw new Error(
            'Both depth-stencil renderbuffer and texture attachments must be provided.',
          );
        (this._renderFramebuffer = new e.Framebuffer({
          context: i,
          colorRenderbuffers: r,
          depthStencilRenderbuffer: o,
          destroyAttachments: t.destroyAttachments,
        })),
          (this._colorFramebuffer = new e.Framebuffer({
            context: i,
            colorTextures: n,
            depthStencilTexture: a,
            destroyAttachments: t.destroyAttachments,
          }));
      }
      getRenderFramebuffer() {
        return this._renderFramebuffer;
      }
      getColorFramebuffer() {
        return this._colorFramebuffer;
      }
      blitFramebuffers(t, i) {
        this._renderFramebuffer.bindRead(), this._colorFramebuffer.bindDraw();
        const s = t.gl;
        let r = 0;
        this._colorFramebuffer._colorTextures.length > 0 &&
          (r |= e.WebGLConstants.COLOR_BUFFER_BIT),
          e.defined(this._colorFramebuffer.depthStencilTexture) &&
            (r |=
              e.WebGLConstants.DEPTH_BUFFER_BIT | (i ? e.WebGLConstants.STENCIL_BUFFER_BIT : 0)),
          s.blitFramebuffer(
            0,
            0,
            this._width,
            this._height,
            0,
            0,
            this._width,
            this._height,
            r,
            e.WebGLConstants.NEAREST,
          ),
          s.bindFramebuffer(e.WebGLConstants.READ_FRAMEBUFFER, null),
          s.bindFramebuffer(e.WebGLConstants.DRAW_FRAMEBUFFER, null);
      }
      isDestroyed() {
        return !1;
      }
      destroy() {
        return (
          this._renderFramebuffer.destroy(), this._colorFramebuffer.destroy(), e.destroyObject(this)
        );
      }
    }
    class Ic {
      constructor(t) {
        (t = e.defaultValue(t, e.defaultValue.EMPTY_OBJECT)),
          (this._numSamples = e.defaultValue(t.numSamples, 1)),
          (this._colorAttachmentsLength = e.defaultValue(t.colorAttachmentsLength, 1)),
          (this._color = e.defaultValue(t.color, !0)),
          (this._depth = e.defaultValue(t.depth, !1)),
          (this._depthStencil = e.defaultValue(t.depthStencil, !1)),
          (this._supportsDepthTexture = e.defaultValue(t.supportsDepthTexture, !1)),
          (this._createColorAttachments = e.defaultValue(t.createColorAttachments, !0)),
          (this._createDepthAttachments = e.defaultValue(t.createDepthAttachments, !0)),
          (this._pixelDatatype = t.pixelDatatype),
          (this._pixelFormat = t.pixelFormat),
          (this._width = void 0),
          (this._height = void 0),
          (this._framebuffer = void 0),
          (this._multisampleFramebuffer = void 0),
          (this._colorTextures = void 0),
          this._color &&
            ((this._colorTextures = new Array(this._colorAttachmentsLength)),
            (this._colorRenderbuffers = new Array(this._colorAttachmentsLength))),
          (this._colorRenderbuffer = void 0),
          (this._depthStencilRenderbuffer = void 0),
          (this._depthStencilTexture = void 0),
          (this._depthRenderbuffer = void 0),
          (this._depthTexture = void 0),
          (this._attachmentsDirty = !1);
      }
      get framebuffer() {
        return this._numSamples > 1
          ? this._multisampleFramebuffer.getRenderFramebuffer()
          : this._framebuffer;
      }
      get numSamples() {
        return this._numSamples;
      }
      get status() {
        return this.framebuffer.status;
      }
      isDirty(t, i, s, r, n) {
        s = e.defaultValue(s, 1);
        const o = this._width !== t || this._height !== i,
          a = this._numSamples !== s,
          l =
            (e.defined(r) && this._pixelDatatype !== r) ||
            (e.defined(n) && this._pixelFormat !== n),
          h = e.defined(1 === s ? this._framebuffer : this._multisampleFramebuffer);
        return (
          this._attachmentsDirty ||
          o ||
          a ||
          l ||
          !h ||
          (this._color && !e.defined(this._colorTextures[0]))
        );
      }
      update(t, i, s, r, n, o) {
        if (
          ((r = t.msaa ? e.defaultValue(r, 1) : 1),
          (n = e.defaultValue(
            n,
            this._color
              ? e.defaultValue(this._pixelDatatype, e.PixelDatatype.UNSIGNED_BYTE)
              : void 0,
          )),
          (o = e.defaultValue(
            o,
            this._color ? e.defaultValue(this._pixelFormat, e.PixelFormat.RGBA) : void 0,
          )),
          this.isDirty(i, s, r, n, o))
        ) {
          if (
            (this.destroy(),
            (this._width = i),
            (this._height = s),
            (this._numSamples = r),
            (this._pixelDatatype = n),
            (this._pixelFormat = o),
            (this._attachmentsDirty = !1),
            this._color && this._createColorAttachments)
          )
            for (let r = 0; r < this._colorAttachmentsLength; ++r)
              if (
                ((this._colorTextures[r] = new e.Texture({
                  context: t,
                  width: i,
                  height: s,
                  pixelFormat: o,
                  pixelDatatype: n,
                  sampler: e.Sampler.NEAREST,
                })),
                this._numSamples > 1)
              ) {
                const o = e.RenderbufferFormat.getColorFormat(n);
                this._colorRenderbuffers[r] = new Bs({
                  context: t,
                  width: i,
                  height: s,
                  format: o,
                  numSamples: this._numSamples,
                });
              }
          this._depthStencil &&
            this._createDepthAttachments &&
            (this._supportsDepthTexture && t.depthTexture
              ? ((this._depthStencilTexture = new e.Texture({
                  context: t,
                  width: i,
                  height: s,
                  pixelFormat: e.PixelFormat.DEPTH_STENCIL,
                  pixelDatatype: e.PixelDatatype.UNSIGNED_INT_24_8,
                  sampler: e.Sampler.NEAREST,
                })),
                this._numSamples > 1 &&
                  (this._depthStencilRenderbuffer = new Bs({
                    context: t,
                    width: i,
                    height: s,
                    format: e.RenderbufferFormat.DEPTH24_STENCIL8,
                    numSamples: this._numSamples,
                  })))
              : (this._depthStencilRenderbuffer = new Bs({
                  context: t,
                  width: i,
                  height: s,
                  format: e.RenderbufferFormat.DEPTH_STENCIL,
                }))),
            this._depth &&
              this._createDepthAttachments &&
              (this._supportsDepthTexture && t.depthTexture
                ? (this._depthTexture = new e.Texture({
                    context: t,
                    width: i,
                    height: s,
                    pixelFormat: e.PixelFormat.DEPTH_COMPONENT,
                    pixelDatatype: e.PixelDatatype.UNSIGNED_INT,
                    sampler: e.Sampler.NEAREST,
                  }))
                : (this._depthRenderbuffer = new Bs({
                    context: t,
                    width: i,
                    height: s,
                    format: e.RenderbufferFormat.DEPTH_COMPONENT16,
                  }))),
            this._numSamples > 1
              ? (this._multisampleFramebuffer = new Rc({
                  context: t,
                  width: this._width,
                  height: this._height,
                  colorTextures: this._colorTextures,
                  colorRenderbuffers: this._colorRenderbuffers,
                  depthStencilTexture: this._depthStencilTexture,
                  depthStencilRenderbuffer: this._depthStencilRenderbuffer,
                  destroyAttachments: !1,
                }))
              : (this._framebuffer = new e.Framebuffer({
                  context: t,
                  colorTextures: this._colorTextures,
                  depthTexture: this._depthTexture,
                  depthRenderbuffer: this._depthRenderbuffer,
                  depthStencilTexture: this._depthStencilTexture,
                  depthStencilRenderbuffer: this._depthStencilRenderbuffer,
                  destroyAttachments: !1,
                }));
        }
      }
      getColorTexture(t) {
        return (t = e.defaultValue(t, 0)), this._colorTextures[t];
      }
      setColorTexture(t, i) {
        (i = e.defaultValue(i, 0)),
          (this._attachmentsDirty = t !== this._colorTextures[i]),
          (this._colorTextures[i] = t);
      }
      getColorRenderbuffer(t) {
        return (t = e.defaultValue(t, 0)), this._colorRenderbuffers[t];
      }
      setColorRenderbuffer(t, i) {
        (i = e.defaultValue(i, 0)),
          (this._attachmentsDirty = t !== this._colorRenderbuffers[i]),
          (this._colorRenderbuffers[i] = t);
      }
      getDepthRenderbuffer() {
        return this._depthRenderbuffer;
      }
      setDepthRenderbuffer(e) {
        (this._attachmentsDirty = e !== this._depthRenderbuffer), (this._depthRenderbuffer = e);
      }
      getDepthTexture() {
        return this._depthTexture;
      }
      setDepthTexture(e) {
        (this._attachmentsDirty = e !== this._depthTexture), (this._depthTexture = e);
      }
      getDepthStencilRenderbuffer() {
        return this._depthStencilRenderbuffer;
      }
      setDepthStencilRenderbuffer(e) {
        (this._attachmentsDirty = e !== this._depthStencilRenderbuffer),
          (this._depthStencilRenderbuffer = e);
      }
      getDepthStencilTexture() {
        return this._depthStencilTexture;
      }
      setDepthStencilTexture(e) {
        (this._attachmentsDirty = e !== this._depthStencilTexture), (this._depthStencilTexture = e);
      }
      prepareTextures(e, t) {
        this._numSamples > 1 && this._multisampleFramebuffer.blitFramebuffers(e, t);
      }
      clear(e, t, i) {
        const s = t.framebuffer;
        (t.framebuffer = this.framebuffer),
          e.bindFramebuffer.set(this.framebuffer.framebuffer),
          t.execute(e, i),
          (t.framebuffer = s);
      }
      destroyFramebuffer() {
        (this._framebuffer = this._framebuffer && this._framebuffer.destroy()),
          (this._multisampleFramebuffer =
            this._multisampleFramebuffer && this._multisampleFramebuffer.destroy());
      }
      destroy() {
        if (this._color) {
          let t;
          const i = this._colorTextures.length;
          for (t = 0; t < i; ++t) {
            const i = this._colorTextures[t];
            this._createColorAttachments &&
              e.defined(i) &&
              !i.isDestroyed() &&
              (this._colorTextures[t].destroy(), (this._colorTextures[t] = void 0)),
              e.defined(i) && i.isDestroyed() && (this._colorTextures[t] = void 0);
            const s = this._colorRenderbuffers[t];
            this._createColorAttachments &&
              e.defined(s) &&
              !s.isDestroyed() &&
              (this._colorRenderbuffers[t].destroy(), (this._colorRenderbuffers[t] = void 0)),
              e.defined(s) && s.isDestroyed() && (this._colorRenderbuffers[t] = void 0);
          }
        }
        this._depthStencil &&
          (this._createDepthAttachments &&
            ((this._depthStencilTexture =
              this._depthStencilTexture && this._depthStencilTexture.destroy()),
            (this._depthStencilRenderbuffer =
              this._depthStencilRenderbuffer && this._depthStencilRenderbuffer.destroy())),
          e.defined(this._depthStencilTexture) &&
            this._depthStencilTexture.isDestroyed() &&
            (this._depthStencilTexture = void 0),
          e.defined(this._depthStencilRenderbuffer) &&
            this._depthStencilRenderbuffer.isDestroyed() &&
            (this._depthStencilRenderbuffer = void 0)),
          this._depth &&
            (this._createDepthAttachments &&
              ((this._depthTexture = this._depthTexture && this._depthTexture.destroy()),
              (this._depthRenderbuffer =
                this._depthRenderbuffer && this._depthRenderbuffer.destroy())),
            e.defined(this._depthTexture) &&
              this._depthTexture.isDestroyed() &&
              (this._depthTexture = void 0),
            e.defined(this._depthRenderbuffer) &&
              this._depthRenderbuffer.isDestroyed() &&
              (this._depthRenderbuffer = void 0)),
          this.destroyFramebuffer();
      }
    }
    class Oc {
      constructor() {
        (this._uniformMap = void 0),
          (this._colorTexture = void 0),
          (this._depthTexture = void 0),
          (this._ready = !1),
          (this._name = 'czm_autoexposure'),
          (this._logDepthChanged = void 0),
          (this._useLogDepth = void 0),
          (this._framebuffers = void 0),
          (this._previousLuminance = new Ic()),
          (this._commands = void 0),
          (this._clearCommand = void 0),
          (this._minMaxLuminance = new e.Vector2()),
          (this.enabled = !0),
          (this._enabled = !0),
          (this.minimumLuminance = 0.1),
          (this.maximumLuminance = 10);
      }
      get ready() {
        return this._ready;
      }
      get name() {
        return this._name;
      }
      get outputTexture() {
        const t = this._framebuffers;
        if (e.defined(t)) return t[t.length - 1].getColorTexture(0);
      }
      update(t) {
        const i = t.drawingBufferWidth,
          s = t.drawingBufferHeight;
        (i === this._width && s === this._height) ||
          ((this._width = i),
          (this._height = s),
          (function (t, i) {
            Lc(t);
            let s = t._width,
              r = t._height;
            const n = i.extTextureHalfFloat ? e.PixelDatatype.HALF_FLOAT : e.PixelDatatype.FLOAT,
              o = Math.ceil(Math.log(Math.max(s, r)) / Math.log(3)),
              a = new Array(o);
            for (let e = 0; e < o; ++e)
              (s = Math.max(Math.ceil(s / 3), 1)),
                (r = Math.max(Math.ceil(r / 3), 1)),
                (a[e] = new Ic()),
                a[e].update(i, s, r, 1, n);
            const l = a[o - 1].getColorTexture(0);
            t._previousLuminance.update(i, l.width, l.height, 1, n), (t._framebuffers = a);
          })(this, t),
          (function (e, t) {
            Dc(e);
            const i = e._framebuffers,
              s = i.length,
              r = new Array(s);
            for (let n = 0; n < s; ++n) r[n] = Nc(t, Vc(n, s), i[n].framebuffer, Bc(e, n));
            e._commands = r;
          })(this, t),
          this._ready || (this._ready = !0)),
          (this._minMaxLuminance.x = this.minimumLuminance),
          (this._minMaxLuminance.y = this.maximumLuminance);
        const r = this._framebuffers,
          n = r[r.length - 1];
        (r[r.length - 1] = this._previousLuminance),
          (this._commands[this._commands.length - 1].framebuffer =
            this._previousLuminance.framebuffer),
          (this._previousLuminance = n);
      }
      execute(t, i) {
        this._colorTexture = i;
        const s = this._commands;
        if (!e.defined(s)) return;
        const r = s.length;
        for (let e = 0; e < r; ++e) t.draw(s[e]);
      }
      isDestroyed() {
        return !1;
      }
      destroy() {
        return Lc(this), Dc(this), e.destroyObject(this);
      }
      clear(t) {
        const i = this._framebuffers;
        if (!e.defined(i)) return;
        let s = this._clearCommand;
        e.defined(s) ||
          (s = this._clearCommand =
            new Ac({ color: new e.Color(0, 0, 0, 0), framebuffer: void 0 }));
        const r = i.length;
        for (let e = 0; e < r; ++e) i[e].clear(t, s);
      }
    }
    function Lc(t) {
      const i = t._framebuffers;
      if (!e.defined(i)) return;
      const s = i.length;
      for (let e = 0; e < s; ++e) i[e].destroy();
      (t._framebuffers = void 0), t._previousLuminance.destroy(), (t._previousLuminance = void 0);
    }
    function Dc(t) {
      const i = t._commands;
      if (!e.defined(i)) return;
      const s = i.length;
      for (let e = 0; e < s; ++e) i[e].shaderProgram.destroy();
      t._commands = void 0;
    }
    function Bc(e, t) {
      const i = new Map();
      if (0 === t)
        i.set('colorTexture', () => e._colorTexture),
          i.set('colorTextureDimensions', () => e._colorTexture.dimensions);
      else {
        const s = e._framebuffers[t - 1].getColorTexture(0);
        i.set('colorTexture', () => s), i.set('colorTextureDimensions', () => s.dimensions);
      }
      return (
        i.set('minMaxLuminance', () => e._minMaxLuminance),
        i.set('previousLuminance', () => e._previousLuminance.getColorTexture(0)),
        i
      );
    }
    function Vc(e, t) {
      let i =
        'uniform sampler2D colorTexture; \nvarying vec2 v_TexCoord; \nfloat sampleTexture(vec2 offset) { \n';
      return (
        (i +=
          0 === e
            ? '    vec4 color = texture2D(colorTexture, v_TexCoord + offset); \n    return czm_luminance(color.rgb); \n'
            : '    return texture2D(colorTexture, v_TexCoord + offset).r; \n'),
        (i += '}\n\n'),
        (i +=
          'uniform vec2 colorTextureDimensions; \nuniform vec2 minMaxLuminance; \nuniform sampler2D previousLuminance; \nvoid main() { \n    float color = 0.0; \n    float xStep = 1.0 / colorTextureDimensions.x; \n    float yStep = 1.0 / colorTextureDimensions.y; \n    int count = 0; \n    for (int i = 0; i < 3; ++i) { \n        for (int j = 0; j < 3; ++j) { \n            vec2 offset; \n            offset.x = -xStep + float(i) * xStep; \n            offset.y = -yStep + float(j) * yStep; \n            if (offset.x < 0.0 || offset.x > 1.0 || offset.y < 0.0 || offset.y > 1.0) { \n                continue; \n            } \n            color += sampleTexture(offset); \n            ++count; \n        } \n    } \n    if (count > 0) { \n        color /= float(count); \n    } \n'),
        e === t - 1 &&
          (i +=
            '    float previous = texture2D(previousLuminance, vec2(0.5)).r; \n    color = clamp(color, minMaxLuminance.x, minMaxLuminance.y); \n    color = previous + (color - previous) / (60.0 * 1.5); \n    color = clamp(color, minMaxLuminance.x, minMaxLuminance.y); \n'),
        (i += '    gl_FragColor = vec4(color); \n} \n'),
        i
      );
    }
    function Nc(t, i, s, r) {
      this._copyColorCommand = {
        painter: t.painter,
        framebuffer: s,
        layer: { id: `postprocess-autoExposure${Date.now()}` },
        geometry: new e.ViewportQuadGeometry(t.painter),
        material: {
          _uniforms: r,
          _shaderSource: new e.ShaderSource({
            vertexSource: e.shaders.screen.vertexSource,
            fragmentSource: i,
          }),
        },
      };
    }
    function kc(t) {
      const i = `#define USE_STEP_SIZE\n${e.shaders.GaussianBlur1D.fragmentSource}`,
        s = new bc({
          name: `${t}_x_direction`,
          fragmentShader: i,
          uniforms: { delta: 1, sigma: 2, stepSize: 1, direction: 0 },
          sampleMode: 1,
        }),
        r = new bc({
          name: `${t}_y_direction`,
          fragmentShader: i,
          uniforms: { delta: 1, sigma: 2, stepSize: 1, direction: 1 },
          sampleMode: 1,
        }),
        n = {};
      return (
        Object.defineProperties(n, {
          delta: {
            get: () => s.uniforms.delta,
            set(e) {
              s.uniforms.delta = r.uniforms.delta = e;
            },
          },
          sigma: {
            get: () => s.uniforms.sigma,
            set(e) {
              s.uniforms.sigma = r.uniforms.sigma = e;
            },
          },
          stepSize: {
            get: () => s.uniforms.stepSize,
            set(e) {
              s.uniforms.stepSize = r.uniforms.stepSize = e;
            },
          },
        }),
        new Mc({ name: t, stages: [s, r], uniforms: n })
      );
    }
    class Fc {
      static createBlurStage() {
        return kc('czm_blur');
      }
      static createDepthOfFieldStage() {
        const t = kc('czm_depth_of_field_blur'),
          i = new bc({
            name: 'czm_depth_of_field_composite',
            fragmentShader: e.shaders.DepthOfField.fragmentSource,
            uniforms: { focalDistance: 5, blurTexture: t.name },
          }),
          s = {};
        return (
          Object.defineProperties(s, {
            focalDistance: {
              get: () => i.uniforms.focalDistance,
              set(e) {
                i.uniforms.focalDistance = e;
              },
            },
            delta: {
              get: () => t.uniforms.delta,
              set(e) {
                t.uniforms.delta = e;
              },
            },
            sigma: {
              get: () => t.uniforms.sigma,
              set(e) {
                t.uniforms.sigma = e;
              },
            },
            stepSize: {
              get: () => t.uniforms.stepSize,
              set(e) {
                t.uniforms.stepSize = e;
              },
            },
          }),
          new Mc({
            name: 'czm_depth_of_field',
            stages: [t, i],
            inputPreviousStageTexture: !1,
            uniforms: s,
          })
        );
      }
      static isDepthOfFieldSupported(e) {
        return e.extDepthTexture;
      }
      static createEdgeDetectionStage(t = {}) {
        const i = Date.now();
        return new bc({
          name: `czm_edge_detection_${i}`,
          fragmentShader: e.shaders.EdgeDetection.fragmentSource,
          uniforms: { length: e.defaultValue(t.length, 0.25), color: new e.Vector4(0, 0, 0, 1) },
        });
      }
      static isEdgeDetectionSupported(e) {
        return e.extDepthTexture;
      }
      static createSilhouetteStage(t) {
        const i = (function (t) {
            if (!e.defined(t)) return Fc.createEdgeDetectionStage();
            const i = new Mc({
                name: 'czm_edge_detection_multiple',
                stages: t,
                inputPreviousStageTexture: !1,
              }),
              s = {};
            let r = '',
              n = '';
            for (let e = 0; e < t.length; ++e)
              (r += `uniform sampler2D edgeTexture${e}; \n`),
                (n += `        vec4 edge${e} = texture2D(edgeTexture${e}, v_TexCoord); \n        if (edge${e}.a > 0.0) \n        { \n            color = edge${e}; \n            break; \n        } \n`),
                (s[`edgeTexture${e}`] = t[e].name);
            const o = new bc({
              name: 'czm_edge_detection_combine',
              fragmentShader: `${r}varying vec2 v_TexCoord; \nvoid main() { \n    vec4 color = vec4(0.0); \n    for (int i = 0; i < ${t.length}; i++) \n    { \n${n}    } \n    gl_FragColor = color; \n} \n`,
              uniforms: s,
            });
            return new Mc({ name: 'czm_edge_detection_composite', stages: [i, o] });
          })(t),
          s = new bc({
            name: 'czm_silhouette_color_edges',
            fragmentShader: e.shaders.Silhouette.fragmentSource,
            uniforms: { silhouetteTexture: i.name },
          });
        return new Mc({
          name: 'czm_silhouette',
          stages: [i, s],
          inputPreviousStageTexture: !1,
          uniforms: i.uniforms,
        });
      }
      static isSilhouetteSupported(e) {
        return e.extDepthTexture;
      }
      static createBloomStage() {
        const t = new bc({
            name: 'czm_bloom_contrast_bias',
            fragmentShader: e.shaders.ContrastBias.fragmentSource,
            uniforms: { contrast: 128, brightness: -0.3 },
          }),
          i = kc('czm_bloom_blur'),
          s = new Mc({ name: 'czm_bloom_contrast_bias_blur', stages: [t, i] }),
          r = new bc({
            name: 'czm_bloom_generate_composite',
            fragmentShader: e.shaders.BloomComposite.fragmentSource,
            uniforms: { glowOnly: !1, bloomTexture: s.name },
          }),
          n = {};
        return (
          Object.defineProperties(n, {
            glowOnly: {
              get: () => r.uniforms.glowOnly,
              set(e) {
                r.uniforms.glowOnly = e;
              },
            },
            contrast: {
              get: () => t.uniforms.contrast,
              set(e) {
                t.uniforms.contrast = e;
              },
            },
            brightness: {
              get: () => t.uniforms.brightness,
              set(e) {
                t.uniforms.brightness = e;
              },
            },
            delta: {
              get: () => i.uniforms.delta,
              set(e) {
                i.uniforms.delta = e;
              },
            },
            sigma: {
              get: () => i.uniforms.sigma,
              set(e) {
                i.uniforms.sigma = e;
              },
            },
            stepSize: {
              get: () => i.uniforms.stepSize,
              set(e) {
                i.uniforms.stepSize = e;
              },
            },
          }),
          new Mc({ name: 'czm_bloom', stages: [s, r], inputPreviousStageTexture: !1, uniforms: n })
        );
      }
      static createAmbientOcclusionStage() {
        const t = new bc({
            name: 'czm_ambient_occlusion_generate',
            fragmentShader: e.shaders.AmbientOcclusionGenerate.fragmentSource,
            uniforms: {
              intensity: 3,
              bias: 0.1,
              lengthCap: 0.26,
              stepSize: 1.95,
              frustumLength: 1e3,
              randomTexture: void 0,
            },
          }),
          i = kc('czm_ambient_occlusion_blur');
        i.uniforms.stepSize = 0.86;
        const s = new Mc({ name: 'czm_ambient_occlusion_generate_blur', stages: [t, i] }),
          r = new bc({
            name: 'czm_ambient_occlusion_composite',
            fragmentShader: e.shaders.AmbientOcclusionModulate.fragmentSource,
            uniforms: { ambientOcclusionOnly: !1, ambientOcclusionTexture: s.name },
          }),
          n = {};
        return (
          Object.defineProperties(n, {
            intensity: {
              get: () => t.uniforms.intensity,
              set(e) {
                t.uniforms.intensity = e;
              },
            },
            bias: {
              get: () => t.uniforms.bias,
              set(e) {
                t.uniforms.bias = e;
              },
            },
            lengthCap: {
              get: () => t.uniforms.lengthCap,
              set(e) {
                t.uniforms.lengthCap = e;
              },
            },
            stepSize: {
              get: () => t.uniforms.stepSize,
              set(e) {
                t.uniforms.stepSize = e;
              },
            },
            frustumLength: {
              get: () => t.uniforms.frustumLength,
              set(e) {
                t.uniforms.frustumLength = e;
              },
            },
            randomTexture: {
              get: () => t.uniforms.randomTexture,
              set(e) {
                t.uniforms.randomTexture = e;
              },
            },
            delta: {
              get: () => i.uniforms.delta,
              set(e) {
                i.uniforms.delta = e;
              },
            },
            sigma: {
              get: () => i.uniforms.sigma,
              set(e) {
                i.uniforms.sigma = e;
              },
            },
            blurStepSize: {
              get: () => i.uniforms.stepSize,
              set(e) {
                i.uniforms.stepSize = e;
              },
            },
            ambientOcclusionOnly: {
              get: () => r.uniforms.ambientOcclusionOnly,
              set(e) {
                r.uniforms.ambientOcclusionOnly = e;
              },
            },
          }),
          new Mc({
            name: 'czm_ambient_occlusion',
            stages: [s, r],
            inputPreviousStageTexture: !1,
            uniforms: n,
          })
        );
      }
      static isAmbientOcclusionSupported(e) {
        return e.extDepthTexture;
      }
      static createFXAAStage() {
        return new bc({
          name: 'czm_FXAA',
          fragmentShader: `#define M_FXAA_QUALITY_PRESET 39 \n${e.shaders.FXAA.fragmentSource}`,
          sampleMode: 1,
        });
      }
      static createAcesTonemappingStage(t) {
        let i = t ? '#define AUTO_EXPOSURE\n' : '';
        return (
          (i += e.shaders.AcesTonemappingStage.fragmentSource),
          new bc({
            name: 'czm_aces',
            fragmentShader: i,
            uniforms: { autoExposure: void 0, u_Gamma: 1.53846 },
          })
        );
      }
      static createFilmicTonemappingStage(t) {
        let i = t ? '#define AUTO_EXPOSURE\n' : '';
        return (
          (i += e.shaders.FilmicTonemapping.fragmentSource),
          new bc({
            name: 'czm_filmic',
            fragmentShader: i,
            uniforms: { autoExposure: void 0, u_Gamma: 1.53846 },
          })
        );
      }
      static createReinhardTonemappingStage(t) {
        let i = t ? '#define AUTO_EXPOSURE\n' : '';
        return (
          (i += e.shaders.ReinhardTonemapping.fragmentSource),
          new bc({
            name: 'czm_reinhard',
            fragmentShader: i,
            uniforms: { autoExposure: void 0, u_Gamma: 1.53846 },
          })
        );
      }
      static createModifiedReinhardTonemappingStage(t) {
        let i = t ? '#define AUTO_EXPOSURE\n' : '';
        return (
          (i += e.shaders.ModifiedReinhardTonemapping.fragmentSource),
          new bc({
            name: 'czm_modified_reinhard',
            fragmentShader: i,
            uniforms: { white: e.Color.white, autoExposure: void 0, u_Gamma: 1.53846 },
          })
        );
      }
      static createAutoExposureStage() {
        return new Oc();
      }
      static createBlackAndWhiteStage() {
        return new bc({
          name: 'czm_black_and_white',
          fragmentShader: e.shaders.BlackAndWhite.fragmentSource,
          uniforms: { gradations: 5 },
        });
      }
      static createBrightnessStage() {
        return new bc({
          name: 'czm_brightness',
          fragmentShader: e.shaders.Brightness.fragmentSource,
          uniforms: { brightness: 0.5 },
        });
      }
      static createNightVisionStage() {
        return new bc({
          name: 'czm_night_vision',
          fragmentShader: e.shaders.NightVision.fragmentSource,
        });
      }
      static createDepthViewStage() {
        return new bc({
          name: 'czm_depth_view',
          fragmentShader: e.shaders.DepthView.fragmentSource,
        });
      }
      static createSkyline(t = {}) {
        const i = t.color || [0.5, 0.3, 0.7],
          s = e.defined(t.width) ? t.width : 1,
          r = e.Color.parse(i);
        if (!r)
          throw new Error(
            "color's type is not support! please use minemap.Color or minemap.Math.Vector3 or minemap.Math.Vector3 or Array<number,3>,4 or Array<number,4> or css color string instead!",
          );
        (r.r > 1 || r.g > 1 || r.b > 1) &&
          ((r.r = e.Color.byteToFloat(r.r)),
          (r.g = e.Color.byteToFloat(r.g)),
          (r.b = e.Color.byteToFloat(r.b)),
          console.warn(
            '请检查，传入的color是否有标准，错误示范如 new minemap.Color(255,0,0); 非0-1， 或 new minemap.Math.Vector3(255,0,0); 或者 [123, 1,5]等数值传入！',
          ));
        const n = e.Vector4.fromColor(r),
          o = Fc.createEdgeDetectionStage({ length: t.edgeDetectionLength || 1e-4 }),
          a = new bc({
            name: 'mm_skyline_red',
            fragmentShader:
              'uniform sampler2D colorTexture;uniform sampler2D depthTexture;varying vec2 v_TexCoord;\r\n#include <fn_readDepth> \r\nvoid main(void){float depth = readDepth(depthTexture, v_TexCoord, true);vec4 color = texture2D(colorTexture, v_TexCoord);if (depth != 1.0) {gl_FragColor = vec4(0.0);}else{gl_FragColor = vec4(1.0,0.0,0.0,1.0);}}',
          }),
          l = new bc({
            name: 'mm_skyline_merge_edge',
            fragmentShader:
              'uniform sampler2D colorTexture;uniform sampler2D redTexture;uniform sampler2D silhouetteTexture;uniform vec4 u_Viewport;uniform vec4 linecolor;uniform float u_PixelRatio;uniform float width;varying vec2 v_TexCoord;void main(void){ vec2 offxy = width* u_PixelRatio / u_Viewport.zw;vec4 redcolor=texture2D(redTexture, v_TexCoord);vec4 silhouetteColor = texture2D(silhouetteTexture, v_TexCoord);silhouetteColor += texture2D(silhouetteTexture, v_TexCoord+vec2(offxy.x,0.));silhouetteColor += texture2D(silhouetteTexture, v_TexCoord+vec2(-offxy.x,0.));silhouetteColor += texture2D(silhouetteTexture, v_TexCoord+vec2(0.,offxy.y));silhouetteColor += texture2D(silhouetteTexture, v_TexCoord+vec2(0.,-offxy.y));vec4 color = texture2D(colorTexture, v_TexCoord);if(redcolor.r == 1.0 &&silhouetteColor.a!=0.){gl_FragColor = linecolor;}else{gl_FragColor = color;}}',
            uniforms: {
              redTexture: a.name,
              silhouetteTexture: o.name,
              linecolor: () => n,
              width: () => s,
            },
          });
        return new Mc({
          stages: [o, a, l],
          inputPreviousStageTexture: !1,
          uniforms: o.uniforms,
          name: 'skyline',
        });
      }
      static createFogEffect(t) {
        let i = e.defaultValue(t?.fogDensity, 50);
        const s = e.Vector4.fromColor(
          e.Color.parse(e.defaultValue(t?.fogColor, 'rgba(255,255,255,1)')),
          !1,
        );
        return (
          i <= 0 ? (i = 1) : i > 100 && (i = 100),
          new bc({
            name: 'mm_fog_effect',
            fragmentShader:
              '\n        #include <infinity>\n        #include <u_FrustumPlanes>\n        #include <u_CurrentFrustum>\n        #include <u_Viewport>\n        uniform mat4 u_ViewportTransformation;\n        uniform mat4 u_InverseProjection;\n        uniform float u_PixelRatio;\n        #include <fn_windowToEyeCoordinates>\n        #include <fn_readDepth>\n        uniform sampler2D colorTexture;\n        uniform sampler2D depthTexture;\n        uniform vec4 fogByDistance;\n        uniform vec4 fogColor;\n\n        float getDistance(sampler2D depthTexture, vec2 texCoords)\n        {\n            float depth = readDepth(depthTexture, texCoords, true);\n\n            if (depth == 0.0) {\n                return infinity;\n            }\n            vec4 eyeCoordinate = windowToEyeCoordinates(gl_FragCoord.xy, depth);\n            return -eyeCoordinate.z / (eyeCoordinate.w * 2.5);\n        }\n        float interpolateByDistance(vec4 nearFarScalar, float distance)\n        {\n            float startDistance = nearFarScalar.x;\n            float startValue = nearFarScalar.y;\n            float endDistance = nearFarScalar.z;\n            float endValue = nearFarScalar.w;\n            float t = clamp((distance - startDistance) / (endDistance - startDistance), 0.0, 1.0);\n            return mix(startValue, endValue, t);\n        }\n        vec4 alphaBlend(vec4 sourceColor, vec4 destinationColor)\n        {\n            return sourceColor * vec4(sourceColor.aaa, 1.0) + destinationColor * (1.0 - sourceColor.a);\n        }\n\n        void main(void)\n        {\n            vec2 v_textureCoordinates = vec2(gl_FragCoord.x, gl_FragCoord.y) / u_Viewport.zw;\n            float distance = getDistance(depthTexture, v_textureCoordinates);\n            vec4 sceneColor = texture2D(colorTexture, v_textureCoordinates);\n            float blendAmount = interpolateByDistance(fogByDistance, distance);\n            vec4 finalFogColor = vec4(fogColor.rgb, fogColor.a * blendAmount);\n            gl_FragColor = alphaBlend(finalFogColor, sceneColor);\n            // gl_FragColor = vec4(sceneColor.rgb,0.3);\n            // gl_FragColor = vec4(distance,0.0,0.0,1.0);\n        }',
            uniforms: { fogByDistance: new e.Vector4(10, 0, 1e4 / i, 1), fogColor: s },
            inputPreviousStageTexture: !1,
          })
        );
      }
    }
    class Gc {
      constructor(e) {
        (this._collection = e),
          (this._framebuffers = []),
          (this._stageNameToFramebuffer = {}),
          (this._width = void 0),
          (this._height = void 0),
          (this._updateDependencies = !1);
      }
      updateDependencies() {
        this._updateDependencies = !0;
      }
      update(t) {
        const i = this._collection,
          s = this._updateDependencies,
          r =
            e.defined(i.ambientOcclusion) &&
            i.ambientOcclusion.enabled &&
            i.ambientOcclusion._isSupported(t),
          n = e.defined(i.bloom) && i.bloom.enabled && i.bloom._isSupported(t),
          o = e.defined(i._tonemapping) && i._tonemapping.enabled && i._tonemapping._isSupported(t),
          a = e.defined(i.fxaa) && i.fxaa.enabled && i.fxaa._isSupported(t),
          l = !e.defined(i._activeStages) || i._activeStages.length > 0 || r || n || o || a;
        if (
          ((s || (!l && this._framebuffers.length > 0)) &&
            (jc(this),
            (this._framebuffers.length = 0),
            (this._stageNameToFramebuffer = {}),
            (this._width = void 0),
            (this._height = void 0)),
          !s && !l)
        )
          return;
        0 === this._framebuffers.length &&
          (function (t, i) {
            const s = (function (t, i) {
              const s = {};
              if (e.defined(t.ambientOcclusion)) {
                const e = t.bloom,
                  r = t._tonemapping,
                  n = t.fxaa;
                let o = Hc(t, i, s, t.ambientOcclusion, void 0);
                (o = Hc(t, i, s, e, o)),
                  (o = zc(t, i, s, r, o)),
                  (o = Hc(t, i, s, t, o)),
                  zc(t, i, s, n, o);
              } else Hc(t, i, s, t, void 0);
              return s;
            })(t._collection, i);
            for (const e in s)
              s.hasOwnProperty(e) && (t._stageNameToFramebuffer[e] = Wc(t, e, s[e]));
          })(this, t);
        const h = t.drawingBufferWidth,
          c = t.drawingBufferHeight;
        (s || this._width !== h || this._height !== c) &&
          ((this._width = h),
          (this._height = c),
          (this._updateDependencies = !1),
          jc(this),
          (function (t, i) {
            const s = t._width,
              r = t._height,
              n = t._framebuffers,
              o = n.length;
            for (let t = 0; t < o; ++t) {
              const o = n[t],
                a = o.textureScale;
              let l = Math.ceil(s * a),
                h = Math.ceil(r * a),
                c = Math.min(l, h);
              o.forcePowerOfTwo &&
                (e.isPowerOfTwo(c) || (c = e.nextPowerOfTwo(c)), (l = c), (h = c)),
                o.buffer.update(i, l, h),
                (o.clear = new Ac({ color: o.clearColor, framebuffer: o.buffer.framebuffer }));
            }
          })(this, t));
      }
      clear(e) {
        const t = this._framebuffers;
        for (let i = 0; i < t.length; ++i) t[i].clear.execute(e);
      }
      getStageByName(e) {
        return this._collection.getStageByName(e);
      }
      getOutputTexture(e) {
        return this._collection.getOutputTexture(e);
      }
      getFramebuffer(t) {
        const i = this._stageNameToFramebuffer[t];
        if (e.defined(i)) return i.buffer.framebuffer;
      }
      isDestroyed() {
        return !1;
      }
      destroy() {
        return jc(this), e.destroyObject(this);
      }
    }
    function Uc(t) {
      for (; e.defined(t.length); ) t = t.get(t.length - 1);
      return t.name;
    }
    function zc(t, i, s, r, n) {
      if (!r.enabled || !r._isSupported(i)) return n;
      const o = (s[r.name] = {});
      e.defined(n) && (o[Uc(t.getStageByName(n))] = !0);
      const a = r.uniforms;
      if (e.defined(a)) {
        const i = Object.getOwnPropertyNames(a),
          s = i.length;
        for (let r = 0; r < s; ++r) {
          const s = a[i[r]];
          if ('string' == typeof s) {
            const i = t.getStageByName(s);
            e.defined(i) && (o[Uc(i)] = !0);
          }
        }
      }
      return r.name;
    }
    function Hc(t, i, s, r, n) {
      if ((e.defined(r.enabled) && !r.enabled) || (e.defined(r._isSupported) && !r._isSupported(i)))
        return n;
      const o = n,
        a = !e.defined(r.inputPreviousStageTexture) || r.inputPreviousStageTexture;
      let l = n;
      const h = r.length;
      for (let o = 0; o < h; ++o) {
        const h = r.get(o);
        (l = e.defined(h.length) ? Hc(t, i, s, h, n) : zc(t, i, s, h, n)), a && (n = l);
      }
      let c, _;
      if (a)
        for (c = 1; c < h; ++c) (_ = Uc(r.get(c))), e.defined(s[_]) || (s[_] = {}), (s[_][o] = !0);
      else
        for (c = 1; c < h; ++c) {
          _ = Uc(r.get(c));
          const e = s[_];
          for (let t = 0; t < c; ++t) e[Uc(r.get(t))] = !0;
        }
      return l;
    }
    function Wc(t, i, s) {
      const r = t._collection.getStageByName(i),
        n = r._textureScale,
        o = r._forcePowerOfTwo,
        a = r._pixelFormat,
        l = r._pixelDatatype,
        h = r._clearColor;
      let c, _;
      const u = t._framebuffers,
        d = u.length;
      for (c = 0; c < d; ++c) {
        if (
          ((_ = u[c]),
          n !== _.textureScale ||
            o !== _.forcePowerOfTwo ||
            a !== _.pixelFormat ||
            l !== _.pixelDatatype ||
            !e.Color.equals(h, _.clearColor))
        )
          continue;
        const t = _.stages,
          i = t.length;
        let r = !1;
        for (let e = 0; e < i; ++e)
          if (s[t[e]]) {
            r = !0;
            break;
          }
        if (!r) break;
      }
      return e.defined(_) && c < d
        ? (_.stages.push(i), _)
        : ((_ = {
            textureScale: n,
            forcePowerOfTwo: o,
            pixelFormat: a,
            pixelDatatype: l,
            clearColor: h,
            stages: [i],
            buffer: new Ic({ pixelFormat: a, pixelDatatype: l }),
            clear: void 0,
          }),
          u.push(_),
          _);
    }
    function jc(e) {
      const t = e._framebuffers,
        i = t.length;
      for (let e = 0; e < i; ++e) t[e].buffer.destroy();
    }
    const qc = {
      REINHARD: 0,
      MODIFIED_REINHARD: 1,
      FILMIC: 2,
      ACES: 3,
      validate: (e) =>
        e === qc.REINHARD || e === qc.MODIFIED_REINHARD || e === qc.FILMIC || e === qc.ACES,
    };
    var Xc = Object.freeze(qc);
    const Zc = [];
    class $c {
      constructor() {
        const t = Fc.createFXAAStage(),
          i = Fc.createAmbientOcclusionStage(),
          s = Fc.createBloomStage();
        (this._autoExposureEnabled = !1),
          (this._autoExposure = Fc.createAutoExposureStage()),
          (this._tonemapping = void 0),
          (this._tonemapper = void 0),
          (this.useHdr = !1),
          (this.tonemapper = Xc.ACES);
        const r = this._tonemapping;
        (t.enabled = !1), (i.enabled = !1), (s.enabled = !1), (r.enabled = !1);
        const n = new Gc(this),
          o = {},
          a = Zc;
        for (a.push(t, i, s, r); a.length > 0; ) {
          const t = a.pop();
          (o[t.name] = t), (t._textureCache = n);
          const i = t.length;
          if (e.defined(i)) for (let e = 0; e < i; ++e) a.push(t.get(e));
        }
        (this._stages = []),
          (this._activeStages = []),
          (this._previousActiveStages = []),
          (this._randomTexture = void 0);
        const l = this;
        (i.uniforms.randomTexture = function () {
          return l._randomTexture;
        }),
          (this._ao = i),
          (this._bloom = s),
          (this._fxaa = t),
          (this._aoEnabled = void 0),
          (this._bloomEnabled = void 0),
          (this._tonemappingEnabled = void 0),
          (this._fxaaEnabled = void 0),
          (this._activeStagesChanged = !1),
          (this._stagesRemoved = !1),
          (this._textureCacheDirty = !1),
          (this._stageNames = o),
          (this._textureCache = n);
      }
      get ready() {
        let e = !1;
        const t = this._stages;
        for (let i = t.length - 1; i >= 0; --i) {
          const s = t[i];
          e = e || (s.ready && s.enabled);
        }
        const i = this._fxaa,
          s = this._ao,
          r = this._bloom,
          n = this._tonemapping;
        return (
          (e = e || (i.ready && i.enabled)),
          (e = e || (s.ready && s.enabled)),
          (e = e || (r.ready && r.enabled)),
          (e = e || (n.ready && n.enabled)),
          e
        );
      }
      get fxaa() {
        return this._fxaa;
      }
      get ambientOcclusion() {
        return this._ao;
      }
      get bloom() {
        return this._bloom;
      }
      get length() {
        return Kc(this), this._stages.length;
      }
      get outputTexture() {
        const t = this._fxaa;
        if (t.enabled && t.ready) return this.getOutputTexture(t.name);
        const i = this._stages;
        for (let t = i.length - 1; t >= 0; --t) {
          const s = i[t];
          if (e.defined(s) && s.ready && s.enabled) return this.getOutputTexture(s.name);
        }
        const s = this._tonemapping;
        if (s.enabled && s.ready) return this.getOutputTexture(s.name);
        const r = this._bloom;
        if (r.enabled && r.ready) return this.getOutputTexture(r.name);
        const n = this._ao;
        return n.enabled && n.ready ? this.getOutputTexture(n.name) : void 0;
      }
      get hasSelected() {
        const t = this._stages.slice();
        for (; t.length > 0; ) {
          const i = t.pop();
          if (!e.defined(i)) continue;
          if (e.defined(i.selected)) return !0;
          const s = i.length;
          if (e.defined(s)) for (let e = 0; e < s; ++e) t.push(i.get(e));
        }
        return !1;
      }
      get tonemapper() {
        return this._tonemapper;
      }
      set tonemapper(t) {
        if (this._tonemapper === t) return;
        e.defined(this._tonemapping) &&
          (delete this._stageNames[this._tonemapping.name], this._tonemapping.destroy());
        const i = this._autoExposureEnabled;
        let s;
        switch (t) {
          case Xc.REINHARD:
            s = Fc.createReinhardTonemappingStage(i);
            break;
          case Xc.MODIFIED_REINHARD:
            s = Fc.createModifiedReinhardTonemappingStage(i);
            break;
          case Xc.FILMIC:
            s = Fc.createFilmicTonemappingStage(i);
            break;
          default:
            s = Fc.createAcesTonemappingStage(i);
        }
        if (i) {
          const e = this._autoExposure;
          s.uniforms.autoExposure = function () {
            return e.outputTexture;
          };
        }
        (this._tonemapper = t),
          (this._tonemapping = s),
          e.defined(this._stageNames) &&
            ((this._stageNames[s.name] = s), (s._textureCache = this._textureCache)),
          (this._textureCacheDirty = !0);
      }
      add(t) {
        const i = this._stageNames,
          s = Zc;
        for (s.push(t); s.length > 0; ) {
          const t = s.pop();
          if (e.defined(i[t.name]))
            throw new Error(
              `${t.name} has already been added to the collection or does not have a unique name.`,
            );
          (i[t.name] = t), (t._textureCache = this._textureCache);
          const r = t.length;
          if (e.defined(r)) for (let e = 0; e < r; ++e) s.push(t.get(e));
        }
        const r = this._stages;
        return (t._index = r.length), r.push(t), (this._textureCacheDirty = !0), t;
      }
      remove(t) {
        if (!this.contains(t)) return !1;
        const i = this._stageNames,
          s = Zc;
        for (s.push(t); s.length > 0; ) {
          const t = s.pop();
          delete i[t.name];
          const r = t.length;
          if (e.defined(r)) for (let e = 0; e < r; ++e) s.push(t.get(e));
        }
        return (
          (this._stages[t._index] = void 0),
          (this._stagesRemoved = !0),
          (this._textureCacheDirty = !0),
          (t._index = void 0),
          (t._textureCache = void 0),
          t.destroy(),
          !0
        );
      }
      contains(t) {
        return e.defined(t) && e.defined(t._index) && t._textureCache === this._textureCache;
      }
      get(e) {
        Kc(this);
        const t = this._stages,
          i = t.length;
        if (i < 0) throw new Error('stages length is 0!');
        if (e < 0) throw new Error('index must be greater than 0!');
        if (e >= i) throw new Error('index must be less than stages length!');
        return t[e];
      }
      removeAll() {
        const e = this._stages,
          t = e.length;
        for (let i = 0; i < t; ++i) this.remove(e[i]);
        e.length = 0;
      }
      getStageByName(e) {
        return this._stageNames[e];
      }
      update(t, i) {
        Kc(this);
        const s = this.useHdr,
          r = this._activeStages,
          n = (this._activeStages = this._previousActiveStages);
        this._previousActiveStages = r;
        const o = this._stages;
        let a,
          l,
          h = (n.length = o.length),
          c = 0;
        for (a = 0; a < h; ++a)
          (l = o[a]), l.ready && l.enabled && l._isSupported(t) && (n[c++] = l);
        n.length = c;
        let _ = c !== r.length;
        if (!_)
          for (a = 0; a < c; ++a)
            if (n[a] !== r[a]) {
              _ = !0;
              break;
            }
        const u = this._ao,
          d = this._bloom,
          m = this._autoExposure,
          p = this._tonemapping,
          f = this._fxaa;
        p.enabled = s;
        const g = u.enabled && u._isSupported(t),
          y = d.enabled && d._isSupported(t),
          T = p.enabled && p._isSupported(t),
          x = f.enabled && f._isSupported(t);
        if (
          ((_ ||
            this._textureCacheDirty ||
            g !== this._aoEnabled ||
            y !== this._bloomEnabled ||
            T !== this._tonemappingEnabled ||
            x !== this._fxaaEnabled) &&
            (this._textureCache.updateDependencies(),
            (this._aoEnabled = g),
            (this._bloomEnabled = y),
            (this._tonemappingEnabled = T),
            (this._fxaaEnabled = x),
            (this._textureCacheDirty = !1)),
          e.defined(this._randomTexture) &&
            !g &&
            (this._randomTexture.destroy(), (this._randomTexture = null)),
          !e.defined(this._randomTexture) && g)
        ) {
          h = 196608;
          const i = new Uint8Array(h);
          for (a = 0; a < h; a += 3) i[a] = Math.floor(255 * Math.random());
          this._randomTexture = new e.Texture({
            context: t,
            pixelFormat: e.PixelFormat.RGB,
            pixelDatatype: e.PixelDatatype.UNSIGNED_BYTE,
            source: { arrayBufferView: i, width: 256, height: 256 },
            sampler: new e.Sampler({
              wrapS: e.TextureWrap.REPEAT,
              wrapT: e.TextureWrap.REPEAT,
              minificationFilter: e.TextureMinificationFilter.NEAREST,
              magnificationFilter: e.TextureMagnificationFilter.NEAREST,
            }),
          });
        }
        for (
          this._textureCache.update(t),
            f.update(t, i),
            u.update(t, i),
            d.update(t, i),
            p.update(t, i),
            this._autoExposureEnabled && m.update(t, i),
            h = o.length,
            a = 0;
          a < h;
          ++a
        )
          o[a].update(t, i);
        for (c = 0, a = 0; a < h; ++a) (l = o[a]), l.ready && l.enabled && l._isSupported(t) && c++;
        (_ = c !== n.length), _ && this.update(t, i, s);
      }
      clear(e) {
        this._textureCache.clear(e), this._autoExposure && this._autoExposure.clear(e);
      }
      getOutputTexture(t) {
        const i = this.getStageByName(t);
        if (e.defined(i)) return Yc(i);
      }
      execute(e, t, i, s) {
        const r = this._activeStages,
          n = r.length,
          o = this._fxaa,
          a = this._ao,
          l = this._bloom,
          h = this._autoExposure,
          c = this._tonemapping,
          _ = a.enabled && a._isSupported(e),
          u = l.enabled && l._isSupported(e),
          d = this._autoExposureEnabled,
          m = c.enabled && c._isSupported(e),
          p = o.enabled && o._isSupported(e);
        if (!(p || _ || u || m || 0 !== n)) return;
        let f = t;
        _ && a.ready && (Qc(a, e, f, i, s), (f = Yc(a))),
          u && l.ready && (Qc(l, e, f, i, s), (f = Yc(l))),
          d && h.ready && Qc(h, e, f, i, s),
          m && c.ready && (Qc(c, e, f, i, s), (f = Yc(c)));
        let g = f;
        if (n > 0) {
          Qc(r[0], e, f, i, s);
          for (let t = 1; t < n; ++t) Qc(r[t], e, Yc(r[t - 1]), i, s);
          g = Yc(r[n - 1]);
        }
        p && o.ready && Qc(o, e, g, i, s);
      }
      createViewportQuadCommand(t) {
        const i = this;
        return (
          e.defined(this._copyColorCommand) ||
            (this._copyColorCommand = {
              painter: t.painter,
              framebuffer: void 0,
              layer: { id: 'postprocess' },
              geometry: new e.ViewportQuadGeometry(t.painter),
              material: {
                _uniforms: new Map([['colorTexture', () => i.outputTexture]]),
                _shaderSource: new e.ShaderSource({
                  vertexSource: e.shaders.screen.vertexSource,
                  fragmentSource: e.shaders.PassThrough.fragmentSource,
                }),
              },
            }),
          this._copyColorCommand
        );
      }
      copy(e, t) {
        (this._copyColorCommand = this.createViewportQuadCommand(e)),
          (this._copyColorCommand.framebuffer = t.framebuffer),
          e.draw(this._copyColorCommand);
      }
      serialize() {
        const t = {
            fxaa: this.fxaa.enabled,
            bloom: this.bloom.enabled,
            hdr: this.useHdr,
            nightVision: !1,
          },
          i = { color: [112, 78, 200], width: 10 },
          s = { fogColor: [], fogDensity: [] };
        for (let r = 0; r < this._stages.length; r++) {
          const n = this._stages[r];
          if (
            ('czm_black_and_white' === n.name && (t.blackWhite = !0),
            'czm_night_vision' === n.name && (t.nightVision = !0),
            'skyline' === n.name)
          ) {
            const s = n._stages[2]._uniformMap.get('linecolor')(),
              r = n._stages[2]._uniformMap.get('width')();
            (i.color = e.Vector4.pack(s, new Array(4))), (i.width = r), (t.skyline = i);
          }
          if ('mm_fog_effect' === n.name) {
            s.fogColor = e.Vector4.pack(n._uniformMap.get('fogColor')(), new Array(4));
            const i = 1e4 / n._uniformMap.get('fogByDistance')()[2];
            (s.fogDensity = Math.max(Math.min(i, 100), 1)), (t.fog = s);
          }
        }
        return t;
      }
      destroy() {
        return (
          this._fxaa.destroy(),
          this._ao.destroy(),
          this._bloom.destroy(),
          this._autoExposure.destroy(),
          this._tonemapping.destroy(),
          this.removeAll(),
          (this._textureCache = this._textureCache && this._textureCache.destroy()),
          e.destroyObject(this)
        );
      }
    }
    function Kc(e) {
      if (!e._stagesRemoved) return;
      e._stagesRemoved = !1;
      const t = [],
        i = e._stages,
        s = i.length;
      for (let e = 0, r = 0; e < s; ++e) {
        const s = i[e];
        s && ((s._index = r++), t.push(s));
      }
      e._stages = t;
    }
    function Yc(t) {
      for (; e.defined(t.length); ) t = t.get(t.length - 1);
      return t.outputTexture;
    }
    function Qc(t, i, s, r, n) {
      if (e.defined(t.execute)) return void t.execute(i, s, r, n);
      const o = t.length;
      let a;
      if (t.inputPreviousStageTexture)
        for (Qc(t.get(0), i, s, r, n), a = 1; a < o; ++a) Qc(t.get(a), i, Yc(t.get(a - 1)), r, n);
      else for (a = 0; a < o; ++a) Qc(t.get(a), i, s, r, n);
    }
    const Jc = e.createLayout([{ name: 'a_POSITION', components: 3, type: 'Float32' }], 4),
      { members: e_ } = Jc;
    class t_ {
      constructor(t) {
        (this._tileCount = 0),
          (this.cache = {}),
          (this.keys = []),
          (this._context = t.context),
          (this._projectionType = t.projection || e.ProjectionType.MERCATOR),
          (this.debugVAO = new yn());
      }
      setProjection(e) {
        this._projectionType = e;
      }
      setMaxTile(e) {
        for (this._tileCount = e; this.keys.length > this._tileCount; )
          this.removeTileById(this.keys[0]);
      }
      addTileByCoord(t) {
        const i = t.canonical,
          s = i.z,
          r = i.x,
          n = i.y,
          o = t.key,
          a = new e.StructArrayLayout3f12();
        let l = 8 - s;
        l < 1 && (l = 1);
        let h = 0,
          c = [];
        for (let t = 0; t < l + 1; t++) {
          const i = e.getSpherePos((t / (l + 1)) * e.EXTENT, 5, 0, r, n, s, this._projectionType);
          0 === c.length && (c = i), a.emplaceBack(i[0] - c[0], i[1] - c[1], i[2] - c[2]), h++;
        }
        for (let t = 0; t < l + 1; t++) {
          const i = e.getSpherePos(
            e.EXTENT,
            (t / (l + 1)) * e.EXTENT,
            5,
            r,
            n,
            s,
            this._projectionType,
          );
          a.emplaceBack(i[0] - c[0], i[1] - c[1], i[2] - c[2]), h++;
        }
        for (let t = l + 1; t > 0; t--) {
          const i = e.getSpherePos(
            (t / (l + 1)) * e.EXTENT,
            e.EXTENT,
            5,
            r,
            n,
            s,
            this._projectionType,
          );
          a.emplaceBack(i[0] - c[0], i[1] - c[1], i[2] - c[2]), h++;
        }
        for (let t = l + 1; t >= 0; t--) {
          const i = e.getSpherePos(0, (t / (l + 1)) * e.EXTENT, 5, r, n, s, this._projectionType);
          a.emplaceBack(i[0] - c[0], i[1] - c[1], i[2] - c[2]), h++;
        }
        const _ = (function (e, t, i, s) {
          s = s || 1;
          const r = [];
          let n, o, a, l, h, c, _, u;
          for (n = 0, o = e.length; n < o; n++)
            if (((h = i_[e[n]]), h)) {
              for (u = null, a = 0, l = h[1].length; a < l; a += 2)
                -1 === h[1][a] && -1 === h[1][a + 1]
                  ? (u = null)
                  : ((c = t + h[1][a] * s),
                    (_ = 800 - h[1][a + 1] * s),
                    u && r.push(u.x, u.y, c, _),
                    (u = { x: c, y: _ }));
              t += h[0] * s;
            }
          return r;
        })(t.toString(), 50, 0, 20);
        let u = 0;
        for (let t = 0; t < _.length; t += 2) {
          const i = e.getSpherePos(_[t], _[t + 1], 5, r, n, s, this._projectionType);
          a.emplaceBack(i[0] - c[0], i[1] - c[1], i[2] - c[2]), u++;
        }
        const d = this._context.createVertexBuffer(a, e_);
        return (
          this.keys.push(o),
          (this.cache[o] = {
            rP: c,
            matrix: new e.Matrix4().translate(c),
            debugBuffer: d,
            lineVerticesCount: h,
            textVerticesCount: u,
          }),
          this.cache[o]
        );
      }
      getTileByCoord(e) {
        if (!this.hasTile(e.key)) return this.addTileByCoord(e);
        for (let t = 0; t < this.keys.length; t++)
          if (this.keys[t] === e.key)
            return this.keys.splice(t, 1), this.keys.push(e.key), this.cache[e.key];
      }
      removeTileById(e) {
        this.cache[e].debugBuffer.destroy(), (this.cache[e] = null), delete this.cache[e];
        for (let t = 0; t < this.keys.length; t++)
          if (this.keys[t] === e) {
            this.keys.splice(t, 1);
            break;
          }
      }
      hasTile(e) {
        return !!this.cache[e];
      }
      release() {
        for (; this.keys.length > 0; ) this.removeTileById(this.keys[0]);
      }
    }
    const i_ = {
      ' ': [16, []],
      '#': [
        21,
        [11, 25, 4, -7, -1, -1, 17, 25, 10, -7, -1, -1, 4, 12, 18, 12, -1, -1, 3, 6, 17, 6],
      ],
      '-': [26, [4, 9, 22, 9]],
      '.': [10, [5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],
      '/': [22, [20, 25, 2, -7]],
      0: [
        20,
        [
          9, 21, 6, 20, 4, 17, 3, 12, 3, 9, 4, 4, 6, 1, 9, 0, 11, 0, 14, 1, 16, 4, 17, 9, 17, 12,
          16, 17, 14, 20, 11, 21, 9, 21,
        ],
      ],
      1: [20, [6, 17, 8, 18, 11, 21, 11, 0]],
      2: [
        20,
        [
          4, 16, 4, 17, 5, 19, 6, 20, 8, 21, 12, 21, 14, 20, 15, 19, 16, 17, 16, 15, 15, 13, 13, 10,
          3, 0, 17, 0,
        ],
      ],
      3: [
        20,
        [
          5, 21, 16, 21, 10, 13, 13, 13, 15, 12, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5,
          1, 4, 2, 3, 4,
        ],
      ],
      4: [20, [13, 21, 3, 7, 18, 7, -1, -1, 13, 21, 13, 0]],
      5: [
        20,
        [
          15, 21, 5, 21, 4, 12, 5, 13, 8, 14, 11, 14, 14, 13, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1,
          11, 0, 8, 0, 5, 1, 4, 2, 3, 4,
        ],
      ],
      6: [
        20,
        [
          16, 18, 15, 20, 12, 21, 10, 21, 7, 20, 5, 17, 4, 12, 4, 7, 5, 3, 7, 1, 10, 0, 11, 0, 14,
          1, 16, 3, 17, 6, 17, 7, 16, 10, 14, 12, 11, 13, 10, 13, 7, 12, 5, 10, 4, 7,
        ],
      ],
      7: [20, [17, 21, 7, 0, -1, -1, 3, 21, 17, 21]],
      8: [
        20,
        [
          8, 21, 5, 20, 4, 18, 4, 16, 5, 14, 7, 13, 11, 12, 14, 11, 16, 9, 17, 7, 17, 4, 16, 2, 15,
          1, 12, 0, 8, 0, 5, 1, 4, 2, 3, 4, 3, 7, 4, 9, 6, 11, 9, 12, 13, 13, 15, 14, 16, 16, 16,
          18, 15, 20, 12, 21, 8, 21,
        ],
      ],
      9: [
        20,
        [
          16, 14, 15, 11, 13, 9, 10, 8, 9, 8, 6, 9, 4, 11, 3, 14, 3, 15, 4, 18, 6, 20, 9, 21, 10,
          21, 13, 20, 15, 18, 16, 14, 16, 9, 15, 4, 13, 1, 10, 0, 8, 0, 5, 1, 4, 3,
        ],
      ],
      b: [
        19,
        [
          4, 21, 4, 0, -1, -1, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13,
          1, 11, 0, 8, 0, 6, 1, 4, 3,
        ],
      ],
      g: [
        19,
        [
          15, 14, 15, -2, 14, -5, 13, -6, 11, -7, 8, -7, 6, -6, -1, -1, 15, 11, 13, 13, 11, 14, 8,
          14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3,
        ],
      ],
      k: [17, [4, 21, 4, 0, -1, -1, 14, 14, 4, 4, -1, -1, 8, 8, 15, 0]],
      m: [
        30,
        [
          4, 14, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0, -1, -1, 15, 10,
          18, 13, 20, 14, 23, 14, 25, 13, 26, 10, 26, 0,
        ],
      ],
    };
    function s_(e, t, i, s) {
      switch (t.type) {
        case e.FLOAT:
          return new r_(e, t, i, s);
        case e.FLOAT_VEC2:
          return new n_(e, t, i, s);
        case e.FLOAT_VEC3:
          return new o_(e, t, i, s);
        case e.FLOAT_VEC4:
          return new a_(e, t, i, s);
        case e.SAMPLER_2D:
        case e.SAMPLER_CUBE:
          return new l_(e, t, i, s);
        case e.INT:
        case e.BOOL:
          return new h_(e, t, i, s);
        case e.INT_VEC2:
        case e.BOOL_VEC2:
          return new c_(e, t, i, s);
        case e.INT_VEC3:
        case e.BOOL_VEC3:
          return new __(e, t, i, s);
        case e.INT_VEC4:
        case e.BOOL_VEC4:
          return new u_(e, t, i, s);
        case e.FLOAT_MAT2:
          return new d_(e, t, i, s);
        case e.FLOAT_MAT3:
          return new m_(e, t, i, s);
        case e.FLOAT_MAT4:
          return new p_(e, t, i, s);
        default:
          console.warn(`Unrecognized uniform type: ${t.type} for uniform "${i}".`);
      }
    }
    class r_ {
      constructor(e, t, i, s) {
        (this.name = i),
          (this.value = void 0),
          (this._value = 0),
          (this._gl = e),
          (this._location = s);
      }
      set() {
        this.value !== this._value &&
          ((this._value = this.value), this._gl.uniform1f(this._location, this.value));
      }
    }
    class n_ {
      constructor(t, i, s, r) {
        (this.name = s),
          (this.value = void 0),
          (this._value = new e.Vector2()),
          (this._gl = t),
          (this._location = r);
      }
      set() {
        const t = this.value;
        e.Vector2.equalsArray(t, this._value) ||
          (this._value.copy(t), this._gl.uniform2f(this._location, t.x, t.y));
      }
    }
    class o_ {
      constructor(t, i, s, r) {
        (this.name = s),
          (this.value = void 0),
          (this._value = new e.Vector3()),
          (this._gl = t),
          (this._location = r);
      }
      set() {
        const t = this.value;
        t &&
          e.defined(t.x) &&
          (e.Vector3.equalsArray(t, this._value) ||
            (this._value.copy(t), this._gl.uniform3f(this._location, t.x, t.y, t.z)));
      }
    }
    class a_ {
      constructor(t, i, s, r) {
        (this.name = s),
          (this.value = void 0),
          (this._value = new e.Vector4()),
          (this._gl = t),
          (this._location = r);
      }
      set() {
        const t = this.value;
        e.defined(t.x) &&
          (e.Vector4.equalsArray(t, this._value) ||
            (this._value.copy(t), this._gl.uniform4f(this._location, t.x, t.y, t.z, t.w)));
      }
    }
    class l_ {
      constructor(e, t, i, s) {
        (this.name = i),
          (this.value = void 0),
          (this._gl = e),
          (this._location = s),
          (this.textureUnitIndex = void 0);
      }
      set() {
        const e = this._gl,
          t = this.value;
        t
          ? (e.activeTexture(e.TEXTURE0 + this.textureUnitIndex),
            e.bindTexture(t._target, t.texture))
          : console.error('Error set null Texture!');
      }
      _setSampler(e) {
        return (this.textureUnitIndex = e), this._gl.uniform1i(this._location, e), e + 1;
      }
    }
    class h_ {
      constructor(e, t, i, s) {
        (this.name = i),
          (this.value = void 0),
          (this._value = 0),
          (this._gl = e),
          (this._location = s);
      }
      set() {
        this.value !== this._value &&
          ((this._value = this.value), this._gl.uniform1i(this._location, this.value));
      }
    }
    class c_ {
      constructor(t, i, s, r) {
        (this.name = s),
          (this.value = void 0),
          (this._value = new e.Vector2()),
          (this._gl = t),
          (this._location = r);
      }
      set() {
        const t = this.value;
        e.Vector2.equalsArray(t, this._value) ||
          (this._value.copy(t), this._gl.uniform2i(this._location, t.x, t.y));
      }
    }
    class __ {
      constructor(t, i, s, r) {
        (this.name = s),
          (this.value = void 0),
          (this._value = new e.Vector3()),
          (this._gl = t),
          (this._location = r);
      }
      set() {
        const t = this.value;
        e.Vector3.equalsArray(t, this._value) ||
          (this._value.copy(t), this._gl.uniform3i(this._location, t.x, t.y, t.z));
      }
    }
    class u_ {
      constructor(t, i, s, r) {
        (this.name = s),
          (this.value = void 0),
          (this._value = new e.Vector4()),
          (this._gl = t),
          (this._location = r);
      }
      set() {
        const t = this.value;
        e.Vector4.equalsArray(t, this._value) ||
          (this._value.copy(t), this._gl.uniform4i(this._location, t.x, t.y, t.z, t.w));
      }
    }
    class d_ {
      constructor(t, i, s, r) {
        (this.name = s),
          (this.value = void 0),
          (this._value = new e.Matrix2([0, 0, 0, 0])),
          (this._gl = t),
          (this._location = r);
      }
      set() {
        if (!e.Matrix2.equalsArray(this.value, this._value)) {
          this._value.copy(this.value);
          const e = this.value.toFloat32Array();
          this._gl.uniformMatrix2fv(this._location, !1, e);
        }
      }
    }
    class m_ {
      constructor(t, i, s, r) {
        (this.name = s),
          (this.value = void 0),
          (this._value = new e.Matrix3()),
          (this._gl = t),
          (this._location = r);
      }
      set() {
        if (!e.Matrix3.equalsArray(this.value, this._value, 0)) {
          this._value.copy(this.value);
          const e = this.value.toFloat32Array();
          this._gl.uniformMatrix3fv(this._location, !1, e);
        }
      }
    }
    class p_ {
      constructor(t, i, s, r) {
        (this.name = s),
          (this.value = void 0),
          (this._value = new e.Matrix4(e.Matrix4.ZERO)),
          (this._gl = t),
          (this._location = r);
      }
      set() {
        if (!e.Matrix4.equalsArray(this.value, this._value, 0)) {
          this._value.copy(this.value);
          const e = this.value.toFloat32Array();
          this._gl.uniformMatrix4fv(this._location, !1, e);
        }
      }
    }
    function f_(e, t, i, s) {
      switch (t.type) {
        case e.FLOAT:
          return new g_(e, t, i, s);
        case e.FLOAT_VEC2:
          return new y_(e, t, i, s);
        case e.FLOAT_VEC3:
          return new T_(e, t, i, s);
        case e.FLOAT_VEC4:
          return new x_(e, t, i, s);
        case e.SAMPLER_2D:
        case e.SAMPLER_CUBE:
          return new v_(e, t, i, s);
        case e.INT:
        case e.BOOL:
          return new b_(e, t, i, s);
        case e.INT_VEC2:
        case e.BOOL_VEC2:
          return new w_(e, t, i, s);
        case e.INT_VEC3:
        case e.BOOL_VEC3:
          return new C_(e, t, i, s);
        case e.INT_VEC4:
        case e.BOOL_VEC4:
          return new S_(e, t, i, s);
        case e.FLOAT_MAT2:
          return new E_(e, t, i, s);
        case e.FLOAT_MAT3:
          return new P_(e, t, i, s);
        case e.FLOAT_MAT4:
          return new M_(e, t, i, s);
        default:
          console.warn(`Unrecognized uniform type: ${t.type} for uniform "${i}".`);
      }
    }
    class g_ {
      constructor(e, t, i, s) {
        const r = s.length;
        (this.name = i),
          (this.value = new Array(r)),
          (this._value = new Float32Array(r)),
          (this._gl = e),
          (this._location = s[0]);
      }
      set() {
        const e = this.value,
          t = e.length,
          i = this._value;
        let s = !1;
        for (let r = 0; r < t; ++r) {
          const t = e[r];
          t !== i[r] && ((i[r] = t), (s = !0));
        }
        s && this._gl.uniform1fv(this._location, i);
      }
    }
    class y_ {
      constructor(e, t, i, s) {
        const r = s.length;
        (this.name = i),
          (this.value = new Array(r)),
          (this._value = new Float32Array(2 * r)),
          (this._gl = e),
          (this._location = s[0]);
      }
      set() {
        const t = this.value,
          i = t.length,
          s = this._value;
        let r = !1,
          n = 0;
        for (let o = 0; o < i; ++o) {
          const i = t[o];
          e.Vector2.equalsArray(i, s, n) || (e.Vector2.pack(i, s, n), (r = !0)), (n += 2);
        }
        r && this._gl.uniform2fv(this._location, s);
      }
    }
    class T_ {
      constructor(e, t, i, s) {
        const r = s.length;
        (this.name = i),
          (this.value = new Array(r)),
          (this._value = new Float32Array(3 * r)),
          (this._gl = e),
          (this._location = s[0]);
      }
      set() {
        const t = this.value,
          i = t.length,
          s = this._value;
        let r = !1,
          n = 0;
        for (let o = 0; o < i; ++o) {
          const i = t[o];
          if (!e.defined(i)) break;
          e.defined(i.r)
            ? (i.r === s[n] && i.g === s[n + 1] && i.b === s[n + 2]) ||
              ((s[n] = i.r), (s[n + 1] = i.g), (s[n + 2] = i.b), (r = !0))
            : e.defined(i.x)
            ? e.Vector3.equalsArray(i, s, n) || (e.Vector3.pack(i, s, n), (r = !0))
            : console.warn('Invalid vec3 value.'),
            (n += 3);
        }
        r && this._gl.uniform3fv(this._location, s);
      }
    }
    class x_ {
      constructor(e, t, i, s) {
        const r = s.length;
        (this.name = i),
          (this.value = new Array(r)),
          (this._value = new Float32Array(4 * r)),
          (this._gl = e),
          (this._location = s[0]);
      }
      set() {
        const t = this.value,
          i = t.length,
          s = this._value;
        let r = !1,
          n = 0;
        for (let o = 0; o < i; ++o) {
          const i = t[o];
          e.defined(i.x) && (e.Vector4.equalsArray(i, s, n) || (e.Vector4.pack(i, s, n), (r = !0))),
            (n += 4);
        }
        r && this._gl.uniform4fv(this._location, s);
      }
    }
    class v_ {
      constructor(e, t, i, s) {
        const r = s.length;
        (this.name = i),
          (this.value = new Array(r)),
          (this._value = new Float32Array(r)),
          (this._gl = e),
          (this._locations = s),
          (this.textureUnitIndex = void 0);
      }
      set() {
        const e = this._gl,
          t = e.TEXTURE0 + this.textureUnitIndex,
          i = this.value,
          s = i.length;
        for (let r = 0; r < s; ++r) {
          const s = i[r];
          e.activeTexture(t + r), e.bindTexture(s._target, s.texture);
        }
      }
      _setSampler(e) {
        this.textureUnitIndex = e;
        const t = this._locations,
          i = t.length;
        for (let s = 0; s < i; ++s) this._gl.uniform1i(t[s], e + s);
        return e + i;
      }
    }
    class b_ {
      constructor(e, t, i, s) {
        const r = s.length;
        (this.name = i),
          (this.value = new Array(r)),
          (this._value = new Int32Array(r)),
          (this._gl = e),
          (this._location = s[0]);
      }
      set() {
        const e = this.value,
          t = e.length,
          i = this._value;
        let s = !1;
        for (let r = 0; r < t; ++r) {
          const t = e[r];
          t !== i[r] && ((i[r] = t), (s = !0));
        }
        s && this._gl.uniform1iv(this._location, i);
      }
    }
    class w_ {
      constructor(e, t, i, s) {
        const r = s.length;
        (this.name = i),
          (this.value = new Array(r)),
          (this._value = new Int32Array(2 * r)),
          (this._gl = e),
          (this._location = s[0]);
      }
      set() {
        const t = this.value,
          i = t.length,
          s = this._value;
        let r = !1,
          n = 0;
        for (let o = 0; o < i; ++o) {
          const i = t[o];
          e.Vector2.equalsArray(i, s, n) || (e.Vector2.pack(i, s, n), (r = !0)), (n += 2);
        }
        r && this._gl.uniform2iv(this._location, s);
      }
    }
    class C_ {
      constructor(e, t, i, s) {
        const r = s.length;
        (this.name = i),
          (this.value = new Array(r)),
          (this._value = new Int32Array(3 * r)),
          (this._gl = e),
          (this._location = s[0]);
      }
      set() {
        const t = this.value,
          i = t.length,
          s = this._value;
        let r = !1,
          n = 0;
        for (let o = 0; o < i; ++o) {
          const i = t[o];
          e.Vector3.equalsArray(i, s, n) || (e.Vector3.pack(i, s, n), (r = !0)), (n += 3);
        }
        r && this._gl.uniform3iv(this._location, s);
      }
    }
    class S_ {
      constructor(e, t, i, s) {
        const r = s.length;
        (this.name = i),
          (this.value = new Array(r)),
          (this._value = new Int32Array(4 * r)),
          (this._gl = e),
          (this._location = s[0]);
      }
      set() {
        const t = this.value,
          i = t.length,
          s = this._value;
        let r = !1,
          n = 0;
        for (let o = 0; o < i; ++o) {
          const i = t[o];
          e.Vector4.equalsArray(i, s, n) || (e.Vector4.pack(i, s, n), (r = !0)), (n += 4);
        }
        r && this._gl.uniform4iv(this._location, s);
      }
    }
    class E_ {
      constructor(e, t, i, s) {
        const r = s.length;
        (this.name = i),
          (this.value = new Array(r)),
          (this._value = new Float32Array(4 * r)),
          (this._gl = e),
          (this._location = s[0]);
      }
      set() {
        const t = this.value,
          i = t.length,
          s = this._value;
        let r = !1,
          n = 0;
        for (let o = 0; o < i; ++o) {
          const i = t[o];
          e.Matrix2.equalsArray(i, s, n) || (e.Matrix2.pack(i, s, n), (r = !0)), (n += 4);
        }
        r && this._gl.uniformMatrix2fv(this._location, !1, s);
      }
    }
    class P_ {
      constructor(e, t, i, s) {
        const r = s.length;
        (this.name = i),
          (this.value = new Array(r)),
          (this._value = new Float32Array(9 * r)),
          (this._gl = e),
          (this._location = s[0]);
      }
      set() {
        const t = this.value,
          i = t.length,
          s = this._value;
        let r = !1,
          n = 0;
        for (let o = 0; o < i; ++o) {
          const i = t[o];
          if (!i) break;
          e.Matrix3.equalsArray(i, s, n) || (e.Matrix3.pack(i, s, n), (r = !0)), (n += 9);
        }
        r && this._gl.uniformMatrix3fv(this._location, !1, s);
      }
    }
    class M_ {
      constructor(e, t, i, s) {
        const r = s.length;
        (this.name = i),
          (this.value = new Array(r)),
          (this._value = new Float32Array(16 * r)),
          (this._gl = e),
          (this._location = s[0]);
      }
      set() {
        const t = this.value,
          i = t.length,
          s = this._value;
        let r = !1,
          n = 0;
        for (let o = 0; o < i; ++o) {
          const i = t[o];
          if (!i) break;
          e.Matrix4.equalsArray(i, s, n) || (e.Matrix4.pack(i, s, n), (r = !0)), (n += 16);
        }
        r && this._gl.uniformMatrix4fv(this._location, !1, s);
      }
    }
    class A_ {
      constructor(e) {
        (this.name = e), (this._value = {}), (this._locations = {}), (this.isUniformStruct = !0);
      }
      addLocation(e) {
        this._locations[e.name] || (this._locations[e.name] = e.value);
      }
      set() {
        const e = Object.getOwnPropertyNames(this._locations);
        for (let t = 0; t < e.length; t++) this._locations[e[t]].set();
      }
    }
    function R_(e, t) {
      return new A_(e, t);
    }
    Object.defineProperties(A_.prototype, {
      value: {
        set(e) {
          if (
            !(function (e, t) {
              const i = Object.getOwnPropertyNames(e),
                s = Object.getOwnPropertyNames(t);
              if (i.length != s.length) return !1;
              for (let s = 0; s < i.length; s++) {
                const r = i[s];
                if (e[r] !== t[r]) return !1;
              }
              return !0;
            })(e, this._value)
          ) {
            const t = Object.getOwnPropertyNames(e);
            for (let i = 0; i < t.length; i++) this._locations[t[i]].value = (0, e[i])();
          }
        },
      },
    });
    const I_ = {
      [e.WebGLConstants.POINTS]: 1,
      [e.WebGLConstants.LINES]: 2,
      [e.WebGLConstants.LINE_LOOP]: 2,
      [e.WebGLConstants.LINE_STRIP]: 2,
      [e.WebGLConstants.TRIANGLES]: 3,
    };
    class O_ {
      constructor(t, i, s) {
        const r = t.gl;
        this.program = r.createProgram();
        const n = s.defines().concat(this._setMicroDefines(i.defines)),
          o = n
            .concat(
              e.shaders.prelude.fragmentSource,
              e.shaders.unpackAll.fragmentSource,
              i.fragmentSource,
            )
            .join('\n'),
          a = n
            .concat(
              e.shaders.prelude.vertexSource,
              e.shaders.unpackAll.vertexSource,
              i.vertexSource,
            )
            .join('\n'),
          l = r.createShader(e.WebGLConstants.FRAGMENT_SHADER);
        r.shaderSource(l, o), r.compileShader(l), r.attachShader(this.program, l);
        const h = r.createShader(e.WebGLConstants.VERTEX_SHADER);
        r.shaderSource(h, a),
          r.compileShader(h),
          r.attachShader(this.program, h),
          (this.attributes = {}),
          r.linkProgram(this.program),
          r.deleteShader(h),
          r.deleteShader(l),
          (this.numAttributes = r.getProgramParameter(
            this.program,
            e.WebGLConstants.ACTIVE_ATTRIBUTES,
          ));
        for (let e = 0; e < this.numAttributes; e++) {
          const t = r.getActiveAttrib(this.program, e);
          t && (this.attributes[t.name] = r.getAttribLocation(this.program, t.name));
        }
        const c = s ? s.getBinderUniforms() : [],
          _ = {};
        for (let e = 0; e < c.length; e++) {
          const t = c[e];
          if (t && !_[t]) {
            const e = r.getUniformLocation(this.program, t);
            e && (_[t] = e);
          }
        }
        (this.binderUniforms = s ? s.getUniforms(t, _) : []),
          (this.programUniforms = O_.findUniforms(r, this.program)),
          this.programUniforms &&
            this.programUniforms.samplerUniforms.length > 0 &&
            (this.maximumTextureUnitIndex = this._setSamplerUniforms(r, this.program));
      }
      _setUniforms(t) {
        const i = this.programUniforms.uniformsByName,
          s = e.intersectionMapKeys(i, t);
        for (let e = 0; e < s.length; e++) {
          const r = s[e],
            n = t.get(r),
            o = i.get(r);
          if (o.isUniformStruct)
            for (const e in o._locations)
              Object.hasOwnProperty.call(o._locations, e) && (o._locations[e].value = n[e]());
          else o.value = n();
        }
        const r = this.programUniforms.uniforms,
          n = r.length;
        for (let e = 0; e < n; ++e)
          if (r[e].isUniformStruct)
            for (const t in r[e]._locations)
              Object.hasOwnProperty.call(r[e]._locations, t) && r[e]._locations[t].set();
          else null != r[e].value && r[e].set();
      }
      _setSamplerUniforms(e, t) {
        e.useProgram(t);
        let i = 0;
        const s = this.programUniforms.samplerUniforms.length;
        for (let e = 0; e < s; ++e) i = this.programUniforms.samplerUniforms[e]._setSampler(i);
        return e.useProgram(null), i;
      }
      _setMicroDefines(e) {
        let t = '';
        for (const i in e)
          'string' == typeof e[i] && e[i]?.includes('#define')
            ? (t += `${e[i]}\r\n`)
            : 'boolean' == typeof e[i]
            ? e[i] && (t += `#define M_${i} \r\n`)
            : (t += `#define M_${i} ${e[i]} \r\n`);
        return t;
      }
      draw(t) {
        const {
            context: i,
            drawMode: s,
            layerID: r,
            layoutVertexBuffer: n,
            indexBuffer: o,
            segments: a,
            configuration: l,
            dynamicLayoutBuffer: h,
            dynamicLayoutBuffer2: c,
            dynamicLayoutBuffer3: _,
            animationVertexBuffers: u,
            instanceVerterBuffers: d,
            numScaleForWireframe: m,
          } = t,
          p = i.gl,
          f = I_[s];
        for (let t = 0; t < a.segments.length; t++) {
          const g = a.segments[t],
            y = g.vaos || (g.vaos = {}),
            T = y[r] || (y[r] = new yn());
          if (g.isModel)
            o
              ? (T.bind(i, this, n, [], o, g.vertexOffset, h),
                g.isInstance
                  ? i.drawInstance.drawElementsInstancedANGLE(
                      s,
                      g.modelVertexCount,
                      o.type,
                      g.modelVertexOffset,
                      g.instancesCount,
                    )
                  : p.drawElements(s, g.modelVertexCount, o.type, g.modelVertexOffset))
              : (T.bind(i, this, n, [], null),
                g.isInstance
                  ? i.drawInstance.drawArraysInstancedANGLE(
                      s,
                      0,
                      g.modelVertexCount,
                      g.instancesCount,
                    )
                  : p.drawArrays(s, g.modelVertexOffset, g.modelVertexCount));
          else {
            if (!n) return;
            g.isInstance && o
              ? (T.bind(
                  i,
                  this,
                  n,
                  l ? l.getPaintVertexBuffers() : [],
                  o || void 0,
                  g.vertexOffset,
                  h,
                  c,
                  _,
                  u,
                  d,
                ),
                i.drawInstance.drawElementsInstancedANGLE(
                  s,
                  g.indicesCount,
                  e.WebGLConstants.UNSIGNED_SHORT,
                  0,
                  g.instanceCount,
                ))
              : (T.bind(
                  i,
                  this,
                  n,
                  l ? l.getPaintVertexBuffers() : [],
                  o || void 0,
                  g.vertexOffset,
                  h,
                  c,
                  _,
                  u,
                ),
                o
                  ? p.drawElements(
                      s,
                      g.primitiveLength * f * (m || 1),
                      o.type ? o.type : e.WebGLConstants.UNSIGNED_SHORT,
                      g.primitiveOffset * f * 2,
                    )
                  : p.drawArrays(s, 0, g.vertexLength));
          }
        }
      }
      static findUniforms(t, i) {
        const s = new Map(),
          r = [],
          n = [],
          o = t.getProgramParameter(i, e.WebGLConstants.ACTIVE_UNIFORMS);
        for (let a = 0; a < o; ++a) {
          const o = t.getActiveUniform(i, a),
            l = '[0]',
            h =
              -1 !== o.name.indexOf(l, o.name.length - l.length)
                ? o.name.slice(0, o.name.length - 3)
                : o.name;
          if (0 !== h.indexOf('gl_')) {
            const a = t.getUniformLocation(i, h);
            if (o.name.indexOf('.') > 0 && o.name.indexOf('[') < 0) {
              const e = o.name.slice(o.name.indexOf('.') + 1, o.name.length),
                i = o.name.slice(0, o.name.indexOf('.')),
                n = s_(t, o, e, a);
              let l = s.get(i);
              l || ((l = R_(i)), s.set(i, l), r.push(l)), l.addLocation({ name: e, value: n });
            } else if (o.name.indexOf('[') < 0) {
              if (null !== a) {
                const e = s_(t, o, h, a);
                s.set(h, e), r.push(e), e._setSampler && n.push(e);
              }
            } else {
              let a, l, c, _;
              const u = h.indexOf('[');
              if (u >= 0) {
                if (((a = s.get(h.slice(0, u))), !e.defined(a))) continue;
                (l = a._locations),
                  l.length <= 1 &&
                    ((c = a.value),
                    (_ = t.getUniformLocation(i, h)),
                    null !== _ && (l.push(_), c.push(t.getUniform(i, _))));
              } else {
                l = [];
                for (let e = 0; e < o.size; ++e)
                  (_ = t.getUniformLocation(i, `${h}[${e}]`)), null !== _ && l.push(_);
                (a = f_(t, o, h, l)), s.set(h, a), r.push(a), a._setSampler && n.push(a);
              }
            }
          }
        }
        return { uniformsByName: s, uniforms: r, samplerUniforms: n };
      }
    }
    class L_ {
      constructor(t) {
        (this.programCache = {}),
          (this._context = t.context),
          (this.globalDefinitions = {
            OVERDRAW_INSPECTOR: !1,
            DEVICE_PIXEL_RATIO: e.exported.devicePixelRatio.toFixed(1),
            AMBIENT_STRENGTH: 0.6,
            RADIATION_REGIONS_COUNT: 5,
            DISCARD_VARYING_NUMBER: 100.01,
            TEXTURE_LOD_SUPPORTED: !!this._context.hasLODExtension,
            STANDARD_DERIVATIVES_SUPPORTED: !!this._context.hasDerivativesExt,
            LOG_DEPTH: !1,
            DEPTH_EXT: !!this._context.extFragDepth,
            UNSUPPORTED_COLOR_BUFFER_FLOAT: !this._context.extColorBufferFloat,
          });
      }
      setGlobalMacroDefinition(e) {
        for (const t in e) this.globalDefinitions[t] = e[t];
      }
      _makeSpecialKey(e) {
        if (!e) return '';
        const t = Object.keys(e).sort();
        let i = '';
        for (let s = 0; s < t.length; s++) {
          const r = t[s];
          'boolean' == typeof e[r] ? e[r] && (i += `${r}:${e[r]},`) : (i += `${r}:${e[r]},`);
        }
        for (const e in this.globalDefinitions)
          this.globalDefinitions[e] && (i += `${e}:${this.globalDefinitions[e]},`);
        return i;
      }
      getFullId(e, t, i) {
        return `${e}_${this._makeSpecialKey(t)}_${i}`;
      }
      hasProgram(e) {
        return e in this.programCache;
      }
      getProgramByGLSLMacroDefinition(e, t) {
        const i = this.getFullId(e.type, e.defines, t.cacheKey);
        return (
          this.hasProgram(i) ||
            ((this.globalDefinitions.LOG_DEPTH = this._context._logDepth),
            (e.defines = Object.assign({}, e.defines, this.globalDefinitions)),
            (this.programCache[i] = new O_(this._context, e, t))),
          this.programCache[i]
        );
      }
      static getVectorLineDefinition(t, i) {
        const s = {};
        return (
          e.checkIsVectorShadowVolumeDataType(i.classificationType) && (s.SHADOW_VOLUME = !0), s
        );
      }
      static getSphereCircleDefinition(t, i) {
        const s = {};
        return (
          e.checkIsVectorShadowVolumeDataType(i.classificationType) && (s.SHADOW_VOLUME = !0), s
        );
      }
      static getSphereHeatmapDefinition(t, i) {
        const s = {};
        return (
          e.checkIsVectorShadowVolumeDataType(i.classificationType) && (s.SHADOW_VOLUME = !0), s
        );
      }
      static getRasterSourceAndLayerMicroDefinition() {
        return {};
      }
      static getExtrusionMicroDefinition(t, i) {
        const s = {};
        return (
          (s.ANS_ENABLED = !!i && !!i.enabled),
          (s.PHONG_LIGHT = t.lightingModel === e.LightingModelType.PHONG),
          s
        );
      }
      static getEarthMaterialDefinition(t) {
        return {
          HAS_NIGHT_MAP: e.defined(t.nightTexture),
          HAS_BASE_MAP: e.defined(t.earthTexture),
          HAS_CLOUD_MAP: e.defined(t.earthCloudTexture),
        };
      }
      destroy() {}
    }
    class D_ extends e.Evented {
      constructor() {
        super(),
          (this._drawCommands = new lh()),
          (this.sharedTextures = new e.SharedTexture()),
          (this.isPlotter = !0);
      }
      update() {}
      updateFrameState(e) {
        this.frameState = e;
      }
      parse(e, t, i, s) {}
      render(e) {}
      createMaterial(e) {}
      parseMaterial() {}
      parseGeometry() {}
      static parseRenderState(t, i) {
        if (e.checkIsVectorShadowVolumeDataType(i.classificationType)) {
          const t = {};
          (t.blending = e.renderStateEnum.disableBlending),
            (t.cull = e.renderStateEnum.disableCull),
            (t.depthTest = e.renderStateEnum.enableDepthTest),
            (t.depthRange = e.renderStateEnum.depthRange),
            (t.depthMask = e.renderStateEnum.disableDepthMask),
            (t.stencilTest = e.renderStateEnum.enableClassificationStencilTest),
            (t.stencilMask = e.renderStateEnum.enableStencilMask),
            (t.colorMask = e.renderStateEnum.disabledColorMask);
          const i = {};
          return (
            (i.blending = e.renderStateEnum.enableBlending),
            (i.cull = e.renderStateEnum.disableCull),
            (i.depthTest = e.renderStateEnum.disableDepthTest),
            (i.depthRange = e.renderStateEnum.depthRange),
            (i.depthMask = e.renderStateEnum.disableDepthMask),
            (i.stencilTest = e.renderStateEnum.openClassificationStencilTest),
            (i.colorMask = e.renderStateEnum.enableColorMask),
            (i.stencilMask = e.renderStateEnum.enableStencilMask),
            e.deepCopyObj({ pass1: t, pass2: i })
          );
        }
        {
          const t = {};
          return (
            (t.blending = e.renderStateEnum.enableBlending),
            (t.depthRange = e.renderStateEnum.depthRange),
            i.depthTest
              ? ((t.depthTest = e.renderStateEnum.enableDepthTest),
                (t.depthMask = e.renderStateEnum.enableDepthMask))
              : ((t.depthTest = e.renderStateEnum.disableDepthTest),
                (t.depthMask = e.renderStateEnum.disableDepthMask)),
            (t.cull = e.renderStateEnum.enableCull),
            (t.frontFace = e.WebGLConstants.CW),
            (t.stencilTest = e.renderStateEnum.disableStencilTest),
            (t.stencilMask = e.renderStateEnum.disableStencilMask),
            e.deepCopyObj(t)
          );
        }
      }
    }
    const B_ = {
        [e.RenderPassConsts._USER_DEFINED_PRE_PASS]: (e, t) => t(e),
        [e.RenderPassConsts.PICK_PASS]: (e) => e,
        [e.RenderPassConsts.SHADOW_PASS]: (e) => e,
        [e.RenderPassConsts.VIEWSHED_PASS]: (e) => e,
        [e.RenderPassConsts.REAL_RENDER_PASS]: (e) => e,
        [e.RenderPassConsts.FXAA_PASS]: (e) => e,
        [e.RenderPassConsts.BLOOM_PASS]: () => [],
        [e.RenderPassConsts.TOON_SHADING_PASS]: () => [],
        [e.RenderPassConsts.HDR_PASS]: () => [],
        [e.RenderPassConsts.USER_DEFINED_POST_PROCESS_PASS]: () => [],
        [e.RenderPassConsts.PICK_COLOR_PASS]: (e) => e,
        [e.RenderPassConsts.CUBE_MAP_RENDER_FOR_SKYBOX]: (t) => {
          const i = [];
          for (let s = 0; s < t.length; s++)
            if (e.RenderPassConsts.CUBE_MAP_RENDER_FOR_SKYBOX in t[s].filterPassIds)
              return i.push(t[s]);
          return i;
        },
        [e.RenderPassConsts.EARTH_EFFECT_PASS]: (e) => e,
      },
      V_ = Object.freeze({ ENCODE_DEPTH_TO_FRAGCOLOR: !1, RENDER_GRAY_IMAGE: !1 });
    function N_({ source: t, layer: i, isInstance: s, passType: r, animationsInfo: n }) {
      const o = (function (t, i, s) {
          const { animationsInfo: r } = s,
            n = {};
          return (
            (n.ANS_ENABLED = !!r && e.defaultValue(r.enabled, !1)),
            i &&
              e.checkIsVectorShadowVolumeDataType(i.classificationType) &&
              (n.SHADOW_VOLUME = !0),
            t &&
              t.clampEnabled &&
              ((n.HAS_CLIPPING = !0),
              t.clampPlane
                ? (n.IS_CLIPPING_PLANE = !0)
                : t.clampBox
                ? (n.IS_CLIPPING_BOX = !0)
                : t.clampRange && (n.IS_CLIPPING_RANGE = !0)),
            i && i.lightingModel === e.LightingModelType.PBR
              ? ((n.USE_PBR = !0), (n.USE_IBL = !0))
              : ((n.USE_PBR = !1), (n.USE_IBL = !1)),
            (n.PHONG_LIGHT = i?.lightingModel === e.LightingModelType.PHONG),
            n
          );
        })(t, i, { isInstance: s, passType: r, animationsInfo: n }),
        a = (function (t) {
          switch (t) {
            case e.RenderPassConsts.PICK_PASS:
              return e.extend({}, V_, { ENCODE_DEPTH_TO_FRAGCOLOR: !0 });
            case e.RenderPassConsts.SHADOW_PASS:
            case e.RenderPassConsts.VIEWSHED_PASS:
            case e.RenderPassConsts.REAL_RENDER_PASS:
            case e.RenderPassConsts.BLOOM_PASS:
            case e.RenderPassConsts.FXAA_PASS:
            case e.RenderPassConsts.HDR_PASS:
            case e.RenderPassConsts.TOON_SHADING_PASS:
              return e.extend({}, V_, {});
            case e.RenderPassConsts.PICK_COLOR_PASS:
              return e.extend({}, V_, { USE_PICKING: !0 });
            default:
              return e.extend({}, V_, {});
          }
        })(r);
      return e.extend(o, a);
    }
    class k_ extends D_ {
      constructor(e) {
        super(e),
          (this._renderPrimitives = []),
          (this._needClearStencilPrimitives = []),
          (this.isRegularVector = !0),
          (this.plotterType = 'fill');
      }
      update(e, t, i, s, r) {
        this.parse(e, t, i, s, r), this.render(e, i, r);
      }
      render(e, t, i) {
        const s = B_[i.passType](this._renderPrimitives);
        let r;
        this.isRegularVector || (r = this.#O(e, t));
        for (let n = 0; n < s.length; n++) {
          const o = s[n];
          this.isRegularVector
            ? (o.update(e, i), o.render(e, t, i))
            : ((o._material.renderState = r.pass1),
              o.update(e, i),
              o.render(e, t, i),
              (o._material.renderState = r.pass2),
              o.update(e, i),
              o.render(e, t, i));
        }
        (this._renderPrimitives = []), (e.tileClippingMask.status = !1);
      }
      parse(t, i, s, r, n) {
        if (r.length > 0) {
          this.isRegularVector = !e.checkIsVectorShadowVolumeDataType(s.classificationType);
          const o = s.paint?.get('fill-antialias');
          for (let e = 0; e < r.length; e++) {
            const a = r[e],
              l = i.getTile(r[e]);
            if (!l.getBucket(s)) continue;
            const h = N_({ source: null, layer: s, isInstance: !1, passType: n.passType }),
              c = l.primitiveMap.get(s.id);
            if (c)
              if (this.isRegularVector) {
                const e = this.#O(t, s, a),
                  i = c.fill;
                i &&
                  ((i._material.defines = h),
                  (i._material.renderState = e),
                  this._renderPrimitives.push(i));
                const r = c.outline;
                r &&
                  o &&
                  ((r._material.defines = h),
                  (r._material.renderState = e),
                  this._renderPrimitives.push(r));
              } else {
                const e = c.fill;
                (e._material.defines = h), this._renderPrimitives.push(e);
              }
          }
        }
      }
      #O(t, i, s) {
        let r;
        if (this.isRegularVector) {
          const n = t.tileClippingMask.getMaskIDByCoord(s);
          t.tileClippingMask.status
            ? (t.tileClippingMask.updateRefValue('useMask', n),
              (r = e.deepCopyObj(t.tileClippingMask.useMaskRs)))
            : (r = k_.parseRenderState(t, i));
        } else r = k_.parseRenderState(t, i);
        return r;
      }
      destroy() {
        (this.programId = void 0),
          (this._renderPrimitives = void 0),
          (this.isRegularVector = void 0),
          (this.plotterType = void 0);
      }
    }
    class F_ {
      constructor() {
        (this.writeMaskRs = void 0),
          (this.useMaskRs = void 0),
          (this.uniforms = {}),
          (this.programType = 'sphereClipping');
      }
      renderMask() {}
      createProgram() {}
    }
    class G_ extends F_ {
      constructor() {
        super(),
          (this._tileClippingMaskIDs = {}),
          (this.nextStencilID = 1),
          (this.shaderSource = new e.ShaderSource({ type: 'sphereClipping' })),
          (this._tileMatrix = new e.Matrix4()),
          (this.uniformMap = new Map([['u_ModelViewProjectionMatrix', () => this._tileMatrix]])),
          this.#L(),
          (this.status = !1);
      }
      #L() {
        (this.writeMaskRs = {
          depthTest: e.renderStateEnum.disableDepthTest,
          depthMask: e.renderStateEnum.disableDepthMask,
          colorMask: e.renderStateEnum.disabledColorMask,
          blending: e.renderStateEnum.disableBlending,
          cull: e.renderStateEnum.disableCull,
          stencilMask: 255,
          stencilTest: {
            enabled: !0,
            frontFunction: e.WebGLConstants.ALWAYS,
            backFunction: e.WebGLConstants.ALWAYS,
            reference: 0,
            mask: 0,
            frontOperation: {
              fail: e.WebGLConstants.KEEP,
              zFail: e.WebGLConstants.KEEP,
              zPass: e.WebGLConstants.REPLACE,
            },
            backOperation: {
              fail: e.WebGLConstants.KEEP,
              zFail: e.WebGLConstants.KEEP,
              zPass: e.WebGLConstants.REPLACE,
            },
          },
        }),
          (this.useMaskRs = {
            blending: e.renderStateEnum.enableBlending,
            depthRange: e.renderStateEnum.depthRange,
            depthTest: e.renderStateEnum.disableDepthTest,
            depthMask: e.renderStateEnum.disableDepthMask,
            cull: e.renderStateEnum.enableCull,
            frontFace: e.WebGLConstants.CW,
            stencilTest: e.deepCopyObj(e.renderStateEnum.stencilModeForClip),
            stencilMask: e.renderStateEnum.enableStencilMask,
          });
      }
      getMaskIDByCoord(e) {
        return this._tileClippingMaskIDs[e.key];
      }
      updateRefValue(e, t) {
        'writeMask' === e
          ? (this.writeMaskRs.stencilTest.reference = t)
          : (this.useMaskRs.stencilTest.reference = t);
      }
      renderMask(e, t) {
        (this.nextStencilID = 1),
          (this._tileClippingMaskIDs = {}),
          (this.status = !0),
          this.program || this.#D(e);
        const i = t.length;
        let s, r;
        if (i < 255)
          for (let n = 0; n < i; n++)
            (r = t[n]),
              (s = this._tileClippingMaskIDs[r.key] = this.nextStencilID++),
              this.updateRefValue('writeMask', s),
              this.#B(e, r);
        else
          for (let n = i - 1; n--; n >= 0)
            (r = t[n]),
              (s = this._tileClippingMaskIDs[r.key] = this.nextStencilID++),
              this.updateRefValue('writeMask', s),
              this.#B(e, r);
      }
      #D(e) {
        this.program = e.useProgram(this.shaderSource);
      }
      #B(t, i) {
        const s = t.style.terrainSourceCache.getRegularSupplier()._proxyGetGeometryByTileId(i);
        e.defined(s) &&
          (t.context.program.set(this.program.program),
          t.context.setRenderState(new e.RenderState(this.writeMaskRs)),
          (this._tileMatrix = t.transform.activeCamera.getVPMatrix().multiplyRight(s.matrix)),
          this.program._setUniforms(this.uniformMap),
          this.program.draw({
            context: t.context,
            drawMode: e.WebGLConstants.TRIANGLES,
            layerID: 'layer.id.sphereClipping',
            layoutVertexBuffer: s.geometry._vertBuffer,
            indexBuffer: s.geometry._indexBuffer,
            segments: s.geometry._segmentVector,
          }));
      }
    }
    const U_ = 'Classification';
    let z_ = Number.MAX_VALUE;
    const H_ = Object.freeze({});
    class W_ {
      constructor(e) {
        this.setup(e);
      }
      setup(e) {
        this.#V(), (this.painter = e.painter), e.painter.style && this.update(e);
      }
      #V() {
        (this.raster = []),
          (this.image = []),
          (this.maskRaster = []),
          (this.sphereLayerOrder = []),
          (this.classificationLayers = []),
          (this.modelPrimitiveList = []),
          (this.modelOpaquePrimitiveList = []),
          (this.modelTranslucentPrimitiveList = []),
          (this.modelClassificationPrimitiveList = []),
          (this.modelClassificationOpaquePrimitiveList = []),
          (this.modelClassificationTranslucentPrimitiveList = []),
          (this.modelIgnoreClassificationPrimitiveList = []),
          (this.modelIgnoreClassificationOpaquePrimitiveList = []),
          (this.modelIgnoreClassificationTranslucentPrimitiveList = []),
          (this.forceOverModelVectorLayerList = []);
      }
      getNearFarPlane(t, i, s) {
        const r = new e.Vector3(i.activeCamera.direction).multiplyByScalar(-1),
          n = i.activeCamera._position;
        let o = +Number.MAX_VALUE,
          a = -Number.MAX_VALUE;
        const l = this.modelPrimitiveList;
        for (let t = 0; t < l.length; t++) {
          const i = l[t];
          let s = i.boundingVolume;
          if (
            (e.defined(i.modelInstanceCollection) && (s = i.modelInstanceCollection.boundingVolume),
            s)
          ) {
            const e = s.computePlaneDistances(n, r),
              t = e.start,
              i = e.stop;
            if (((a = Math.max(a, i)), Math.abs(i - t) > 25e3)) continue;
            o = Math.min(o, t);
          }
        }
        if (s) {
          if (
            (this.transformCompareParams || (this.transformCompareParams = [0, 0, 0, 0, 0, 0]),
            i.height > 8848)
          )
            o = z_;
          else if (i.checkTransformsParamsUnChanged(this.transformCompareParams)) o = z_;
          else {
            const e = t.map.painter;
            let s = Number.MAX_VALUE;
            null != e.frameState.camera && (s = e.getDistance()),
              s < a && (o = s),
              (this.transformCompareParams = (i.__oldVal || []).slice(0));
          }
          o != Number.MAX_VALUE && (z_ = o);
        }
        return { near: o, far: a };
      }
      update(t) {
        const { layers: i, orders: s, frameState: r } = t,
          n = this.painter,
          o = r.camera.frustumCrate.cullingVolume;
        this.#V();
        for (let t = 0; t < s.length; t++) {
          const r = i[s[t]];
          (r && r.source && r.isHiddenByMapZoom(n.transform.activeCamera.mapZoom)) ||
            'visible' !== r.visibility ||
            !r.paint ||
            (r.type == e.VectorLayerType.TILES || r.type == e.VectorLayerType.MODEL
              ? (n.style.sourceCaches[r.source].addClippingPlanes &&
                  n.style.sourceCaches[r.source].addClippingPlanes(r.clippingPlanes),
                n.style.sourceCaches[r.source].addCustomizedStyle &&
                  n.style.sourceCaches[r.source].addCustomizedStyle(r.paint),
                r.classificationType === e.ClassificationType.IGNORECLASSIFICATION
                  ? ((this.modelIgnoreClassificationOpaquePrimitiveList =
                      this.modelIgnoreClassificationOpaquePrimitiveList.concat(
                        n.style.sourceCaches[r.source].getOpaquePrimitives(o, void 0, r),
                      )),
                    (this.modelIgnoreClassificationTranslucentPrimitiveList =
                      this.modelIgnoreClassificationTranslucentPrimitiveList.concat(
                        n.style.sourceCaches[r.source].getTranslucentPrimitives(o, void 0, r),
                      )))
                  : ((this.modelOpaquePrimitiveList = this.modelOpaquePrimitiveList.concat(
                      n.style.sourceCaches[r.source].getOpaquePrimitives(o, void 0, r),
                    )),
                    (this.modelTranslucentPrimitiveList = this.modelTranslucentPrimitiveList.concat(
                      n.style.sourceCaches[r.source].getTranslucentPrimitives(o, void 0, r),
                    ))))
              : (r.type === e.VectorLayerType.RASTER &&
                  ('image' === n.style.sourceCaches[r.source].sourceType
                    ? this.image.push(s[t])
                    : r.maskingEnabled
                    ? this.maskRaster.push(s[t])
                    : this.raster.push(s[t])),
                e.checkIsVectorShadowVolumeDataType(r.classificationType)
                  ? this.classificationLayers.push(s[t])
                  : r.classificationType == e.ClassificationType.FORCE_VECTOR_OVER_MODEL ||
                    r.classificationType == e.ClassificationType.IGNORECLASSIFICATION
                  ? this.forceOverModelVectorLayerList.push(s[t])
                  : this.sphereLayerOrder.push(s[t])));
        }
        n.style.tilesetCollection.update(r),
          n.style.modelCollection.update(r),
          n.style.primitiveCollection.update(r),
          n._map.videoManager.clear3DModel(),
          n._map.videoManager.clear3DTiles(),
          [
            n.style.modelCollection,
            n.style.tilesetCollection,
            n.style.primitiveCollection,
            n.style.scenePointPrimitiveCollection,
            n.style.sceneObjectCollection,
          ].forEach((e, t) => {
            const i = e.getIndependentPrimitiveObject(o);
            e instanceof Eh &&
              t <= 2 &&
              (n._map.videoManager.update3DModel(i.opaque),
              n._map.videoManager.update3DModel(i.translucent)),
              (this.modelOpaquePrimitiveList = this.modelOpaquePrimitiveList.concat(i.opaque)),
              (this.modelTranslucentPrimitiveList = this.modelTranslucentPrimitiveList.concat(
                i.translucent,
              ));
            const s = e.getIgnoreClassificationPrimitiveObject(o);
            (this.modelIgnoreClassificationOpaquePrimitiveList =
              this.modelIgnoreClassificationOpaquePrimitiveList.concat(s.opaque)),
              (this.modelIgnoreClassificationTranslucentPrimitiveList =
                this.modelIgnoreClassificationTranslucentPrimitiveList.concat(s.translucent));
          }),
          (this.modelPrimitiveList = this.modelOpaquePrimitiveList.concat(
            this.modelTranslucentPrimitiveList,
          ));
        const a = n.style.primitiveCollection.getClassificationPrimitiveObject(o);
        (this.modelClassificationOpaquePrimitiveList =
          this.modelClassificationOpaquePrimitiveList.concat(a.opaque)),
          (this.modelClassificationTranslucentPrimitiveList =
            this.modelClassificationTranslucentPrimitiveList.concat(a.translucent)),
          (this.modelClassificationPrimitiveList =
            this.modelClassificationOpaquePrimitiveList.concat(
              this.modelClassificationTranslucentPrimitiveList,
            )),
          (this.modelIgnoreClassificationPrimitiveList =
            this.modelIgnoreClassificationOpaquePrimitiveList.concat(
              this.modelIgnoreClassificationTranslucentPrimitiveList,
            )),
          t.ignoreNonePickPrimitive &&
            ((this.modelPrimitiveList = this.modelPrimitiveList.filter((e) => e.allowPick)),
            (this.modelClassificationPrimitiveList = this.modelClassificationPrimitiveList.filter(
              (e) => e.allowPick,
            )),
            (this.modelIgnoreClassificationPrimitiveList =
              this.modelIgnoreClassificationPrimitiveList.filter((e) => e.allowPick)));
      }
      setFilter() {}
      render(e) {
        const { layers: t, frameState: i } = e,
          s = this.painter;
        (this.currentLayer = 0),
          this.#N({
            primitives: s.style.sceneObjectCollection.getSkyAndEarthPrimitives(),
            frameState: i,
          }),
          this.renderLayers(this.sphereLayerOrder, t, i),
          this.#N({ primitives: this.modelPrimitiveList, frameState: i }),
          this.renderLayers(this.classificationLayers, t, i),
          this.#N({
            primitives: this.modelClassificationPrimitiveList,
            frameState: i,
            renderType: U_,
          }),
          this.#N({ primitives: this.modelIgnoreClassificationPrimitiveList, frameState: i }),
          this.renderLayers(this.forceOverModelVectorLayerList, t, i);
      }
      renderLayers(t, i, s) {
        let r,
          n = [];
        const o = this.painter;
        for (let a = 0; a < t.length; a++) {
          if ('raster' === i[t[a]].type) {
            if (this.raster[this.raster.length - 1] == t[a]) {
              const e = [],
                t = [],
                a = new Map();
              for (let s = 0; s < this.raster.length; s++) {
                const l = i[this.raster[s]];
                (r = o.style.sourceCaches[l.source]),
                  (n = r.getVisibleCoordinates(!1)),
                  e.push(r),
                  t.push(l);
                for (const e of n) a.set(e.key, e);
              }
              const l = Array.from(a.values());
              this.executePaint({ sourceCache: e, layer: t, coords: l, frameState: s });
            }
            if (this.image.includes(t[a])) {
              const e = i[t[a]];
              (r = o.style.sourceCaches[e.source]),
                this.executePaint({ sourceCache: r, layer: e, coords: n, frameState: s });
            }
            if (this.maskRaster.includes(t[a])) {
              const e = i[t[a]];
              (r = o.style.sourceCaches[e.source]),
                (n = r.getVisibleCoordinates(!1)),
                this.executePaint({ sourceCache: [r], layer: [e], coords: n, frameState: s });
            }
            continue;
          }
          const l = i[t[a]];
          if (l?.source !== (r && r.id))
            (r = o.style.sourceCaches[l.source]),
              r &&
                r.getVisibleCoordinates &&
                (n = r.getVisibleCoordinates(
                  l.type === e.VectorLayerType.SYMBOL || l.type === e.VectorLayerType.SYMTRACKING,
                ));
          else {
            const t = l.layout && l.layout.get('symbol-placement'),
              i = n.every((e) => e.posMatrix);
            !t ||
              ('point' !== t && 'line' !== t && 'line-center' !== t) ||
              i ||
              (r &&
                r.getVisibleCoordinates &&
                (n = r.getVisibleCoordinates(
                  l.type === e.VectorLayerType.SYMBOL || l.type === e.VectorLayerType.SYMTRACKING,
                )));
          }
          this.executePaint({ sourceCache: r, layer: l, coords: n, frameState: s });
        }
      }
      executePaint(t) {
        const { sourceCache: i, layer: s, coords: r, primitives: n, frameState: o } = t,
          a = void 0 === o.overrideMaterial,
          l = this.painter;
        if (
          e.defined(n) &&
          e.defined(o.overrideMaterial) &&
          'depthMaterial' === o.overrideMaterial._type
        )
          for (let t = 0; t < n.length; t++)
            e.defined(n[t]._material) &&
              'BillboardMaterial' === n[t]._material._type &&
              n.splice(t--, 1);
        let h = !1;
        if (s) {
          if (s instanceof Array && s.length > 0) l.rasterPlotter.update(l, i, s, r, o);
          else if (s.type === e.VectorLayerType.LINE && a) {
            const e = s.paint.get('line-opacity');
            !l._map.style._originalLayer.includes(s.id) &&
              (e.constantOr(1) < 1 || !e.isConstant()) &&
              r.length &&
              (l.tileClippingMask.renderMask(l, r), (h = !0));
          } else if (s.type === e.VectorLayerType.FILL && a) {
            const t = s.paint.get('fill-opacity').constantOr(1),
              i = !s.paint.get('fill-opacity').isConstant(),
              n = s.paint.get('fill-color').constantOr(new e.Color(1, 1, 1, 1)),
              o = s.getPaintProperty('fill-outline-color'),
              a = s.getPaintProperty('fill-pattern');
            !l._map.style._originalLayer.includes(s.id) &&
              (t < 1 || i || o || n.a < 1 || a) &&
              (l.tileClippingMask.renderMask(l, r), (h = !0));
          }
          if (s.type === e.VectorLayerType.FILL) {
            const e = this.filterTile(i, s, r, l);
            e.length && l.fillPlotter.update(l, i, s, e, o), (l.tileClippingMask.status = !1);
          } else if (
            s.type === e.VectorLayerType.SYMBOL ||
            s.type === e.VectorLayerType.SYMTRACKING
          ) {
            const e = this.filterTile(i, s, r, l);
            e.length && l.symbolPlotter.update(l, i, s, e, o);
          } else if (s.type === e.VectorLayerType.MODEL || s.type === e.VectorLayerType.TILES)
            l.modelPlotter.update(l, i, s, o, n);
          else if (
            s.type === e.VectorLayerType.LINE ||
            s.type === e.VectorLayerType.TRACKING ||
            s.type === e.VectorLayerType.SPRITE
          ) {
            const e = this.filterTile(i, s, r, l);
            e.length && l.linePlotter.update(l, i, s, e, o), (l.tileClippingMask.status = !1);
          } else if (s.type === e.VectorLayerType.RASTER) l.imagePlotter.update(l, i, s, r, o);
          else if (s.type === e.VectorLayerType.CIRCLE)
            l.circlePlotter.update(l, i, s, r, o), (l.tileClippingMask.status = !1);
          else if (s.type === e.VectorLayerType.HEATMAP) {
            const e = this.filterTile(i, s, r, l);
            e.length && l.heatmapPlotter.update(l, i, s, e, o), (l.tileClippingMask.status = !1);
          } else if (
            s.type === e.VectorLayerType.EXTRUSION ||
            s.type === e.VectorLayerType.HISTOGRAM
          ) {
            const e = this.filterTile(i, s, r, l);
            e.length && l.extrusionPlotter.update(l, i, s, e, o);
          } else
            s.type === e.VectorLayerType.BACKGROUND && l.backgroundPlotter.update(l, i, s, r, o);
          (s.type !== e.VectorLayerType.RASTER &&
            s.type !== e.VectorLayerType.MODEL &&
            s.type !== e.VectorLayerType.TILES) ||
            !l.options.showDebugBoundingBox ||
            l.debugBoundingBoxPlotter.update(l, i, s, o),
            h && l.clearStencil();
        }
        o.sameLayerFrame = !1;
      }
      filterTile(t, i, s, r) {
        const n = [];
        e.checkIsVectorShadowVolumeDataType(i.classificationType) && r.clearStencil();
        for (let e = 0; e < s.length; e++) t.getTile(s[e]).getBucket(i) && n.push(s[e]);
        return n;
      }
      #N({ primitives: t, frameState: i, renderType: s }) {
        0 !== t.length &&
          this.executePaint({
            sourceCache: H_,
            layer: {
              lightingModel: this.painter._map.lightingModel,
              type: e.VectorLayerType.MODEL,
              isHidden: () => !1,
              classificationType: s === U_ ? e.ClassificationType.ALL : e.ClassificationType.NONE,
            },
            primitives: t,
            frameState: i,
          });
      }
    }
    class j_ extends D_ {
      constructor(e) {
        super(e), (this._renderPrimitives = []), (this.plotterType = 'symbol');
      }
      update(t, i, s, r, n) {
        void 0 !== s.paint &&
          n.passType !== e.RenderPassConsts.PICK_PASS &&
          (this.parse(t, i, s, r, n), this.render(t, s, n));
      }
      render(e, t, i) {
        const s = B_[i.passType](this._renderPrimitives);
        for (let r = 0; r < s.length; r++) {
          const n = s[r];
          n._material.isSDF &&
            n._material.hasHalo &&
            ((n._material.ishalo = !0), n.update(e, i), n.render(e, t, i)),
            (n._material.ishalo = !1),
            n.update(e, i),
            n.render(e, t, i);
        }
        this._renderPrimitives = [];
      }
      removePrimitive(e, t) {}
      parse(t, i, s, r, n) {
        if (r.length > 0) {
          'symtracking' === s.type && e.SymbolMaterial.updateSymtrackingLayerProperty(s, t, i);
          const o = N_({ source: null, layer: null, isInstance: !1, passType: n.passType }),
            a = this.#O();
          for (const e of r) {
            const t = i.getTile(e);
            if (!t.getBucket(s)) continue;
            const r = t.primitiveMap.get(s.id);
            if (!r) continue;
            const n = r.icon;
            n &&
              ((n._material.defines = o),
              (n._material.renderState = a),
              this._renderPrimitives.unshift(n));
            const l = r.text;
            l &&
              ((l._material.defines = o),
              (l._material.renderState = a),
              this._renderPrimitives.push(l));
          }
        }
      }
      #O() {
        const t = {};
        return (
          (t.blending = e.renderStateEnum.enableBlending),
          (t.depthTest = e.renderStateEnum.disableDepthTest),
          (t.depthMask = e.renderStateEnum.disableDepthMask),
          (t.cull = e.renderStateEnum.disableCull),
          (t.stencilTest = e.renderStateEnum.disableStencilTest),
          (t.stencilMask = e.renderStateEnum.disableStencilMask),
          t
        );
      }
      destroy() {
        (this._renderPrimitives = []), (this.plotterType = void 0);
      }
    }
    class q_ extends D_ {
      constructor(e) {
        super(e), (this._renderPrimitives = []), (this.plotterType = 'extrusion');
      }
      update(e, t, i, s, r) {
        if (!i.paint || 0 === i.paint.get('extrusion-opacity')?.value?.value) return;
        const n = t.getSource();
        this.#k(n),
          this.parse(e, t, i, s, r, n.animationsInfo),
          this._error || this.render(e, i, r, n.animationsInfo);
      }
      render(t, i, s, r) {
        const n = B_[s.passType](this._renderPrimitives);
        t.clearStencil();
        const o = i.paint.get('extrusion-opacity')?.value?.value,
          a = 1 === o,
          l = e.stencilModeforExtrusion(t);
        for (let e = 0; e < n.length; e++) {
          const o = n[e];
          o.update(t, s, { renderStateTag: 'first', enableColorMask: a, animationsInfo: r }),
            o.render(t, i, s);
        }
        if (1 !== o)
          for (let e = 0; e < n.length; e++) {
            const o = n[e];
            o.update(t, s, { renderStateTag: 'second', stencilTest: l, animationsInfo: r }),
              o.render(t, i, s);
          }
        this._renderPrimitives = [];
      }
      parse(e, t, i, s, r, n) {
        if (s.length > 0) {
          const o = this.getMicroDefinition(e, i, r, n);
          for (const r of s) {
            const s = t.getTile(r).primitiveMap.get(i.id);
            s &&
              (s._material.initializedRenderState ||
                ((s._material.renderState = this.#O(e, i)),
                (s._material.initializedRenderState = !0)),
              (s._material.defines = o),
              this._renderPrimitives.push(s));
          }
        }
      }
      #O() {
        return {
          depthMask: e.renderStateEnum.enableDepthMask,
          depthTest: e.renderStateEnum.enableDepthTestWithLEQUAL,
          stencilMask: e.renderStateEnum.enableStencilMask,
          colorMask: e.renderStateEnum.enableColorMask,
          cull: e.renderStateEnum.disableCull,
          blending: e.renderStateEnum.enableBlending,
        };
      }
      destroy() {
        (this._renderPrimitives = void 0),
          (this.isRegularVector = void 0),
          (this.plotterType = void 0);
      }
      getMicroDefinition(t, i, s, r) {
        const n = N_({ source: null, layer: null, isInstance: !1, passType: s.passType }),
          o = L_.getExtrusionMicroDefinition(i, r);
        return e.extend(n, o);
      }
      #k(e) {
        if (!e.animationPropertyCollection || 0 === e.animationPropertyCollection.size) return;
        const t = e?.animationPropertyCollection,
          i = t.getAll();
        1 === i.length && i[0].updateAnimation(e);
      }
    }
    const X_ = e.createLayout([{ name: 'a_POSITION', type: 'Float32', components: 3 }], 4),
      Z_ = e.createLayout(
        [
          { name: 'a_PositionHigh', type: 'Float32', components: 3 },
          { name: 'a_PositionLow', type: 'Float32', components: 3 },
        ],
        4,
      );
    class $_ extends e.Geometry {
      constructor(t) {
        super(t),
          (this.type = 'BoxOutlineGeometry'),
          (this.primitiveType = e.WebGLConstants.LINES),
          this.setData(t);
      }
      setData(t) {
        if ((super.setData(t), t.minPoint && t.maxPoint)) {
          (t.minPoint = e.Vector3.unpack(t.minPoint)), (t.maxPoint = e.Vector3.unpack(t.maxPoint));
          const i = (t.maxPoint.x - t.minPoint.x) / 2,
            s = (t.maxPoint.y - t.minPoint.y) / 2,
            r = (t.maxPoint.z - t.minPoint.z) / 2;
          (this.minPoint = new e.Vector3(-i, -s, -r)), (this.maxPoint = new e.Vector3(i, s, r));
        } else (this.maxPoint = e.Vector3.multiplyByScalar(new e.Vector3(t.width, t.height, t.depth), 0.5, new e.Vector3())), (this.minPoint = e.Vector3.negate(this.maxPoint, new e.Vector3()));
        (this._usedDoublePrecision = !1),
          this._vertexArray
            ? (this._vertexArray.clear(), this._indices.clear())
            : ((this._vertexArray = this._usedDoublePrecision
                ? new e.StructArrayLayout3f3f24()
                : new e.StructArrayLayout3f12()),
              (this._indices = new e.StructArrayLayout2ui4())),
          this.parse(),
          this.computeBoundingSphere(),
          this.computeBoundingBox();
      }
      parse() {
        this.computeNearFarPlanes(), this.emplaceVertexBufferOfLines(), this.computeIndices();
        for (let e = 0; e < this.indices.length; e += 2)
          this._indices.emplaceBack(this.indices[e], this.indices[e + 1]);
        this.needUpdate = !0;
      }
      computeNearFarPlanes() {
        const e = new Float64Array(24);
        (e[0] = this.minPoint.x),
          (e[1] = this.minPoint.y),
          (e[2] = this.minPoint.z),
          (e[3] = this.maxPoint.x),
          (e[4] = this.minPoint.y),
          (e[5] = this.minPoint.z),
          (e[6] = this.maxPoint.x),
          (e[7] = this.maxPoint.y),
          (e[8] = this.minPoint.z),
          (e[9] = this.minPoint.x),
          (e[10] = this.maxPoint.y),
          (e[11] = this.minPoint.z),
          (e[12] = this.minPoint.x),
          (e[13] = this.minPoint.y),
          (e[14] = this.maxPoint.z),
          (e[15] = this.maxPoint.x),
          (e[16] = this.minPoint.y),
          (e[17] = this.maxPoint.z),
          (e[18] = this.maxPoint.x),
          (e[19] = this.maxPoint.y),
          (e[20] = this.maxPoint.z),
          (e[21] = this.minPoint.x),
          (e[22] = this.maxPoint.y),
          (e[23] = this.maxPoint.z),
          (this.vertices = e);
      }
      computeIndices() {
        const e = new Uint16Array(24);
        (e[0] = 4),
          (e[1] = 5),
          (e[2] = 5),
          (e[3] = 6),
          (e[4] = 6),
          (e[5] = 7),
          (e[6] = 7),
          (e[7] = 4),
          (e[8] = 0),
          (e[9] = 1),
          (e[10] = 1),
          (e[11] = 2),
          (e[12] = 2),
          (e[13] = 3),
          (e[14] = 3),
          (e[15] = 0),
          (e[16] = 0),
          (e[17] = 4),
          (e[18] = 1),
          (e[19] = 5),
          (e[20] = 2),
          (e[21] = 6),
          (e[22] = 3),
          (e[23] = 7),
          (this.indices = e);
      }
      update(t) {
        if (this.needUpdate && t.painter) {
          this.needUpdate = !1;
          const i = t.painter.context;
          this._vertBuffer && this._indexBuffer
            ? (this._vertBuffer.updateData(this._vertexArray),
              this._indexBuffer.updateData(this._indices))
            : ((this._vertBuffer = i.createVertexBuffer(
                this._vertexArray,
                this._usedDoublePrecision ? Z_.members : X_.members,
                this.dynamicDraw,
              )),
              (this._indexBuffer = i.createIndexBuffer(this._indices, this.dynamicDraw))),
            (this._segmentVector = e.SegmentVector.simpleSegment(
              0,
              0,
              this.vertices.length / 3,
              this.indices.length / 2,
            ));
        }
      }
      serialize() {
        return {
          type: this.type,
          maxPoint: e.Vector3.pack(this.maxPoint, new Array(3)),
          minPoint: e.Vector3.pack(this.minPoint, new Array(3)),
        };
      }
      destroy() {
        super.destroy(),
          (this.type = null),
          (this.primitiveType = null),
          (this._vertexArray = null),
          (this._indices = null),
          (this.maxPoint = null),
          (this.minPoint = null),
          (this.vertices = null);
      }
      static fromDiagonal(t, i) {
        if (!e.defined(t) || !e.defined(i)) throw new Error('diagonal positios must be defined!');
        if (!e.Vector3.equals(t, i)) return new $_({ minPoint: t, maxPoint: i });
        console.error('两点不能是同一个点');
      }
    }
    class K_ extends D_ {
      constructor(e) {
        super(e);
      }
      update(e, t, i, s) {
        this.render(e, i, s, t);
      }
      render(e, t, i, s) {
        e.clearStencil();
        const r = e.style.debugBoundingBoxPrimitiveCollection.getAllNeedRenderPrimitive();
        for (let n = 0; n < r.length; n++) {
          const o = r[n];
          o.update(e, i, {
            hasMixedContent:
              (s?.tileset3d?._hasMixedContent && s?.tileset3d?.skipLevelOfDetail) || !1,
          }),
            o.render(e, t, i);
        }
        e.style.debugBoundingBoxPrimitiveCollection.removeNeedRenderPrimitiveList();
      }
      removePrimitive() {}
      static createDebugBoundingBoxPrimitive(t) {
        const i = e.Matrix4.fromRotationTranslation(t.halfAxes, t.center, new e.Matrix4()),
          s = new $_({ width: 2, height: 2, depth: 2 }),
          r = e.StandardMaterial.fromType('Color', {
            color: 'white',
            opacity: 1,
            lightingModel: e.LightingModelType.NONE,
          }),
          n = new e.Primitive({ modelMatrix: i, geometry: s, material: r });
        return (n.id = t.id), t.painter.style.debugBoundingBoxPrimitiveCollection.add(n), n;
      }
      destroy() {
        (this.programId = void 0), (this.sharedTextures = void 0);
      }
    }
    class Y_ extends D_ {
      constructor(e) {
        super(e),
          (this.programId = 'gltfPBR'),
          (this._renderPrimitives = []),
          (this.plotterType = 'model');
      }
      update(e, t, i, s, r) {
        this.parse(e, t, i, s, r), this.render(e, i, s, t);
      }
      render(t, i, s, r) {
        const n = B_[s.passType](this._renderPrimitives),
          o = !e.checkIsVectorShadowVolumeDataType(i.classificationType);
        let a;
        if ((o || (t.clearStencil(), (a = Y_.#O(t, i))), r?.tileset3d?.skipLevelOfDetail)) {
          t.context.setRenderState({ stencilMask: e.WebGLConstants.SKIP_LOD_MASK }, null, t),
            t.clearStencil();
          let r = [],
            o = [],
            a = n.filter((e) => !e.owner.extra.finalResolution);
          for (let e = 0; e < a.length; e++)
            a[e].owner.extra.markAsRoot || -1 != a[e].owner.tileID.indexOf('top')
              ? r.push(a[e])
              : o.push(a[e]);
          (a = r.concat(o)), (r = []), (o = []);
          for (let e = 0; e < a.length; e++) {
            const r = a[e];
            (null != s.overrideMaterial && r.framebuffer) ||
              ((r._material.needPreRender = !0),
              r.update(t, s, { hasMixedContent: !1 }),
              r.render(t, i, s),
              (r._material.needPreRender = !1));
          }
          const l = n.filter((e) => e.owner.extra.finalResolution);
          for (let e = 0; e < l.length; e++) {
            const r = l[e];
            (null != s.overrideMaterial && r.framebuffer) ||
              ((r._material.needTilesNextRender = !0),
              r.update(t, s, { hasMixedContent: !1 }),
              r.render(t, i, s),
              (r._material.needTilesNextRender = !1),
              r._afterRenderFunction && r.afterRender(r._afterRenderFunction));
          }
        } else
          for (let r = 0; r < n.length; r++) {
            const l = n[r];
            if (void 0 !== s.overrideMaterial && l.framebuffer) continue;
            if (null != l.rootId) {
              const e = t._map.getSceneComponent(l.rootId);
              (i.lightingModel = void 0 === e ? 0 : e.lightingModel), fh.setLightDefines(l, i);
            }
            const h = s.overrideMaterial || l._material;
            o
              ? ((l._material.overrideRenderState = void 0),
                l.update(t, s, { hasMixedContent: !1 }),
                l.render(t, i, s))
              : ((h.overrideRenderState = a.pass1),
                l.update(t, s, { hasMixedContent: !1 }),
                l.render(t, i, s),
                (h.overrideRenderState = a.pass2),
                h instanceof e.PickColorMaterial &&
                  (h.overrideRenderState.blending = e.renderStateEnum.disableBlending),
                l.update(t, s, { hasMixedContent: !1 }),
                l.render(t, i, s)),
              l._afterRenderFunction && l.afterRender(l._afterRenderFunction),
              (h.overrideRenderState = void 0);
          }
        this._renderPrimitives = [];
      }
      parse(t, i, s, r, n) {
        const o = N_({ source: i?._source, layer: s, passType: r.passType }),
          a = i?.tilesForRender || [];
        for (let e = 0; e < a.length; e++) {
          const t = a[e];
          t.animations &&
            t.animations.length > 0 &&
            (t.animations[0].isRunning || t.animations[0].play(), t.rootNode.updateMatrixWorld(!0));
        }
        (this._renderPrimitives = n),
          this._renderPrimitives.forEach((i) => {
            (r.overrideMaterial || i._material).defines = Object.assign(
              {},
              o,
              i?._material?.defines,
            );
            let s = i.boundingVolume;
            e.defined(i.modelInstanceCollection) && (s = i.modelInstanceCollection.boundingVolume),
              t.options.showDebugBoundingBox &&
                this.createDebugBoundingBox(t, s, i.tileUid || i.id);
          });
      }
      createDebugBoundingBox(e, t, i) {
        if (!t) return;
        let s = e.style.debugBoundingBoxPrimitiveCollection.get(i);
        s ||
          (s = K_.createDebugBoundingBoxPrimitive({
            painter: e,
            center: t.center,
            halfAxes: t.halfAxes,
            id: i,
          })),
          e.style.debugBoundingBoxPrimitiveCollection.add(s);
      }
      static #O(e, t) {
        return Y_.parseRenderState(e, t);
      }
      destroy() {
        (this.programId = void 0), (this._renderPrimitives = void 0);
      }
    }
    class Q_ extends D_ {
      constructor(e) {
        super(e),
          (this._renderPrimitives = []),
          (this.isRegularVector = !0),
          (this.plotterType = 'line');
      }
      update(t, i, s, r, n) {
        if (void 0 === s.paint) return;
        if (n.overrideMaterial instanceof e.PickColorMaterial) return;
        const o =
            s.paint.get('line-opacity') ||
            s.paint.get('tracking-opacity') ||
            s.paint.get('sprite-opacity'),
          a =
            s.paint.get('line-width') ||
            s.paint.get('tracking-width') ||
            s.paint.get('sprite-width');
        if (0 === o.constantOr(1) || 0 === a.constantOr(1)) return;
        const l = i.getSource();
        (l.animationsInfo = {}),
          'trips' === s.paint.get('tracking-type') && this.#k(l),
          this.parse(t, i, s, r, n, l.animationsInfo),
          this.render(t, s, n, l.animationsInfo);
      }
      render(e, t, i, s) {
        const r = B_[i.passType](this._renderPrimitives);
        let n;
        this.isRegularVector || (n = this.#O(e, t));
        for (let o = 0; o < r.length; o++) {
          const a = r[o],
            l = a._material.isBorder;
          this.isRegularVector
            ? (l && (a.update(e, i, { animationsInfo: s }), a.render(e, t, i)),
              l && (a._material.isBorder = !1),
              a.update(e, i, { animationsInfo: s }),
              a.render(e, t, i),
              l && (a._material.isBorder = !0))
            : (l &&
                ((a._material.renderState = n.pass1),
                a.update(e, i, { animationsInfo: s }),
                a.render(e, t, i),
                (a._material.renderState = n.pass2),
                a.update(e, i, { animationsInfo: s }),
                a.render(e, t, i)),
              l && (a._material.isBorder = !1),
              (a._material.renderState = n.pass1),
              a.update(e, i, { animationsInfo: s }),
              a.render(e, t, i),
              (a._material.renderState = n.pass2),
              a.update(e, i, { animationsInfo: s }),
              a.render(e, t, i),
              l && (a._material.isBorder = !0));
        }
        (this._renderPrimitives = []), (e.tileClippingMask.status = !1);
      }
      parse(t, i, s, r, n, o) {
        if (r.length > 0) {
          (this.isRegularVector = !e.checkIsVectorShadowVolumeDataType(s.classificationType)),
            'tracking' === s.type && Gn.updateLayerProperty(s, t);
          const a = N_({
              source: null,
              layer: null,
              isInstance: !1,
              passType: n.passType,
              animationsInfo: o,
            }),
            l = L_.getVectorLineDefinition(null, s);
          e.extend(a, l);
          const h = s.getCrossfadeParameters();
          for (let e = 0; e < r.length; e++) {
            const n = r[e],
              o = i.getTile(n),
              l = o.getBucket(s);
            if (!l) continue;
            'sprite' == s.type && l.programConfigurations.get(s.id).updatePaintBuffers(h);
            const c = o.primitiveMap.get(s.id);
            if (c)
              if (this.isRegularVector) {
                const e = this.#O(t, s, n),
                  i = c.line;
                (i._material.defines = a),
                  (i._material.renderState = e),
                  this._renderPrimitives.push(i);
              } else {
                const e = c.line;
                (e._material.defines = a), this._renderPrimitives.push(e);
              }
          }
        }
      }
      #O(t, i, s) {
        let r = Q_.parseRenderState(t, i);
        if (this.isRegularVector) {
          if (t.tileClippingMask.status) {
            const i = t.tileClippingMask.getMaskIDByCoord(s);
            t.tileClippingMask.updateRefValue('useMask', i),
              (r = e.deepCopyObj(t.tileClippingMask.useMaskRs));
          }
          r.cull = e.renderStateEnum.disableCull;
        }
        return r;
      }
      destroy() {
        (this.programId = void 0),
          (this._renderPrimitives = void 0),
          (this.isRegularVector = void 0),
          (this.plotterType = void 0);
      }
      #k(e) {
        if (!e.animationPropertyCollection || 0 === e.animationPropertyCollection.size) return;
        const t = e?.animationPropertyCollection,
          i = t.getAll();
        1 === i.length && i[0].updateAnimation(e);
      }
    }
    class J_ extends D_ {
      constructor(e) {
        super(e),
          (this.sourceType = void 0),
          (this._renderPrimitives = []),
          (this.programId = 'sphereRaster'),
          (this.plotterType = 'raster');
      }
      update(e, t, i, s, r) {
        for (let e = 0; e < i.length; e++) {
          const t = i[e];
          (t.paint && 0 !== t.paint.get('raster-opacity')) || i.splice(e, 1);
        }
        this.parse(e, t, i, s), this.render(e, i, r);
      }
      render(t, i, s) {
        const r = B_[s.passType](this._renderPrimitives);
        if (t._map.analysis.excavationCollection.length > 0) {
          t._map.analysis.excavationCollection.update(t, r, i);
          for (let t = 0; t < r.length; t++)
            (r[t]._material.renderState.stencilMask = 255),
              (r[t]._material.renderState.stencilTest = {
                enabled: !0,
                frontFunction: e.WebGLConstants.EQUAL,
                backFunction: e.WebGLConstants.EQUAL,
                reference: 0,
                mask: 255,
                frontOperation: {
                  fail: e.WebGLConstants.KEEP,
                  zFail: e.WebGLConstants.KEEP,
                  zPass: e.WebGLConstants.KEEP,
                },
                backOperation: {
                  fail: e.WebGLConstants.KEEP,
                  zFail: e.WebGLConstants.KEEP,
                  zPass: e.WebGLConstants.KEEP,
                },
              });
        }
        for (const n of i)
          if (n.maskingEnabled) {
            const i = n.maskingPolygonPrimitive;
            i && (i.update(t, s), i.render(t, n, s));
            for (let t = 0; t < r.length; t++)
              (r[t]._material.renderState.stencilMask = 255),
                (r[t]._material.renderState.stencilTest = {
                  enabled: !0,
                  frontFunction: e.WebGLConstants.EQUAL,
                  backFunction: e.WebGLConstants.EQUAL,
                  reference: n.maskingId,
                  mask: 255,
                  frontOperation: {
                    fail: e.WebGLConstants.KEEP,
                    zFail: e.WebGLConstants.KEEP,
                    zPass: e.WebGLConstants.REPLACE,
                  },
                  backOperation: {
                    fail: e.WebGLConstants.KEEP,
                    zFail: e.WebGLConstants.KEEP,
                    zPass: e.WebGLConstants.REPLACE,
                  },
                });
          }
        for (let e = 0; e < r.length; e++) {
          const n = r[e];
          n.update(t, s), n.render(t, i, s);
        }
        this._renderPrimitives = [];
      }
      parse(e, t, i, s) {
        if (s.length > 0) {
          const r = {};
          for (const e of t) r[e.id] = e;
          for (const n of s) {
            const s = [],
              o = [],
              a = [],
              l = [],
              h = [],
              c = [],
              _ = [];
            for (let e = 0; e < i.length; e++) {
              const t = i[e],
                u = r[t.source].getTile(n);
              if (u) {
                s.push(...u.imagery);
                const e = t.paint.get('raster-opacity'),
                  i = t.paint.get('raster-brightness-min'),
                  r = t.paint.get('raster-brightness-max'),
                  n = tu(t.paint.get('raster-saturation')),
                  d = eu(t.paint.get('raster-contrast')),
                  m = iu(t.paint.get('raster-hue-rotate'));
                for (let t = 0; t < u.imagery.length; t++)
                  o.push(e), a.push(i), l.push(r), h.push(n), c.push(d), _.push(m);
              }
            }
            let u, d;
            for (let e = 0; e < i.length; e++) {
              const t = i[e],
                m = r[t.source].getTile(n);
              t.lightingModel && (d = t.lightingModel),
                m &&
                  ((m.totalImagery = s),
                  (m.totalOpacity = o),
                  (m.totalBrightnessMin = a),
                  (m.totalBrightnessMax = l),
                  (m.totalSaturationFactor = h),
                  (m.totalContrastFactor = c),
                  (m.totalSpinWight = _),
                  u || (u = m.primitiveMap.get(t.id)));
            }
            const m = t[0].getSource(),
              p = L_.getRasterSourceAndLayerMicroDefinition(m, i[0]),
              f = this.#O(e, i[0]);
            u &&
              ((u._material.renderState = f),
              (u._material.defines = p),
              fh.setLightDefines(u, { lightingModel: d }),
              this._renderPrimitives.push(u));
          }
        }
      }
      #O(t, i) {
        const s = {};
        (s.blending = e.renderStateEnum.enableBlending),
          (s.depthRange = e.renderStateEnum.depthRange),
          (s.stencilTest = e.renderStateEnum.disableStencilTest),
          (s.stencilMask = e.renderStateEnum.disableStencilMask);
        const r = t.style._layers;
        for (const n in r)
          void 0 === r[n].classificationType
            ? i.depthTest || t.style.terrainSourceCache.isTerrain()
              ? ((s.depthTest = e.renderStateEnum.enableDepthTest),
                (s.depthMask = e.renderStateEnum.enableDepthMask))
              : ((s.cull = e.renderStateEnum.enableCull),
                (s.frontFace = e.WebGLConstants.CCW),
                (s.depthTest = e.renderStateEnum.disableDepthTest),
                (s.depthMask = e.renderStateEnum.disableDepthMask))
            : i.depthTest ||
              t.style.terrainSourceCache.isTerrain() ||
              r[n].classificationType === e.ClassificationType.ALL
            ? ((s.depthTest = e.renderStateEnum.enableDepthTest),
              (s.depthMask = e.renderStateEnum.enableDepthMask))
            : ((s.cull = e.renderStateEnum.enableCull),
              (s.frontFace = e.WebGLConstants.CCW),
              (s.depthTest = e.renderStateEnum.disableDepthTest),
              (s.depthMask = e.renderStateEnum.disableDepthMask));
        return s;
      }
      destroy() {
        (this.sourceType = void 0),
          (this._renderPrimitives = void 0),
          (this.programId = void 0),
          (this.plotterType = void 0);
      }
    }
    function eu(e) {
      return e > 0 ? 1 / (1 - e) : 1 + e;
    }
    function tu(e) {
      return e > 0 ? 1 - 1 / (1.001 - e) : -e;
    }
    function iu(t) {
      t *= Math.PI / 180;
      const i = Math.sin(t),
        s = Math.cos(t);
      return new e.Vector3(
        (2 * s + 1) / 3,
        (-Math.sqrt(3) * i - s + 1) / 3,
        (Math.sqrt(3) * i - s + 1) / 3,
      );
    }
    class su extends D_ {
      constructor(e) {
        super(e),
          (this.sourceType = void 0),
          (this._renderPrimitives = []),
          (this.programId = 'sphereImage'),
          (this.plotterType = 'image');
      }
      update(e, t, i, s, r) {
        i.paint &&
          0 !== i.paint.get('raster-opacity') &&
          (this.parse(e, t, i, s), this.render(e, i, r));
      }
      render(t, i, s) {
        const r = B_[s.passType](this._renderPrimitives);
        if (t._map.analysis.excavationCollection.length > 0) {
          t._map.analysis.excavationCollection.update(t, r, i);
          for (let t = 0; t < r.length; t++)
            (r[t]._material.renderState.stencilMask = 255),
              (r[t]._material.renderState.stencilTest = {
                enabled: !0,
                frontFunction: e.WebGLConstants.EQUAL,
                backFunction: e.WebGLConstants.EQUAL,
                reference: 0,
                mask: 255,
                frontOperation: {
                  fail: e.WebGLConstants.KEEP,
                  zFail: e.WebGLConstants.KEEP,
                  zPass: e.WebGLConstants.KEEP,
                },
                backOperation: {
                  fail: e.WebGLConstants.KEEP,
                  zFail: e.WebGLConstants.KEEP,
                  zPass: e.WebGLConstants.KEEP,
                },
              });
        }
        if (i.maskingEnabled) {
          const n = i.maskingPolygonPrimitive;
          n && (n.update(t, s), n.render(t, i, s));
          for (let t = 0; t < r.length; t++)
            (r[t]._material.renderState.stencilMask = 255),
              (r[t]._material.renderState.stencilTest = {
                enabled: !0,
                frontFunction: e.WebGLConstants.EQUAL,
                backFunction: e.WebGLConstants.EQUAL,
                reference: i.maskingId,
                mask: 255,
                frontOperation: {
                  fail: e.WebGLConstants.KEEP,
                  zFail: e.WebGLConstants.KEEP,
                  zPass: e.WebGLConstants.REPLACE,
                },
                backOperation: {
                  fail: e.WebGLConstants.KEEP,
                  zFail: e.WebGLConstants.KEEP,
                  zPass: e.WebGLConstants.REPLACE,
                },
              });
        }
        for (let e = 0; e < r.length; e++) {
          const n = r[e];
          n.update(t, s), n.render(t, i, s);
        }
        this._renderPrimitives = [];
      }
      parse(t, i, s, r) {
        if (r.length > 0) {
          const n = i.getSource(),
            o = L_.getRasterSourceAndLayerMicroDefinition(n, s),
            a = this.#O(t, s);
          if (n instanceof gn && n.primitive)
            return (
              n.primitive._material.layer || n.primitive._material.setLayer(s),
              (n.primitive._material.renderState = a),
              (n.primitive._material.defines = o),
              void this._renderPrimitives.push(n.primitive)
            );
          for (const t of r) {
            const r = i.getTile(t);
            if (!e.defined(r)) continue;
            r.registerFadeDuration(s.paint.get('raster-fade-duration'));
            const n = r.primitiveMap.get(s.id);
            n &&
              ((n._material.renderState = a),
              (n._material.defines = o),
              this._renderPrimitives.push(n));
          }
        }
      }
      #O(t, i) {
        const s = {};
        return (
          (s.blending = e.renderStateEnum.enableBlending),
          (s.depthRange = e.renderStateEnum.depthRange),
          (s.stencilTest = e.renderStateEnum.disableStencilTest),
          (s.stencilMask = e.renderStateEnum.disableStencilMask),
          i.depthTest || t.style.terrainSourceCache.isTerrain()
            ? ((s.depthTest = e.renderStateEnum.enableDepthTest),
              (s.depthMask = e.renderStateEnum.enableDepthMask))
            : ((s.cull = e.renderStateEnum.enableCull),
              (s.frontFace = e.WebGLConstants.CCW),
              (s.depthTest = e.renderStateEnum.disableDepthTest),
              (s.depthMask = e.renderStateEnum.disableDepthMask)),
          s
        );
      }
      destroy() {
        (this.sourceType = void 0),
          (this._renderPrimitives = void 0),
          (this.programId = void 0),
          (this.plotterType = void 0);
      }
    }
    class ru extends D_ {
      constructor(e) {
        super(e), (this._renderPrimitives = []), (this.plotterType = 'circle');
      }
      update(e, t, i, s, r) {
        this.parse(e, t, i, s, r), this.render(e, t, i, s, r);
      }
      render(e, t, i, s, r) {
        const n = B_[r.passType](this._renderPrimitives);
        for (let t = 0; t < n.length; t++) {
          const s = n[t];
          s.update(e, r), s.render(e, i, r);
        }
        (this._renderPrimitives = []), (e.tileClippingMask.status = !1);
      }
      parse(t, i, s, r, n) {
        if (r.length > 0) {
          const o = N_({ source: null, layer: null, isInstance: !1, passType: n.passType }),
            a = L_.getSphereCircleDefinition(null, s);
          e.extend(o, a);
          for (let e = 0; e < r.length; e++) {
            const n = i.getTile(r[e]).primitiveMap.get(s.id);
            n &&
              ((n._material.renderState = this.#O(t, s)),
              (n._material.defines = o),
              this._renderPrimitives.push(n));
          }
        }
      }
      #O(t, i) {
        const s = ru.parseRenderState(t, i);
        return (s.cull = e.renderStateEnum.disableCull), s;
      }
      destroy() {
        (this.isPlotter = void 0), (this.plotterType = void 0), (this._renderPrimitives = void 0);
      }
    }
    class nu extends D_ {
      constructor(e) {
        super(e),
          (this.sourceType = void 0),
          (this._renderPrimitives = []),
          (this.programId = 'sphereBackground'),
          (this.plotterType = 'background'),
          (this.backgroundTileSize = 512),
          (this.layerId = void 0);
      }
      update(t, i, s, r, n) {
        if (!s.paint) return;
        if (0 === s.paint.get('background-opacity')) return;
        const o = s.paint.get('background-pattern');
        (o && e.isPatternMissing(o, t)) ||
          ((r = (i = t.style.backgroundSourceCache).getVisibleCoordinates()),
          this.parse(t, i, s, r, n),
          this._error || this.render(t, s, n));
      }
      render(e, t, i) {
        const s = B_[i.passType](this._renderPrimitives);
        for (let r = 0; r < s.length; r++) {
          const n = s[r];
          n.update(e, i), n.render(e, t, i);
        }
        this._renderPrimitives = [];
      }
      parse(e, t, i, s, r) {
        const n = N_({ source: null, layer: null, isInstance: !1, passType: r.passType }),
          o = this.#O(e, i);
        for (const e of s) {
          if (i.minzoom > e.canonical.z || i.maxzoom <= e.canonical.z) continue;
          const s = t.getTile(e),
            r = s?.primitiveMap.get(i.id);
          r &&
            ((r._material.renderState = o),
            (r._material.defines = n),
            this._renderPrimitives.push(r));
        }
      }
      #O(t, i) {
        const s = nu.parseRenderState(t, i);
        return (
          (s.frontFace = e.WebGLConstants.CCW),
          i.paint.get('background-terrain-analysis').value._parameters &&
            ((s.depthTest = e.renderStateEnum.enableDepthTest),
            (s.depthMask = e.renderStateEnum.enableDepthMask),
            (s.blending = e.renderStateEnum.disableBlending)),
          s
        );
      }
      destroy() {
        (this.sourceType = void 0),
          (this._renderPrimitives = void 0),
          (this.programId = void 0),
          (this.plotterType = void 0);
      }
    }
    class ou extends e.Material {
      constructor(t) {
        super(t),
          (this.layer = t.layer),
          (this.tile = t.tile),
          (this.coord = t.coord),
          (this._programConfiguration = t.programConfiguration),
          (this._renderState = t.renderState),
          (this._unitsToPixels = new e.Vector2()),
          (this._cameraPosition = new e.Vector3()),
          (this._pixelMatrix = new e.Matrix2());
        const i = t.painter;
        (this.matrix = new e.Matrix4()),
          this.matrix.ortho({ left: 0, right: i.width, bottom: i.height, top: 0, near: 0, far: 1 }),
          (this.colorRampTexture = new e.Texture({
            context: i.context,
            image: this.layer.colorRamp,
            pixelFormat: e.WebGLConstants.RGBA,
          })),
          this.#A(i);
      }
      update(t, i, s = {}) {
        super.update(t, i, s),
          (this.basecolorTexture = s.texture),
          this._uniforms.set('u_ModelViewProjectionMatrix', () => this.matrix),
          (this.renderState.blending = {
            enabled: !0,
            color: { red: 0, green: 0, blue: 0, alpha: 0 },
            equationRgb: e.WebGLConstants.FUNC_ADD,
            equationAlpha: e.WebGLConstants.FUNC_ADD,
            functionSourceRgb: e.WebGLConstants.SRC_ALPHA,
            functionSourceAlpha: e.WebGLConstants.ONE,
            functionDestinationRgb: e.WebGLConstants.ONE_MINUS_SRC_ALPHA,
            functionDestinationAlpha: e.WebGLConstants.ONE_MINUS_SRC_ALPHA,
          });
      }
      #A(t) {
        this._uniforms.set('u_GlUnitsToPixels', () =>
          this._unitsToPixels.set(t.transform.width / 2, t.transform.height / 2),
        ),
          this._uniforms.set(
            'u_PixelMatrix',
            () => (
              this._pixelMatrix.identity(),
              this._pixelMatrix.scale([1, Math.cos(t.transform.hpr.pitch)]),
              this._pixelMatrix.rotate(-t.transform.hpr.heading),
              this._pixelMatrix
            ),
          ),
          this._uniforms.set('u_Opacity', () => this.layer.paint.get('heatmap-opacity')),
          this._uniforms.set(
            'u_BaseColorSampler',
            () => (
              (this.basecolorTexture.sampler = {
                minificationFilter: e.WebGLConstants.LINEAR,
                magnificationFilter: e.WebGLConstants.LINEAR,
                wrapS: e.WebGLConstants.CLAMP_TO_EDGE,
                wrapT: e.WebGLConstants.CLAMP_TO_EDGE,
              }),
              this.basecolorTexture
            ),
          ),
          this._uniforms.set(
            'u_color_ramp',
            () => (
              (this.colorRampTexture.sampler = {
                minificationFilter: e.WebGLConstants.LINEAR,
                magnificationFilter: e.WebGLConstants.LINEAR,
                wrapS: e.WebGLConstants.CLAMP_TO_EDGE,
                wrapT: e.WebGLConstants.CLAMP_TO_EDGE,
              }),
              this.colorRampTexture
            ),
          ),
          this._uniforms.set(
            'u_World',
            () => new e.Vector2(t.context.drawingBufferWidth, t.context.drawingBufferHeight),
          );
      }
      destroy() {
        (this.layer = void 0),
          (this.tile = void 0),
          (this.coord = void 0),
          (this.pattern = void 0),
          (this.type = void 0),
          (this._uniforms = void 0),
          (this._textures = void 0),
          (this._program = void 0),
          (this._programConfiguration = void 0),
          (this._renderState = void 0),
          (this._unitsToPixels = void 0),
          (this._cameraPosition = void 0),
          (this._pixelMatrix = void 0);
      }
    }
    class au extends e.Geometry {
      constructor(t) {
        super(),
          (this.type = 'HeatMapViewPortGeometry'),
          (this.primitiveType = e.WebGLConstants.TRIANGLES),
          (this.widthSegments = t.widthSegments),
          (this.heightSegments = t.heightSegments),
          (this.transform = t.transform),
          (this._zoom = this.transform.cameraHeightConvertedZoom),
          (this._vertexArray = void 0),
          (this._indices = void 0),
          (this._width = 1),
          (this._height = 1),
          (this._vertexLength = 0),
          (this._primitiveLength = 0),
          (this._needUpdate = !1),
          this.parse();
      }
      parse() {
        let t, i;
        (this._vertexArray = new e.StructArrayLayout5f20()),
          (this._indices = new e.StructArrayLayout3ul12()),
          this._zoom < 17
            ? ((t = Math.floor(this.widthSegments)), (i = Math.floor(this.heightSegments)))
            : ((t = Math.floor(this.widthSegments / 2)), (i = Math.floor(this.heightSegments / 2)));
        const s = t + 1,
          r = i + 1,
          n = this._width / t,
          o = this._height / i;
        if (this._zoom < 17)
          for (let e = 0; e < r; e++) {
            const r = e * o;
            for (let o = 0; o < s; o++)
              this._vertexArray.emplaceBack(
                ((o * n) / this._width) * 2 - 1,
                1 - (r / this._height) * 2,
                1,
                o / t,
                1 - e / i,
              );
          }
        else
          for (let a = 0; a < r; a++) {
            const r = a * o;
            for (let o = 0; o < s; o++) {
              const s = o * n,
                l = this.transform.getCameraPos(),
                h = new e.Ray(
                  l,
                  e.getPointInWorldRay(
                    (s / this._width) * this.transform.width,
                    (r / this._height) * this.transform.height,
                    0.999999,
                    this.transform,
                  ),
                ),
                c = e.IntersectionTests.rayEllipsoid(h, e.Transforms.DefaultEllipsoid);
              if (!c) {
                this._vertexArray.emplaceBack(
                  (s / this._width) * 2 - 1,
                  1 - (r / this._height) * 2,
                  1,
                  -5906376272e3,
                  -5906376272e3,
                );
                continue;
              }
              const _ = h.origin.add(h.direction.multiplyScalar(c.start));
              this._vertexArray.emplaceBack(_.x, _.y, _.z, o / t, 1 - a / i);
            }
          }
        this._vertexLength = s * r;
        for (let e = 0; e < i; e++)
          for (let i = 0; i < t; i++) {
            const t = i + s * (e + 1),
              r = i + 1 + s * (e + 1),
              n = i + 1 + s * e;
            this._indices.emplaceBack(i + s * e, n, t), this._indices.emplaceBack(n, t, r);
          }
        (this._primitiveLength = t * i * 2), (this._needUpdate = !0);
      }
      update(t) {
        const i = t.painter.context,
          s = this._zoom;
        (this.transform = t.painter.transform),
          (this._zoom = this.transform.cameraHeightConvertedZoom),
          this.widthSegments !== this.transform.width / 4 ||
          this.heightSegments !== this.transform.height / 4 ||
          this._zoom >= 17
            ? ((this.widthSegments = this.transform.width / 4),
              (this.heightSegments = this.transform.height / 4),
              this.parse())
            : this._zoom < 17 && s >= 17 && this.parse(),
          this._needUpdate &&
            (this._vertBuffer && this._indexBuffer && this._segmentVector
              ? (this._vertBuffer.updateData(this._vertexArray),
                this._indexBuffer.updateData(this._indices),
                this._segmentVector.destroy(),
                (this._segmentVector = e.SegmentVector.simpleSegment(
                  0,
                  0,
                  this._vertexLength,
                  this._primitiveLength,
                )))
              : ((this._vertBuffer = i.createVertexBuffer(this._vertexArray, Ir.members, !0)),
                (this._indexBuffer = new Ns(i, this._indices, !0, e.WebGLConstants.UNSIGNED_INT)),
                (this._segmentVector = e.SegmentVector.simpleSegment(
                  0,
                  0,
                  this._vertexLength,
                  this._primitiveLength,
                ))),
            (this._needUpdate = !1));
      }
      destroy() {
        return (
          (this.type = void 0),
          (this.primitiveType = void 0),
          (this.widthSegments = void 0),
          (this.heightSegments = void 0),
          (this.transform = void 0),
          (this._zoom = void 0),
          (this._vertexArray = void 0),
          (this._indices = void 0),
          (this._width = void 0),
          (this._height = void 0),
          (this._vertexLength = void 0),
          (this._primitiveLength = void 0),
          (this._needUpdate = void 0),
          this._segmentVector.destroy(),
          (this._segmentVector = void 0),
          this._vertBuffer.destroy(),
          (this._vertBuffer = void 0),
          this._indexBuffer.destroy(),
          (this._indexBuffer = void 0),
          e.destroyObject(this)
        );
      }
    }
    class lu extends e.Material {
      constructor(t) {
        super(t),
          (this.layer = t.layer),
          (this.tile = t.tile),
          (this.coord = t.coord),
          (this._programConfiguration = t.programConfiguration),
          (this._renderState = t.renderState),
          (this.colorRampTexture = new e.Texture({
            context: t.painter.context,
            image: this.layer.colorRamp,
            pixelFormat: e.WebGLConstants.RGBA,
          })),
          this.#A();
      }
      update(t, i, s = {}) {
        super.update(t, i, s),
          (this.defines =
            t.transform.cameraHeightConvertedZoom < 17 ? { LARGE_SCALE: !0 } : { LARGE_SCALE: !1 }),
          (this.basecolorTexture = s.texture);
        const r = this.getCamera(i);
        this._uniforms.set('u_ModelViewProjectionMatrix', () => r.getVPMatrix()),
          this._uniforms.set(
            'u_HeightFactor',
            () => this.layer.paint.get('heatmap-height-factor').value.value,
          ),
          (this.renderState.blending = {
            enabled: !0,
            color: { red: 0, green: 0, blue: 0, alpha: 0 },
            equationRgb: e.WebGLConstants.FUNC_ADD,
            equationAlpha: e.WebGLConstants.FUNC_ADD,
            functionSourceRgb: e.WebGLConstants.SRC_ALPHA,
            functionSourceAlpha: e.WebGLConstants.ONE,
            functionDestinationRgb: e.WebGLConstants.ONE_MINUS_SRC_ALPHA,
            functionDestinationAlpha: e.WebGLConstants.ONE_MINUS_SRC_ALPHA,
          });
      }
      #A() {
        this._uniforms.set('u_Opacity', () => this.layer.paint.get('heatmap-opacity')),
          this._uniforms.set(
            'u_BaseColorSampler',
            () => (
              (this.basecolorTexture.sampler = {
                minificationFilter: e.WebGLConstants.LINEAR,
                magnificationFilter: e.WebGLConstants.LINEAR,
                wrapS: e.WebGLConstants.CLAMP_TO_EDGE,
                wrapT: e.WebGLConstants.CLAMP_TO_EDGE,
              }),
              this.basecolorTexture
            ),
          ),
          this._uniforms.set(
            'u_color_ramp',
            () => (
              (this.colorRampTexture.sampler = {
                minificationFilter: e.WebGLConstants.LINEAR,
                magnificationFilter: e.WebGLConstants.LINEAR,
                wrapS: e.WebGLConstants.CLAMP_TO_EDGE,
                wrapT: e.WebGLConstants.CLAMP_TO_EDGE,
              }),
              this.colorRampTexture
            ),
          ),
          this._uniforms.set('u_Bezier', () => new e.Vector4(0.5, 0, 1, 0.5));
      }
      destroy() {
        (this.layer = void 0),
          (this.tile = void 0),
          (this.coord = void 0),
          (this.pattern = void 0),
          (this.type = void 0),
          (this._uniforms = void 0),
          (this._textures = void 0),
          (this._program = void 0),
          (this._programConfiguration = void 0),
          (this._renderState = void 0),
          this.colorRampTexture.destroy(),
          (this.colorRampTexture = void 0);
      }
    }
    class hu extends D_ {
      constructor(e) {
        super(e),
          (this._renderPrimitives = []),
          (this.plotterType = 'heatmap'),
          (this._texturePrimitive = null),
          (this.framebuffer = null);
      }
      update(e, t, i, s, r) {
        this.parse(e, t, i, s, r), this.render(e, t, i, s, r);
      }
      render(t, i, s, r, n) {
        const o = B_[n.passType](this._renderPrimitives);
        if (0 == o.length || !this._texturePrimitive) return;
        const a = t.context,
          l = n.framebuffer;
        (n.framebuffer = this.framebuffer),
          a.bindFramebuffer.set(this.framebuffer.framebuffer),
          a.clear({ color: e.Color.transparent, depth: 1, stencil: 0 });
        for (let e = 0; e < o.length; e++) {
          const i = o[e];
          i.update(t, n), i.render(t, s, n);
        }
        (n.framebuffer = l),
          this._texturePrimitive.update(t, n, { texture: this.framebuffer.getColorTexture(0) }),
          this._texturePrimitive.render(t, s, n),
          (this._renderPrimitives = []),
          (t.tileClippingMask.status = !1);
      }
      parse(t, i, s, r, n) {
        if (r.length > 0) {
          const o = N_({ source: null, layer: null, isInstance: !1, passType: n.passType }),
            a = L_.getSphereHeatmapDefinition(null, s);
          e.extend(o, a);
          for (let e = 0; e < r.length; e++) {
            const n = i.getTile(r[e]);
            if (!n.getBucket(s)) continue;
            const a = n.primitiveMap.get(s.id);
            a &&
              ((a._material.renderState = this.#O(t, s)),
              (a._material.defines = o),
              this._renderPrimitives.push(a));
          }
          if (!this._texturePrimitive || !this.framebuffer || s.colorRampChanged) {
            s.colorRampChanged && this.resize();
            const e = s.getLayoutProperty('display-mode');
            if ('3d' === e || '3D' === e) {
              const e = new au({
                widthSegments: t.transform.width / 4,
                heightSegments: t.transform.height / 4,
                transform: t.transform,
              });
              this.#F({ layer: s, painter: t, type: 'heatmap3DTexture', geometry: e });
            } else this.#G({ layer: s, painter: t, type: 'heatmapTexture' });
            this.#U(t.width, t.height, t.context), (s.colorRampChanged = !1);
          }
        }
      }
      #U(t, i, s) {
        this.framebuffer ||
          (this.framebuffer = new e.Framebuffer({
            context: s,
            width: t,
            height: i,
            colorTextures: [
              new e.Texture({
                width: t,
                height: i,
                context: s,
                pixelFormat: e.WebGLConstants.RGBA,
                pixelDatatype: e.WebGLConstants.FLOAT,
              }),
            ],
            depthStencilRenderbuffer: new Bs({
              context: s,
              width: t,
              height: i,
              format: e.RenderbufferFormat.DEPTH_STENCIL,
            }),
          }));
      }
      #F(t) {
        const { layer: i, painter: s, type: r, geometry: n } = t;
        if (!this._texturePrimitive) {
          const t = this.#z({ layer: i, painter: s, type: r });
          this._texturePrimitive = new e.Primitive({ geometry: n, material: t });
        }
      }
      #z(e) {
        const { layer: t, painter: i, type: s } = e,
          r = this.#O(i, t);
        return new lu({ layer: t, painter: i, type: s, renderState: r });
      }
      #G(t) {
        const { layer: i, painter: s, type: r } = t;
        if (!this._texturePrimitive) {
          const t = this.#H({ layer: i, painter: s, type: r }),
            n = new e.ViewportQuadGeometry(s),
            o = new e.Primitive({ geometry: n, material: t });
          this._texturePrimitive = o;
        }
      }
      #H(e) {
        const { layer: t, painter: i, type: s } = e,
          r = this.#O(i, t);
        return new ou({ layer: t, painter: i, type: s, renderState: r });
      }
      #O(t, i) {
        const s = hu.parseRenderState(t, i);
        return (s.cull = e.renderStateEnum.disableCull), s;
      }
      resize() {
        this.framebuffer && (this.framebuffer.destroy(), (this.framebuffer = null)),
          (this._texturePrimitive = null);
      }
      destroy() {
        (this.isPlotter = void 0), (this.plotterType = void 0), (this._renderPrimitives = void 0);
      }
    }
    class cu {
      constructor() {
        this.texMap = new Map();
      }
      getTexture(t) {
        const i = e.defaultValue(t.name, ''),
          s = e.defaultValue(t.texUrl, '');
        let r = i;
        '' == i && (r = s);
        const n = this.texMap.get(r);
        if (n) return n.addReference(), n;
        {
          const i = new e.Texture(t);
          return r && '' != r && this.texMap.set(r, i), i;
        }
      }
      getTextureByName(e) {
        const t = this.texMap.get(e);
        return t && t.addReference(), t;
      }
      addTexture(e, t) {
        e && '' != e && this.texMap.set(e, t);
      }
      removeTexture(e) {
        const t = this.texMap.get(e);
        t && (t.reduceReference(), 0 === t.referenceCount && (this.texMap.delete(e), t.destroy()));
      }
    }
    class _u {
      constructor(t) {
        (this.context = t.context), (this.map = t.savedMap);
        const { gl: i } = this.context,
          s = i.getExtension('EXT_SRGB'),
          r = s ? s.SRGB_EXT : e.WebGLConstants.RGBA,
          n = this.map.getStyle(),
          o = 'minemap://assets/IBLtextures_BlueSky';
        (this.IBLUrl = ((e) => {
          if (!yr(e)) return e;
          const t = Pr(e);
          return `${pr.SRC_URL}/${t.authority}${t.path}`;
        })(n.IBL ? n.IBL : o)),
          n.IBL ||
            this.map.testMode ||
            e.warnOnce(`map.style has no IBL defined, minemap.js sets the default value to ${o}`),
          this.getIBLImage(`${this.IBLUrl}/SkyBox0/brdfLUT.png`, r, i),
          (this.mDiffuseEnvTex = this.loadCubeMap(i, 'diffuse')),
          (this.mSpecularEnvTex = this.loadCubeMap(i, 'specular')),
          (this.isLoaded = !0);
      }
      async getIBLImage(t, i) {
        const s = await (() =>
          new Promise((i, s) => {
            e.getImage(this.map._transformRequest(t, e.ResourceType.Image), (e, t) => {
              e && s(e), i(t);
            });
          }))();
        if (!(s.nodeName || (s.width && s.height)))
          throw ((this.isLoaded = !1), new Error('load IBL image error'));
        {
          const t = new e.Texture({
            context: this.context,
            image: s,
            pixelFormat: i,
            useMipmap: !1,
          });
          t.bind(e.WebGLConstants.LINEAR, e.WebGLConstants.CLAMP_TO_EDGE), (this.mBrdfTex = t);
        }
      }
      loadCubeMap(t, i) {
        const s = t.getExtension('EXT_SRGB'),
          r = t.createTexture();
        let n = -1,
          o = e.WebGLConstants.TEXTURE0,
          a = 0;
        if (
          ('diffuse' === i
            ? ((o = e.WebGLConstants.TEXTURE1), (n = 1), (a = 1))
            : 'specular' === i
            ? ((o = e.WebGLConstants.TEXTURE2), (n = 2), (a = 10))
            : 'environment' === i && ((o = e.WebGLConstants.TEXTURE0), (n = 0), (a = 1)),
          -1 === n)
        )
          return null;
        t.activeTexture(o),
          t.bindTexture(e.WebGLConstants.TEXTURE_CUBE_MAP, r),
          t.texParameteri(
            e.WebGLConstants.TEXTURE_CUBE_MAP,
            e.WebGLConstants.TEXTURE_WRAP_S,
            e.WebGLConstants.CLAMP_TO_EDGE,
          ),
          t.texParameteri(
            e.WebGLConstants.TEXTURE_CUBE_MAP,
            e.WebGLConstants.TEXTURE_WRAP_T,
            e.WebGLConstants.CLAMP_TO_EDGE,
          ),
          a < 2
            ? (t.texParameteri(
                e.WebGLConstants.TEXTURE_CUBE_MAP,
                e.WebGLConstants.TEXTURE_MIN_FILTER,
                e.WebGLConstants.LINEAR,
              ),
              t.texParameteri(
                e.WebGLConstants.TEXTURE_CUBE_MAP,
                e.WebGLConstants.TEXTURE_MAG_FILTER,
                e.WebGLConstants.LINEAR,
              ))
            : (t.texParameteri(
                e.WebGLConstants.TEXTURE_CUBE_MAP,
                e.WebGLConstants.TEXTURE_MIN_FILTER,
                e.WebGLConstants.LINEAR_MIPMAP_LINEAR,
              ),
              t.texParameteri(
                e.WebGLConstants.TEXTURE_CUBE_MAP,
                e.WebGLConstants.TEXTURE_MAG_FILTER,
                e.WebGLConstants.LINEAR,
              ));
        const l = `${this.IBLUrl}/SkyBox0/${i}/${i}`;
        for (let i = 0; i < a; i++) {
          const n = [
            [`${l}_right_${i}.jpg`, e.WebGLConstants.TEXTURE_CUBE_MAP_POSITIVE_X],
            [`${l}_left_${i}.jpg`, e.WebGLConstants.TEXTURE_CUBE_MAP_NEGATIVE_X],
            [`${l}_top_${i}.jpg`, e.WebGLConstants.TEXTURE_CUBE_MAP_POSITIVE_Y],
            [`${l}_bottom_${i}.jpg`, e.WebGLConstants.TEXTURE_CUBE_MAP_NEGATIVE_Y],
            [`${l}_front_${i}.jpg`, e.WebGLConstants.TEXTURE_CUBE_MAP_POSITIVE_Z],
            [`${l}_back_${i}.jpg`, e.WebGLConstants.TEXTURE_CUBE_MAP_NEGATIVE_Z],
          ];
          for (let e = 0; e < n.length; e++) this.loadCubeImage(i, n[e][1], n[e][0], o, s, r, t);
        }
        return new Rh({ context: this.context, texture: r });
      }
      async loadCubeImage(t, i, s, r, n, o, a) {
        const l = await (() =>
          new Promise((t, i) =>
            e.getImage(this.map._transformRequest(s, e.ResourceType.Image), (e, s) => {
              e && i(e), t(s);
            }),
          ))();
        if (l.nodeName || (l.width && l.height))
          this.onLoadEnvironmentURLImage(r, n, o, i, l, t, a);
        else if (l) throw ((this.isLoaded = !1), new Error('load IBL image error'));
      }
      onLoadEnvironmentURLImage(t, i, s, r, n, o, a) {
        const l = i ? i.SRGB_EXT : e.WebGLConstants.RGBA;
        a.activeTexture(t),
          a.bindTexture(e.WebGLConstants.TEXTURE_CUBE_MAP, s),
          a.pixelStorei(e.WebGLConstants.UNPACK_FLIP_Y_WEBGL, !1),
          a.texImage2D(r, o, l, l, e.WebGLConstants.UNSIGNED_BYTE, n),
          (s[r] = !0);
      }
    }
    class uu extends e.Material {
      constructor(e) {
        super(e),
          (this.type = 'distanceMaterial'),
          (this.renderState = this.#O()),
          (this.dirty = !1),
          (this.bUniformCreated = !1);
      }
      update(e, t, i = {}) {
        super.update(e, t, i), this.#u(i.primitive, e), this.bUniformCreated || this.#W();
      }
      #u(t, i) {
        this.defines = {
          JOINT_MATRIX_CNT: e.defaultValue(t?._material?.defines?.JOINT_MATRIX_CNT, !1),
          INSTANCE_MATRIX: e.defaultValue(t?._material?.defines?.INSTANCE_MATRIX, !1),
          USE_MORPHTARGETS: e.defaultValue(t?._material?.defines?.USE_MORPHTARGETS, !1),
          LOG_DEPTH: e.defaultValue(i._logDepth, !1),
        };
      }
      #O() {
        return {
          cull: { enabled: !1 },
          depthTest: { enabled: !0, func: e.WebGLConstants.LESS },
          blending: e.renderStateEnum.disableBlending,
          stencilTest: {
            enabled: !1,
            frontFunction: e.WebGLConstants.ALWAYS,
            backFunction: e.WebGLConstants.ALWAYS,
            reference: 0,
            mask: 0,
            frontOperation: {
              fail: e.WebGLConstants.KEEP,
              zFail: e.WebGLConstants.KEEP,
              zPass: e.WebGLConstants.REPLACE,
            },
            backOperation: {
              fail: e.WebGLConstants.KEEP,
              zFail: e.WebGLConstants.KEEP,
              zPass: e.WebGLConstants.REPLACE,
            },
          },
        };
      }
      #W() {
        this.bUniformCreated = !0;
      }
      destroy() {
        return (
          (this.type = void 0),
          (this._renderState = void 0),
          (this.dirty = void 0),
          (this.bUniformCreated = void 0),
          (this._uniforms = void 0),
          (this._programConfiguration = void 0),
          this._shaderSource.destroy(),
          (this._shaderSource = void 0),
          (this.layer = void 0),
          (this._pickColor = void 0),
          (this._usePickColorTexture = void 0),
          (this._isOneDimensionBatchTexture = void 0),
          (this._pickTextureUniformsCallBack = void 0),
          e.destroyObject(this)
        );
      }
    }
    class du extends e.Pass {
      constructor(e) {
        super(e), (this.replaceMaterial = new uu({}));
      }
      update(e, t, i) {
        (e.frameState.overrideMaterial = this.replaceMaterial),
          super.update(e, t, i),
          (this.cameraStatusStore = null);
      }
      createFramebuffer({ width: e, height: t, context: i }) {
        return super.createFramebuffer({ width: e, height: t, context: i });
      }
      initSize(t, i) {
        (e.defined(this.width) && e.defined(this.height)) ||
          ((this.width = t), (this.height = i), (this.bufferSize = this.width * this.height * 4));
      }
      render(e) {
        const { painter: t } = e,
          { context: i, frameState: s } = t,
          r = t.frameState.framebuffer,
          { width: n, height: o } = t.getMaxFramebufferSize();
        this.initSize(Math.floor(n / 20), Math.floor(o / 20)),
          this.update(t, this.width, this.height),
          super.middleRender(t, i, s),
          (t.frameState.overrideMaterial = void 0),
          t.frameState.update({ framebuffer: r }),
          t.frameState.bindFramebuffer(i);
      }
      getDistance(t) {
        if (!this.height || !this.width) return Number.MAX_VALUE;
        const i = e.readPixel(
            {
              x: 0,
              y: this.height / e.window.devicePixelRatio,
              height: this.height,
              width: this.width,
            },
            t,
            this.framebuffer,
            this.height,
            e.WebGLConstants.UNSIGNED_BYTE,
            this.bufferSize,
          ),
          s = new e.Vector4(),
          r = new e.Vector4(1, 1 / 255, 1 / 65025, 1 / 16581375);
        let n = Number.MAX_VALUE;
        for (let e = 0; e < this.bufferSize; e += 4) {
          if (0 == i[e] && 0 == i[e + 1] && 0 == i[e + 2] && 0 == i[e + 3]) continue;
          s.set(i[e], i[e + 1], i[e + 2], i[e + 3]);
          const t = s.dot(r);
          n = Math.min(n, 64.25 * t);
        }
        return n <= 0 ? 0.01 : n;
      }
      readPixel(t, i) {
        const s = e.readPixel(t, i, this.framebuffer, this.height);
        return e.unpackDepth(s);
      }
    }
    class mu extends e.Pass {
      constructor(t) {
        super(t), (this.replaceMaterial = new e.NormalMaterial({}));
      }
      update(e, t, i) {
        (e.frameState.overrideMaterial = this.replaceMaterial),
          super.update(e, t, i),
          (this.cameraStatusStore = null);
      }
      createFramebuffer({ width: t, height: i, context: s }) {
        return new e.Framebuffer({
          context: s,
          width: t,
          height: i,
          colorTextures: [
            new e.Texture({
              width: t,
              height: i,
              context: s,
              pixelFormat: e.WebGLConstants.RGBA,
              pixelDatatype: e.PixelDatatype.UNSIGNED_BYTE,
            }),
          ],
          depthStencilRenderbuffer: new Bs({
            context: s,
            width: t,
            height: i,
            format: e.RenderbufferFormat.DEPTH_STENCIL,
          }),
        });
      }
      render(e) {
        const { painter: t } = e,
          { context: i, frameState: s } = t,
          r = t.frameState.framebuffer,
          { width: n, height: o } = t.getMaxFramebufferSize();
        this.update(t, n, o),
          super.middleRender(t, i, s),
          (t.frameState.overrideMaterial = void 0),
          t.frameState.update({ framebuffer: r }),
          t.frameState.bindFramebuffer(i);
      }
      readPixel(t, i) {
        const s = e.readPixel(t, i, this.framebuffer, this.height);
        return e.unpackDepth(s);
      }
    }
    class pu extends e.Pass {
      constructor(e) {
        super(e);
      }
      update(e, t, i) {
        e.frameState.passType = this.passType;
        const { context: s } = e;
        (this.width === t && this.height === i && this.framebuffer) ||
          (this.framebuffer && this.framebuffer.destroy(),
          (this.framebuffer = this.createFramebuffer({ width: t, height: i, context: s }))),
          e.frameState.update({ framebuffer: this.framebuffer }),
          e.frameState.bindFramebuffer(s),
          (this.width = t),
          (this.height = i);
      }
      createFramebuffer({ width: t, height: i, context: s }) {
        const r = new e.Sampler({
          minificationFilter: e.TextureMinificationFilter.NEAREST,
          magnificationFilter: e.TextureMagnificationFilter.NEAREST,
        });
        return new e.Framebuffer({
          context: s,
          width: t,
          height: i,
          colorTextures: [
            new e.Texture({ width: t, height: i, context: s, pixelFormat: e.WebGLConstants.RGBA }),
          ],
          depthStencilTexture: new e.Texture({
            context: s,
            width: t,
            height: i,
            minFilter: e.WebGLConstants.LINEAR,
            magFilter: e.WebGLConstants.LINEAR,
            pixelFormat: e.PixelFormat.DEPTH_STENCIL,
            pixelDatatype: e.PixelDatatype.UNSIGNED_INT_24_8,
            sampler: r,
            anisotropy: 1,
          }),
        });
      }
      render(t) {
        const { painter: i } = t,
          { context: s } = i,
          r = i.frameState.framebuffer,
          n = i.frameState.passType,
          { width: o, height: a } = i.getMaxFramebufferSize();
        this.update(i, o, a),
          e.RenderState.applyRenderState(
            s,
            e.RenderState.fromCache({ viewport: { x: 0, y: 0, width: o, height: a } }),
          ),
          s.clear({ color: e.Color.white, depth: 1, stencil: 0 }),
          i.renderGroup.executePaint({
            sourceCache: {},
            layer: i.style.backgroundDepthRenderLayer,
            frameState: i.frameState,
            coords: [],
          }),
          (i.frameState.passType = n),
          i.frameState.update({ framebuffer: r }),
          i.frameState.bindFramebuffer(s);
      }
      readPixel(t, i) {
        return e.readPixel(t, i, this.framebuffer, this.height, e.WebGLConstants.UNSIGNED_BYTE);
      }
    }
    class fu extends e.Material {
      constructor(t) {
        super(t),
          (this.type = 'depthMaterial'),
          (this.lightView = new e.Matrix4()),
          (this.lightPosition = new e.Vector3(0, 0, 0)),
          (this.lightDir = new e.Vector3(
            0.8190732591319829,
            -0.8293986987322569,
            0.3855001742951572,
          )),
          (this.lightUp = new e.Vector3(
            -0.06079590320587158,
            0.17691355105489492,
            0.982346910983324,
          )),
          (this.lightRight = new e.Vector3()),
          (this.renderState = this.createRenderState()),
          (this.updateMVPMatrix = (t, i, s) => {
            this._uniforms.set('u_ModelViewProjectionMatrix', () => {
              const r = t.transform.shadowCamera.vpMatrix.clone();
              return (
                (i.shadowVPMatrix = r.clone()), e.defined(s) ? r.multiplyRight(s.matrixWorld) : r
              );
            });
          });
      }
      createRenderState() {
        return { blending: { enabled: !1 } };
      }
    }
    class gu extends e.Pass {
      constructor(e) {
        super(e), (this.replaceMaterial = new fu({}));
      }
      update(e, t, i) {
        (e.frameState.overrideMaterial = this.replaceMaterial),
          super.update(e, t, i),
          (this.cameraStatusStore = null);
      }
      createFramebuffer({ width: e, height: t, context: i }) {
        return super.createFramebuffer({ width: e, height: t, context: i });
      }
      render(e) {
        const { painter: t } = e,
          { context: i, frameState: s } = t,
          r = t.frameState.framebuffer,
          { width: n, height: o } = t.getMaxFramebufferSize();
        this.update(t, n, o),
          super.middleRender(t, i, s),
          (t.frameState.overrideMaterial = void 0),
          t.frameState.update({ framebuffer: r }),
          t.frameState.bindFramebuffer(i);
      }
      readPixel(t, i) {
        const s = e.readPixel(t, i, this.framebuffer, this.height);
        return e.unpackDepth(s);
      }
    }
    class yu extends e.Pass {
      constructor(t) {
        super(t), (this.replaceMaterial = new e.PickColorMaterial({}));
      }
      update(e, t, i) {
        e.frameState.overrideMaterial = this.replaceMaterial;
        const { context: s } = e;
        (this.width === t && this.height === i && this.framebuffer && !this._SSAASamplesDirty) ||
          (this.framebuffer && this.framebuffer.destroy(),
          (this.framebuffer = this.createFramebuffer({ width: t, height: i, context: s })),
          (this._SSAASamplesDirty = !1)),
          e.frameState.update({ framebuffer: this.framebuffer }),
          e.frameState.bindFramebuffer(s),
          this.bindDepthTexture(e),
          (this.width = t),
          (this.height = i),
          (this.cameraStatusStore = null);
      }
      createFramebuffer({ width: t, height: i, context: s }) {
        return new e.Framebuffer({
          context: s,
          width: t * this.SSAASamples,
          height: i * this.SSAASamples,
          colorTextures: [
            new e.Texture({
              width: t * this.SSAASamples,
              height: i * this.SSAASamples,
              context: s,
              pixelFormat: e.WebGLConstants.RGBA,
            }),
          ],
        });
      }
      render(t) {
        const { painter: i, ignoreNonePickPrimitive: s } = t,
          { context: r, frameState: n } = i,
          o = i.frameState.framebuffer,
          { width: a, height: l } = i.getMaxFramebufferSize(),
          h = i.mainPass.SSAASamples;
        (this.SSAASamples = h),
          this.update(i, a, l),
          e.RenderState.applyRenderState(
            r,
            e.RenderState.fromCache({ viewport: { x: 0, y: 0, width: a * h, height: l * h } }),
          ),
          r.clear({ color: e.Color.transparent, stencil: 0 }),
          i.renderGroup.update({
            layers: i.style._layers,
            orders: i.style._order,
            painter: i,
            frameState: n,
            ignoreNonePickPrimitive: s,
          }),
          i.renderGroup.render({ layers: i.style._layers, painter: i, frameState: n }),
          (i.frameState.overrideMaterial = void 0),
          i.frameState.update({ framebuffer: o }),
          i.frameState.bindFramebuffer(r);
      }
      readPixel(t, i) {
        return e.readPixel(t, i, this.framebuffer, this.height, void 0, void 0, this.SSAASamples);
      }
      bindDepthTexture(t) {
        if (!t.mainPass.framebuffer) return;
        const { gl: i } = t.context,
          s = t.mainPass.framebuffer.depthStencilTexture;
        i.framebufferTexture2D(
          e.WebGLConstants.FRAMEBUFFER,
          e.WebGLConstants.DEPTH_STENCIL_ATTACHMENT,
          s._target,
          s.texture,
          0,
        );
      }
    }
    class Tu extends e.Pass {
      constructor(t) {
        (t.passType = e.RenderPassConsts.REAL_RENDER_PASS),
          super(t),
          (this.width = 32),
          (this.height = 32);
      }
      update(e, t, i) {
        this.framebuffer ||
          (this.framebuffer = this.#U({ width: t, height: i, context: e.context })),
          e.frameState.update({ framebuffer: this.framebuffer }),
          (this.cameraStatusStore = null);
      }
      #U({ width: e, height: t, context: i }) {
        return i.createFramebuffer(e, t);
      }
      render(t) {
        const { painter: i, skybox: s } = t,
          r = i.context,
          n = r.gl;
        if (s.ready) return;
        this.update(i, this.width, this.height);
        const o = i.frameState.framebuffer,
          a = i.frameState.passType;
        (i.frameState.passType = this.passType),
          i.frameState.bindFramebuffer(r),
          e.RenderState.applyRenderState(
            r,
            e.RenderState.fromCache({
              viewport: { x: 0, y: 0, width: this.width, height: this.height },
            }),
          ),
          r.clear({ color: e.Color.transparent, depth: 1, stencil: 0 });
        const l = new Rh({
          context: r,
          pixelFormat: e.WebGLConstants.RGBA,
          fboTextureParameter: { width: this.width, height: this.height },
        });
        for (let t = 0; t < 6; t++)
          n.framebufferTexture2D(
            n.FRAMEBUFFER,
            n.COLOR_ATTACHMENT0,
            e.WebGLConstants.TEXTURE_CUBE_MAP_POSITIVE_X + t,
            l.texture,
            0,
          ),
            s.primitiveToGenerateTexture._material.setMatrixByFaces(
              e.CONSTS.SOURCE.TEXTURE_CUBE_KEYS[t],
            ),
            i.renderGroup.executePaint({
              sourceCache: {},
              layer: { type: '3d-model', isHidden() {} },
              primitives: [s.primitiveToGenerateTexture],
              frameState: i.frameState,
            });
        s.updateSkyCubeTexture(l),
          e.RenderState.applyRenderState(
            r,
            e.RenderState.fromCache({ viewport: { x: 0, y: 0, width: i.width, height: i.height } }),
          ),
          (i.frameState.passType = a),
          i.frameState.update({ framebuffer: o }),
          i.frameState.bindFramebuffer(r);
      }
    }
    class xu {
      constructor(t, i, s) {
        (this.texture = t.createTexture()),
          (this._target = e.WebGLConstants.TEXTURE_CUBE_MAP),
          t.bindTexture(this._target, this.texture);
        for (let r = 0; r < 6; r++)
          t.texImage2D(
            e.WebGLConstants.TEXTURE_CUBE_MAP_POSITIVE_X + r,
            0,
            e.WebGLConstants.RGBA,
            i,
            s,
            0,
            e.WebGLConstants.RGBA,
            e.WebGLConstants.UNSIGNED_BYTE,
            null,
          );
        t.texParameteri(
          e.WebGLConstants.TEXTURE_CUBE_MAP,
          e.WebGLConstants.TEXTURE_MAG_FILTER,
          e.WebGLConstants.LINEAR,
        ),
          t.texParameteri(
            e.WebGLConstants.TEXTURE_CUBE_MAP,
            e.WebGLConstants.TEXTURE_MIN_FILTER,
            e.WebGLConstants.LINEAR,
          ),
          t.texParameteri(
            e.WebGLConstants.TEXTURE_CUBE_MAP,
            e.WebGLConstants.TEXTURE_WRAP_S,
            e.WebGLConstants.CLAMP_TO_EDGE,
          ),
          t.texParameteri(
            e.WebGLConstants.TEXTURE_CUBE_MAP,
            e.WebGLConstants.TEXTURE_WRAP_T,
            e.WebGLConstants.CLAMP_TO_EDGE,
          ),
          t.bindTexture(this._target, null);
      }
    }
    class vu extends e.Pass {
      constructor(t) {
        (t.passType = e.RenderPassConsts.REAL_RENDER_PASS),
          super(t),
          (this.width = t.textureSize ? t.textureSize : 512),
          (this.height = t.textureSize ? t.textureSize : 512);
      }
      update(e, t, i) {
        this.framebuffer ||
          (this.framebuffer = this.#U({ width: t, height: i, context: e.context })),
          e.frameState.update({ framebuffer: this.framebuffer }),
          (this.cameraStatusStore = null);
      }
      #U({ width: e, height: t, context: i }) {
        return i.createFramebuffer(e, t);
      }
      render(t) {
        const { painter: i, cubeMap: s, position: r, near: o, far: a } = t,
          { frameState: l, context: h } = i,
          { gl: c } = h,
          _ = i.frameState.camera,
          u = new n(90, 1, o, a);
        this.update(i, this.width, this.height),
          i.frameState.bindFramebuffer(h),
          e.RenderState.applyRenderState(
            h,
            e.RenderState.fromCache({
              viewport: { x: 0, y: 0, width: this.width, height: this.height },
            }),
          ),
          h.clear({ color: e.Color.transparent, depth: 1, stencil: 0 });
        const d = new xu(h.gl, this.width, this.height);
        this.renderCubeTexture(i, l, c, d, r, u), (i.frameState.camera = _), (s.cubeMap = d);
      }
      renderCubeTexture(t, i, s, r, n, o) {
        for (let a = 0; a < 6; a++) {
          s.clear(s.DEPTH_BUFFER_BIT),
            s.framebufferTexture2D(
              s.FRAMEBUFFER,
              s.COLOR_ATTACHMENT0,
              e.WebGLConstants.TEXTURE_CUBE_MAP_POSITIVE_X + a,
              r.texture,
              0,
            );
          const l = e.Transforms.cartographicToFixedFrame(n);
          0 == a
            ? o.setMatrix(
                l
                  .clone()
                  .rotateY(0.5 * -Math.PI)
                  .rotateZ(Math.PI),
              )
            : 1 == a
            ? o.setMatrix(
                l
                  .clone()
                  .rotateY(0.5 * Math.PI)
                  .rotateZ(Math.PI),
              )
            : 2 == a
            ? o.setMatrix(l.clone().rotateX(0.5 * Math.PI))
            : 3 == a
            ? o.setMatrix(l.clone().rotateX(0.5 * -Math.PI))
            : 4 == a
            ? o.setMatrix(l.clone().rotateY(-Math.PI).rotateZ(Math.PI))
            : 5 == a && o.setMatrix(l.clone().rotateZ(Math.PI)),
            (t.frameState.camera = o),
            t.renderGroup.update({
              layers: t.style._layers,
              orders: t.style._order,
              frameState: i,
            }),
            t.renderGroup.render({ layers: t.style._layers, frameState: i });
        }
      }
    }
    class bu extends e.Pass {
      constructor(e) {
        super(e);
      }
      update(e, t, i) {
        (e.frameState.passType = this.passType), super.update(e, t, i);
      }
      render(e) {
        const { painter: t, ignoreNonePickPrimitive: i } = e,
          { context: s, frameState: r } = t,
          n = t.frameState.framebuffer,
          o = t.frameState.passType,
          { width: a, height: l } = t.getMaxFramebufferSize();
        this.update(t, a, l),
          super.middleRender(t, s, r, i),
          (t.frameState.passType = o),
          t.frameState.update({ framebuffer: n }),
          t.frameState.bindFramebuffer(s);
      }
    }
    class wu {
      constructor(e, t) {
        (this.painter = e), (this.pass = t), this.#j();
      }
      #j() {
        (this.shaderSource = new e.ShaderSource({ type: 'screen' })),
          (this.geometry = new e.ViewportQuadGeometry(this.painter)),
          (this.uniforms = new Map([
            [
              'u_World',
              () =>
                new e.Vector2(
                  this.painter.context.drawingBufferWidth,
                  this.painter.context.drawingBufferHeight,
                ),
            ],
            [
              'u_ModelViewProjectionMatrix',
              () =>
                new e.Matrix4().ortho({
                  left: 0,
                  right: this.painter.context.drawingBufferWidth,
                  bottom: this.painter.context.drawingBufferHeight,
                  top: 0,
                  near: 0,
                  far: 1,
                }),
            ],
            [
              'u_BaseColorSampler',
              () => {
                let t;
                return (
                  (t = this.painter.usePostProcess
                    ? this.painter.postProcessStages.outputTexture
                    : this.pass.framebuffer.getColorTexture(0)),
                  t.bind(e.WebGLConstants.LINEAR, e.WebGLConstants.CLAMP_TO_EDGE),
                  t
                );
              },
            ],
            ['u_Resolution', () => new e.Vector2(this.painter.width, this.painter.height)],
          ])),
          (this.renderState = {
            depthTest: { enabled: !0, func: e.WebGLConstants.LESS },
            blending: {
              color: { red: 0, green: 0, blue: 0, alpha: 0 },
              enabled: !1,
              equationRgb: e.WebGLConstants.FUNC_ADD,
              equationAlpha: e.WebGLConstants.FUNC_ADD,
              functionSourceRgb: e.WebGLConstants.SRC_ALPHA,
              functionSourceAlpha: e.WebGLConstants.ONE,
              functionDestinationRgb: e.WebGLConstants.ONE_MINUS_SRC_ALPHA,
              functionDestinationAlpha: e.WebGLConstants.ONE_MINUS_SRC_ALPHA,
            },
            stencilTest: {
              enabled: !1,
              frontFunction: e.WebGLConstants.ALWAYS,
              backFunction: e.WebGLConstants.ALWAYS,
              reference: 0,
              mask: 0,
              frontOperation: {
                fail: e.WebGLConstants.KEEP,
                zFail: e.WebGLConstants.KEEP,
                zPass: e.WebGLConstants.REPLACE,
              },
              backOperation: {
                fail: e.WebGLConstants.KEEP,
                zFail: e.WebGLConstants.KEEP,
                zPass: e.WebGLConstants.REPLACE,
              },
            },
          });
      }
      resolveFramebufferToScreen() {
        this.painter.context.bindFramebuffer.set(null),
          this.painter.context.clear({
            color: this.painter._map._canvasTransparent ? e.Color.transparent : e.Color.black,
            depth: 1,
            stencil: 0,
          }),
          (this.shaderSource._defines.SSAASamples = this.painter._map.SSAASamples),
          this.painter.context.draw({
            painter: this.painter,
            framebuffer: null,
            layer: { id: 'resovescreeen' },
            geometry: this.geometry,
            material: {
              renderState: this.renderState,
              _uniforms: this.uniforms,
              _shaderSource: this.shaderSource,
            },
          });
      }
      destroy() {
        (this.uniforms = null),
          (this.painter = null),
          (this._segmentVector = null),
          (this.pass = null),
          (this.shaderSource = null);
      }
    }
    class Cu {
      constructor() {
        this.framebuffer = void 0;
      }
      initialize(t) {
        const i = t.context,
          s = t.width,
          r = t.height;
        this.framebuffer = new e.Framebuffer({
          context: i,
          width: s,
          height: r,
          colorTextures: [
            new e.Texture({ width: s, height: r, context: i, pixelFormat: e.WebGLConstants.RGBA }),
          ],
          depthStencilRenderbuffer: new Bs({
            context: i,
            width: s,
            height: r,
            format: e.RenderbufferFormat.DEPTH_STENCIL,
          }),
        });
      }
      update(t) {
        e.defined(this.framebuffer) || this.initialize(t);
      }
      destroy() {}
    }
    class Su extends e.Pass {
      constructor(t) {
        (t.passType = e.RenderPassConsts.REAL_RENDER_PASS), super(t);
      }
      update(e, t, i) {}
      static render(t) {
        const { painter: i, style: s } = t,
          { context: r } = i,
          { width: n, height: o } = i.getMaxFramebufferSize();
        if (!i || !s || !r) return;
        const a = i.frameState.framebuffer,
          l = i.frameState.passType;
        e.RenderState.applyRenderState(
          r,
          e.RenderState.fromCache({
            viewport: { x: 0, y: 0, width: n, height: o },
            blending: e.renderStateEnum.disableBlending,
          }),
        ),
          r.clear({
            color: i._map._canvasTransparent ? e.Color.transparent : e.Color.black,
            depth: 1,
            stencil: 0,
          });
        const h = s.primitivePreRenderCollection.getAll();
        h.length > 0 &&
          i.renderGroup.executePaint({
            sourceCache: {},
            layer: { type: '3d-model', isHidden() {} },
            primitives: h,
            frameState: i.frameState,
          }),
          (i.frameState.passType = l),
          i.frameState.update({ framebuffer: a }),
          i.frameState.bindFramebuffer(r);
      }
    }
    class Eu extends D_ {
      constructor(t) {
        super(t),
          (this._renderPrimitives = []),
          (this.plotterType = 'tile-debug'),
          (this.layerId = 'tile-debug');
        const i = this.#O();
        (this.redColorMaterial = new e.Material({ type: 'debug' })),
          this.redColorMaterial._uniforms.set('u_Color', () => new e.Vector4(1, 1, 0, 1)),
          (this.redColorMaterial.renderState = i),
          (this.blackColorMaterial = new e.Material({ type: 'debug' })),
          this.blackColorMaterial._uniforms.set('u_Color', () => new e.Vector4(0, 1, 0, 1)),
          (this.blackColorMaterial.renderState = i);
      }
      update(e, t, i, s, r) {
        this.parse(e, t, i, s, r), this.render(e, t, i, s, r);
      }
      render(e, t, i, s, r) {
        const n = B_[r.passType](this._renderPrimitives);
        for (let t = 0; t < n.length; t++) {
          const i = n[t];
          i.update(e, r), i.render(e, { id: this.layerId }, r);
        }
        this._renderPrimitives = [];
      }
      parse(e, t, i, s) {
        if (s.length > 0) {
          let t = this._drawCommands.get(this.layerId);
          t || (t = this._drawCommands.set(this.layerId, new lh()));
          const i = {};
          for (let r = 0; r < s.length; r++) {
            const n = s[r],
              o = e.debugTileCache.getTileByCoord(n);
            if (!o) continue;
            const a = o.matrix,
              l = t.get(n.key);
            l
              ? ((l.line._material.defines = i),
                this._renderPrimitives.push(l.line),
                (l.text._material.defines = i),
                this._renderPrimitives.push(l.text))
              : this.#q({
                  painter: e,
                  tile: o,
                  tileID: n,
                  modelMatrix: a,
                  currentLayerDrawCommands: t,
                });
          }
        }
      }
      #q(t) {
        const { painter: i, tile: s, tileID: r, modelMatrix: n, currentLayerDrawCommands: o } = t,
          a = this.#X(s, i.style.commonQuadtree.getBoundingRegionById(r.key)),
          l = new e.Primitive({
            modelMatrix: n,
            geometry: a.lineGeom,
            material: this.redColorMaterial,
          }),
          h = new e.Primitive({
            modelMatrix: n,
            geometry: a.textGeom,
            material: this.blackColorMaterial,
          });
        this._renderPrimitives.push(l, h), o.set(r.key, { line: l, text: h });
      }
      #Z(e) {}
      #O() {
        const t = e.RenderState.generateSimpleRenderState();
        return (
          (t.depthTest.enabled = !1),
          (t.blending.enabled = !1),
          (t.frontFace = e.WebGLConstants.CCW),
          (t.cull = { enabled: !1, face: e.WebGLConstants.BACK }),
          t
        );
      }
      #X(t, i) {
        return {
          lineGeom: new e.Geometry({
            vertBuffer: t.debugBuffer,
            segmentVector: e.SegmentVector.simpleSegment(0, 0, t.lineVerticesCount, 0),
            primitiveType: e.WebGLConstants.LINE_STRIP,
            tileBoundingRegion: i,
          }),
          textGeom: new e.Geometry({
            vertBuffer: t.debugBuffer,
            segmentVector: e.SegmentVector.simpleSegment(
              t.lineVerticesCount,
              0,
              t.textVerticesCount,
              0,
            ),
            primitiveType: e.WebGLConstants.LINES,
            tileBoundingRegion: i,
          }),
        };
      }
      removePrimitive(e) {
        const t = e.tileID.key,
          i = this._drawCommands.get(this.layerId);
        if (i) {
          const e = i.remove(t);
          e.line && e.line.destroy(), e.text && e.text.destroy();
        }
      }
      destroy() {
        (this.isPlotter = void 0),
          (this.plotterType = void 0),
          (this._drawCommands = void 0),
          (this._renderPrimitives = void 0);
      }
    }
    class Pu {
      constructor(t) {
        (t = t || {}),
          (this.type = 'scene-object'),
          (this.id = `skybox-${e.uniqueId()}`),
          (this.isSceneObject = !0),
          (this._ready = !1),
          (this.initialized = !1),
          (this.cubeMap = void 0),
          this.init(t.painter);
      }
      init(t) {
        const { context: i } = t;
        (this.geometry = new Ah({ context: i })),
          (this._cubeMapRenderingMaterial = new Oh({ type: 'skyboxCapture' })),
          (this.primitiveToGenerateTexture = new e.Primitive({
            material: this._cubeMapRenderingMaterial,
            geometry: this.geometry,
            allowPick: !1,
          }));
      }
      getPrimitiveForPass() {
        return this.primitiveToGenerateTexture;
      }
      updateSkyCubeTexture(e) {
        (this._skyMaterial._fboTextureCube = e), (this._ready = !0);
      }
      async _requestBoxImages(t, i) {
        const s = e.CONSTS.SOURCE.TEXTURE_CUBE_KEYS,
          r = [];
        for (let n = 0; n < 6; n++) {
          const o = new Promise((r, o) => {
            e.getImage(t._map._transformRequest(i[s[n]], e.ResourceType.Image), (e, t) => {
              e && o(e), r(t);
            });
          });
          r.push(o);
        }
        const n = await Promise.all(r),
          o = {};
        for (let e = 0; e < s.length; e++) o[s[e]] = n[e];
        return this._createTexture(t, o);
      }
      async _requestSingleImage(t, i) {
        const s = new Promise((s, r) => {
            e.getImage(t._map._transformRequest(i, e.ResourceType.Image), (e, t) => {
              e && r(e), s(t);
            });
          }),
          r = await s;
        return this._createTexture(t, r);
      }
      async _createTexture(t, i) {
        const s = new Rh({ context: t.context, images: i, pixelFormat: e.WebGLConstants.RGBA });
        return s.bind(e.WebGLConstants.LINEAR, e.WebGLConstants.CLAMP_TO_EDGE), s;
      }
      async _prepareTextures(e) {
        this.starrySkyTextureUrls &&
          (this._skyMaterial.starrySkyTexture = await this._requestBoxImages(
            e,
            this.starrySkyTextureUrls,
          )),
          this.dayTextureUrls &&
            (this._skyMaterial.dayTexture = await this._requestBoxImages(e, this.dayTextureUrls));
      }
      prepare(e) {
        e.shaderProgramManager.setGlobalMacroDefinition({ SKYBOX_CUBE_MAP_G: this.isCubeMap }),
          (this._ready = !0);
      }
      get ready() {
        return this._ready;
      }
      set ready(e) {
        this._ready = e;
      }
      onAdd(e) {
        this.init({ painter: e.painter });
      }
      loaded() {
        return this._ready;
      }
      destroy() {
        this.primitive.destroy(), this.primitiveToGenerateTexture.destroy();
      }
      collect() {
        return this._ready ? [this.primitive] : [];
      }
    }
    class Mu extends bs {
      constructor() {
        super(new n(90, 1, 0.5, 500)),
          (this._frameExtents = new e.Vector2(4, 2)),
          (this._viewportCount = 6),
          (this._viewports = [
            new e.Vector4(2, 1, 1, 1),
            new e.Vector4(0, 1, 1, 1),
            new e.Vector4(3, 1, 1, 1),
            new e.Vector4(1, 1, 1, 1),
            new e.Vector4(3, 0, 1, 1),
            new e.Vector4(1, 0, 1, 1),
          ]),
          (this._cubeDirections = [
            new e.Vector3(1, 0, 0),
            new e.Vector3(-1, 0, 0),
            new e.Vector3(0, 0, 1),
            new e.Vector3(0, 0, -1),
            new e.Vector3(0, 1, 0),
            new e.Vector3(0, -1, 0),
          ]),
          (this._cubeUps = [
            new e.Vector3(0, 1, 0),
            new e.Vector3(0, 1, 0),
            new e.Vector3(0, 1, 0),
            new e.Vector3(0, 1, 0),
            new e.Vector3(0, 0, 1),
            new e.Vector3(0, 0, -1),
          ]);
      }
      updateMatrices(e, t, i) {
        const s = this.camera,
          r = this.matrix,
          n = this._lightPositionWorld,
          o = this._lookTarget;
        let a = this._projScreenMatrix;
        n.setFromMatrixPosition(e.matrixWorld),
          s.position.copy(n),
          o.copy(s.position),
          o.add(this._cubeDirections[i]),
          s.up.copy(this._cubeUps[i]),
          s.lookAt(o),
          s.updateMatrixWorld(),
          r.makeTranslation(-n.x, -n.y, -n.z),
          (a = s.projectionMatrix.clone().multiplyRight(s.matrixWorldInverse)),
          this._frustum.setFromMatrix(a);
      }
    }
    class Au extends vs {
      constructor(e, t) {
        super(e, t), (this.type = 'PointLight'), (this.isPointLight = !0), (this.shadow = new Mu());
      }
      setPosition(t) {
        this.position = e.Vector3.unpack(t);
      }
      get power() {
        return 4 * this.intensity * Math.PI;
      }
      set power(e) {
        this.intensity = e / (4 * Math.PI);
      }
      serialize() {
        return {
          color: e.Vector3.pack(this.color, new Array(3)),
          intensity: this.intensity,
          position: e.Vector3.pack(this.position, new Array(3)),
          distane: this.distane,
          decay: this.decay,
          type: this.type,
        };
      }
    }
    class Ru extends e.Material {
      constructor(t) {
        (t.type = 'mirrorMaterial'),
          super(t),
          (this.renderState = this.#O()),
          (this._reflectNear = e.defaultValue(t.reflectNear, 1)),
          (this._reflectFar = e.defaultValue(t.reflectFar, 1e3));
      }
      enableSSR() {
        this._enableSSR = !0;
      }
      disableSSR() {
        this._enableSSR = !1;
      }
      update(e, t, i = {}) {
        super.update(e, t, i),
          this._uniforms.set('u_EnvMap', () => {
            if (null != e.cubeMapCollection[this.id]) return e.cubeMapCollection[this.id].cubeMap;
          });
      }
      createRenderState() {
        const t = {};
        return (
          (t.depthTest = e.renderStateEnum.disableDepthTest),
          (t.depthMask = e.renderStateEnum.disableDepthMask),
          (t.stencilTest = e.renderStateEnum.disableStencilTest),
          t
        );
      }
      #O() {
        const t = e.Material.getDefaultRenderState();
        return (t.cull.enabled = !0), (t.polygonOffset = { enabled: !0, factor: 1, units: 1 }), t;
      }
      set reflectNear(e) {
        this._reflectNear = e;
      }
      get reflectNear() {
        return this._reflectNear;
      }
      set reflectFar(e) {
        this._reflectNear = e;
      }
      get reflectFar() {
        return this._reflectFar;
      }
      serialize() {
        return { reflectFar: this._reflectFar, reflectNear: this._reflectNear };
      }
      destroy() {}
    }
    class Iu extends vu {
      constructor(t) {
        super(t),
          (this.replaceMaterial = new e.DepthMaterial({})),
          (this.replaceMaterial.defines.DEPTH_DISTANCE = !0);
      }
      update(e, t, i) {
        (e.frameState.overrideMaterial = this.replaceMaterial), super.update(e, t, i);
      }
      render(e) {
        super.render(e), (e.painter.frameState.overrideMaterial = null);
      }
    }
    const Ou = new e.ProgramConfiguration();
    class Lu {
      constructor(t, i) {
        (this.textureResourceManager = new cu()),
          (this.context = new mc(t, this)),
          (this.transform = i.transform),
          (this.transform.shadowCamera._painter = this),
          this.setup(),
          (this._logDepth = i._logDepth),
          (this.context._logDepth = this._logDepth),
          (this.shadowOff = e.CONSTS.EFFECTS.SHADOW_OFFSET),
          (this._map = i),
          (this.emptyTileTextureCanvas = null),
          (this.nextStencilID = 1),
          (this.shaderProgramManager = new L_({ context: this.context })),
          (this.backgroundPlotter = new nu({})),
          (this.fillPlotter = new k_({})),
          (this.extrusionPlotter = new q_({})),
          (this.tileClippingMask = new G_()),
          (this.symbolPlotter = new j_({})),
          (this.modelPlotter = new Y_({})),
          (this.linePlotter = new Q_({})),
          (this.debugBoundingBoxPlotter = new K_({})),
          (this.rasterPlotter = new J_({})),
          (this.imagePlotter = new su({})),
          (this.circlePlotter = new ru({})),
          (this.heatmapPlotter = new hu({})),
          (this.debugTilePlotter = new Eu({})),
          (this.plotterMap = {
            [e.VectorLayerType.SYMBOL]: this.symbolPlotter,
            [e.VectorLayerType.SYMTRACKING]: this.symbolPlotter,
            [e.VectorLayerType.LINE]: this.linePlotter,
            [e.VectorLayerType.SPRITE]: this.linePlotter,
            [e.VectorLayerType.TRACKING]: this.linePlotter,
            [e.VectorLayerType.DYNAMIC_LINE]: this.linePlotter,
            [e.VectorLayerType.FILL]: this.fillPlotter,
            [e.VectorLayerType.RASTER]: this.rasterPlotter,
            [e.VectorLayerType.IMAGE]: this.imagePlotter,
            [e.VectorLayerType.MODEL]: this.modelPlotter,
            [e.VectorLayerType.EXTRUSION]: this.extrusionPlotter,
            [e.VectorLayerType.HISTOGRAM]: this.extrusionPlotter,
            [e.VectorLayerType.CIRCLE]: this.circlePlotter,
            [e.VectorLayerType.BACKGROUND]: this.backgroundPlotter,
            [e.VectorLayerType.DEBUG_TILE]: this.debugTilePlotter,
            [e.VectorLayerType.HEATMAP]: this.heatmapPlotter,
          }),
          (this.renderGroup = new W_({ layers: {}, orders: [], painter: this })),
          (this.backgroundPass = new pu({ passType: e.RenderPassConsts.PICK_PASS })),
          (this.distancePass = new du({
            context: this.context,
            passType: e.RenderPassConsts.PICK_PASS,
          })),
          (this.depthPass = new e.DepthPass({
            context: this.context,
            passType: e.RenderPassConsts.PICK_PASS,
          })),
          (this.normalPass = new mu({
            context: this.context,
            passType: e.RenderPassConsts.PICK_PASS,
          })),
          (this.shadowPass = new gu({
            context: this.context,
            passType: e.RenderPassConsts.PICK_PASS,
          })),
          (this.mainPass = new bu({ passType: e.RenderPassConsts.REAL_RENDER_PASS })),
          (this.ssrPass = new bu({ passType: e.RenderPassConsts.REAL_RENDER_PASS })),
          (this.colorPass = new yu({
            context: this.context,
            passType: e.RenderPassConsts.PICK_COLOR_PASS,
          })),
          (this.frameState = new Vs()),
          (this.resolveFramebuffer = new wu(this, this.mainPass)),
          (this.postProcessStages = new $c()),
          (this.usePostProcess = !1),
          (this.usePostProcessSelected = !1),
          (this.postProcessFramebuffer = new Cu()),
          (this.shadowOptions = { EPSILON: 0.005, MapSizeScale: 0.1 }),
          (this.cubeMapCollection = {}),
          (this.cubeMapRenderPassCollection = {});
      }
      setShadowOptions(e, t) {
        this.shadowOptions[e] = t;
      }
      get iBLTextures() {
        return (
          this._iBLTextures ||
            (this._iBLTextures = new _u({ context: this.context, savedMap: this._map })),
          this._iBLTextures
        );
      }
      get getAllPlotter() {
        return [
          this.symbolPlotter,
          this.fillPlotter,
          this.modelPlotter,
          this.debugBoundingBoxPlotter,
          this.linePlotter,
          this.rasterPlotter,
          this.imagePlotter,
          this.circlePlotter,
          this.heatmapPlotter,
          this.extrusionPlotter,
          this.backgroundPlotter,
          this.debugTilePlotter,
        ];
      }
      getPlotterByKey(e) {
        return this.plotterMap[e];
      }
      get projection() {
        return this._projection;
      }
      set projection(t) {
        (t !== e.ProjectionType.MERCATOR && t !== e.ProjectionType.LATLON) ||
          (this._projection = t);
      }
      getMaxFramebufferSize() {
        let t = this.width,
          i = this.height;
        const s = Math.min(
            e.ContextLimits.maximumViewportWidth,
            e.ContextLimits.maximumRenderbufferSize,
          ),
          r = Math.min(
            e.ContextLimits.maximumViewportHeight,
            e.ContextLimits.maximumRenderbufferSize,
          );
        return (
          (this.width > s || this.height > r) &&
            (this.width / s > this.height / r
              ? ((t = s), (i = t / (this.width / this.height)))
              : ((i = r), (t = (this.width / this.height) * i))),
          { width: t, height: i }
        );
      }
      resize(t, i) {
        if (
          ((this.width = t * e.exported.devicePixelRatio),
          (this.height = i * e.exported.devicePixelRatio),
          this.context.viewport.set({ x: 0, y: 0, width: this.width, height: this.height }),
          this.style)
        )
          for (const e of this.style._order) this.style._layers[e].resize();
        this.heatmapPlotter.resize();
      }
      getPickRay(e) {
        return this.frameState.camera.getPickRay(e, this._map._canvas);
      }
      getDistance() {
        return (
          this.distancePass.render({ painter: this }), this.distancePass.getDistance(this.context)
        );
      }
      getPositionByGPUPick(t, i = this.depthPass) {
        if (!this._map.unproject(t)) return null;
        const s = this.context,
          r = t,
          n = new e.Vector2(
            r.x * (s.drawingBufferWidth / this._map._canvas.clientWidth),
            r.y * (s.drawingBufferHeight / this._map._canvas.clientHeight),
          );
        n.y = s.drawingBufferHeight - n.y;
        const o = i.readPixel(r, s),
          a = new e.Vector4();
        (a.x = ((n.x - s._viewport.current.x) / s._viewport.current.width) * 2 - 1),
          (a.y = ((n.y - s._viewport.current.y) / s._viewport.current.height) * 2 - 1),
          (a.z = 2 * o - 1),
          (a.w = 1);
        let l = this.frameState.camera?.getVPMatrix().invert();
        l || (l = new e.Matrix4());
        const h = new e.Vector4();
        e.Matrix4.multiplyByVector(l, a, h);
        const c = 1 / h.w,
          _ = new e.Vector3();
        return (
          e.Vector3.multiplyByScalar(h, c, _),
          new e.Vector3(e.Transforms.cartesian3ToCartographic(_))
        );
      }
      getFeatureByGPUPick(t) {
        if (!this._map.unproject(t)) return null;
        const i = t;
        this.mainPass.render({ painter: this, ignoreNonePickPrimitive: !0 }),
          this.colorPass.render({ painter: this, ignoreNonePickPrimitive: !0 });
        const s = this.colorPass.readPixel(i, this.context);
        return this.context.getObjectByPickColor(
          new e.Color(
            e.Color.byteToFloat(s[0]),
            e.Color.byteToFloat(s[1]),
            e.Color.byteToFloat(s[2]),
            e.Color.byteToFloat(s[3]),
          ),
        );
      }
      getFeatureByPickColor(t) {
        const i = new e.Color(
          e.Color.byteToFloat(t[0]),
          e.Color.byteToFloat(t[1]),
          e.Color.byteToFloat(t[2]),
          e.Color.byteToFloat(t[3]),
        );
        return this.context.getObjectByPickColor(i);
      }
      getClipPointsOnScreen(t) {
        t = e.defined(t) ? t : 25;
        const i = this.width / 2,
          s = this.height / 2;
        return {
          leftTop: { x: i - t, y: s - t, z: 0 },
          rightTop: { x: i + t, y: s - t, z: 0 },
          leftBottom: { x: i - t, y: s + t, z: 0 },
          rightBottom: { x: i + t, y: s + t, z: 0 },
        };
      }
      getClipPointsPosition(t) {
        t = e.defined(t) ? t : 25;
        const i = this.getClipPointsOnScreen(t),
          s = {};
        for (const e in i)
          try {
            s[e] = this.getPositionByGPUPick(i[e]);
          } catch (e) {
            return;
          }
        return s;
      }
      queryPixelColor(t) {
        const i = e.readPixel(t[0], this.context, null, this.height),
          s = `rgba(${i[0]}, ${i[1]}, ${i[2]}, ${+parseFloat(i[3] / 255).toFixed(2)})`;
        return {
          rgba: s,
          hex: e.rgba2Hex(s),
          color: new e.Color(i[0] / 255, i[1] / 255, i[2] / 255, i[3] / 255),
        };
      }
      setup() {}
      clearStencil() {
        this.context.clear({ stencil: 0 });
      }
      #$(t, i) {
        (this.tileClippingMask.nextStencilID = 1),
          (this.style = t),
          (this.options = i),
          (this.lineAtlas = t.lineAtlas),
          (this.imageManager = t.imageManager),
          this.imageManager.beginFrame(),
          (this.glyphManager = t.glyphManager),
          (this.symbolFadeChange = t.placement.symbolFadeChange(e.exported.now()));
        for (const e in t.sourceCaches) {
          const t = this.style.sourceCaches[e];
          t.used && t.prepare(this.context);
        }
        t.backgroundSourceCache.prepare(this.context),
          this.frameState.update({
            camera: this.transform.activeCamera,
            shadowCamera: this.transform.shadowCamera,
          });
      }
      #K() {
        (this.objectsNeedCubeMap = []),
          this.frameState._lights.length > 0 &&
            this.frameState._shadows &&
            this.frameState._lights.forEach((e) => {
              e instanceof Au && this.objectsNeedCubeMap.push(e);
            });
        const e = this.frameState.camera.frustumCrate.cullingVolume;
        this.style.primitiveCollection.getOpaquePrimitives(e).forEach((e) => {
          e._material instanceof Ru && this.objectsNeedCubeMap.push(e);
        }),
          this.style.primitiveCollection.getTranslucentPrimitives(e).forEach((e) => {
            e._material instanceof Ru && ((e._material.id = e.id), this.objectsNeedCubeMap.push(e));
          });
      }
      #Y() {
        this.objectsNeedCubeMap.forEach((e) => {
          null == this.cubeMapCollection[e.id] &&
            (this.cubeMapCollection[e.id] = new Pu({ painter: this }));
        });
      }
      #Q() {
        this.#K(),
          this.#Y(),
          this.objectsNeedCubeMap.forEach((t) => {
            const i = e.Transforms.cartesian3ToCartographic(t.position);
            let s;
            t instanceof Au
              ? (null == this.cubeMapRenderPassCollection[t.id]
                  ? ((s = new Iu({
                      passType: e.RenderPassConsts.CUBE_MAP_RENDER,
                      textureSize: t.textureSize,
                    })),
                    (this.cubeMapRenderPassCollection[t.id] = s))
                  : (s = this.cubeMapRenderPassCollection[t.id]),
                t.shadowRepaint &&
                  (s.render({
                    painter: this,
                    cubeMap: this.cubeMapCollection[t.id],
                    position: new e.Vector3(i[0], i[1], i[2]),
                    near: t.shadowNear,
                    far: t.shadowFar,
                  }),
                  (t.shadowRepaint = !1)))
              : (null == this.cubeMapRenderPassCollection[t.id]
                  ? ((s = new vu({ passType: e.RenderPassConsts.CUBE_MAP_RENDER })),
                    (this.cubeMapRenderPassCollection[t.id] = s))
                  : (s = this.cubeMapRenderPassCollection[t.id]),
                s.render({
                  painter: this,
                  cubeMap: this.cubeMapCollection[t.id],
                  position: new e.Vector3(i[0], i[1], i[2]),
                  near: t._material.reflectNear,
                  far: t._material.reflectFar,
                }));
          });
      }
      #J() {
        const t = this.renderGroup.getNearFarPlane(this.style, this.transform, this._nearDetection);
        this.transform.updateNearFarPlane(t),
          Su.render({ painter: this, style: this.style }),
          !this.style.isSkyboxReady &&
            this.style.skybox &&
            (this.frameState.update({ camera: this.transform.activeCamera }),
            new Tu({ passType: e.RenderPassConsts.CUBE_MAP_RENDER_FOR_SKYBOX }).render({
              painter: this,
              skybox: this.style.skybox,
            })),
          this._shadows && this.shadowPass.render({ painter: this }),
          this.#Q(),
          this.style.scenePointPrimitiveCollection.update(this),
          this._map.videoManager.update(this),
          this._map.analysis.cutFillCollection.update(this),
          this._map.analysis.highlightCollection.update(this),
          this._map.analysis.sightlineCollection.update(this),
          this._map.analysis.viewDomeCollection.update(this),
          this._map.analysis.viewshed3DCollection.update(this),
          this.backgroundPass.render({ painter: this });
      }
      #ee() {
        this.mainPass.render({ painter: this }),
          this.depthPass.render({ painter: this }),
          this._enableNormal && this.normalPass.render({ painter: this });
      }
      #te() {
        for (let e = 0; e < this._map.analysis.viewshed3DCollection.length; e++)
          this._map.analysis.viewshed3DCollection.getByIndex(e).render(this);
        for (let e = 0; e < this._map.analysis.viewDomeCollection.length; e++)
          this._map.analysis.viewDomeCollection.getByIndex(e).render(this);
        for (let e = 0; e < this._map.analysis.highlightCollection.length; e++)
          this._map.analysis.highlightCollection.getByIndex(e).render(this);
        for (let e = 0; e < this._map.analysis.cutFillCollection.length; e++)
          this._map.analysis.cutFillCollection.getByIndex(e).render(this);
        for (let e = 0; e < this._map.analysis.sightlineCollection.length; e++)
          this._map.analysis.sightlineCollection.getByIndex(e).render(this);
        const e = this.postProcessStages;
        let t = (this.usePostProcess = e.length > 0 || e.fxaa.enabled || e.bloom.enabled);
        if (
          ((this.usePostProcessSelected = !1),
          t &&
            (e.update(this.context, !1),
            e.clear(this.context),
            (t = this.usePostProcess = e.ready),
            (this.usePostProcessSelected = t && e.hasSelected)),
          t)
        ) {
          const e = this.postProcessStages,
            t = this.mainPass.framebuffer.getColorTexture(0),
            i = this.colorPass.framebuffer?.getColorTexture(0),
            s = this.depthPass.framebuffer.getColorTexture(0);
          e.execute(this.context, t, s, i), e.copy(this.context, this.mainPass.framebuffer);
        }
        this.enableSSR
          ? (this.#ie(), (this.resolveFramebuffer.pass = this.ssrPass))
          : 'main' == this._resolvePass
          ? (this.resolveFramebuffer.pass = this.mainPass)
          : 'normal' == this._resolvePass
          ? (this.resolveFramebuffer.pass = this.normalPass)
          : 'depth' == this._resolvePass
          ? (this.resolveFramebuffer.pass = this.depthPass)
          : 'shadow' == this._resolvePass && (this.resolveFramebuffer.pass = this.shadowPass),
          this.resolveFramebuffer.resolveFramebufferToScreen();
      }
      #ie() {
        (this.depthTexture = this.depthPass.framebuffer.getColorTexture(0)),
          (this.normalTexture = this.normalPass.framebuffer.getColorTexture(0)),
          (this.colorTexture = this.mainPass.framebuffer.getColorTexture(0)),
          (this.normalTexture.sampler = {
            wrapS: e.WebGLConstants.REPEAT,
            wrapT: e.WebGLConstants.REPEAT,
          }),
          (this.depthTexture.sampler = {
            wrapS: e.WebGLConstants.REPEAT,
            wrapT: e.WebGLConstants.REPEAT,
          }),
          (this.colorTexture.sampler = {
            wrapS: e.WebGLConstants.REPEAT,
            wrapT: e.WebGLConstants.REPEAT,
          }),
          (this.SSRState = !0),
          this.ssrPass.render({ painter: this }),
          (this.SSRState = !1);
      }
      #se() {}
      #re(e, t) {
        this.#$(e, t), this.#J(), this.#ee(), this.#te(), this.#se();
      }
      render(e, t) {
        this.#re(e, t), this._debugRender();
      }
      _debugRender() {
        if (this.options.showTileBoundaries) {
          this.debugTileCache ||
            (this.debugTileCache = new t_({
              projection: this._map.projection,
              context: this.context,
            }));
          const e = Object.keys(this.style.sourceCaches);
          this.frameState.framebuffer = null;
          for (let t = 0; t < e.length; t++) {
            const i = this.style.sourceCaches[e[t]],
              s = i.getVisibleCoordinates();
            if (i && !(i instanceof fh) && s.length > 0) {
              this.debugTilePlotter.update(this, i, null, s, this.frameState);
              break;
            }
          }
        } else this.debugTileCache && (this.debugTileCache.release(), (this.debugTileCache = null));
      }
      useProgram(e, t) {
        const i = this.shaderProgramManager.getProgramByGLSLMacroDefinition(e, t || Ou);
        return this.context.program.set(i.program), (this.context._Program = i), i;
      }
      setBaseState() {
        const t = e.RenderState.fromCache({
          viewport: { x: 0, y: 0, width: this.width, height: this.height },
        });
        e.RenderState.applyRenderState(this.context, t);
      }
      setShadows(e) {
        this._shadows = e;
      }
      setNearDetection(e) {
        this._nearDetection = e;
      }
      setNormalPass(e) {
        (this._enableNormal = e), (this.context._enableNormal = e);
      }
      setResolvePass(e) {
        this._resolvePass = e;
      }
      destroy() {
        this.resolveFramebuffer.destroy();
      }
    }
    class Du {
      constructor() {
        e.bindAll(['_onHashChange', '_updateHash'], this),
          (this._updateHash = (function (e, t) {
            let i = !1,
              s = 0;
            const r = () => {
              (s = 0), i && (e(), (s = setTimeout(r, 300)), (i = !1));
            };
            return () => ((i = !0), s || r(), s);
          })(this._updateHashUnthrottled.bind(this)));
      }
      addTo(t) {
        return (
          (this._map = t),
          e.window.addEventListener('hashchange', this._onHashChange, !1),
          this._map.on('moveend', this._updateHash),
          this
        );
      }
      remove() {
        return (
          e.window.removeEventListener('hashchange', this._onHashChange, !1),
          this._map.off('moveend', this._updateHash),
          clearTimeout(this._updateHash()),
          delete this._map,
          this
        );
      }
      getHashString(e) {
        const t = this._map.getCenter(),
          i = Math.round(100 * this._map.getZoom()) / 100,
          s = Math.ceil((i * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10),
          r = Math.pow(10, s),
          n = Math.round(t.lng * r) / r,
          o = Math.round(t.lat * r) / r,
          a = this._map.getBearing(),
          l = this._map.getPitch();
        let h = '';
        return (
          (h += e ? `#/${n}/${o}/${i}` : `#${i}/${o}/${n}`),
          (a || l) && (h += '/' + Math.round(10 * a) / 10),
          l && (h += `/${Math.round(l)}`),
          h
        );
      }
      _onHashChange() {
        const t = e.window.location.hash.replace('#', '').split('/');
        return (
          t.length >= 3 &&
          (this._map.jumpTo({
            center: [+t[2], +t[1]],
            zoom: +t[0],
            bearing: +(t[3] || 0),
            pitch: +(t[4] || 0),
          }),
          !0)
        );
      }
      _updateHashUnthrottled() {
        const t = this.getHashString();
        e.window.history.replaceState(e.window.history.state, '', t);
      }
    }
    const Bu = { linearity: 0.3, easing: e.bezier(0, 0, 0.3, 1) },
      Vu = e.extend({ deceleration: 2500, maxSpeed: 1400 }, Bu),
      Nu = e.extend({ deceleration: 20, maxSpeed: 1400 }, Bu),
      ku = e.extend({ deceleration: 1e3, maxSpeed: 360 }, Bu),
      Fu = e.extend({ deceleration: 1e3, maxSpeed: 90 }, Bu);
    class Gu {
      constructor(e) {
        (this._map = e), this.clear();
      }
      clear() {
        this._inertiaBuffer = [];
      }
      record(t) {
        this._drainInertiaBuffer(),
          this._inertiaBuffer.push({ time: e.exported.now(), settings: t });
      }
      _drainInertiaBuffer() {
        const t = this._inertiaBuffer,
          i = e.exported.now();
        for (; t.length > 0 && i - t[0].time > 160; ) t.shift();
      }
      _onMoveEnd(t) {
        if ((this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)) return;
        const i = {
          zoom: 0,
          bearing: 0,
          pitch: 0,
          pan: new e.pointGeometry3d(0, 0),
          pinchAround: void 0,
          around: void 0,
        };
        for (const { settings: e } of this._inertiaBuffer)
          (i.zoom += e.zoomDelta || 0),
            (i.bearing += e.bearingDelta || 0),
            (i.pitch += e.pitchDelta || 0),
            e.panDelta && i.pan._add(e.panDelta),
            e.around && (i.around = e.around),
            e.pinchAround && (i.pinchAround = e.pinchAround);
        const s =
            this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time,
          r = {};
        if (i.pan.mag()) {
          const n = zu(i.pan.mag(), s, e.extend({}, Vu, t || {}));
          (r.offset = i.pan.mult(n.amount / i.pan.mag())),
            (r.center = this._map.transform.center),
            Uu(r, n);
        }
        if (i.zoom) {
          const e = zu(i.zoom, s, Nu);
          (r.zoom = this._map.transform.zoom + e.amount), Uu(r, e);
        }
        let n;
        if (
          (i.bearing &&
            ((n = zu(i.bearing, s, ku)),
            (r.bearing = this._map.transform.bearing + e.clamp(n.amount, -179, 179)),
            Uu(r, n)),
          i.pitch)
        ) {
          const e = zu(i.pitch, s, Fu);
          (r.pitch = this._map.transform.pitch + e.amount), Uu(r, e);
        }
        if (r.zoom || r.bearing) {
          const e = void 0 === i.pinchAround ? i.around : i.pinchAround;
          r.around = e ? this._map.unproject(e) : this._map.getCenter();
        }
        return this.clear(), e.extend(r, { noMoveStart: !0 });
      }
    }
    function Uu(e, t) {
      (!e.duration || e.duration < t.duration) &&
        ((e.duration = t.duration), (e.easing = t.easing));
    }
    function zu(t, i, s) {
      const { maxSpeed: r, linearity: n, deceleration: o } = s,
        a = e.clamp((t * n) / (i / 1e3), -r, r),
        l = Math.abs(a) / (o * n);
      return { easing: s.easing, duration: 1e3 * l, amount: a * (l / 2) };
    }
    class Hu extends e.Event {
      preventDefault() {
        this._defaultPrevented = !0;
      }
      get defaultPrevented() {
        return this._defaultPrevented;
      }
      constructor(t, i, s, r = {}) {
        const n = Ur.mousePos(i.getCanvasContainer(), s),
          o = i.unproject(n);
        super(t, e.extend({ point: n, lngLat: o, originalEvent: s }, r)),
          (this._defaultPrevented = !1),
          (this.target = i);
      }
    }
    class Wu extends e.Event {
      preventDefault() {
        this._defaultPrevented = !0;
      }
      get defaultPrevented() {
        return this._defaultPrevented;
      }
      constructor(t, i, s) {
        const r = 'touchend' === t ? s.changedTouches : s.touches,
          n = Ur.touchPos(i.getCanvasContainer(), r),
          o = n.map((e) => i.unproject(e)),
          a = n.reduce((e, t, i, s) => e.add(t.div(s.length)), new e.pointGeometry3d(0, 0));
        super(t, { points: n, point: a, lngLats: o, lngLat: i.unproject(a), originalEvent: s }),
          (this._defaultPrevented = !1);
      }
    }
    class ju extends e.Event {
      preventDefault() {
        this._defaultPrevented = !0;
      }
      get defaultPrevented() {
        return this._defaultPrevented;
      }
      constructor(e, t, i) {
        super(e, { originalEvent: i }), (this._defaultPrevented = !1);
      }
    }
    class qu {
      constructor(e, t) {
        (this._map = e), (this._clickTolerance = t.clickTolerance);
      }
      reset() {
        delete this._mousedownPos;
      }
      wheel(e) {
        return this._firePreventable(new ju(e.type, this._map, e));
      }
      mousedown(e, t) {
        return (this._mousedownPos = t), this._firePreventable(new Hu(e.type, this._map, e));
      }
      mouseup(e) {
        this._map.fire(new Hu(e.type, this._map, e));
      }
      preclick(t) {
        const i = e.extend({}, t);
        (i.type = 'preclick'), this._map.fire(new Hu(i.type, this._map, i));
      }
      click(e, t) {
        (this._mousedownPos && this._mousedownPos.dist(t) >= this._clickTolerance) ||
          (this.preclick(e), this._map.fire(new Hu(e.type, this._map, e)));
      }
      dblclick(e) {
        return this._firePreventable(new Hu(e.type, this._map, e));
      }
      mouseover(e) {
        this._map.fire(new Hu(e.type, this._map, e));
      }
      mouseout(e) {
        this._map.fire(new Hu(e.type, this._map, e));
      }
      touchstart(e) {
        return this._firePreventable(new Wu(e.type, this._map, e));
      }
      touchmove(e) {
        this._map.fire(new Wu(e.type, this._map, e));
      }
      touchend(e) {
        this._map.fire(new Wu(e.type, this._map, e));
      }
      touchcancel(e) {
        this._map.fire(new Wu(e.type, this._map, e));
      }
      _firePreventable(e) {
        if ((this._map.fire(e), e.defaultPrevented)) return {};
      }
      isEnabled() {
        return !0;
      }
      isActive() {
        return !1;
      }
      enable() {}
      disable() {}
    }
    class Xu {
      constructor(e) {
        this._map = e;
      }
      reset() {
        (this._delayContextMenu = !1), delete this._contextMenuEvent;
      }
      mousemove(e) {
        this._map.fire(new Hu(e.type, this._map, e));
      }
      mousedown() {
        this._delayContextMenu = !0;
      }
      mouseup() {
        (this._delayContextMenu = !1),
          this._contextMenuEvent &&
            (this._map.fire(new Hu('contextmenu', this._map, this._contextMenuEvent)),
            delete this._contextMenuEvent);
      }
      contextmenu(e) {
        this._delayContextMenu
          ? (this._contextMenuEvent = e)
          : this._map.fire(new Hu(e.type, this._map, e)),
          this._map.listens('contextmenu') && e.preventDefault();
      }
      isEnabled() {
        return !0;
      }
      isActive() {
        return !1;
      }
      enable() {}
      disable() {}
    }
    class Zu {
      constructor(e, t) {
        (this._map = e),
          (this._el = e.getCanvasContainer()),
          (this._container = e.getContainer()),
          (this._clickTolerance = t.clickTolerance || 1);
      }
      isEnabled() {
        return !!this._enabled;
      }
      isActive() {
        return !!this._active;
      }
      enable() {
        this.isEnabled() || (this._enabled = !0);
      }
      disable() {
        this.isEnabled() && (this._enabled = !1);
      }
      mousedown(e, t) {
        this.isEnabled() &&
          e.shiftKey &&
          0 === e.button &&
          (Ur.disableDrag(), (this._startPos = this._lastPos = t), (this._active = !0));
      }
      mousemoveWindow(e, t) {
        if (!this._active) return;
        const i = t;
        if (
          this._lastPos.equals(i) ||
          (!this._box && i.dist(this._startPos) < this._clickTolerance)
        )
          return;
        const s = this._startPos;
        (this._lastPos = i),
          this._box ||
            ((this._box = Ur.create('div', 'minemap-boxzoom', this._container)),
            this._container.classList.add('minemap-crosshair'),
            this._fireEvent('boxzoomstart', e));
        const r = Math.min(s.x, i.x),
          n = Math.max(s.x, i.x),
          o = Math.min(s.y, i.y),
          a = Math.max(s.y, i.y);
        this._map._requestDomTask(() => {
          this._box &&
            (Ur.setTransform(this._box, `translate(${r}px,${o}px)`),
            (this._box.style.width = n - r + 'px'),
            (this._box.style.height = a - o + 'px'));
        });
      }
      mouseupWindow(t) {
        if (!this._active) return;
        if (0 !== t.button) return;
        const i = this._startPos,
          s = Ur.mousePos(this._el, t);
        if ((this.reset(), Ur.suppressClick(), i.x !== s.x || i.y !== s.y))
          return (
            this._map.fire(new e.Event('boxzoomend', { originalEvent: t })),
            {
              cameraAnimation: (e) =>
                e.fitScreenCoordinates(i, s, this._map.getBearing(), { linear: !0 }),
            }
          );
        this._fireEvent('boxzoomcancel', t);
      }
      keydown(e) {
        this._active && 27 === e.keyCode && (this.reset(), this._fireEvent('boxzoomcancel', e));
      }
      blur() {
        this.reset();
      }
      reset() {
        (this._active = !1),
          this._container.classList.remove('minemap-crosshair'),
          this._box && (Ur.remove(this._box), (this._box = null)),
          Ur.enableDrag(),
          delete this._startPos,
          delete this._lastPos;
      }
      _fireEvent(t, i) {
        return this._map.fire(new e.Event(t, { originalEvent: i }));
      }
    }
    function $u(e, t) {
      const i = {};
      for (let s = 0; s < e.length; s++) i[e[s].identifier] = t[s];
      return i;
    }
    class Ku {
      constructor(e) {
        this.reset(), (this.numTouches = e.numTouches);
      }
      reset() {
        delete this.centroid, delete this.startTime, delete this.touches, (this.aborted = !1);
      }
      touchstart(t, i, s) {
        (this.centroid || s.length > this.numTouches) && (this.aborted = !0),
          this.aborted ||
            (void 0 === this.startTime && (this.startTime = t.timeStamp),
            s.length === this.numTouches &&
              ((this.centroid = (function (t) {
                const i = new e.pointGeometry3d(0, 0);
                for (const e of t) i._add(e);
                return i.div(t.length);
              })(i)),
              (this.touches = $u(s, i))));
      }
      touchmove(e, t, i) {
        if (this.aborted || !this.centroid) return;
        const s = $u(i, t);
        for (const e in this.touches) {
          const t = s[e];
          (!t || t.dist(this.touches[e]) > 30) && (this.aborted = !0);
        }
      }
      touchend(e, t, i) {
        if (
          ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0),
          0 === i.length)
        ) {
          const e = !this.aborted && this.centroid;
          if ((this.reset(), e)) return e;
        }
      }
    }
    class Yu {
      constructor(e) {
        (this.singleTap = new Ku(e)), (this.numTaps = e.numTaps), this.reset();
      }
      reset() {
        (this.lastTime = 1 / 0), delete this.lastTap, (this.count = 0), this.singleTap.reset();
      }
      touchstart(e, t, i) {
        this.singleTap.touchstart(e, t, i);
      }
      touchmove(e, t, i) {
        this.singleTap.touchmove(e, t, i);
      }
      touchend(e, t, i) {
        const s = this.singleTap.touchend(e, t, i);
        if (s) {
          const t = e.timeStamp - this.lastTime < 500,
            i = !this.lastTap || this.lastTap.dist(s) < 30;
          if (
            ((t && i) || this.reset(),
            this.count++,
            (this.lastTime = e.timeStamp),
            (this.lastTap = s),
            this.count === this.numTaps)
          )
            return this.reset(), s;
        }
      }
    }
    class Qu {
      constructor() {
        (this._zoomIn = new Yu({ numTouches: 1, numTaps: 2 })),
          (this._zoomOut = new Yu({ numTouches: 2, numTaps: 1 })),
          this.reset();
      }
      reset() {
        (this._active = !1), this._zoomIn.reset(), this._zoomOut.reset();
      }
      touchstart(e, t, i) {
        this._zoomIn.touchstart(e, t, i), this._zoomOut.touchstart(e, t, i);
      }
      touchmove(e, t, i) {
        this._zoomIn.touchmove(e, t, i), this._zoomOut.touchmove(e, t, i);
      }
      touchend(e, t, i) {
        const s = this._zoomIn.touchend(e, t, i),
          r = this._zoomOut.touchend(e, t, i);
        return s
          ? ((this._active = !0),
            e.preventDefault(),
            setTimeout(() => this.reset(), 0),
            {
              cameraAnimation: (t) =>
                t.easeTo(
                  { duration: 300, zoom: t.getZoom() + 1, around: t.unproject(s) },
                  { originalEvent: e },
                ),
            })
          : r
          ? ((this._active = !0),
            e.preventDefault(),
            setTimeout(() => this.reset(), 0),
            {
              cameraAnimation: (t) =>
                t.easeTo(
                  { duration: 300, zoom: t.getZoom() - 1, around: t.unproject(r) },
                  { originalEvent: e },
                ),
            })
          : void 0;
      }
      touchcancel() {
        this.reset();
      }
      enable() {
        this._enabled = !0;
      }
      disable() {
        (this._enabled = !1), this.reset();
      }
      isEnabled() {
        return this._enabled;
      }
      isActive() {
        return this._active;
      }
    }
    const Ju = { 0: 1, 2: 2 };
    class ed {
      constructor(e) {
        this.reset(), (this._clickTolerance = e.clickTolerance || 1);
      }
      blur() {
        this.reset();
      }
      reset() {
        (this._active = !1), (this._moved = !1), delete this._lastPoint, delete this._eventButton;
      }
      _correctButton(e, t) {
        return !1;
      }
      _move(e, t) {
        return {};
      }
      mousedown(t, i) {
        if (this._lastPoint) return;
        const s = Ur.mouseButton(t);
        this._correctButton(t, s) &&
          ((this._mousedownClickPoint = new e.pointGeometry3d(i.x, i.y)),
          (this._lastPoint = i),
          (this._eventButton = s));
      }
      mousemoveWindow(e, t) {
        const i = this._lastPoint;
        if (!i) return;
        if (
          (e.preventDefault(),
          (function (e, t) {
            const i = Ju[t];
            return void 0 === e.buttons || (e.buttons & i) !== i;
          })(e, this._eventButton))
        )
          return void this.reset();
        const s = t.dist(i);
        return this._moved || !(s < this._clickTolerance || s > 30)
          ? ((this._moved = !0), (this._lastPoint = t), this._move(i, t))
          : void 0;
      }
      mouseupWindow(e) {
        (this._mousedownClickPoint = null),
          this._lastPoint &&
            Ur.mouseButton(e) === this._eventButton &&
            (this._moved && Ur.suppressClick(), this.reset());
      }
      enable() {
        this._enabled = !0;
      }
      disable() {
        (this._enabled = !1), this.reset();
      }
      isEnabled() {
        return this._enabled;
      }
      isActive() {
        return this._active;
      }
    }
    class td extends ed {
      mousedown(e, t) {
        super.mousedown(e, t), this._lastPoint && (this._active = !0);
      }
      _correctButton(e, t) {
        return 0 === t && !e.ctrlKey;
      }
      _move(e, t) {
        return { around: t, panDelta: t.sub(e) };
      }
    }
    class id extends ed {
      _correctButton(e, t) {
        return (0 === t && e.ctrlKey) || 2 === t;
      }
      _move(e, t) {
        const i = 0.8 * (t.x - e.x);
        if (i) return (this._active = !0), { bearingDelta: i };
      }
      contextmenu(e) {
        e.preventDefault();
      }
    }
    class sd extends ed {
      _correctButton(e, t) {
        return (0 === t && e.ctrlKey) || 2 === t;
      }
      _move(e, t) {
        const i = -0.5 * (t.y - e.y);
        if (i) return (this._active = !0), { pitchDelta: i };
      }
      contextmenu(e) {
        e.preventDefault();
      }
    }
    class rd {
      constructor(t, i) {
        (this._map = t),
          (this._el = t.getCanvasContainer()),
          (this._minTouches = 1),
          (this._clickTolerance = i.clickTolerance || 1),
          this.reset(),
          e.bindAll(['_addTouchPanBlocker', '_showTouchPanBlockerAlert'], this);
      }
      reset() {
        (this._active = !1), (this._touches = {}), (this._sum = new e.pointGeometry3d(0, 0));
      }
      touchstart(e, t, i) {
        return this._calculateTransform(e, t, i);
      }
      touchmove(e, t, i) {
        if (this._active && !(i.length < this._minTouches)) {
          if (this._map._cooperativeGestures && !this._map.isMoving()) {
            if (1 === i.length) return void this._showTouchPanBlockerAlert();
            'hidden' !== this._alertContainer.style.visibility &&
              ((this._alertContainer.style.visibility = 'hidden'), clearTimeout(this._alertTimer));
          }
          return e.preventDefault(), this._calculateTransform(e, t, i);
        }
      }
      touchend(e, t, i) {
        this._calculateTransform(e, t, i),
          this._active && i.length < this._minTouches && this.reset();
      }
      touchcancel() {
        this.reset();
      }
      _calculateTransform(t, i, s) {
        s.length > 0 && (this._active = !0);
        const r = $u(s, i),
          n = new e.pointGeometry3d(0, 0),
          o = new e.pointGeometry3d(0, 0);
        let a = 0;
        for (const e in r) {
          const t = r[e],
            i = this._touches[e];
          i && (n._add(t), o._add(t.sub(i)), a++, (r[e] = t));
        }
        if (((this._touches = r), a < this._minTouches || !o.mag())) return;
        const l = o.div(a);
        return (
          this._sum._add(l),
          this._sum.mag() < this._clickTolerance ? void 0 : { around: n.div(a), panDelta: l }
        );
      }
      enable() {
        (this._enabled = !0),
          this._map._cooperativeGestures &&
            (this._addTouchPanBlocker(),
            this._el.classList.add(
              'minemap-touch-pan-blocker-override',
              'minemap-scrollable-page',
            ));
      }
      disable() {
        (this._enabled = !1),
          this._map._cooperativeGestures &&
            (clearTimeout(this._alertTimer),
            this._alertContainer.remove(),
            this._el.classList.remove(
              'minemap-touch-pan-blocker-override',
              'minemap-scrollable-page',
            )),
          this.reset();
      }
      isEnabled() {
        return this._enabled;
      }
      isActive() {
        return this._active;
      }
      _addTouchPanBlocker() {
        this._map &&
          !this._alertContainer &&
          ((this._alertContainer = Ur.create(
            'div',
            'minemap-touch-pan-blocker',
            this._map._container,
          )),
          (this._alertContainer.textContent = this._map._getUIString('TouchPanBlocker.Message')),
          (this._alertContainer.style.fontSize = `${Math.max(
            10,
            Math.min(24, Math.floor(0.05 * this._el.clientWidth)),
          )}px`));
      }
      _showTouchPanBlockerAlert() {
        'hidden' === this._alertContainer.style.visibility &&
          (this._alertContainer.style.visibility = 'visible'),
          this._alertContainer.classList.add('minemap-touch-pan-blocker-show'),
          clearTimeout(this._alertTimer),
          (this._alertTimer = setTimeout(() => {
            this._alertContainer.classList.remove('minemap-touch-pan-blocker-show');
          }, 500));
      }
    }
    class nd {
      constructor() {
        this.reset();
      }
      reset() {
        (this._active = !1), delete this._firstTwoTouches;
      }
      _start(e) {}
      _move(e, t, i) {
        return {};
      }
      touchstart(e, t, i) {
        this._firstTwoTouches ||
          i.length < 2 ||
          ((this._firstTwoTouches = [i[0].identifier, i[1].identifier]), this._start([t[0], t[1]]));
      }
      touchmove(e, t, i) {
        if (!this._firstTwoTouches) return;
        e.preventDefault();
        const [s, r] = this._firstTwoTouches,
          n = od(i, t, s),
          o = od(i, t, r);
        if (!n || !o) return;
        const a = this._aroundCenter ? null : n.add(o).div(2);
        return this._move([n, o], a, e);
      }
      touchend(e, t, i) {
        if (!this._firstTwoTouches) return;
        const [s, r] = this._firstTwoTouches,
          n = od(i, t, s),
          o = od(i, t, r);
        (n && o) || (this._active && Ur.suppressClick(), this.reset());
      }
      touchcancel() {
        this.reset();
      }
      enable(e) {
        (this._enabled = !0), (this._aroundCenter = !!e && 'center' === e.around);
      }
      disable() {
        (this._enabled = !1), this.reset();
      }
      isEnabled() {
        return this._enabled;
      }
      isActive() {
        return this._active;
      }
    }
    function od(e, t, i) {
      for (let s = 0; s < e.length; s++) if (e[s].identifier === i) return t[s];
    }
    function ad(e, t) {
      return Math.log(e / t) / Math.LN2;
    }
    class ld extends nd {
      reset() {
        super.reset(), delete this._distance, delete this._startDistance;
      }
      _start(e) {
        this._startDistance = this._distance = e[0].dist(e[1]);
      }
      _move(e, t) {
        const i = this._distance;
        if (
          ((this._distance = e[0].dist(e[1])),
          this._active || !(Math.abs(ad(this._distance, this._startDistance)) < 0.1))
        )
          return (this._active = !0), { zoomDelta: ad(this._distance, i), pinchAround: t };
      }
    }
    function hd(e, t) {
      return (180 * e.angleWith(t)) / Math.PI;
    }
    class cd extends nd {
      reset() {
        super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
      }
      _start(t) {
        (this._startVector = this._vector = t[0].sub(t[1])),
          (this._minDiameter = t[0].dist(t[1])),
          (this._mousedownClickPoint = new e.pointGeometry3d(t[0].x, t[0].y));
      }
      _move(e, t) {
        const i = this._vector;
        if (
          ((this._vector = e[0].sub(e[1])), this._active || !this._isBelowThreshold(this._vector))
        )
          return (this._active = !0), { bearingDelta: hd(this._vector, i), pinchAround: t };
      }
      _isBelowThreshold(e) {
        this._minDiameter = Math.min(this._minDiameter, e.mag());
        const t = (25 / (Math.PI * this._minDiameter)) * 360,
          i = hd(e, this._startVector);
        return Math.abs(i) < t;
      }
    }
    function _d(e) {
      return Math.abs(e.y) > Math.abs(e.x);
    }
    class ud extends nd {
      constructor(e) {
        super(), (this._map = e);
      }
      reset() {
        super.reset(), (this._valid = void 0), delete this._firstMove, delete this._lastPoints;
      }
      _start(t) {
        (this._lastPoints = t),
          _d(t[0].sub(t[1]))
            ? (this._valid = !1)
            : (this._mousedownClickPoint = new e.pointGeometry3d(t[0].x, t[0].y));
      }
      _move(e, t, i) {
        const s = e[0].sub(this._lastPoints[0]),
          r = e[1].sub(this._lastPoints[1]);
        if (
          !(this._map._cooperativeGestures && i.touches.length < 3) &&
          ((this._valid = this.gestureBeginsVertically(s, r, i.timeStamp)), this._valid)
        )
          return (
            (this._lastPoints = e), (this._active = !0), { pitchDelta: ((s.y + r.y) / 2) * -0.5 }
          );
      }
      gestureBeginsVertically(e, t, i) {
        if (void 0 !== this._valid) return this._valid;
        const s = e.mag() >= 2,
          r = t.mag() >= 2;
        if (!s && !r) return;
        if (!s || !r)
          return (
            void 0 === this._firstMove && (this._firstMove = i), i - this._firstMove < 100 && void 0
          );
        const n = e.y > 0 == t.y > 0;
        return _d(e) && _d(t) && n;
      }
    }
    const dd = { panStep: 100, bearingStep: 15, pitchStep: 10 };
    class md {
      constructor() {
        const e = dd;
        (this._panStep = e.panStep),
          (this._bearingStep = e.bearingStep),
          (this._pitchStep = e.pitchStep),
          (this._rotationDisabled = !1);
      }
      blur() {
        this.reset();
      }
      reset() {
        this._active = !1;
      }
      keydown(e) {
        if (e.altKey || e.ctrlKey || e.metaKey) return;
        let t = 0,
          i = 0,
          s = 0,
          r = 0;
        switch (e.keyCode) {
          case 61:
          case 107:
          case 171:
          case 187:
          case 189:
          case 109:
          case 173:
            break;
          case 37:
            e.shiftKey ? (t = -1) : (e.preventDefault(), (s = -1));
            break;
          case 39:
            e.shiftKey ? (t = 1) : (e.preventDefault(), (s = 1));
            break;
          case 38:
            e.shiftKey ? (i = 1) : (e.preventDefault(), (r = -1));
            break;
          case 40:
            e.shiftKey ? (i = -1) : (e.preventDefault(), (r = 1));
            break;
          default:
            return;
        }
        return (
          this._rotationDisabled && ((t = 0), (i = 0)),
          {
            cameraAnimation: (n) => {
              n.easeTo(
                {
                  duration: 300,
                  easeId: 'keyboardHandler',
                  easing: pd,
                  bearing: n.getBearing() + t * this._bearingStep,
                  pitch: n.getPitch() + i * this._pitchStep,
                  offset: [-s * this._panStep, -r * this._panStep],
                },
                { originalEvent: e },
              );
            },
          }
        );
      }
      enable() {
        this._enabled = !0;
      }
      disable() {
        (this._enabled = !1), this.reset();
      }
      isEnabled() {
        return this._enabled;
      }
      isActive() {
        return this._active;
      }
      disableRotation() {
        this._rotationDisabled = !0;
      }
      enableRotation() {
        this._rotationDisabled = !1;
      }
    }
    function pd(e) {
      return e * (2 - e);
    }
    const fd = 4.000244140625;
    class gd {
      constructor(t, i) {
        (this._map = t),
          (this._el = t.getCanvasContainer()),
          (this._handler = i),
          (this._delta = 0),
          (this._defaultZoomRate = 0.01),
          (this._wheelZoomRate = 0.0022222222222222222),
          e.bindAll(
            ['_onTimeout', '_addScrollZoomBlocker', '_showBlockerAlert', '_isFullscreen'],
            this,
          );
      }
      setZoomRate(e) {
        this._defaultZoomRate = e;
      }
      setWheelZoomRate(e) {
        this._wheelZoomRate = e;
      }
      isEnabled() {
        return !!this._enabled;
      }
      isActive() {
        return !!this._active || void 0 !== this._finishTimeout;
      }
      isZooming() {
        return !!this._zooming;
      }
      enable(e) {
        this.isEnabled() ||
          ((this._enabled = !0),
          (this._aroundCenter = e && 'center' === e.around),
          this._map._cooperativeGestures && this._addScrollZoomBlocker());
      }
      disable() {
        this.isEnabled() &&
          ((this._enabled = !1),
          this._map._cooperativeGestures &&
            (clearTimeout(this._alertTimer), this._alertContainer.remove()));
      }
      wheel(t) {
        if (!this.isEnabled()) return;
        if (this._map._cooperativeGestures) {
          if (!(t.ctrlKey || t.metaKey || this.isZooming() || this._isFullscreen()))
            return void this._showBlockerAlert();
          'hidden' !== this._alertContainer.style.visibility &&
            ((this._alertContainer.style.visibility = 'hidden'), clearTimeout(this._alertTimer));
        }
        let i = t.deltaMode === e.window.WheelEvent.DOM_DELTA_LINE ? 40 * t.deltaY : t.deltaY;
        const s = e.exported.now(),
          r = s - (this._lastWheelEventTime || 0);
        let n, o;
        if (
          ((this._lastWheelEventTime = s),
          0 !== i && i % fd == 0
            ? (this._type = 'wheel')
            : 0 !== i && Math.abs(i) < 4
            ? (this._type = 'trackpad')
            : r > 400
            ? ((this._type = null),
              (this._lastValue = i),
              (this._timeout = setTimeout(this._onTimeout, 40, t)))
            : this._type ||
              ((this._type = Math.abs(r * i) < 200 ? 'trackpad' : 'wheel'),
              this._timeout &&
                (clearTimeout(this._timeout), (this._timeout = null), (i += this._lastValue))),
          this._map.transform.zoom > 11 &&
            ((o = this._map.getPositionByGPUPick(new e.pointGeometry3d(t.offsetX, t.offsetY))), o))
        ) {
          const t = e.Transforms.cartographicToCartesian3(o);
          n = e.Vector3.distance(
            new e.Vector3(t[0], t[1], t[2]),
            this._map.transform.activeCamera.position,
          );
        }
        const a = () => this._map.transform.zoom;
        if (n && n < 700 && o[2] > 0) {
          const t = this._map.getZoomFromDistance(o[2]),
            s = a(),
            r = e.lerp(s, t, 0.1 + Math.sin((((700 - n) / 700) * Math.PI) / 2));
          this._slowZoom = i < 0 ? s + (r - s) / 2 : s - (r - s) / 2;
        } else this._slowZoom = void 0;
        t.shiftKey && i && (i /= 4),
          this._type &&
            ((this._lastWheelEvent = t), (this._delta -= i), this._active || this._start(t)),
          t.preventDefault();
      }
      _onTimeout(e) {
        (this._type = 'wheel'), (this._delta -= this._lastValue), this._active || this._start(e);
      }
      _start(e) {
        if (!this._delta) return;
        this._frameId && (this._frameId = null),
          (this._active = !0),
          this.isZooming() || (this._zooming = !0),
          this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
        const t = Ur.mousePos(this._el, e);
        (this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t),
          (this._targetZoom = void 0),
          this._frameId || ((this._frameId = !0), this._handler._triggerRenderFrame());
      }
      renderFrame() {
        if (!this._frameId) return;
        if (((this._frameId = null), !this.isActive())) return;
        const t = this._map.transform,
          i = () => t.zoom;
        if (0 !== this._delta) {
          const e =
            'wheel' === this._type && Math.abs(this._delta) > fd
              ? this._wheelZoomRate
              : this._defaultZoomRate;
          let s = 2 / (1 + Math.exp(-Math.abs(this._delta * e)));
          this._delta < 0 && 0 !== s && (s = 1 / s);
          const r = i(),
            n = Math.pow(2, r),
            o = 'number' == typeof this._targetZoom ? t.zoomScale(this._targetZoom) : n;
          (this._targetZoom = Math.min(t.maxZoom, Math.max(t.minZoom, t.scaleZoom(o * s)))),
            (this._targetZoom =
              i() > t.maxZoom
                ? Math.min(i(), Math.max(t.minZoom, t.scaleZoom(o * s)))
                : r < t.minZoom
                ? Math.max(r, t.scaleZoom(o * s))
                : Math.min(t.maxZoom, Math.max(t.minZoom, t.scaleZoom(o * s)))),
            (this._targetZoom =
              this._delta > 0
                ? this._slowZoom && this._slowZoom < this._targetZoom
                  ? this._slowZoom
                  : this._targetZoom
                : this._slowZoom
                ? this._slowZoom
                : this._targetZoom),
            this._targetZoom - r < -0.8 && (this._targetZoom = r - 0.8),
            'wheel' === this._type &&
              ((this._startZoom = i()), (this._easing = this._smoothOutEasing(200))),
            (this._delta = 0);
        }
        const s = 'number' == typeof this._targetZoom ? this._targetZoom : i(),
          r = this._startZoom,
          n = this._easing;
        let o,
          a = !1;
        if ('wheel' === this._type && r && n) {
          const t = Math.min((e.exported.now() - this._lastWheelEventTime) / 200, 1),
            i = n(t);
          (o = e.number(r, s, i)), t < 1 ? this._frameId || (this._frameId = !0) : (a = !0);
        } else (o = s), (a = !0);
        return (
          (this._active = !0),
          a &&
            ((this._active = !1),
            (this._finishTimeout = setTimeout(() => {
              (this._zooming = !1),
                this._handler._triggerRenderFrame(),
                delete this._targetZoom,
                delete this._finishTimeout;
            }, 200))),
          {
            noInertia: !0,
            needsRenderFrame: !a,
            zoomDelta: o - i(),
            around: this._aroundPoint,
            aroundCoord: this._aroundCoord,
            originalEvent: this._lastWheelEvent,
          }
        );
      }
      _smoothOutEasing(t) {
        let i = e.ease;
        if (this._prevEase) {
          const t = this._prevEase,
            s = (e.exported.now() - t.start) / t.duration,
            r = t.easing(s + 0.01) - t.easing(s),
            n = (0.27 / Math.sqrt(r * r + 1e-4)) * 0.01,
            o = Math.sqrt(0.0729 - n * n);
          i = e.bezier(n, o, 0.25, 1);
        }
        return (this._prevEase = { start: e.exported.now(), duration: t, easing: i }), i;
      }
      blur() {
        this.reset();
      }
      reset() {
        this._active = !1;
      }
      _addScrollZoomBlocker() {
        this._map &&
          !this._alertContainer &&
          ((this._alertContainer = Ur.create(
            'div',
            'minemap-scroll-zoom-blocker',
            this._map._container,
          )),
          (this._alertContainer.textContent = /(Mac|iPad)/i.test(e.window.navigator.userAgent)
            ? this._map._getUIString('ScrollZoomBlocker.CmdMessage')
            : this._map._getUIString('ScrollZoomBlocker.CtrlMessage')),
          (this._alertContainer.style.fontSize = `${Math.max(
            10,
            Math.min(24, Math.floor(0.05 * this._el.clientWidth)),
          )}px`));
      }
      _isFullscreen() {
        return !!e.window.document.fullscreenElement;
      }
      _showBlockerAlert() {
        'hidden' === this._alertContainer.style.visibility &&
          (this._alertContainer.style.visibility = 'visible'),
          this._alertContainer.classList.add('minemap-scroll-zoom-blocker-show'),
          clearTimeout(this._alertTimer),
          (this._alertTimer = setTimeout(() => {
            this._alertContainer.classList.remove('minemap-scroll-zoom-blocker-show');
          }, 200));
      }
    }
    class yd {
      constructor(e, t) {
        (this._clickZoom = e), (this._tapZoom = t);
      }
      enable() {
        this._clickZoom.enable(), this._tapZoom.enable();
      }
      disable() {
        this._clickZoom.disable(), this._tapZoom.disable();
      }
      isEnabled() {
        return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
      }
      isActive() {
        return this._clickZoom.isActive() || this._tapZoom.isActive();
      }
    }
    class Td {
      constructor(e, t) {
        (this._map = e), (this._handler = t), (this._el = e.getCanvasContainer()), this.reset();
      }
      reset() {
        this._active = !1;
      }
      blur() {
        this.reset();
      }
      dblclick(e) {
        const t = Ur.mousePos(this._el, e);
        return (
          (this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t),
          this._handler._triggerRenderFrame(),
          {
            noInertia: !0,
            needsRenderFrame: !1,
            zoomDelta: e.shiftKey ? -1 : 1,
            around: this._aroundPoint,
            aroundCoord: this._aroundCoord,
            originalEvent: e,
          }
        );
      }
      enable(e) {
        (this._enabled = !0), (this._aroundCenter = e && 'center' === e.around);
      }
      disable() {
        (this._enabled = !1), this.reset();
      }
      isEnabled() {
        return this._enabled;
      }
      isActive() {
        return this._active;
      }
    }
    class xd {
      constructor() {
        (this._tap = new Yu({ numTouches: 1, numTaps: 1 })), this.reset();
      }
      reset() {
        (this._active = !1),
          delete this._swipePoint,
          delete this._swipeTouch,
          delete this._tapTime,
          this._tap.reset();
      }
      touchstart(e, t, i) {
        this._swipePoint ||
          (this._tapTime && e.timeStamp - this._tapTime > 500 && this.reset(),
          this._tapTime
            ? i.length > 0 && ((this._swipePoint = t[0]), (this._swipeTouch = i[0].identifier))
            : this._tap.touchstart(e, t, i));
      }
      touchmove(e, t, i) {
        if (this._tapTime) {
          if (this._swipePoint) {
            if (i[0].identifier !== this._swipeTouch) return;
            const s = t[0],
              r = s.y - this._swipePoint.y;
            return (
              (this._swipePoint = s),
              e.preventDefault(),
              (this._active = !0),
              { zoomDelta: r / 128 }
            );
          }
        } else this._tap.touchmove(e, t, i);
      }
      touchend(e, t, i) {
        this._tapTime
          ? this._swipePoint && 0 === i.length && this.reset()
          : this._tap.touchend(e, t, i) && (this._tapTime = e.timeStamp);
      }
      touchcancel() {
        this.reset();
      }
      enable() {
        this._enabled = !0;
      }
      disable() {
        (this._enabled = !1), this.reset();
      }
      isEnabled() {
        return this._enabled;
      }
      isActive() {
        return this._active;
      }
    }
    class vd {
      constructor(e, t, i) {
        (this._el = e), (this._mousePan = t), (this._touchPan = i);
      }
      enable(e) {
        (this._inertiaOptions = e || {}),
          this._mousePan.enable(),
          this._touchPan.enable(),
          this._el.classList.add('minemap-touch-drag-pan');
      }
      disable() {
        this._mousePan.disable(),
          this._touchPan.disable(),
          this._el.classList.remove('minemap-touch-drag-pan');
      }
      isEnabled() {
        return this._mousePan.isEnabled() && this._touchPan.isEnabled();
      }
      isActive() {
        return this._mousePan.isActive() || this._touchPan.isActive();
      }
    }
    class bd {
      constructor(e, t, i) {
        (this._pitchWithRotate = e.pitchWithRotate),
          (this._mouseRotate = t),
          (this._mousePitch = i);
      }
      enable() {
        this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
      }
      disable() {
        this._mouseRotate.disable(), this._mousePitch.disable();
      }
      isEnabled() {
        return (
          this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled())
        );
      }
      isActive() {
        return this._mouseRotate.isActive() || this._mousePitch.isActive();
      }
    }
    class wd {
      constructor(e, t, i, s) {
        (this._el = e),
          (this._touchZoom = t),
          (this._touchRotate = i),
          (this._tapDragZoom = s),
          (this._rotationDisabled = !1),
          (this._enabled = !0);
      }
      enable(e) {
        this._touchZoom.enable(e),
          this._rotationDisabled || this._touchRotate.enable(e),
          this._tapDragZoom.enable(),
          this._el.classList.add('minemap-touch-zoom-rotate');
      }
      disable() {
        this._touchZoom.disable(),
          this._touchRotate.disable(),
          this._tapDragZoom.disable(),
          this._el.classList.remove('minemap-touch-zoom-rotate');
      }
      isEnabled() {
        return (
          this._touchZoom.isEnabled() &&
          (this._rotationDisabled || this._touchRotate.isEnabled()) &&
          this._tapDragZoom.isEnabled()
        );
      }
      isActive() {
        return (
          this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive()
        );
      }
      disableRotation() {
        (this._rotationDisabled = !0), this._touchRotate.disable();
      }
      enableRotation() {
        (this._rotationDisabled = !1), this._touchZoom.isEnabled() && this._touchRotate.enable();
      }
    }
    const Cd = (e) => e.zoom || e.drag || e.pitch || e.rotate;
    class Sd extends e.Event {}
    function Ed(e) {
      return (e.panDelta && e.panDelta.mag()) || e.zoomDelta || e.bearingDelta || e.pitchDelta;
    }
    class Pd {
      constructor(t, i) {
        (this._map = t),
          (this._el = this._map.getCanvasContainer()),
          (this._handlers = []),
          (this._handlersById = {}),
          (this._changes = []),
          (this._inertia = new Gu(t)),
          (this._bearingSnap = i.bearingSnap),
          (this._previousActiveHandlers = {}),
          (this._eventsInProgress = {}),
          this._addDefaultHandlers(i),
          e.bindAll(['handleEvent', 'handleWindowEvent'], this);
        const s = this._el;
        this._listeners = [
          [s, 'touchstart', { passive: !0 }],
          [s, 'touchmove', { passive: !1 }],
          [s, 'touchend', void 0],
          [s, 'touchcancel', void 0],
          [s, 'mousedown', void 0],
          [s, 'mousemove', void 0],
          [s, 'mouseup', void 0],
          [e.window.document, 'mousemove', { capture: !0 }],
          [e.window.document, 'mouseup', void 0],
          [s, 'mouseover', void 0],
          [s, 'mouseout', void 0],
          [s, 'dblclick', void 0],
          [s, 'click', void 0],
          [s, 'keydown', { capture: !1 }],
          [s, 'keyup', void 0],
          [s, 'wheel', { passive: !1 }],
          [s, 'contextmenu', void 0],
          [e.window, 'blur', void 0],
        ];
        for (const [t, i, s] of this._listeners)
          Ur.addEventListener(
            t,
            i,
            t === e.window.document ? this.handleWindowEvent : this.handleEvent,
            s,
          );
      }
      destroy() {
        for (const [t, i, s] of this._listeners)
          Ur.removeEventListener(
            t,
            i,
            t === e.window.document ? this.handleWindowEvent : this.handleEvent,
            s,
          );
      }
      _addDefaultHandlers(e) {
        const t = this._map,
          i = t.getCanvasContainer();
        this._add('mapEvent', new qu(t, e));
        const s = (t.boxZoom = new Zu(t, e));
        this._add('boxZoom', s);
        const r = new Qu(),
          n = new Td(t, this);
        (t.doubleClickZoom = new yd(n, r)), this._add('tapZoom', r), this._add('clickZoom', n);
        const o = new xd();
        this._add('tapDragZoom', o);
        const a = (t.touchPitch = new ud(t));
        this._add('touchPitch', a);
        const l = new id(e),
          h = new sd(e);
        (t.dragRotate = new bd(e, l, h)),
          this._add('mouseRotate', l, ['mousePitch']),
          this._add('mousePitch', h, ['mouseRotate']);
        const c = new td(e),
          _ = new rd(t, e);
        (t.dragPan = new vd(i, c, _)),
          this._add('mousePan', c),
          this._add('touchPan', _, ['touchZoom', 'touchRotate']);
        const u = new cd(),
          d = new ld();
        (t.touchZoomRotate = new wd(i, d, u, o)),
          this._add('touchRotate', u, ['touchPan', 'touchZoom']),
          this._add('touchZoom', d, ['touchPan', 'touchRotate']),
          this._add('blockableMapEvent', new Xu(t));
        const m = (t.scrollZoom = new gd(t, this));
        this._add('scrollZoom', m, ['mousePan']);
        const p = (t.keyboard = new md());
        this._add('keyboard', p);
        for (const i of [
          'boxZoom',
          'doubleClickZoom',
          'tapDragZoom',
          'touchPitch',
          'dragRotate',
          'dragPan',
          'touchZoomRotate',
          'scrollZoom',
          'keyboard',
        ])
          e.interactive && e[i] && t[i].enable(e[i]);
      }
      _add(e, t, i) {
        this._handlers.push({ handlerName: e, handler: t, allowed: i }),
          (this._handlersById[e] = t);
      }
      stop(e) {
        if (!this._updatingCamera) {
          for (const { handler: e } of this._handlers) e.reset();
          this._inertia.clear(), this._fireEvents({}, {}, e), (this._changes = []);
        }
      }
      isActive() {
        for (const { handler: e } of this._handlers) if (e.isActive()) return !0;
        return !1;
      }
      isZooming() {
        return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
      }
      isRotating() {
        return !!this._eventsInProgress.rotate;
      }
      isMoving() {
        return Boolean(Cd(this._eventsInProgress)) || this.isZooming();
      }
      _blockedByActive(e, t, i) {
        for (const s in e) if (s !== i && (!t || t.indexOf(s) < 0)) return !0;
        return !1;
      }
      handleWindowEvent(e) {
        this.handleEvent(e, `${e.type}Window`);
      }
      _getMapTouches(e) {
        const t = [];
        for (const i of e) this._el.contains(i.target) && t.push(i);
        return t;
      }
      handleEvent(e, t) {
        this._updatingCamera = !0;
        const i = 'renderFrame' === e.type,
          s = i ? void 0 : e,
          r = { needsRenderFrame: !1 },
          n = {},
          o = {},
          a = e.touches ? this._getMapTouches(e.touches) : void 0,
          l = a ? Ur.touchPos(this._el, a) : i ? void 0 : Ur.mousePos(this._el, e);
        for (const { handlerName: i, handler: h, allowed: c } of this._handlers) {
          if (!h.isEnabled()) continue;
          let _;
          this._blockedByActive(o, c, i)
            ? h.reset()
            : h[t || e.type] &&
              (('mouseup' != t && 'mouseupWindow' != t) ||
                (this._map.transform.pinchPosition = null),
              (_ = h[t || e.type](e, l, a)),
              this.mergeHandlerResult({
                mergedHandlerResult: r,
                eventsInProgress: n,
                handlerResult: _,
                name: i,
                e: s,
                _mousedownClickPoint: h._mousedownClickPoint,
              }),
              _ && _.needsRenderFrame && this._triggerRenderFrame()),
            (_ || h.isActive()) && (o[i] = h);
        }
        const h = {};
        for (const e in this._previousActiveHandlers) o[e] || (h[e] = s);
        (this._previousActiveHandlers = o),
          (Object.keys(h).length || Ed(r)) &&
            (this._changes.push([r, n, h]), this._triggerRenderFrame()),
          (Object.keys(o).length || Ed(r)) && this._map._stop(!0),
          (this._updatingCamera = !1);
        const { cameraAnimation: c } = r;
        c &&
          (this._inertia.clear(), this._fireEvents({}, {}, !0), (this._changes = []), c(this._map));
      }
      mergeHandlerResult(t) {
        const {
          mergedHandlerResult: i,
          eventsInProgress: s,
          handlerResult: r,
          name: n,
          e: o,
          _mousedownClickPoint: a,
        } = t;
        if (!r) return;
        e.extend(i, r), e.defined(a) && (i._mousedownClickPoint = a);
        const l = { handlerName: n, originalEvent: r.originalEvent || o };
        (this._map.cameraController.eventInProgress = l),
          void 0 !== r.zoomDelta && (s.zoom = l),
          void 0 !== r.panDelta && (s.drag = l),
          void 0 !== r.pitchDelta && (s.pitch = l),
          void 0 !== r.bearingDelta && (s.rotate = l);
      }
      _applyChanges() {
        const t = {},
          i = {},
          s = {};
        for (const [r, n, o] of this._changes)
          r.panDelta && (t.panDelta = (t.panDelta || new e.pointGeometry3d(0, 0))._add(r.panDelta)),
            r.zoomDelta && (t.zoomDelta = (t.zoomDelta || 0) + r.zoomDelta),
            r.bearingDelta && (t.bearingDelta = (t.bearingDelta || 0) + r.bearingDelta),
            r.pitchDelta && (t.pitchDelta = (t.pitchDelta || 0) + r.pitchDelta),
            void 0 !== r.aroundCoord && (t.aroundCoord = r.aroundCoord),
            void 0 !== r.around && (t.around = r.around),
            void 0 !== r.pinchAround && (t.pinchAround = r.pinchAround),
            r.noInertia && (t.noInertia = r.noInertia),
            r._mousedownClickPoint && (t._mousedownClickPoint = r._mousedownClickPoint),
            e.extend(i, n),
            e.extend(s, o);
        this._updateMapTransform(t, i, s), (this._changes = []);
      }
      _updateMapTransform(t, i, s) {
        const r = this._map,
          n = r.transform;
        if (!Ed(t)) return this._fireEvents(i, s, !0);
        let {
          panDelta: o,
          zoomDelta: a,
          bearingDelta: l,
          pitchDelta: h,
          around: c,
          pinchAround: _,
        } = t;
        if (
          (void 0 !== _ && (c = _),
          r._stop(!0),
          (c = c || r.transform.centerPoint),
          t._mousedownClickPoint && (i.rotate || i.pitch))
        ) {
          let s;
          if (
            ((n._pinchOperationData._rollDiff = 0),
            (n._pinchOperationData._pitchDiff = h * e.CONSTS.TRANSFORM.DEG_TO_RAD || 0),
            (n._pinchOperationData._headingDiff = l * e.CONSTS.TRANSFORM.DEG_TO_RAD || 0),
            this.lastvSpace
              ? ((s = new e.Vector3(this.lastvSpace)), (n.pinchPosition = null))
              : (s = this._map.painter.getPositionByGPUPick(t._mousedownClickPoint)),
            s && (this.lastvSpace = new e.Vector3(s)),
            s)
          )
            if (r.cameraController.enableCollisionDetection && i.rotate)
              if (
                r.cameraController.checkColliding(
                  n.position,
                  n._terrainSupplier,
                  n.projection,
                  n.position[2],
                )
              ) {
                const t = e.Vector3.fromDegrees(s[0], s[1], s[2]),
                  i = r.cameraController.adjustCameraHeight(
                    n.position,
                    n._terrainRender,
                    n._terrainSupplier,
                    n.projection,
                  );
                i[2] > n.position[2] && (n.positionHeight = i[2]), (n.pinchPosition = t);
              } else n.pinchPosition = e.Vector3.fromDegrees(s[0], s[1], s[2]);
            else n.pinchPosition = e.Vector3.fromDegrees(s[0], s[1], s[2]);
          this._savedPinchPosition = n.pinchPosition;
        } else (n.pinchPosition = null), (this.lastvSpace = null);
        if (i.zoom) {
          let t;
          if ((o || (t = n.pointLocation(c)), a)) {
            const t =
              e.getDistanceFromZoom(n._fov, n.cameraHeightConvertedZoom + a, e.CONSTS.TRANSFORM.R) -
              e.CONSTS.TRANSFORM.R;
            (n.positionHeight = t), (n.zoomDelta = a);
          }
          o || n.setLocationAtPoint(t, c);
        }
        if (
          i.drag &&
          o &&
          ((n.panDelta = o),
          (n.zoomDelta = 0),
          this.firstPickPosition ||
            (this.firstPickPosition = this._map.painter.getPositionByGPUPick(c)),
          this.firstPickPosition && this.firstPickPosition[2] < n.position[2])
        ) {
          const t = new e.Ellipsoid(
              e.Transforms.DefaultEllipsoid.radii.x + this.firstPickPosition[2],
              e.Transforms.DefaultEllipsoid.radii.y + this.firstPickPosition[2],
              e.Transforms.DefaultEllipsoid.radii.z + this.firstPickPosition[2],
            ),
            i = n.pointLocation(c.sub(o), t),
            s = n.getLocationAtPointDiff(i, c, t);
          if (s !== [0, 0]) {
            let e = n.position[1] - s[1];
            e > 90 && (e = 90),
              e < -90 && (e = -90),
              (n.position = [n.position[0] - s[0], e, n.position[2]]);
          }
        }
        this._map._update(!0),
          t.noInertia || this._inertia.record(t),
          this._fireEvents(i, s, !0),
          this._fireEvent('handler-moveend', 'eventData');
      }
      _fireEvents(t, i, s) {
        const r = Cd(this._eventsInProgress),
          n = Cd(t),
          o = {};
        for (const e in t) {
          const { originalEvent: i } = t[e];
          this._eventsInProgress[e] || (o[`${e}start`] = i), (this._eventsInProgress[e] = t[e]);
        }
        !r && n && this._fireEvent('movestart', n.originalEvent);
        for (const e in o) this._fireEvent(e, o[e]);
        n && this._fireEvent('move', n.originalEvent);
        for (const e in t) {
          const { originalEvent: i } = t[e];
          this._fireEvent(e, i);
        }
        const a = {};
        let l;
        for (const e in this._eventsInProgress) {
          const { handlerName: t, originalEvent: s } = this._eventsInProgress[e];
          this._handlersById[t].isActive() ||
            (delete this._eventsInProgress[e], (l = i[t] || s), (a[`${e}end`] = l));
        }
        for (const e in a) this._fireEvent(e, a[e]);
        const h = Cd(this._eventsInProgress);
        if (s && (r || n) && !h) {
          (this.lastvSpace = null),
            (this.lastPanDelta = null),
            (this.firstPickPosition = null),
            (this._updatingCamera = !0);
          const t = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions),
            i = (e) => 0 !== e && -this._bearingSnap < e && e < this._bearingSnap;
          t && t.duration > 800
            ? (i(t.bearing || this._map.getBearing()) && (t.bearing = 0),
              t.bearing
                ? ((t.pinchPosition = this._savedPinchPosition),
                  this._map.easeToByPinchPosition(t, { originalEvent: l }))
                : (delete t.center, this._map.easeTo(t, { originalEvent: l })))
            : (this._map.fire(new e.Event('moveend', { originalEvent: l })),
              i(this._map.getBearing()) && this._map.resetNorth()),
            (this._updatingCamera = !1);
        }
      }
      _fireEvent(t, i) {
        this._map.fire(new e.Event(t, i ? { originalEvent: i } : {}));
      }
      _requestFrame() {
        return (
          this._map.triggerRepaint(),
          this._map._renderTaskQueue.add((e) => {
            delete this._frameId,
              this.handleEvent(new Sd('renderFrame', { timeStamp: e })),
              this._applyChanges();
          })
        );
      }
      _triggerRenderFrame() {
        void 0 === this._frameId && (this._frameId = this._requestFrame());
      }
    }
    const Md = (function () {
      let e = [];
      return {
        getAll: () => e,
        removeAll() {
          e = [];
        },
        add(t) {
          e.push(t);
        },
        remove(t) {
          const i = e.indexOf(t);
          -1 !== i && e.splice(i, 1);
        },
        update(t, i) {
          if (0 === e.length) return !1;
          let s = 0;
          for (t = void 0 !== t ? t : Md.now(); s < e.length; )
            e[s].update(t) || i ? s++ : e.splice(s, 1);
          return !0;
        },
      };
    })();
    (Md.now =
      void 0 !== e.window && void 0 !== e.window.performance && void 0 !== e.window.performance.now
        ? e.window.performance.now.bind(e.window.performance)
        : void 0 !== Date.now
        ? Date.now
        : function () {
            return new Date().getTime();
          }),
      (Md.Tween = function (e) {
        const t = e,
          i = {};
        let s = {};
        const r = {};
        let n,
          o = 1e3,
          a = 0,
          l = !1,
          h = !1,
          c = 0,
          _ = null,
          u = Md.Easing.Linear.None,
          d = Md.Interpolation.Linear,
          m = [],
          p = null,
          f = !1,
          g = null,
          y = null,
          T = null;
        (this.to = function (e, t) {
          return (s = e), void 0 !== t && (o = t), this;
        }),
          (this.start = function (e) {
            Md.add(this), (h = !0), (f = !1), (_ = void 0 !== e ? e : Md.now()), (_ += c);
            for (const e in s) {
              if (s[e] instanceof Array) {
                if (0 === s[e].length) continue;
                s[e] = [t[e]].concat(s[e]);
              }
              void 0 !== t[e] &&
                ((i[e] = t[e]), i[e] instanceof Array == 0 && (i[e] *= 1), (r[e] = i[e] || 0));
            }
            return this;
          }),
          (this.stop = function () {
            return h
              ? (Md.remove(this),
                (h = !1),
                null !== T && T.call(t, t),
                this.stopChainedTweens(),
                this)
              : this;
          }),
          (this.end = function () {
            return this.update(_ + o), this;
          }),
          (this.stopChainedTweens = function () {
            let e = 0;
            const t = m.length;
            for (; e < t; e++) m[e].stop();
          }),
          (this.delay = function (e) {
            return (c = e), this;
          }),
          (this.repeat = function (e) {
            return (a = e), this;
          }),
          (this.repeatDelay = function (e) {
            return (n = e), this;
          }),
          (this.yoyo = function (e) {
            return (l = e), this;
          }),
          (this.easing = function (e) {
            return (u = e), this;
          }),
          (this.interpolation = function (e) {
            return (d = e), this;
          }),
          (this.chain = function () {
            return (m = arguments), this;
          }),
          (this.onStart = function (e) {
            return (p = e), this;
          }),
          (this.onUpdate = function (e) {
            return (g = e), this;
          }),
          (this.onComplete = function (e) {
            return (y = e), this;
          }),
          (this.onStop = function (e) {
            return (T = e), this;
          }),
          (this.update = function (e) {
            let h, T, x;
            if (e < _) return !0;
            for (h in (!1 === f && (null !== p && p.call(t, t), (f = !0)),
            (T = (e - _) / o),
            (T = T > 1 ? 1 : T),
            (x = u(T)),
            s)) {
              if (void 0 === i[h]) continue;
              const e = i[h] || 0;
              let r = s[h];
              r instanceof Array
                ? (t[h] = d(r, x))
                : ('string' == typeof r &&
                    (r =
                      '+' === r.charAt(0) || '-' === r.charAt(0)
                        ? e + parseFloat(r)
                        : parseFloat(r)),
                  'number' == typeof r && (t[h] = e + (r - e) * x));
            }
            if ((null !== g && g.call(t, x), 1 === T)) {
              if (a > 0) {
                for (h in (isFinite(a) && a--, r)) {
                  if (('string' == typeof s[h] && (r[h] = r[h] + parseFloat(s[h])), l)) {
                    const e = r[h];
                    (r[h] = s[h]), (s[h] = e);
                  }
                  i[h] = r[h];
                }
                return (_ = void 0 !== n ? e + n : e + c), !0;
              }
              {
                null !== y && y.call(t, t);
                let e = 0;
                const i = m.length;
                for (; e < i; e++) m[e].start(_ + o);
                return !1;
              }
            }
            return !0;
          });
      }),
      (Md.Easing = {
        Linear: { None: (e) => e },
        Quadratic: {
          In: (e) => e * e,
          Out: (e) => e * (2 - e),
          InOut: (e) => ((e *= 2) < 1 ? 0.5 * e * e : -0.5 * (--e * (e - 2) - 1)),
        },
        Cubic: {
          In: (e) => e * e * e,
          Out: (e) => --e * e * e + 1,
          InOut: (e) => ((e *= 2) < 1 ? 0.5 * e * e * e : 0.5 * ((e -= 2) * e * e + 2)),
        },
        Quartic: {
          In: (e) => e * e * e * e,
          Out: (e) => 1 - --e * e * e * e,
          InOut: (e) => ((e *= 2) < 1 ? 0.5 * e * e * e * e : -0.5 * ((e -= 2) * e * e * e - 2)),
        },
        Quintic: {
          In: (e) => e * e * e * e * e,
          Out: (e) => --e * e * e * e * e + 1,
          InOut: (e) =>
            (e *= 2) < 1 ? 0.5 * e * e * e * e * e : 0.5 * ((e -= 2) * e * e * e * e + 2),
        },
        Sinusoidal: {
          In: (e) => 1 - Math.cos((e * Math.PI) / 2),
          Out: (e) => Math.sin((e * Math.PI) / 2),
          InOut: (e) => 0.5 * (1 - Math.cos(Math.PI * e)),
        },
        Exponential: {
          In: (e) => (0 === e ? 0 : Math.pow(1024, e - 1)),
          Out: (e) => (1 === e ? 1 : 1 - Math.pow(2, -10 * e)),
          InOut: (e) =>
            0 === e
              ? 0
              : 1 === e
              ? 1
              : (e *= 2) < 1
              ? 0.5 * Math.pow(1024, e - 1)
              : 0.5 * (2 - Math.pow(2, -10 * (e - 1))),
        },
        Circular: {
          In: (e) => 1 - Math.sqrt(1 - e * e),
          Out: (e) => Math.sqrt(1 - --e * e),
          InOut: (e) =>
            (e *= 2) < 1
              ? -0.5 * (Math.sqrt(1 - e * e) - 1)
              : 0.5 * (Math.sqrt(1 - (e -= 2) * e) + 1),
        },
        Elastic: {
          In: (e) =>
            0 === e
              ? 0
              : 1 === e
              ? 1
              : -Math.pow(2, 10 * (e - 1)) * Math.sin(5 * (e - 1.1) * Math.PI),
          Out: (e) =>
            0 === e
              ? 0
              : 1 === e
              ? 1
              : Math.pow(2, -10 * e) * Math.sin(5 * (e - 0.1) * Math.PI) + 1,
          InOut: (e) =>
            0 === e
              ? 0
              : 1 === e
              ? 1
              : (e *= 2) < 1
              ? -0.5 * Math.pow(2, 10 * (e - 1)) * Math.sin(5 * (e - 1.1) * Math.PI)
              : 0.5 * Math.pow(2, -10 * (e - 1)) * Math.sin(5 * (e - 1.1) * Math.PI) + 1,
        },
        Back: {
          In(e) {
            const t = 1.70158;
            return e * e * ((t + 1) * e - t);
          },
          Out(e) {
            const t = 1.70158;
            return --e * e * ((t + 1) * e + t) + 1;
          },
          InOut(e) {
            const t = 2.5949095;
            return (e *= 2) < 1
              ? e * e * ((t + 1) * e - t) * 0.5
              : 0.5 * ((e -= 2) * e * ((t + 1) * e + t) + 2);
          },
        },
        Bounce: {
          In: (e) => 1 - Md.Easing.Bounce.Out(1 - e),
          Out: (e) =>
            e < 1 / 2.75
              ? 7.5625 * e * e
              : e < 2 / 2.75
              ? 7.5625 * (e -= 1.5 / 2.75) * e + 0.75
              : e < 2.5 / 2.75
              ? 7.5625 * (e -= 2.25 / 2.75) * e + 0.9375
              : 7.5625 * (e -= 2.625 / 2.75) * e + 0.984375,
          InOut: (e) =>
            e < 0.5
              ? 0.5 * Md.Easing.Bounce.In(2 * e)
              : 0.5 * Md.Easing.Bounce.Out(2 * e - 1) + 0.5,
        },
      }),
      (Md.Interpolation = {
        Linear(e, t) {
          const i = e.length - 1,
            s = i * t,
            r = Math.floor(s),
            n = Md.Interpolation.Utils.Linear;
          return t < 0
            ? n(e[0], e[1], s)
            : t > 1
            ? n(e[i], e[i - 1], i - s)
            : n(e[r], e[r + 1 > i ? i : r + 1], s - r);
        },
        Bezier(e, t) {
          let i = 0;
          const s = e.length - 1,
            r = Math.pow,
            n = Md.Interpolation.Utils.Bernstein;
          for (let o = 0; o <= s; o++) i += r(1 - t, s - o) * r(t, o) * e[o] * n(s, o);
          return i;
        },
        CatmullRom(e, t) {
          const i = e.length - 1;
          let s = i * t,
            r = Math.floor(s);
          const n = Md.Interpolation.Utils.CatmullRom;
          return e[0] === e[i]
            ? (t < 0 && (r = Math.floor((s = i * (1 + t)))),
              n(e[(r - 1 + i) % i], e[r], e[(r + 1) % i], e[(r + 2) % i], s - r))
            : t < 0
            ? e[0] - (n(e[0], e[0], e[1], e[1], -s) - e[0])
            : t > 1
            ? e[i] - (n(e[i], e[i], e[i - 1], e[i - 1], s - i) - e[i])
            : n(e[r ? r - 1 : 0], e[r], e[i < r + 1 ? i : r + 1], e[i < r + 2 ? i : r + 2], s - r);
        },
        Utils: {
          Linear: (e, t, i) => (t - e) * i + e,
          Bernstein(e, t) {
            const i = Md.Interpolation.Utils.Factorial;
            return i(e) / i(t) / i(e - t);
          },
          Factorial: (function () {
            const e = [1];
            return function (t) {
              let i = 1;
              if (e[t]) return e[t];
              for (let e = t; e > 1; e--) i *= e;
              return (e[t] = i), i;
            };
          })(),
          CatmullRom(e, t, i, s, r) {
            const n = 0.5 * (i - e),
              o = 0.5 * (s - t),
              a = r * r;
            return (2 * t - 2 * i + n + o) * (r * a) + (-3 * t + 3 * i - 2 * n - o) * a + n * r + t;
          },
        },
      });
    var Ad = Object.freeze({
      LINEAR_NONE: Md.Easing.Linear.None,
      QUADRATIC_IN: Md.Easing.Quadratic.In,
      QUADRATIC_OUT: Md.Easing.Quadratic.Out,
      QUADRATIC_IN_OUT: Md.Easing.Quadratic.InOut,
      CUBIC_IN: Md.Easing.Cubic.In,
      CUBIC_OUT: Md.Easing.Cubic.Out,
      CUBIC_IN_OUT: Md.Easing.Cubic.InOut,
      QUARTIC_IN: Md.Easing.Quartic.In,
      QUARTIC_OUT: Md.Easing.Quartic.Out,
      QUARTIC_IN_OUT: Md.Easing.Quartic.InOut,
      QUINTIC_IN: Md.Easing.Quintic.In,
      QUINTIC_OUT: Md.Easing.Quintic.Out,
      QUINTIC_IN_OUT: Md.Easing.Quintic.InOut,
      SINUSOIDAL_IN: Md.Easing.Sinusoidal.In,
      SINUSOIDAL_OUT: Md.Easing.Sinusoidal.Out,
      SINUSOIDAL_IN_OUT: Md.Easing.Sinusoidal.InOut,
      EXPONENTIAL_IN: Md.Easing.Exponential.In,
      EXPONENTIAL_OUT: Md.Easing.Exponential.Out,
      EXPONENTIAL_IN_OUT: Md.Easing.Exponential.InOut,
      CIRCULAR_IN: Md.Easing.Circular.In,
      CIRCULAR_OUT: Md.Easing.Circular.Out,
      CIRCULAR_IN_OUT: Md.Easing.Circular.InOut,
      ELASTIC_IN: Md.Easing.Elastic.In,
      ELASTIC_OUT: Md.Easing.Elastic.Out,
      ELASTIC_IN_OUT: Md.Easing.Elastic.InOut,
      BACK_IN: Md.Easing.Back.In,
      BACK_OUT: Md.Easing.Back.Out,
      BACK_IN_OUT: Md.Easing.Back.InOut,
      BOUNCE_IN: Md.Easing.Bounce.In,
      BOUNCE_OUT: Md.Easing.Bounce.Out,
      BOUNCE_IN_OUT: Md.Easing.Bounce.InOut,
    });
    const { CesiumMath: Rd } = e.CONSTS,
      Id = {},
      Od = new e.Vector3(),
      Ld = new e.Vector3();
    function Dd(e, t) {
      return (
        Rd.equalsEpsilon(e, Rd.TWO_PI, Rd.EPSILON11) && (e = 0),
        t > e + Math.PI ? (e += Rd.TWO_PI) : t < e - Math.PI && (e -= Rd.TWO_PI),
        e
      );
    }
    function Bd(t, s, r, n, o, a, l, h, c, _, u, d) {
      const m = t.activeCamera,
        p = e.Cartographic.fromDegrees(t.position[0], t.position[1], t.position[2], Od),
        f = t.hpr.pitch,
        g = Dd(t.hpr.heading, n),
        y = Dd(t.hpr.roll, a),
        T = new e.Cartographic();
      e.Cartographic.fromDegrees(r[0], r[1], r[2], T),
        (p.longitude = Rd.zeroToTwoPi(p.longitude)),
        (T.longitude = Rd.zeroToTwoPi(T.longitude));
      let x = !1;
      if (e.defined(h)) {
        const t = Rd.zeroToTwoPi(h),
          i = Math.min(p.longitude, T.longitude),
          s = Math.max(p.longitude, T.longitude),
          r = t >= i && t <= s;
        if (e.defined(c)) {
          const e = Math.abs(p.longitude - T.longitude),
            t = Rd.TWO_PI - e;
          (r ? e : t) < (r ? t : e) * c && !r && (x = !0);
        } else r || (x = !0);
      }
      x
        ? (function (e, t) {
            e.longitude < t.longitude ? (e.longitude += Rd.TWO_PI) : (t.longitude += Rd.TWO_PI);
          })(p, T)
        : (function (e, t) {
            const i = e.longitude - t.longitude;
            i < -Rd.PI ? (e.longitude += Rd.TWO_PI) : i > Rd.PI && (t.longitude += Rd.TWO_PI);
          })(p, T);
      const v = (function (t, s, r, n, o, a) {
          let l = o;
          const h = Math.max(r, n);
          if (!a) {
            if (!e.defined(l)) {
              const r = t.position,
                n = e.Vector3.fromDegrees(s[0], s[1], s[2]),
                o = t.up,
                a = t.right,
                h = t.frustumCrate.frustum,
                c = e.Vector3.subtract(r, n, Od),
                _ = e.Vector3.magnitude(e.Vector3.multiplyByScalar(o, e.Vector3.dot(c, o), Ld)),
                u = e.Vector3.magnitude(e.Vector3.multiplyByScalar(a, e.Vector3.dot(c, a), Ld));
              l = Math.min(
                0.2 *
                  (function (t, s, r) {
                    let n, o, a;
                    if (t instanceof i) {
                      const e = Math.tan(0.5 * t.fovy);
                      return (
                        (n = t.near),
                        (o = t.near * e),
                        (a = t.aspectRatio * o),
                        Math.max((s * n) / a, (r * n) / o)
                      );
                    }
                    return t instanceof e.PerspectiveOffCenterFrustum
                      ? ((n = t.near),
                        (o = t.top),
                        (a = t.right),
                        Math.max((s * n) / a, (r * n) / o))
                      : Math.max(s, r);
                  })(h, _, u),
                1e9,
              );
            }
            if (h < l) {
              const e = 8,
                t = 1e6,
                i = -Math.pow((l - r) * t, 1 / e),
                s = Math.pow((l - n) * t, 1 / e);
              return function (r) {
                return -Math.pow(r * (s - i) + i, e) / t + l;
              };
            }
          }
          return function (t) {
            return e.lerp(r, n, t);
          };
        })(m, r, p.height, T.height, l, d),
        b = (function (t, i, s, r) {
          if (e.defined(r) && s(0.5) > r) {
            const r = s(0),
              n = s(1),
              o = s(0.5),
              a = o - r,
              l = o - n;
            return function (o) {
              const h = s(o);
              return o <= 0.5
                ? e.lerp(t, -Rd.PI_OVER_TWO, (h - r) / a)
                : e.lerp(-Rd.PI_OVER_TWO, i, 1 - (h - n) / l);
            };
          }
          return function (s) {
            return e.lerp(t, i, s);
          };
        })(f, o, v, _);
      return (function () {
        const i = p.longitude,
          r = T.longitude,
          o = p.latitude,
          l = T.latitude;
        return function (h) {
          const c = h.time / s,
            _ = e.lerp(i, r, c),
            d = e.lerp(o, l, c),
            m = v(c);
          (t.position = [_ * e.CONSTS.TRANSFORM.RAD_TO_DEG, d * e.CONSTS.TRANSFORM.RAD_TO_DEG, m]),
            (t.pitch = b(c) * e.CONSTS.TRANSFORM.RAD_TO_DEG),
            (t.bearing = e.lerp(g, n, c) * e.CONSTS.TRANSFORM.RAD_TO_DEG),
            (t.roll = e.lerp(y, a, c) * e.CONSTS.TRANSFORM.RAD_TO_DEG),
            u();
        };
      })();
    }
    function Vd(e, t) {
      return { startObject: {}, stopObject: {}, duration: 0, complete: e, cancel: t };
    }
    let Nd;
    (Id.createTween = function (t, i) {
      const s = t.activeCamera,
        r = (i = e.defaultValue(i, e.defaultValue.EMPTY_OBJECT)).destination,
        n = i.maximumHeight,
        o = i.flyOverLongitude,
        a = i.flyOverLongitudeWeight,
        l = i.pitchAdjustHeight;
      let h = i.easingFunction;
      const c = i.updateExtraFunction,
        _ = i.isEaseToType;
      let u = i.duration;
      e.defined(u) ||
        ((u = Math.ceil(e.Vector3.distance(s.position, r) / 1e6) + 2), (u = Math.min(u, 3)));
      const d = e.defaultValue(i.heading, 0),
        m = e.defaultValue(i.pitch, -Rd.PI_OVER_TWO),
        p = e.defaultValue(i.roll, 0),
        f = i.complete,
        g = i.cancel;
      let y = !1;
      if (
        ((y =
          y ||
          e.Vector3.equalsEpsilon(
            e.Vector3.fromDegrees(r[0], r[1], r[2]),
            s.position,
            Rd.EPSILON10,
          )),
        (y =
          y &&
          Rd.equalsEpsilon(Rd.negativePiToPi(d), Rd.negativePiToPi(t.hpr.heading), Rd.EPSILON10) &&
          Rd.equalsEpsilon(Rd.negativePiToPi(m), Rd.negativePiToPi(t.hpr.pitch), Rd.EPSILON10) &&
          Rd.equalsEpsilon(Rd.negativePiToPi(p), Rd.negativePiToPi(t.hpr.roll), Rd.EPSILON10)),
        y)
      )
        return Vd(f, g);
      const T = new Array(4);
      if (((T.SCENE3D = Bd), u <= 0))
        return Vd(function () {
          T.SCENE3D(t, 1, r, d, m, p, n, o, a, l, c, _)({ time: 1 }), 'function' == typeof f && f();
        }, g);
      const x = T.SCENE3D(t, u, r, d, m, p, n, o, a, l, c, _);
      if (!e.defined(h)) {
        const e = t.cameraHeightToSurface;
        h = e > r[2] && e > 11500 ? Ad.CUBIC_OUT : Ad.QUINTIC_IN_OUT;
      }
      return {
        duration: u,
        easingFunction: h,
        startObject: { time: 0 },
        stopObject: { time: u },
        update: x,
        complete: f,
        cancel: g,
      };
    }),
      (Nd =
        'undefined' != typeof performance &&
        'function' == typeof performance.now &&
        isFinite(performance.now())
          ? function () {
              return performance.now();
            }
          : function () {
              return Date.now();
            });
    var kd = Nd,
      Fd = Object.freeze({
        SECONDS_PER_MILLISECOND: 0.001,
        SECONDS_PER_MINUTE: 60,
        MINUTES_PER_HOUR: 60,
        HOURS_PER_DAY: 24,
        SECONDS_PER_HOUR: 3600,
        MINUTES_PER_DAY: 1440,
        SECONDS_PER_DAY: 86400,
        DAYS_PER_JULIAN_CENTURY: 36525,
        PICOSECOND: 1e-9,
        MODIFIED_JULIAN_DATE_DIFFERENCE: 2400000.5,
      });
    class Gd {
      constructor(e, t, i, s, r, n, o, a, l, h) {
        (this._tweens = e),
          (this._tweenjs = t),
          (this._startObject = $s(i)),
          (this._stopObject = $s(s)),
          (this._duration = r),
          (this._delay = n),
          (this._easingFunction = o),
          (this._update = a),
          (this._complete = l),
          (this.cancel = h),
          (this.needsStart = !0);
      }
      get startObject() {
        return this._startObject;
      }
      get stopObject() {
        return this._stopObject;
      }
      get duration() {
        return this._duration;
      }
      get delay() {
        return this._delay;
      }
      get easingFunction() {
        return this._easingFunction;
      }
      get update() {
        return this._update;
      }
      get complete() {
        return this._complete;
      }
      get tweenjs() {
        return this._tweenjs;
      }
      cancelTween() {
        this._tweens.remove(this);
      }
    }
    class Ud {
      constructor() {
        this._tweens = [];
      }
      get length() {
        return this._tweens.length;
      }
      add(t) {
        if (0 === (t = e.defaultValue(t, e.defaultValue.EMPTY_OBJECT)).duration)
          return e.defined(t.complete) && t.complete(), new Gd(this);
        const i = t.duration / Fd.SECONDS_PER_MILLISECOND,
          s = e.defaultValue(t.delay, 0),
          r = s / Fd.SECONDS_PER_MILLISECOND,
          n = e.defaultValue(t.easingFunction, Ad.LINEAR_NONE),
          o = t.startObject,
          a = new Md.Tween(o);
        a.to($s(t.stopObject), i),
          a.delay(r),
          a.easing(n),
          e.defined(t.update) &&
            a.onUpdate(() => {
              t.update(o);
            }),
          a.onComplete(e.defaultValue(t.complete, null)),
          a.repeat(e.defaultValue(t._repeat, 0));
        const l = new Gd(
          this,
          a,
          t.startObject,
          t.stopObject,
          t.duration,
          s,
          n,
          t.update,
          t.complete,
          t.cancel,
        );
        return this._tweens.push(l), l;
      }
      addProperty(t) {
        const i = (t = e.defaultValue(t, e.defaultValue.EMPTY_OBJECT)).object,
          s = t.property;
        return this.add({
          startObject: { value: t.startValue },
          stopObject: { value: t.stopValue },
          duration: e.defaultValue(t.duration, 3),
          delay: t.delay,
          easingFunction: t.easingFunction,
          update: function (e) {
            i[s] = e.value;
          },
          complete: t.complete,
          cancel: t.cancel,
          _repeat: t._repeat,
        });
      }
      addAlpha(t) {
        const i = (t = e.defaultValue(t, e.defaultValue.EMPTY_OBJECT)).material,
          s = [];
        for (const t in i.uniforms)
          i.uniforms.hasOwnProperty(t) &&
            e.defined(i.uniforms[t]) &&
            e.defined(i.uniforms[t].alpha) &&
            s.push(t);
        return this.add({
          startObject: { alpha: e.defaultValue(t.startValue, 0) },
          stopObject: { alpha: e.defaultValue(t.stopValue, 1) },
          duration: e.defaultValue(t.duration, 3),
          delay: t.delay,
          easingFunction: t.easingFunction,
          update: function (e) {
            const t = s.length;
            for (let r = 0; r < t; ++r) i.uniforms[s[r]].alpha = e.alpha;
          },
          complete: t.complete,
          cancel: t.cancel,
        });
      }
      addOffsetIncrement(t) {
        const i = (t = e.defaultValue(t, e.defaultValue.EMPTY_OBJECT)).material.uniforms;
        return this.addProperty({
          object: i,
          property: 'offset',
          startValue: i.offset,
          stopValue: i.offset + 1,
          duration: t.duration,
          delay: t.delay,
          easingFunction: t.easingFunction,
          update: t.update,
          cancel: t.cancel,
          _repeat: 1 / 0,
        });
      }
      remove(t) {
        if (!e.defined(t)) return !1;
        const i = this._tweens.indexOf(t);
        return (
          -1 !== i &&
          (t.tweenjs.stop(), e.defined(t.cancel) && t.cancel(), this._tweens.splice(i, 1), !0)
        );
      }
      removeAll() {
        const t = this._tweens;
        for (let i = 0; i < t.length; ++i) {
          const s = t[i];
          s.tweenjs.stop(), e.defined(s.cancel) && s.cancel();
        }
        t.length = 0;
      }
      contains(t) {
        return e.defined(t) && -1 !== this._tweens.indexOf(t);
      }
      get(e) {
        return this._tweens[e];
      }
      update(t) {
        const i = this._tweens;
        let s = 0;
        for (t = e.defined(t) ? t / Fd.SECONDS_PER_MILLISECOND : kd(); s < i.length; ) {
          const e = i[s],
            r = e.tweenjs;
          e.needsStart
            ? ((e.needsStart = !1), r.start(t))
            : r.update(t)
            ? s++
            : (r.stop(), i.splice(s, 1));
        }
      }
    }
    class zd {
      constructor() {}
      static createUpdateFunction(t, i, s, r, n) {
        let o = 0;
        return function (a) {
          const l = a.time / i;
          (t._pinchOperationData._headingDiff = (s * l - o) * e.CONSTS.TRANSFORM.DEG_TO_RAD || 0),
            (o = s * l),
            (t.pinchPosition = r),
            n();
        };
      }
      static createTween(e, t) {
        const i = t.duration,
          s = t.complete,
          r = t.cancel;
        return {
          duration: i,
          easingFunction: t.easingFunction,
          startObject: { time: 0 },
          stopObject: { time: i },
          update: zd.createUpdateFunction(e, i, t.heading, t.pinchPosition, t.updateExtraFunction),
          complete: s,
          cancel: r,
        };
      }
    }
    class Hd {
      constructor() {}
      static reduceVertices(t, i) {
        const s = new e.Vector3(),
          r = new e.Vector3(),
          n = [],
          o = t.length;
        if (o <= 2) return t;
        let a = 0,
          l = 0;
        for (n.push(e.clone(t[0])); a < o - 1; ) {
          let h = a + 1;
          for (qd(t, a, s), qd(t, h, r), l = Zd(s, r); l <= i && ((h += 1), !(h > o - 1)); )
            qd(t, h, r), (l = Zd(s, r));
          n.push(e.clone(r)), (a = h);
        }
        return e.clone(n);
      }
      static chaiken(t, i, s) {
        let r = 0,
          n = new e.Vector3(),
          o = new e.Vector3(),
          a = [];
        if (((r = t.length), r < 3)) return t;
        const l = 1 / (1 + s),
          h = s / (1 + s);
        (n = qd(t, 0, n)), (o = qd(t, r - 1, o));
        let c = e.clone(t);
        for (let t = 0; t < i; t++) jd(c, a, l, h), (c = e.clone(a)), (a = []);
        return c.unshift(n), c.push(o), e.clone(c);
      }
      static boyle(t, i) {
        const s = new e.Vector3(),
          r = new e.Vector3();
        let n = new e.Vector3(),
          o = 1,
          a = 0,
          l = 0,
          h = 0,
          c = 0;
        const _ = t.length;
        if (i < 2 || i > _) return t;
        for (qd(t, 0, n), h = 1 / (i - 1), c = 1 - h; a < _ - 2; )
          (l = a + i),
            l >= _ && (l = _ - 1),
            qd(t, l, s),
            Xd(s, h, s),
            Xd(n, c, n),
            ((m = r).x = (u = n).x + (d = s).x),
            (m.y = u.y + d.y),
            (m.z = u.z + d.z),
            (t[o] = e.clone(r)),
            (o += 1),
            (a += 1),
            (n = e.clone(r));
        var u, d, m;
        return (
          (function (e, t) {
            const i = e.length;
            (e[t].x = e[i - 1].x), (e[t].y = e[i - 1].y), (e[t].z = e[i - 1].z);
          })(t, o),
          t
        );
      }
    }
    function Wd(e, t, i, s) {
      (s.x = e.x + (t.x - e.x) * i), (s.y = e.y + (t.y - e.y) * i), (s.z = e.z + (t.z - e.z) * i);
    }
    function jd(t, i, s, r) {
      const n = new e.Vector3(),
        o = new e.Vector3(),
        a = new e.Vector3(),
        l = new e.Vector3();
      for (let h = 0; h < t.length && h !== t.length - 1; h++)
        qd(t, h, n),
          qd(t, h + 1, o),
          Wd(n, o, s, a),
          Wd(n, o, r, l),
          i.push(e.clone(a)),
          i.push(e.clone(l));
    }
    function qd(e, t, i) {
      return (i.x = e[t].x), (i.y = e[t].y), (i.z = e[t].z), i;
    }
    function Xd(e, t, i) {
      return (i.x = e.x * t), (i.y = e.y * t), (i.z = e.z * t), i;
    }
    function Zd(e, t) {
      const i = e.x - t.x,
        s = e.y - t.y,
        r = e.z - t.z;
      return Math.sqrt(i * i + s * s + r * r);
    }
    class $d {
      constructor(t, i) {
        (this.roamingOptions = t),
          (this.map = i),
          (this.roamInterval = t.roamInterval),
          (this.roamPitch = t.pitch),
          (this.bearing = t.bearing),
          (this.heightOffset = t.heightOffset),
          (this.currentMileage = 0),
          (this.currentIndex = 0),
          (this.roamLength = 0),
          (this.roamSegments = []),
          (this.points = []),
          (this.stages = []);
        let s = t.positions;
        if (s && s.length % 3 != 0) throw new Error('Incorrect number of positions!');
        let r,
          n = s.length / 3,
          o = [];
        for (let t = 0; t < n; t++) o.push(e.Vector3.fromArray(s.slice(3 * t, 3 * t + 3)));
        n > 50
          ? ((o = Hd.reduceVertices(o, 5e-5)),
            (o = Hd.boyle(o, 7)),
            (o = Hd.boyle(o, 5)),
            (r = Hd.chaiken(o, 1, 3)),
            (s = r.map((e) => [e[0], e[1], e[2]]).flat()))
          : (r = o),
          (n = r.length);
        for (let t = 0; t < n - 1; t++) {
          const i = e.Vector3.fromArray(
              e.Transforms.cartographicToCartesian3(s.slice(3 * t, 3 * t + 3)),
            ),
            r = e.Vector3.fromArray(
              e.Transforms.cartographicToCartesian3(s.slice(3 * (t + 1), 3 * (t + 1) + 3)),
            ),
            n = e.Vector3.distance(i, r);
          this.roamSegments.push(n), (this.roamLength += n);
        }
        let a = 0;
        for (let t = 0; t < n; t++)
          this.points.push(
            e.Vector3.fromArray(e.Transforms.cartographicToCartesian3(s.slice(3 * t, 3 * t + 3))),
          ),
            0 === t ? this.stages.push(0) : ((a += this.roamSegments[t - 1]), this.stages.push(a));
      }
      getRoamingParam() {
        this.update();
        const {
          weight: t,
          pointCurrent: i,
          pointNext: s,
          currentIndex: r,
        } = this.getWeightAndPoints(this.stages, this.points, this.currentMileage);
        let n;
        (this.currentIndex = r),
          (n = 0 === this.currentMileage ? this.points[0] : this.map.camera.position);
        const o = this.getLinearInterpolationPosition(t, i, s);
        1 === t && (this.currentMileage = this.stages.at(r + 1)),
          o[0] === this.points.at(-1)[0] &&
            o[1] === this.points.at(-1)[1] &&
            o[2] === this.points.at(-1)[2] &&
            (this.map._roaming = !1);
        const a = e.Transforms.cartesian3ToCartographic(n),
          l = e.Transforms.cartesian3ToCartographic(o),
          h = d(a[1], a[0], l[1], l[0]).bearing,
          c = Math.asin(
            (l[2] - a[2]) / e.Vector3.distance(e.Vector3.fromArray(o), e.Vector3.fromArray(n)),
          );
        return {
          position: [l[0], l[1], l[2] + this.heightOffset],
          bearing: e.defined(this.bearing) ? this.bearing + h : h,
          pitch: this.roamPitch + c,
          trackIndex: this.currentIndex + 1,
          currentPosition: l,
          currentMileage: this.currentMileage,
          totalMileage: this.roamLength,
        };
      }
      getWeightAndPoints(e, t, i) {
        const s = this.leftBinarySearch(e, i, 0, e.length - 2),
          r = e[s];
        return {
          weight: Math.min((i - r) / (e[s + 1] - r), 1),
          pointCurrent: t[s],
          pointNext: t[s + 1],
          currentIndex: s,
        };
      }
      getLinearInterpolationPosition(e, t, i) {
        return [(i[0] - t[0]) * e + t[0], (i[1] - t[1]) * e + t[1], (i[2] - t[2]) * e + t[2]];
      }
      leftBinarySearch(e, t, i, s) {
        const r = Math.floor((i + s) / 2),
          n = e[r];
        return i > s
          ? r
          : n > t
          ? this.leftBinarySearch(e, t, i, r - 1)
          : n < t
          ? this.leftBinarySearch(e, t, r + 1, s)
          : r;
      }
      update() {
        (this.roamInterval = this.map.roamingOptions.roamInterval),
          (this.roamPitch = this.map.roamingOptions.pitch),
          (this.bearing = this.map.roamingOptions.bearing),
          (this.heightOffset = this.map.roamingOptions.heightOffset),
          (this.currentMileage += this.roamInterval);
      }
    }
    class Kd extends e.Evented {
      _minimumCameraCheckHeight = 2e3;
      _minimumCameraCheckHeightNoTerrain = 1;
      _maxmumCameraCheckHeight = 1e4;
      constructor(t, i) {
        super(),
          (this._moving = !1),
          (this._zooming = !1),
          (this.transform = t),
          (this._bearingSnap = i.bearingSnap),
          (this.latRange = [e.CONSTS.TRANSFORM.MIN_LAT, e.CONSTS.TRANSFORM.MAX_LAT]),
          (this._roaming = !1),
          (this.roamObject = void 0),
          (this.tweens = new Ud()),
          e.bindAll(['_renderFrameCallback'], this);
      }
      getCenter() {
        return this.transform.center;
      }
      setCenter(e, t) {
        return this.jumpTo({ center: e }, t);
      }
      getCameraPosition() {
        return new e.Vector3(this.transform.position);
      }
      setCameraPosition(e, t) {
        return this.jumpTo({ target: e }, t), this;
      }
      panBy(t, i, s) {
        return (
          (t = e.pointGeometry3d.convert(t).mult(-1)),
          this.panTo(this.transform.center, e.extend({ offset: t }, i), s)
        );
      }
      panTo(t, i, s) {
        return this.easeTo(e.extend({ center: t }, i), s);
      }
      getZoom() {
        return this.transform.zoom;
      }
      setZoom(e, t) {
        return this.jumpTo({ zoom: e, center: this.getCenter() }, t), this;
      }
      setCameraHeight(e, t) {
        return (
          this.jumpTo({ target: [this.transform.position[0], this.transform.position[1], e] }, t),
          this
        );
      }
      zoomTo(t, i, s) {
        return this.easeTo(
          e.extend(
            {
              center: this.getCenter(),
              zoom: e.clamp(t, this.transform.minZoom, this.transform.maxZoom),
            },
            i,
          ),
          s,
        );
      }
      zoomIn(e, t) {
        return this.zoomTo(this.getZoom() + 1, e, t), this;
      }
      zoomOut(e, t) {
        return this.zoomTo(this.getZoom() - 1, e, t), this;
      }
      getBearing() {
        return this.transform.getMapViewParams().bearing;
      }
      getCameraBearing() {
        return this.transform.bearing;
      }
      setBearing(e, t) {
        const i = this.transform.getMapViewParams();
        return this.jumpTo({ bearing: e, center: i.center, zoom: i.zoom }, t), this;
      }
      setCameraBearing(e, t) {
        return this.jumpTo({ bearing: e }, t), this;
      }
      getPadding() {
        return this.transform.padding;
      }
      setPadding(e, t) {
        return this.jumpTo({ padding: e }, t), this;
      }
      rotateTo(t, i, s) {
        return this.easeTo(
          e.extend({ bearing: t, center: this.getCenter(), zoom: this.getZoom() }, i),
          s,
        );
      }
      resetNorth(t, i) {
        return this.rotateTo(0, e.extend({ duration: 1e3 }, t), i), this;
      }
      snapToNorth(e, t) {
        return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, t) : this;
      }
      getPitch() {
        return this.transform.getMapViewParams().pitch;
      }
      getCameraPitch() {
        return this.transform.pitch;
      }
      setPitch(e, t) {
        const i = this.transform.getMapViewParams();
        return this.jumpTo({ pitch: e, center: i.center, zoom: i.zoom }, t), this;
      }
      setCameraPitch(e, t) {
        return this.jumpTo({ pitch: e }, t), this;
      }
      getRoll() {
        return this.transform.getMapViewParams().roll;
      }
      getCameraRoll() {
        return this.transform.roll;
      }
      setRoll(e, t) {
        const i = this.transform.getMapViewParams();
        return this.jumpTo({ roll: e, center: i.center, zoom: i.zoom }, t), this;
      }
      setCameraRoll(e, t) {
        return this.jumpTo({ roll: e }, t), this;
      }
      cameraForBounds(t, i) {
        return (
          (t = e.LngLatBounds.convert(t)),
          this._cameraForBoxAndBearing(t.getNorthWest(), t.getSouthEast(), 0, i)
        );
      }
      _cameraForBoxAndBearing(i, s, r, n) {
        if (
          'number' ==
          typeof (n = e.extend(
            {
              padding: { top: 0, bottom: 0, right: 0, left: 0 },
              offset: [0, 0],
              maxZoom: this.transform.maxZoom,
            },
            n,
          )).padding
        ) {
          const e = n.padding;
          n.padding = { top: e, bottom: e, right: e, left: e };
        }
        if (
          !t(
            Object.keys(n.padding).sort((e, t) => (e < t ? -1 : e > t ? 1 : 0)),
            ['bottom', 'left', 'right', 'top'],
          )
        )
          return void e.warnOnce(
            "options.padding must be a positive number, or an Object with keys 'bottom', 'left', 'right', 'top'",
          );
        const o = [(n.padding.left - n.padding.right) / 2, (n.padding.top - n.padding.bottom) / 2],
          a = Math.min(n.padding.right, n.padding.left),
          l = Math.min(n.padding.top, n.padding.bottom);
        n.offset = [n.offset[0] + o[0], n.offset[1] + o[1]];
        const h = e.pointGeometry3d.convert(n.offset),
          c = this.transform,
          _ = this._calcOffsetDifLngLat(h);
        n.center = { lng: (i.lng + s.lng) / 2 - _[0], lat: (i.lat + s.lat) / 2 - _[1] };
        const u = e.Transforms.cartographicToCartesian3(
            new e.Vector3([(i.lng + s.lng) / 2, i.lat, 0]),
          ),
          d = e.Transforms.cartographicToCartesian3(new e.Vector3([(i.lng + s.lng) / 2, s.lat, 0])),
          m = Math.sqrt(
            Math.pow(u[0] - d[0], 2) + Math.pow(u[1] - d[1], 2) + Math.pow(u[2] - d[2], 2),
          ),
          p = Math.atan(((c.height - l) / c.height) * Math.tan(c._fov / 2)),
          f = e.Transforms.cartographicToCartesian3(new e.Vector3([i.lng, (i.lat + s.lat) / 2, 0])),
          g = e.Transforms.cartographicToCartesian3(new e.Vector3([s.lng, (i.lat + s.lat) / 2, 0])),
          y = Math.sqrt(
            Math.pow(f[0] - g[0], 2) + Math.pow(f[1] - g[1], 2) + Math.pow(f[2] - g[2], 2),
          ),
          T = Math.atan(((c.width - a) / c.height) * Math.tan(c._fov / 2)),
          x = c.width / y,
          v = c.height / m;
        if (v < 0 || x < 0)
          return void e.warnOnce(
            'Map cannot fit within canvas with the given bounds, padding, and/or offset.',
          );
        let b, w;
        v < x ? ((b = p), (w = m)) : ((b = T), (w = y));
        const C = Math.asin(w / 2 / e.CONSTS.TRANSFORM.R),
          S = (Math.sin(Math.PI - b - C) * e.CONSTS.TRANSFORM.R) / Math.sin(b);
        return (
          (n.zoom = e.getZoomFromDistance(c._fov, S, e.CONSTS.TRANSFORM.R)), (n.bearing = 0), n
        );
      }
      fitBounds(t, i, s, r) {
        const n = this.boundsToPosition(t, i, r);
        return (
          (i = i || {}),
          this.flyTo(
            void 0 !== (s = s || void 0)
              ? {
                  target: [n[0], n[1], n[2] + s],
                  bearing: 0,
                  pitch: e.defined(i.pitch) ? i.pitch : 0,
                  roll: 0,
                  duration: i.duration,
                  complete: i.complete,
                  cancel: i.cancel,
                  endTransform: i.endTransform,
                  maximumHeight: i.maximumHeight,
                  easingFunction: i.easing,
                  flyOverLongitude: i.flyOverLongitude,
                  flyOverLongitudeWeight: i.flyOverLongitudeWeight,
                  pitchAdjustHeight: i.pitchAdjustHeight,
                }
              : {
                  center: [n[0], n[1]],
                  zoom: e.defined(i.zoom) ? i.zoom : n[3],
                  bearing: 0,
                  pitch: e.defined(i.pitch) ? i.pitch : 0,
                  roll: 0,
                  duration: i.duration,
                  complete: i.complete,
                  cancel: i.cancel,
                  endTransform: i.endTransform,
                  maximumHeight: i.maximumHeight,
                  easingFunction: i.easing,
                  flyOverLongitude: i.flyOverLongitude,
                  flyOverLongitudeWeight: i.flyOverLongitudeWeight,
                  pitchAdjustHeight: i.pitchAdjustHeight,
                },
            r,
          )
        );
      }
      boundsToPosition(t, i, s) {
        const r = (t = e.LngLatBounds.convert(t)).getNorthWest(),
          n = t.getSouthEast(),
          o = 180;
        let a = o;
        (i = i || {}) && i.padding && null != i.padding.left && (a = i.padding.left);
        let l = o;
        i && i.padding && null != i.padding.right && (l = i.padding.right);
        let h = o;
        i && i.padding && null != i.padding.top && (h = i.padding.top);
        let c = o;
        i && i.padding && null != i.padding.bottom && (c = i.padding.bottom);
        const _ = r.lat > n.lat ? r.lat : n.lat,
          u = r.lat < n.lat ? r.lat : n.lat;
        let d = (_ + u) / 2;
        const m = r.lng < n.lng ? r.lng : n.lng,
          p = r.lng > n.lng ? r.lng : n.lng;
        let f = (m + p) / 2;
        const g = new e.Vector3(e.Transforms.DefaultEllipsoid.cartographicToCartesian([f, _, 0])),
          y = new e.Vector3(e.Transforms.DefaultEllipsoid.cartographicToCartesian([f, u, 0]));
        let T = e.Vector3.distance(g, y);
        (T *= this.transform.height / (this.transform.height - h - c)),
          (T = T / 2 / Math.tan(this.transform._fov / 2));
        const x = new e.Vector3(e.Transforms.DefaultEllipsoid.cartographicToCartesian([m, d, 0])),
          v = new e.Vector3(e.Transforms.DefaultEllipsoid.cartographicToCartesian([p, d, 0]));
        let b = e.Vector3.distance(x, v);
        (b *= this.transform.width / (this.transform.width - a - l)),
          (b =
            b /
            2 /
            Math.tan(((this.transform._fov / 2) * this.transform.width) / this.transform.height));
        const w = T > b ? T : b;
        (f -= ((a - l) / (this.transform.width - a - l)) * ((p - m) / 2)),
          (d -= ((c - h) / (this.transform.height - h - c)) * ((_ - u) / 2));
        const C = new e.Vector3(e.Transforms.DefaultEllipsoid.cartographicToCartesian([f, d, 0])),
          S = e.Vector3.normalize(C, new e.Vector3()).multiplyScalar(w);
        S.add(C);
        const E = e.Transforms.DefaultEllipsoid.cartesianToCartographic(S, new e.Vector3()),
          P = e.getZoomFromDistance(
            this.transform._fov,
            E[2] + e.CONSTS.TRANSFORM.R,
            e.CONSTS.TRANSFORM.R,
          );
        return [E[0], E[1], E[2], P];
      }
      fitScreenCoordinates(t, i, s, r, n) {
        return this._fitInternal(
          this._cameraForBoxAndBearing(
            this.transform.pointLocation(e.pointGeometry3d.convert(t)),
            this.transform.pointLocation(e.pointGeometry3d.convert(i)),
            s,
            r,
          ),
          r,
          n,
        );
      }
      _fitInternal(t, i, s) {
        return t ? ((i = e.extend(t, i)).linear ? this.easeTo(i, s) : this.flyTo(i, s)) : this;
      }
      async jumpTo(t, i) {
        const s = !!(t = { ...t }).target || (e.defined(t.zoom) && t.zoom != this.transform.zoom),
          r = t,
          n = await this._convertToMainCameraOptions(r);
        if (1 != n.unchanged)
          return (
            this.jumpTo3D(n, i),
            s &&
              this.fire(new e.Event('zoomstart', i))
                .fire(new e.Event('zoom', i))
                .fire(new e.Event('zoomend', i)),
            this
          );
        t.callback && t.callback(i);
      }
      jumpTo3D(t, i) {
        this.stop();
        const s = this.transform;
        s.position = t.position;
        let r = !1,
          n = !1,
          o = !1;
        'bearing' in t && s.bearing !== +t.bearing && ((r = !0), (s.bearing = +t.bearing)),
          'pitch' in t && s.pitch !== +t.pitch && ((n = !0), (s.pitch = +t.pitch)),
          'roll' in t && s.roll !== +t.roll && ((o = !0), (s.roll = +t.roll)),
          this.fire(new e.Event('movestart', i)).fire(new e.Event('move', i)),
          r &&
            this.fire(new e.Event('rotatestart', i))
              .fire(new e.Event('rotate', i))
              .fire(new e.Event('rotateend', i)),
          n &&
            this.fire(new e.Event('pitchstart', i))
              .fire(new e.Event('pitch', i))
              .fire(new e.Event('pitchend', i)),
          o &&
            this.fire(new e.Event('rollstart', i))
              .fire(new e.Event('roll', i))
              .fire(new e.Event('rollend', i)),
          this.fire(new e.Event('moveend', i));
      }
      easeToByPinchPosition(e, t) {
        this._stop(!1, e.easeId);
        const i = zd.createTween(this.transform, {
          duration: e.duration / 1e3 || 3,
          heading: e.bearing,
          pinchPosition: e.pinchPosition,
          easingFunction: e.easing || Ad.QUINTIC_OUT,
          complete: () => {
            (this.transform.pinchPosition = null), this._afterEase(t), e.callback && e.callback(t);
          },
          updateExtraFunction: () => {
            this._fireMoveEvents(t);
          },
        });
        0 !== i.duration
          ? ((this._currentFlight = this.tweens.add(i)),
            (this._rotating = this._rotating || !0),
            this._prepareEase(t, !1),
            this._ease())
          : 'function' == typeof i.complete && i.complete();
      }
      roam() {
        if (!this._roaming || !this.roamingOptions) return;
        this.roamObject || (this.roamObject = new $d(this.roamingOptions, this));
        const e = this.roamObject.getRoamingParam();
        this.jumpTo({ target: e.position, bearing: e.bearing, pitch: e.pitch }),
          this.callback &&
            this.callback({
              trackIndex: e.trackIndex,
              currentPosition: e.currentPosition,
              currentMileage: e.currentMileage,
              totalMileage: e.totalMileage,
            });
      }
      initRoam(e) {
        (this._roaming = !0), e && (this.callback = e);
      }
      pauseRoam() {
        this._roaming = !1;
      }
      resumeRoam() {
        this._roaming = !0;
      }
      stopRoam() {
        (this._roaming = !1), (this.roamObject = void 0), (this.roamingOptions = null);
      }
      async _convertToMainCameraOptions(t) {
        const i = this.transform,
          s = this.getBearing(),
          r = this.getPitch(),
          n = this.getRoll();
        if (
          ((t.bearing = 'bearing' in t ? this._normalizeBearing(t.bearing, s) : s),
          (t.pitch = 'pitch' in t ? +t.pitch : r),
          (t.roll = 'roll' in t ? this._normalizeBearing(t.roll, n) : n),
          e.defined(t.center) && e.defined(t.zoom))
        ) {
          const s = this.getCenter(),
            r = this.getZoom(),
            n = this.getBearing(),
            o = this.getPitch(),
            a = this.getRoll();
          let l = !0;
          const h = e.LngLat.convert(t.center);
          if (
            ((Math.abs(h.lng - s.lng) > e.CONSTS.CesiumMath.EPSILON11 ||
              Math.abs(h.lat - s.lat) > e.CONSTS.CesiumMath.EPSILON11 ||
              (e.defined(t.zoom) && Math.abs(t.zoom - r) > e.CONSTS.CesiumMath.EPSILON9) ||
              (e.defined(t.bearing) && Math.abs(t.bearing - n) > e.CONSTS.CesiumMath.EPSILON8) ||
              (e.defined(t.pitch) && Math.abs(t.pitch - o) > e.CONSTS.CesiumMath.EPSILON8) ||
              (e.defined(t.roll) && Math.abs(t.roll - a) > e.CONSTS.CesiumMath.EPSILON8)) &&
              (l = !1),
            l)
          )
            return { unchanged: !0, callback: t.callback };
          const c = i.getMapViewParams();
          (t.center = e.LngLat.convert(t.center || c.center).toArray()),
            e.defined(t.zoom) || (t.zoom = c.zoom);
          const _ = e.Transforms.convertV34Pos2V4([
            t.center[0],
            t.center[1],
            t.zoom,
            t.bearing,
            t.pitch,
            t.roll,
          ]);
          return (
            (t.position = [_[0], _[1], _[6][2]]),
            delete t.center,
            (t.bearing = _[3]),
            (t.pitch = _[4]),
            (t.roll = _[5]),
            t
          );
        }
        if (e.defined(t.target) || (e.defined(t.center) && e.defined(t.zoom))) {
          if (
            (e.defined(t.target) || (t.target = i.position),
            t.target instanceof Array || t.target instanceof e.Vector3)
          ) {
            const e = await (async function (e) {
              return { target: e, range: 0 };
            })(t.target);
            (t.position = e.target), (t.position[2] += t.range ? t.range + e.range : e.range);
          } else if (t.target instanceof e.Primitive) {
            const i = await (async function (t) {
              if (!t.boundingSphere) throw new Error('当前的飞行目标没有包围球');
              const i = 2 * t.boundingSphere.radius;
              return {
                target: e.Transforms.cartesian3ToCartographic(t.boundingSphere.center),
                range: i,
              };
            })(t.target);
            (t.position = i.target), (t.position[2] += t.range ? t.range + i.range : i.range);
          } else if (
            t.target instanceof e.BoundingSphere ||
            t.target instanceof e.OrientedBoundingBox ||
            t.target instanceof e.AxisAlignedBoundingBox
          ) {
            const i = await (async function (t) {
              let i, s;
              if (t instanceof e.BoundingSphere) (i = t.center), (s = t.radius);
              else if (t instanceof e.OrientedBoundingBox) {
                const e = t.getBoundingSphere();
                (i = e.center), (s = e.radius);
              } else if (t instanceof e.AxisAlignedBoundingBox) {
                i = t.center;
                const e = t.halfDiagonal;
                s = Math.max(e[0], e[1], e[2]);
              }
              return { target: e.Transforms.cartesian3ToCartographic(i), range: 2 * s };
            })(t.target);
            (t.position = i.target), (t.position[2] += t.range ? t.range + i.range : i.range);
          } else if (t.target instanceof Tn) {
            const i = this.style.sourceCaches[t.target.id];
            let s = [],
              r = [];
            (s = s.concat(i.getOpaquePrimitives(), i.getTranslucentPrimitives())),
              s.forEach((e) => {
                r.push(e.boundingBox.center);
              }),
              (r = r.filter((e) => !isNaN(e[0]) && !isNaN(e[1]) && !isNaN(e[2])));
            const n = Math.min.apply(
                null,
                r.map((e) => e.x),
              ),
              o = Math.max.apply(
                null,
                r.map((e) => e.x),
              ),
              a = Math.min.apply(
                null,
                r.map((e) => e.y),
              ),
              l = Math.max.apply(
                null,
                r.map((e) => e.y),
              ),
              h = Math.min.apply(
                null,
                r.map((e) => e.z),
              ),
              c = Math.max.apply(
                null,
                r.map((e) => e.z),
              );
            (t.position = e.Transforms.cartesian3ToCartographic(
              new e.Vector3((n + o) / 2, (a + l) / 2, (h + c) / 2),
            )),
              t.range && (t.position[2] += t.range);
          } else if (t.target instanceof xn) {
            const e = this.boundsToPosition(this.style.sourceCaches[t.target.id]._geoBounds[0]);
            (t.position = e), t.range && (t.position[2] += t.range);
          } else if (t.target instanceof Ar || t.target instanceof e.ModelInstance) {
            const e = this.boundsToPosition(t.target.getBounds());
            (t.position = e), t.range && (t.position[2] += t.range);
          } else if (t.target instanceof mh) {
            const e = this.boundsToPosition(t.target.getBounds());
            (t.position = e), t.range && (t.position[2] += t.range);
          }
          const s = i.position,
            r = this.getCameraBearing(),
            n = this.getCameraPitch(),
            o = this.getCameraRoll();
          let a = !0;
          return (
            (Math.abs(s[0] - t.position[0]) > e.CONSTS.CesiumMath.EPSILON11 ||
              Math.abs(s[0] - t.position[0]) > e.CONSTS.CesiumMath.EPSILON11 ||
              Math.abs(s[0] - t.position[0]) > e.CONSTS.CesiumMath.EPSILON10 ||
              (e.defined(t.bearing) && Math.abs(t.bearing - r) > e.CONSTS.CesiumMath.EPSILON8) ||
              (e.defined(t.pitch) && Math.abs(t.pitch - n) > e.CONSTS.CesiumMath.EPSILON8) ||
              (e.defined(t.roll) && Math.abs(t.roll - o) > e.CONSTS.CesiumMath.EPSILON8)) &&
              (a = !1),
            a ? { unchanged: !0, callback: t.callback } : t
          );
        }
        {
          const s = i.getMapViewParams();
          (t.center = e.LngLat.convert(t.center || s.center).toArray()),
            e.defined(t.zoom) || (t.zoom = s.zoom);
          const r = e.Transforms.convertV34Pos2V4([
            t.center[0],
            t.center[1],
            t.zoom,
            t.bearing,
            t.pitch,
            t.roll,
          ]);
          return (
            (t.position = [r[0], r[1], r[6][2]]),
            delete t.center,
            (t.bearing = r[3]),
            (t.pitch = r[4]),
            (t.roll = r[5]),
            t
          );
        }
      }
      async easeTo(t, i) {
        const s = !!(t = { ...t }).target || (e.defined(t.zoom) && t.zoom != this.transform.zoom);
        if (1 == (t = await this._convertToMainCameraOptions(t)).unchanged)
          return void (t.callback && t.callback(i));
        this._stop(!1, t.easeId),
          !1 === (t = e.extend({ offset: [0, 0], duration: 500 }, t)).animate && (t.duration = 0);
        const r = this.getBearing(),
          n = this.getPitch(),
          o = this.getRoll(),
          a = 'bearing' in t ? this._normalizeBearing(t.bearing, r) : r,
          l = 'pitch' in t ? +t.pitch : n,
          h = 'roll' in t ? this._normalizeBearing(t.roll, o) : o;
        let c;
        c =
          t.position && 0 == t.offset[0] && 0 == t.offset[1]
            ? [0, 0]
            : this._calcOffsetDifLngLat(t.offset);
        const _ = {
          moving: this._moving,
          zooming: this._zooming,
          rotating: this._rotating,
          pitching: this._pitching,
          rolling: this._rolling,
        };
        (this._easeId = t.easeId), this._prepareEase(i, t.noMoveStart, _);
        const u = {};
        (u.cancel = t.cancel),
          (u.complete = () => {
            this._afterEase(i), t.callback && t.callback(i);
          }),
          (u.updateExtraFunction = () => {
            this._fireMoveEvents(i);
          }),
          (u.destination = [t.position[0] + c[0], t.position[1] + c[1], t.position[2]]),
          (u.heading = a * e.CONSTS.TRANSFORM.DEG_TO_RAD),
          (u.pitch = l * e.CONSTS.TRANSFORM.DEG_TO_RAD),
          (u.roll = h * e.CONSTS.TRANSFORM.DEG_TO_RAD),
          (u.duration = e.defined(t.duration) ? t.duration : 1e3),
          (u.duration /= 1e3),
          (u.maximumHeight = t.maximumHeight),
          (u.pitchAdjustHeight = t.pitchAdjustHeight),
          (u.flyOverLongitude = t.flyOverLongitude),
          (u.flyOverLongitudeWeight = t.flyOverLongitudeWeight),
          (u.isEaseToType = !0),
          (u.easingFunction = t.easing || Ad.QUINTIC_OUT);
        const d = Id.createTween(this.transform, u);
        if (0 !== d.duration)
          return (
            (this._currentFlight = this.tweens.add(d)),
            (this._zooming = s),
            (this._rotating = this._rotating || r !== a),
            (this._pitching = this._pitching || l !== n),
            (this._rolling = this._rolling || h !== o),
            this._prepareEase(i, !1),
            this._ease(),
            this
          );
        'function' == typeof d.complete && d.complete();
      }
      _calcOffsetDifLngLat(t) {
        t instanceof Array && (t = { x: t[0], y: t[1] });
        const i = this.transform;
        let s = 0,
          r = 0,
          n = 0;
        if (0 !== t.x && 0 !== t.y)
          Math.abs(t.x) > Math.abs(t.y)
            ? ((s = 10), (r = (10 * t.y) / t.x), (n = t.x / 10))
            : ((s = (10 * t.x) / t.y), (r = 10), (n = t.y / 10));
        else if (0 !== t.x && 0 === t.y) (s = 10), (n = t.x / 10);
        else {
          if (0 !== t.x || 0 === t.y) return [0, 0];
          (r = 10), (n = t.y / 10);
        }
        const o = i.pointLocation(new e.pointGeometry3d(i.width / 2 + s, i.height / 2 + 10 + r)),
          a = i.pointLocation(new e.pointGeometry3d(i.width / 2, i.height / 2 + 10));
        return o && a ? [(a.lng - o.lng) * n, (a.lat - o.lat) * n] : [0, 0];
      }
      _prepareEase(t, i, s = {}) {
        (this._moving = !0),
          i || s.moving || this.fire(new e.Event('movestart', t)),
          this._zooming && !s.zooming && this.fire(new e.Event('zoomstart', t)),
          this._rotating && !s.rotating && this.fire(new e.Event('rotatestart', t)),
          this._pitching && !s.pitching && this.fire(new e.Event('pitchstart', t)),
          this._rolling && !s.rolling && this.fire(new e.Event('rollstart', t));
      }
      _fireMoveEvents(t) {
        this.fire(new e.Event('move', t)),
          this._zooming && this.fire(new e.Event('zoom', t)),
          this._rotating && this.fire(new e.Event('rotate', t)),
          this._pitching && this.fire(new e.Event('pitch', t)),
          this._rolling && this.fire(new e.Event('roll', t));
      }
      _afterEase(t, i) {
        if (this._easeId && i && this._easeId === i) return;
        delete this._easeId;
        const s = this._zooming,
          r = this._rotating,
          n = this._pitching,
          o = this._rolling;
        (this._moving = !1),
          (this._zooming = !1),
          (this._rotating = !1),
          (this._pitching = !1),
          (this._rolling = !1),
          s && this.fire(new e.Event('zoomend', t)),
          r && this.fire(new e.Event('rotateend', t)),
          n && this.fire(new e.Event('pitchend', t)),
          o && this.fire(new e.Event('rollend', t)),
          this.fire(new e.Event('moveend', t));
      }
      flyToBoundingSphere(e, t) {
        console.error(
          '此方法已经废弃！ //替代方案，采用map.flyTo({target: boundingSphere}); 或参考开发文档',
        );
      }
      async flyTo(t, i) {
        const s = !!(t = { ...t }).target || (e.defined(t.zoom) && t.zoom != this.transform.zoom);
        if (1 == (t = await this._convertToMainCameraOptions(t)).unchanged)
          return void (t.callback && t.callback(i));
        this.stop(), (t = e.extend({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: e.ease }, t));
        const r = this.getBearing(),
          n = this.getPitch(),
          o = this.getRoll(),
          a = 'bearing' in t ? this._normalizeBearing(t.bearing, r) : r,
          l = 'pitch' in t ? +t.pitch : n,
          h = 'roll' in t ? this._normalizeBearing(t.roll, o) : o,
          c = {};
        (c.cancel = t.cancel),
          (c.complete = () => {
            this._afterEase(i), t.callback && t.callback(i);
          }),
          (c.updateExtraFunction = () => {
            this._fireMoveEvents(i);
          }),
          (c.destination = t.position),
          (c.heading = a * e.CONSTS.TRANSFORM.DEG_TO_RAD),
          (c.pitch = l * e.CONSTS.TRANSFORM.DEG_TO_RAD),
          (c.roll = h * e.CONSTS.TRANSFORM.DEG_TO_RAD),
          (c.duration = e.defined(t.duration) ? t.duration : 1e3),
          (c.duration /= 1e3),
          (c.maximumHeight = t.maximumHeight),
          (c.pitchAdjustHeight = t.pitchAdjustHeight),
          (c.flyOverLongitude = t.flyOverLongitude),
          (c.flyOverLongitudeWeight = t.flyOverLongitudeWeight),
          (c.easingFunction = t.easing);
        const _ = Id.createTween(this.transform, c);
        if (0 !== _.duration)
          return (
            (this._currentFlight = this.tweens.add(_)),
            (this._zooming = s),
            (this._rotating = r !== a),
            (this._pitching = l !== n),
            (this._rolling = h !== o),
            this._prepareEase(i, !1),
            this._ease(),
            this
          );
        'function' == typeof _.complete && _.complete();
      }
      isEasing() {
        return !!this._easeFrameId;
      }
      stop() {
        return this._stop();
      }
      _stop(e, t) {
        if (
          (this._currentFlight && (this._currentFlight.cancelTween(), (this._currentFlight = null)),
          this.tweens.removeAll(),
          this._easeFrameId &&
            (this._cancelRenderFrame(this._easeFrameId),
            delete this._easeFrameId,
            delete this._onEaseFrame),
          this._onEaseEnd)
        ) {
          const e = this._onEaseEnd;
          delete this._onEaseEnd, e.call(this, t);
        }
        if (!e) {
          const e = this.handlers;
          e && e.stop(!1);
        }
        return this;
      }
      _ease() {
        e.defined(this._easeFrameId) ||
          (this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
      }
      _renderFrameCallback() {
        this.tweens.update(),
          (this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
      }
      _normalizeBearing(t, i) {
        t = e.wrap(t, -180, 180);
        const s = Math.abs(t - i);
        return Math.abs(t - 360 - i) < s && (t -= 360), Math.abs(t + 360 - i) < s && (t += 360), t;
      }
    }
    new e.Vector3(),
      new e.Quaternion(),
      new e.Quaternion(),
      new e.Matrix3(),
      new e.Matrix4(),
      new e.Matrix4(),
      new e.Vector3(),
      new e.Vector3(),
      new e.Vector3();
    class Yd {
      constructor(t = {}) {
        (this.options = t), e.bindAll(['_updateEditLink', '_updateData', '_updateCompact'], this);
      }
      getDefaultPosition() {
        return 'bottom-right';
      }
      onAdd(e) {
        const t = this.options && this.options.compact;
        return (
          (this._map = e),
          (this._container = Ur.create('div', 'minemap-ctrl minemap-ctrl-attrib')),
          t && this._container.classList.add('minemap-compact'),
          this._updateAttributions(),
          this._updateEditLink(),
          this._map.on('sourcedata', this._updateData),
          this._map.on('moveend', this._updateEditLink),
          void 0 === t && (this._map.on('resize', this._updateCompact), this._updateCompact()),
          this._container
        );
      }
      onRemove() {
        Ur.remove(this._container),
          this._map.off('sourcedata', this._updateData),
          this._map.off('moveend', this._updateEditLink),
          this._map.off('resize', this._updateCompact),
          (this._map = void 0);
      }
      _updateEditLink() {
        let e = this._editLink;
        e || (e = this._editLink = this._container.querySelector('.minemap-improve-map'));
        const t = [
          { key: 'owner', value: this.styleOwner },
          { key: 'id', value: this.styleId },
          { key: 'access_token', value: pr.ACCESS_TOKEN },
        ];
        if (e) {
          const i = t.reduce(
            (e, i, s) => (i.value && (e += `${i.key}=${i.value}${s < t.length - 1 ? '&' : ''}`), e),
            '?',
          );
          e.href = `https://www.minemap.com/feedback/${i}${
            this._map._hash ? this._map._hash.getHashString(!0) : ''
          }`;
        }
      }
      _updateData(e) {
        e &&
          'metadata' === e.sourceDataType &&
          (this._updateAttributions(), this._updateEditLink());
      }
      _updateAttributions() {
        if (!this._map.style) return;
        let e = [];
        if (this._map.style.stylesheet) {
          const e = this._map.style.stylesheet;
          (this.styleOwner = e.owner), (this.styleId = e.id);
        }
        const t = this._map.style.sourceCaches;
        for (const i in t) {
          const s = t[i].getSource();
          s.attribution && e.indexOf(s.attribution) < 0 && e.push(s.attribution);
        }
        e.sort((e, t) => e.length - t.length),
          (e = e.filter((t, i) => {
            for (let s = i + 1; s < e.length; s++) if (e[s].indexOf(t) >= 0) return !1;
            return !0;
          })),
          e.length
            ? ((this._container.innerHTML = e.join(' | ')),
              this._container.classList.remove('minemap-attrib-empty'))
            : this._container.classList.add('minemap-attrib-empty'),
          (this._editLink = null);
      }
      _updateCompact() {
        this._map.getCanvasContainer().offsetWidth <= 640
          ? this._container.classList.add('minemap-compact')
          : this._container.classList.remove('minemap-compact');
      }
    }
    class Qd {
      constructor() {
        e.bindAll(['_updateLogo'], this);
      }
      onAdd(e, t) {
        (this._map = e), (this._container = Ur.create('div', 'minemap-ctrl'));
        const i = Ur.create('a', 'minemap-ctrl-logo');
        return (
          (i.target = '_blank'),
          (i.href = t || 'https://www.minedata.cn/'),
          i.setAttribute('aria-label', this._map._getUIString('LogoControl.Title')),
          i.setAttribute('rel', 'noopener'),
          this._container.appendChild(i),
          (this._container.style.display = 'none'),
          this._map.on('sourcedata', this._updateLogo),
          this._updateLogo(),
          this._container
        );
      }
      onRemove() {
        Ur.remove(this._container), this._map.off('sourcedata', this._updateLogo);
      }
      getDefaultPosition() {
        return 'bottom-left';
      }
      _updateLogo(e) {
        (e && 'metadata' !== e.sourceDataType) ||
          (this._container.style.display = this._logoRequired() ? 'block' : 'none');
      }
      _logoRequired() {
        if (this._map.style) return !0;
      }
    }
    class Jd {
      constructor() {}
      max(e) {
        return Math.max.apply(null, e);
      }
      min(e) {
        return Math.min.apply(null, e);
      }
      range(e) {
        return this.max(e) - this.min(e);
      }
      midrange(e) {
        return this.range(e) / 2;
      }
      sum(e) {
        let t = 0;
        for (let i = 0, s = e.length; i < s; i++) t += e[i];
        return t;
      }
      mean(e) {
        return this.sum(e) / e.length;
      }
      median(e) {
        e.sort((e, t) => e - t);
        const t = e.length / 2;
        return t % 1 ? e[t - 0.5] : (e[t - 1] + e[t]) / 2;
      }
      modes(e) {
        if (!e.length) return [];
        const t = {};
        let i = 0,
          s = [];
        return (
          e.forEach((e) => {
            t[e] ? t[e]++ : (t[e] = 1),
              t[e] > i ? ((s = [e]), (i = t[e])) : t[e] === i && (s.push(e), (i = t[e]));
          }),
          s
        );
      }
      variance(e) {
        const t = this.mean(e);
        return this.mean(e.map((e) => Math.pow(e - t, 2)));
      }
      standardDeviation(e) {
        return Math.sqrt(this.variance(e));
      }
      meanAbsoluteDeviation(e) {
        const t = this.mean(e);
        return this.mean(e.map((e) => Math.abs(e - t)));
      }
      zScores(e) {
        const t = this.mean(e),
          i = this.standardDeviation(e);
        return e.map((e) => (e - t) / i);
      }
      average(e) {
        return this.mean(e);
      }
    }
    const em = function () {
      return window && window.performance ? window.performance.now() : Date.now();
    };
    class tm {
      constructor(e = {}) {
        (this.options = e),
          (this.framesCounter = 0),
          (this.lastFPSTimestamp = null),
          (this.lastFPSMeasure = 0),
          (this.measurements = []),
          (this.lastMeasurementTimestamp = null),
          (this.started = !1),
          (this.stat = new Jd());
      }
      startMeasuring(e) {
        (this.started = !0),
          this.updateFPS(),
          e && !isNaN(e) && e > 0 && setTimeout(this.stopMeasuring.bind(this), e);
      }
      stopMeasuring() {
        this.started = !1;
      }
      registerRenderFrame() {
        this.started && (this.framesCounter++, this.updateFPS());
      }
      getLastMeasurement() {
        return this.measurements.length ? this.measurements[this.measurements.length - 1] : 0;
      }
      updateFPS() {
        null === this.lastFPSTimestamp && (this.lastFPSTimestamp = em());
        const e = em(),
          t = e - this.lastFPSTimestamp;
        if (t > 500) {
          let i = Math.round((this.framesCounter / (t / 1e3)) * 10) / 10;
          (i = i > 60 ? 60 : i),
            (this.lastFPSTimestamp = e),
            (this.framesCounter = 0),
            this.recordMeasurement(i, t);
        }
      }
      recordMeasurement(e) {
        this.measurements.push(e);
      }
      getMeasurements() {
        return this.measurements.slice();
      }
      getMeasurementsReport() {
        const e = this.getMeasurements();
        return {
          measurements: e,
          median: Number(this.stat.median(e).toFixed(1)),
          average: Number(this.stat.average(e).toFixed(1)),
          variance: Number(this.stat.variance(e).toFixed(1)),
          stdDev: Number(this.stat.standardDeviation(e).toFixed(1)),
        };
      }
    }
    class im {
      constructor(e = { className: 'minemap-fps-control' }) {
        (this.measurer = new tm()),
          (this.options = e),
          (this.countRenderBound = this.measurer.registerRenderFrame.bind(this.measurer)),
          (this.updateFPSCounterBound = this.updateFPSCounter.bind(this)),
          (this.lastFPSMeasure = null);
      }
      updateFPSCounter() {
        const e = this.measurer.getLastMeasurement(),
          t = this.measurer.getMeasurementsReport();
        if (e === this.lastFPSMeasure) return;
        let i = `FPS:${e.toFixed(1)}<br />`;
        (i += `平均值:${t.median}<br />`), (this._container.innerHTML = i);
      }
      onAdd(e) {
        return (
          (this._map = e),
          (this._container = document.createElement('div')),
          (this._container.className = `${this.options.className} minemap-ctrl-group minemap-ctrl`),
          this.addEventListeners(),
          this.measurer.startMeasuring(),
          this._container
        );
      }
      remove() {
        this.onRemove();
      }
      onRemove() {
        this.removeEventListeners(), this.measurer.stopMeasuring(), this._container.remove();
      }
      addEventListeners() {
        this._map.on('render', this.countRenderBound),
          this._map.on('render', this.updateFPSCounterBound);
      }
      removeEventListeners() {
        this._map.off('render', this.countRenderBound),
          this._map.off('render', this.updateFPSCounterBound);
      }
    }
    var sm = e.createCommonjsModule(function (e) {
      function t(e) {
        return !i(e);
      }
      function i(e) {
        return 'undefined' == typeof window || 'undefined' == typeof document
          ? 'not a browser'
          : Array.prototype &&
            Array.prototype.every &&
            Array.prototype.filter &&
            Array.prototype.forEach &&
            Array.prototype.indexOf &&
            Array.prototype.lastIndexOf &&
            Array.prototype.map &&
            Array.prototype.some &&
            Array.prototype.reduce &&
            Array.prototype.reduceRight &&
            Array.isArray
          ? Function.prototype && Function.prototype.bind
            ? Object.keys &&
              Object.create &&
              Object.getPrototypeOf &&
              Object.getOwnPropertyNames &&
              Object.isSealed &&
              Object.isFrozen &&
              Object.isExtensible &&
              Object.getOwnPropertyDescriptor &&
              Object.defineProperty &&
              Object.defineProperties &&
              Object.seal &&
              Object.freeze &&
              Object.preventExtensions
              ? 'JSON' in window && 'parse' in JSON && 'stringify' in JSON
                ? (function () {
                    if (!('Worker' in window && 'Blob' in window && 'URL' in window)) return !1;
                    var e,
                      t,
                      i = new Blob([''], { type: 'text/javascript' }),
                      s = URL.createObjectURL(i);
                    try {
                      (t = new Worker(s)), (e = !0);
                    } catch (t) {
                      e = !1;
                    }
                    return t && t.terminate(), URL.revokeObjectURL(s), e;
                  })()
                  ? 'Uint8ClampedArray' in window
                    ? ArrayBuffer.isView
                      ? (function () {
                          const e = document.createElement('canvas');
                          e.width = e.height = 1;
                          const t = e.getContext('2d');
                          if (!t) return !1;
                          const i = t.getImageData(0, 0, 1, 1);
                          return i && i.width === e.width;
                        })()
                        ? (void 0 === s[(i = e && e.failIfMajorPerformanceCaveat)] &&
                            (s[i] = (function (e) {
                              const i = (function (e) {
                                var i = document.createElement('canvas'),
                                  s = Object.create(t.webGLContextAttributes);
                                return (
                                  (s.failIfMajorPerformanceCaveat = e),
                                  i.probablySupportsContext
                                    ? i.probablySupportsContext('webgl', s) ||
                                      i.probablySupportsContext('experimental-webgl', s)
                                    : i.supportsContext
                                    ? i.supportsContext('webgl', s) ||
                                      i.supportsContext('experimental-webgl', s)
                                    : i.getContext('webgl', s) ||
                                      i.getContext('experimental-webgl', s)
                                );
                              })(e);
                              if (!i) return !1;
                              const s = i.createShader(i.VERTEX_SHADER);
                              return (
                                !(!s || i.isContextLost()) &&
                                (i.shaderSource(s, 'void main() {}'),
                                i.compileShader(s),
                                !0 === i.getShaderParameter(s, i.COMPILE_STATUS))
                              );
                            })(i)),
                          s[i] ? void 0 : 'insufficient WebGL support')
                        : 'insufficient Canvas/getImageData support'
                      : 'insufficient ArrayBuffer support'
                    : 'insufficient Uint8ClampedArray support'
                  : 'insufficient worker support'
                : 'insufficient JSON support'
              : 'insufficient Object support'
            : 'insufficient Function support'
          : 'insufficent Array support';
        var i;
      }
      e.exports
        ? (e.exports = t)
        : window &&
          ((window.minemap = window.minemap || {}),
          (window.minemap.supported = t),
          (window.minemap.notSupportedReason = i));
      var s = {};
      t.webGLContextAttributes = { antialias: !1, alpha: !0, stencil: !0, depth: !0 };
    });
    class rm {
      constructor() {
        (this._queue = []), (this._id = 0), (this._cleared = !1), (this._currentlyRunning = !1);
      }
      add(e) {
        const t = ++this._id;
        return this._queue.push({ callback: e, id: t, cancelled: !1 }), t;
      }
      remove(e) {
        const t = this._currentlyRunning,
          i = t ? this._queue.concat(t) : this._queue;
        for (const t of i) if (t.id === e) return void (t.cancelled = !0);
      }
      run(e = 0) {
        const t = (this._currentlyRunning = this._queue);
        this._queue = [];
        for (const i of t) if (!i.cancelled && (i.callback(e), this._cleared)) break;
        (this._cleared = !1), (this._currentlyRunning = !1);
      }
      clear() {
        this._currentlyRunning && (this._cleared = !0), (this._queue = []);
      }
    }
    class nm {
      constructor(t, i) {
        (this.map = i),
          (this._sphereRender = t.sphereRender || !1),
          (this._projection = t.projection || e.ProjectionType.MERCATOR),
          (this.options = t);
      }
      get projection() {
        return this._projection;
      }
      set projection(t) {
        (this._projection = t || e.ProjectionType.MERCATOR),
          (this.map.transform.projection = this._projection),
          this.map.style.changWorkerProjection(this._projection),
          (this.map.painter.projection = this._projection),
          (this.map.isLatLon = 'LATLON' === t),
          (this.map._tilingScheme = 'LATLON' === t ? new hn() : new ln());
      }
    }
    class om {
      constructor(t, i, s, r, a, l) {
        (this.tileSize = 512),
          (this._minZoom = t || 0),
          (this._maxZoom = i || 22),
          (this.width = 0),
          (this.height = 0),
          (this._position = new e.Vector3(0, 0, 0)),
          (this._cameraHeightConvertedZoom = 0),
          (this.scale = this.zoomScale(0)),
          (this._fov = e.CONSTS.TRANSFORM.FOV_IN_RADIANS),
          (this._3dNearPlaneNumber = Number.MAX_VALUE),
          (this._3dFarPlaneNumber = Number.MIN_VALUE),
          (this._unmodified = !0),
          (this._posMatrixCache = {}),
          (this.latRange = [e.CONSTS.TRANSFORM.MIN_LAT, e.CONSTS.TRANSFORM.MAX_LAT]),
          (this._projection = s),
          (this._terrainRender = !1),
          (this.pixelMatrix = new e.Matrix4()),
          (this._hpr = new e.HeadingPitchRoll(0, 0, 0)),
          (this._pinchOperationData = {
            lastMatrix: new e.Matrix4(),
            _rollDiff: 0,
            _pitchDiff: 0,
            _headingDiff: 0,
          }),
          (this.near = 0.1),
          (this.far = 1e4),
          (this._pinchPosition = null),
          (this._adjustHeightStep = 10),
          (this._minHeightToDemSurface = 1),
          (this._maximumCameraCheckHeight = 1e4),
          (this._minimumCameraCheckHeightNoTerrain = 1),
          (this.activeCamera = new n()),
          (this.shadowCamera = new o()),
          this._calcProjectionsMatrix(),
          (this._minPitch = e.defined(r) ? r : 0),
          (this._maxPitch = e.defined(a) ? a : 90),
          (this._cameraController = l),
          (this._zoomDelta = 0),
          (this._panDelta = new e.Vector3(0, 0, 0)),
          (this._justTerrain = !1);
      }
      clone() {
        const e = new om(this._minZoom, this._maxZoom, this._projection);
        return (
          (e.width = this.width),
          (e.height = this.height),
          (e._position = this._position),
          (e._cameraHeightConvertedZoom = this._cameraHeightConvertedZoom),
          (e._fov = this._fov),
          (e.hpr = this.hpr),
          (e._unmodified = this._unmodified),
          e._calcMatrices(),
          e
        );
      }
      set minHeightToDemSurface(t) {
        this._minHeightToDemSurface = e.defined(t) ? t : 1;
      }
      get minHeightToDemSurface() {
        return this._minHeightToDemSurface;
      }
      updateNearFarPlane(e) {
        (this._3dNearPlaneNumber = e.near),
          (this._3dFarPlaneNumber = e.far),
          this._calcProjectionsMatrix();
      }
      get terrainRender() {
        return this._terrainRender;
      }
      set terrainRender(e) {
        this._terrainRender = e;
      }
      set terrainSupplier(e) {
        e instanceof yo && (this._terrainSupplier = e);
      }
      get minPitch() {
        return this._minPitch;
      }
      set minPitch(e) {
        this._minPitch !== e &&
          ((this._minPitch = e), (this.cameraPitch = Math.max(this.pitch, e)));
      }
      get maxPitch() {
        return this._maxPitch;
      }
      set maxPitch(e) {
        this._maxPitch !== e &&
          ((this._maxPitch = e), (this.cameraPitch = Math.min(this.pitch, e)));
      }
      resize(t, i) {
        (this.width = t),
          (this.height = i),
          (this.pixelsToGLUnits = [2 / t, -2 / i]),
          this._constrain(),
          (this.cameraHeightToCartesianCenter = e.getDistanceFromZoom(
            this._fov,
            this.cameraHeightConvertedZoom,
            e.CONSTS.TRANSFORM.R,
          )),
          (this._position[2] = this.cameraHeightToCartesianCenter - e.CONSTS.TRANSFORM.R),
          (this.pixelMatrix = new e.Matrix4().scale([this.width / 2, -this.height / 2, 1])),
          (this.pixelMatrix = new e.Matrix4(this.pixelMatrix).translate([1, -1, 0])),
          this._calcMatrices();
      }
      get zoom() {
        return this.getMapViewParams().zoom;
      }
      get cameraHeightConvertedZoom() {
        return this._cameraHeightConvertedZoom;
      }
      set zoomDelta(e) {
        this._zoomDelta = e;
      }
      get zoomDelta() {
        return this._zoomDelta;
      }
      set panDelta(e) {
        this._panDelta = e;
      }
      get panDelta() {
        return this._panDelta;
      }
      set positionHeight(t) {
        if (this._fov && this.positionHeight !== t) {
          if (this.terrainRender && this._cameraController.enableCollisionDetection) {
            if (
              this._zoomDelta >= 0 &&
              this._cameraController.checkColliding(
                this._position,
                this._terrainSupplier,
                this.projection,
                t,
              )
            )
              return;
          } else if (this._cameraController.enableCollisionDetection) {
            if (
              this._zoomDelta > 0 &&
              this._cameraController.checkColliding(
                this._position,
                this._terrainSupplier,
                this.projection,
                t,
              )
            )
              return;
          } else if (t < this._minimumCameraCheckHeightNoTerrain) return;
          (this._unmodified = !1),
            (this._cameraHeightConvertedZoom = e.getZoomFromDistance(
              this._fov,
              t + e.CONSTS.TRANSFORM.R,
              e.CONSTS.TRANSFORM.R,
            )),
            (this.scale = this.zoomScale(this._cameraHeightConvertedZoom)),
            (this.tileZoom = Math.floor(this._cameraHeightConvertedZoom)),
            (this.cameraHeightToCartesianCenter = e.CONSTS.TRANSFORM.R + t),
            (this._position[2] = t),
            this._constrain(),
            this._calcMatrices();
        }
      }
      get positionHeight() {
        return this._position[2];
      }
      set pinchPosition(e) {
        (this._cameraController.enableCollisionDetection &&
          this._pinchOperationData._pitchDiff > 0 &&
          this._cameraController.checkColliding(
            this._position,
            this._terrainSupplier,
            this.projection,
            this.positionHeight,
          )) ||
          ((this._pinchPosition = e), this._calcMatrices());
      }
      get pinchPosition() {
        return this._pinchPosition;
      }
      _calcProjectionsMatrix() {
        if (0 === this.width || 0 === this.height) return;
        const t = this._getIntersectionResultFromSharedTerrainTileCache(
          this._position[0],
          this._position[1],
          this._position[2],
        );
        let i, s;
        (this.cameraHeightToTerrainSurface = Number.isFinite(t.intersectionZ)
          ? t.intersectionZ
          : this._position[2]),
          (i = this.cameraHeightToTerrainSurface / 4),
          (s = this._position[2] + e.CONSTS.TRANSFORM.R / Math.pow(1.2, this.zoom)),
          this._3dNearPlaneNumber < i && (i = this._3dNearPlaneNumber),
          this._3dFarPlaneNumber > s && (s = this._3dFarPlaneNumber),
          i < 0.1 && (i = 0.1),
          s < 13e3 && (s = 13e3),
          (this.near = i),
          (this.far = s),
          this.activeCamera.updatePerspectiveOptions({
            fov: this.fov,
            aspect: this.width / this.height,
            near: i,
            far: s,
          }),
          this.shadowCamera.update();
      }
      set projection(e) {
        this._projection = e;
      }
      get projection() {
        return this._projection;
      }
      locationPoint(t, i) {
        const s = e.Transforms.cartographicToCartesian3(new e.Vector3(t.lng, t.lat, i || 0)),
          r = e.Transforms.pointToWindowCoordinates(
            this.activeCamera.getVPMatrix(),
            this.pixelMatrix,
            new e.Vector3(s),
          );
        return new e.pointGeometry3d(r.x, r.y);
      }
      set hpr(e) {
        (this._hpr = e), this._calcMatrices();
      }
      get hpr() {
        return this._hpr;
      }
      get pitch() {
        return this._hpr.pitch * e.CONSTS.TRANSFORM.RAD_TO_DEG;
      }
      set pitch(t) {
        const i = e.clamp(t, this.minPitch, this.maxPitch) * e.CONSTS.TRANSFORM.DEG_TO_RAD;
        this._hpr.pitch !== i &&
          ((this._unmodified = !1), (this._hpr.pitch = i), this._calcMatrices());
      }
      get bearing() {
        return this._hpr.heading * e.CONSTS.TRANSFORM.RAD_TO_DEG;
      }
      set bearing(t) {
        const i = e.wrap(t, -180, 180) * e.CONSTS.TRANSFORM.DEG_TO_RAD;
        this._hpr.heading !== i &&
          ((this._unmodified = !1), (this._hpr.heading = i), this._calcMatrices());
      }
      get roll() {
        return this._hpr.roll * e.CONSTS.TRANSFORM.RAD_TO_DEG;
      }
      set roll(t) {
        const i = (e.wrap(t, -180, 180) * Math.PI) / 180;
        this._hpr.roll !== i &&
          ((this._unmodified = !1), (this._hpr.roll = i), this._calcMatrices());
      }
      get center() {
        return this.getMapViewParams().center;
      }
      get mapPitch() {
        return this.getMapViewParams().pitch;
      }
      get mapBearing() {
        return this.getMapViewParams().bearing;
      }
      get mapRoll() {
        return this.getMapViewParams().roll;
      }
      get cameraCenter() {
        return new e.LngLat(this._position[0], this._position[1]);
      }
      checkTransformsParamsUnChanged(e) {
        return !(
          !e ||
          e[0] != this._position[0] ||
          e[1] != this._position[1] ||
          e[2] != this._cameraHeightConvertedZoom ||
          e[3] != this.bearing ||
          e[4] != this.pitch ||
          e[5] != this.roll
        );
      }
      getMapViewParams() {
        if (this.checkTransformsParamsUnChanged(this.__oldVal)) return this.__oldVal[6];
        const t = [
            this._position[0],
            this._position[1],
            this._cameraHeightConvertedZoom,
            this.bearing,
            this.pitch,
            this.roll,
          ],
          i = e.Transforms.convertV4Pos2V34(t);
        let s;
        return (
          (s = i
            ? {
                center: new e.LngLat(i[0], i[1]),
                zoom: i[2],
                bearing: i[3],
                pitch: i[4],
                roll: i[5],
              }
            : {
                center: new e.LngLat(this._position[0], this._position[1]),
                zoom: this._cameraHeightConvertedZoom,
                pitch: this.pitch,
                bearing: this.bearing,
                roll: this.roll,
              }),
          (this.activeCamera.mapZoom = s.zoom),
          (this.activeCamera.heightZoom = this._cameraHeightConvertedZoom),
          (this.__oldVal = t),
          this.__oldVal.push(s),
          s
        );
      }
      get position() {
        return this._position;
      }
      set position(e) {
        !e ||
          (e[0] === this._position[0] &&
            e[1] === this._position[1] &&
            e[2] === this._position[2]) ||
          (this._cameraController.enableCollisionDetection &&
            this._cameraController.checkColliding(
              e,
              this._terrainSupplier,
              this.projection,
              e[2],
            ) &&
            (0 != this._pinchOperationData._headingDiff ||
              this._justTerrain ||
              (e = this._cameraController.adjustCameraHeight(
                e,
                this._terrainRender,
                this._terrainSupplier,
                this.projection,
              ))),
          (this._unmodified = !1),
          (this._position[0] = e[0]),
          (this._position[1] = e[1]),
          this._constrain(),
          this._calcMatrices(),
          (this.positionHeight = e[2]));
      }
      _constrain() {}
      pointLocation(t, i) {
        return e.getPickPositionOfSurface({
          canvasX: t.x,
          canvasY: t.y,
          transform: this,
          ellipsoid: i,
        }).lngLat;
      }
      getLocationAtPointDiff(t, i, s) {
        const r = e.getPickPositionOfSurface({
          canvasX: i.x,
          canvasY: i.y,
          transform: this,
          ellipsoid: s,
        });
        return r.lngLat && t ? [r.lngLat.lng - t.lng, r.lngLat.lat - t.lat] : [0, 0];
      }
      setLocationAtPoint(e, t) {
        const i = this.getLocationAtPointDiff(e, t);
        (0 == i[0] && 0 == i[1]) ||
          (this.position = [this._position[0] - i[0], this._position[1] - i[1], this._position[2]]);
      }
      _getIntersectionResultFromSharedTerrainTileCache(t, i, s) {
        if (this._terrainRender && this._terrainSupplier) {
          const r = e.defined(s) ? s : this._position[2],
            n = e.Vector3.fromDegrees(t, i, r);
          return vo(new e.Vector3(t, i, r), n, this._terrainSupplier, this._projection);
        }
        return { intersectionZ: 1 / 0, intersectionPoint: null, isUnderground: !1 };
      }
      pointCoordinate(t, i) {
        const s = e.getPickPositionOfSurface({ canvasX: t.x, canvasY: t.y, transform: this });
        return s.lngLat
          ? new e.Coordinate(
              e.ProjectionProxy.lngX(s.lngLat.lng, this.worldSize, this._projection) /
                this.tileSize,
              e.ProjectionProxy.latY(s.lngLat.lat, this.worldSize, this._projection) /
                this.tileSize,
              this.cameraHeightConvertedZoom,
            )._zoomTo(i || this.cameraHeightConvertedZoom)
          : null;
      }
      _convertPinchGestureToBasicTransform() {
        const t = this._pinchOperationData.lastMatrix.clone(),
          i = e.Transforms.fixedFrameToHeadingPitchRoll(t),
          s = e.Transforms.cartesian3ToCartographic(new e.Vector3(t[12], t[13], t[14]));
        this._position = s;
        const r = e.getZoomFromDistance(
          this._fov,
          this._position[2] + e.CONSTS.TRANSFORM.R,
          e.CONSTS.TRANSFORM.R,
        );
        (this._cameraHeightConvertedZoom = r),
          0 !== this._pinchOperationData._pitchDiff &&
            (this.hpr.pitch = e.clamp(i.roll, 0, Math.PI / 2)),
          (this.hpr.heading = e.wrap(i.heading, -Math.PI, Math.PI)),
          (this.hpr.roll = e.wrap(i.pitch, -Math.PI, Math.PI)),
          (this._pinchOperationData._rollDiff = 0),
          (this._pinchOperationData._pitchDiff = 0),
          (this._pinchOperationData._headingDiff = 0),
          (this.scale = this.zoomScale(this.cameraHeightConvertedZoom));
      }
      _calculateTDSceneMatrix() {
        this._calcProjectionsMatrix();
        const t = JSON.parse(JSON.stringify(this.position)),
          i = this._pinchPosition;
        if (i) {
          const t = this.activeCamera.matrix.clone();
          (t[12] -= i[0]), (t[13] -= i[1]), (t[14] -= i[2]);
          const s = new e.Vector3(t[0], t[1], t[2]);
          (this.hpr.pitch + this._pinchOperationData._pitchDiff >
            this._maxPitch * e.CONSTS.TRANSFORM.DEG_TO_RAD ||
            this.hpr.pitch + this._pinchOperationData._pitchDiff <
              this._minPitch * e.CONSTS.TRANSFORM.DEG_TO_RAD) &&
            (this._pinchOperationData._pitchDiff = 0);
          const r = new e.Matrix4().rotateAxis(this._pinchOperationData._pitchDiff, s),
            n = new e.Matrix4().rotateAxis(-this._pinchOperationData._headingDiff, i);
          if (
            (t.multiplyLeft(r).multiplyLeft(n),
            (t[12] += i[0]),
            (t[13] += i[1]),
            (t[14] += i[2]),
            e.Transforms.cartesian3ToCartographic([t[12], t[13], t[14]])[2] < 0)
          )
            return (
              (this._pinchOperationData._rollDiff = 0),
              (this._pinchOperationData._pitchDiff = 0),
              void (this._pinchOperationData._headingDiff = 0)
            );
          this.activeCamera.setMatrix(t),
            (this._pinchOperationData.lastMatrix = t.clone()),
            this._convertPinchGestureToBasicTransform();
        } else {
          const t = e.Vector3.fromDegrees(this.position[0], this.position[1], this.position[2]),
            i = e.Transforms.headingPitchRollToFixedFrame(t, this.hpr);
          this.activeCamera.setMatrix(i);
        }
        this._cameraController.enableCollisionDetection &&
          ((t[2] > this.position[2] &&
            'mouseRotate' === this._cameraController.eventInProgress.handlerName) ||
            (t[2] > this.position[2] && this._justTerrain)) &&
          (this.position[2] = t[2]);
      }
      _calcMatrices() {
        if (!this.height) return;
        this._calculateTDSceneMatrix(),
          (this.cameraToCenterDistance = (0.5 / Math.tan(this._fov / 2)) * this.height);
        const t = this.getMapViewParams().pitch * e.CONSTS.TRANSFORM.DEG_TO_RAD,
          i = this.getMapViewParams().bearing * e.CONSTS.TRANSFORM.DEG_TO_RAD,
          s = Math.PI / 2 + t,
          r = (0.5 * this.height) / Math.sin(Math.PI - s - this._fov / 2),
          n = this.cameraX,
          o = this.cameraY,
          a = 1.01 * (Math.cos(Math.PI / 2 - t) * r + this.cameraToCenterDistance),
          l = new e.Matrix4();
        l.perspective({ fov: this._fov, aspect: this.width / this.height, near: 1, far: a }),
          l.scale([1, -1, 1]);
        const h = this.getMapViewParams().pitch * e.CONSTS.TRANSFORM.DEG_TO_RAD;
        l.rotateX(h), l.rotateZ(-i), l.translate([-n, -o, -this.cameraToCenterDistance]);
        const c =
          this.worldSize /
          (2 *
            Math.PI *
            e.CONSTS.TRANSFORM.REAL_R *
            Math.abs(Math.cos(this.getMapViewParams().center.lat * e.CONSTS.TRANSFORM.DEG_TO_RAD)));
        l.scale([1, 1, c, 1]), (this.projMatrix = l.clone()), (this._posMatrixCache = {});
      }
      calculateVPMatrix() {
        return this.activeCamera.getVPMatrix();
      }
      getCameraPos() {
        return this.activeCamera.position;
      }
      get minZoom() {
        return this._minZoom;
      }
      set minZoom(e) {
        this._minZoom !== e && (this._minZoom = e);
      }
      get maxZoom() {
        return this._maxZoom;
      }
      set maxZoom(e) {
        this._maxZoom !== e && (this._maxZoom = e);
      }
      get worldSize() {
        return this.tileSize * this.scale;
      }
      get centerPoint() {
        return this.size._div(2);
      }
      get size() {
        return new e.pointGeometry3d(this.width, this.height);
      }
      get fov() {
        return (this._fov / Math.PI) * 180;
      }
      set fov(e) {
        (e = Math.max(0.01, Math.min(60, e))),
          this._fov !== e &&
            ((this._unmodified = !1), (this._fov = (e / 180) * Math.PI), this._calcMatrices());
      }
      get unmodified() {
        return this._unmodified;
      }
      zoomScale(e) {
        return Math.pow(2, e);
      }
      scaleZoom(e) {
        return Math.log(e) / Math.LN2;
      }
      project(t) {
        return new e.pointGeometry3d(
          e.ProjectionProxy.lngX(t.lng, this.worldSize, this._projection),
          e.ProjectionProxy.latY(t.lat, this.worldSize, this._projection),
        );
      }
      unproject(t) {
        return new e.LngLat(
          e.ProjectionProxy.xLng(t.x, this.worldSize, this._projection),
          e.ProjectionProxy.yLat(t.y, this.worldSize, this._projection),
        );
      }
      get x() {
        return e.ProjectionProxy.lngX(this.center.lng, this.worldSize, this._projection);
      }
      get y() {
        return e.ProjectionProxy.latY(this.center.lat, this.worldSize, this._projection);
      }
      get cameraX() {
        return e.ProjectionProxy.lngX(this.cameraCenter.lng, this.worldSize, this._projection);
      }
      get cameraY() {
        return e.ProjectionProxy.latY(this.cameraCenter.lat, this.worldSize, this._projection);
      }
      get point() {
        return new e.pointGeometry3d(this.x, this.y);
      }
      locationCoordinate(t) {
        const i = e.ProjectionProxy.latY(t.lat, this.worldSize, this._projection);
        return (
          this.tileZoom || (this.tileZoom = this.cameraHeightConvertedZoom),
          new e.Coordinate(
            e.ProjectionProxy.lngX(t.lng, this.worldSize, this._projection) / this.tileSize,
            i / this.tileSize,
            this.cameraHeightConvertedZoom,
          ).zoomTo(this.tileZoom)
        );
      }
      calculatePosMatrix(t) {
        const i = t.key,
          s = this._posMatrixCache;
        if (s[i]) return s[i];
        const r = t.canonical,
          n = this.worldSize / this.zoomScale(r.z),
          o = r.x + Math.pow(2, r.z) * t.wrap,
          a = new e.Matrix4();
        return (
          a.translate([o * n, r.y * n, 0]),
          a.scale([n / e.EXTENT, n / e.EXTENT, 1]),
          a.multiplyLeft(this.projMatrix),
          (s[i] = a.toArray()),
          s[i]
        );
      }
      maxPitchScaleFactor() {
        return 1;
      }
      getCameraPoint() {
        const t = Math.tan(this._hpr.pitch) * (this.cameraToCenterDistance || 1);
        return this.centerPoint.add(new e.pointGeometry3d(0, t));
      }
      getCameraQueryGeometry(t) {
        const i = this.getCameraPoint();
        if (1 === t.length) return [t[0], i];
        {
          let s = i.x,
            r = i.y,
            n = i.x,
            o = i.y;
          for (const e of t)
            (s = Math.min(s, e.x)),
              (r = Math.min(r, e.y)),
              (n = Math.max(n, e.x)),
              (o = Math.max(o, e.y));
          return [
            new e.pointGeometry3d(s, r),
            new e.pointGeometry3d(n, r),
            new e.pointGeometry3d(n, o),
            new e.pointGeometry3d(s, o),
            new e.pointGeometry3d(s, r),
          ];
        }
      }
    }
    let am = null,
      lm = 0,
      hm = 0;
    const cm = {
        obj: null,
        init(e) {
          (am = e.cb),
            (lm = e.restrictX),
            (hm = e.restrictY),
            (e.handler.onmousedown = this.start),
            (e.handler.root = e.root || e.handler);
          const t = e.handler.root;
          (t.onDragStart = e.dragStart || new Function()),
            (t.onDrag = e.onDrag || new Function()),
            (t.onDragEnd = e.onDragEnd || new Function());
        },
        start(t) {
          const i = (cm.obj = this);
          i.style.cursor = 'move';
          const s = (t = t || cm.fixEvent(e.window.event)).pageY;
          (i.lastMouseX = t.pageX), (i.lastMouseY = s);
          const r = i.root.offsetLeft,
            n = i.root.offsetTop;
          (i.root.style.left = `${r}px`),
            (i.root.style.top = `${n}px`),
            (e.window.document.onmouseup = cm.end),
            (e.window.document.onmousemove = cm.drag),
            i.root.onDragStart(r, n);
        },
        drag(t) {
          const i = (t = t || cm.fixEvent(e.window.event)).pageX,
            s = t.pageY,
            r = cm.obj.root;
          let n = r.style.left ? parseInt(r.style.left) : 0,
            o = r.style.top ? parseInt(r.style.top) : 0;
          n <= -1 && (n = -1), o <= -1 && (o = -1), n >= lm && (n = lm), o >= hm && (o = hm);
          const a = i - cm.obj.lastMouseX + n,
            l = s - cm.obj.lastMouseY + o;
          (r.style.left = `${a}px`),
            (r.style.top = `${l}px`),
            cm.obj.root.onDrag(a, l),
            (cm.obj.lastMouseX = i),
            (cm.obj.lastMouseY = s);
        },
        end() {
          const t = cm.obj.root.style.left ? parseInt(cm.obj.root.style.left) : 0,
            i = cm.obj.root.style.top ? parseInt(cm.obj.root.style.top) : 0;
          cm.obj.root.onDragEnd(t, i),
            e.window.setTimeout(() => {
              am(t, i);
            }, 100),
            (e.window.document.onmousemove = null),
            (e.window.document.onmouseup = null),
            (cm.obj = null);
        },
        fixEvent: (t) => (
          (t.pageX = t.clientX + e.window.document.documentElement.scrollLeft),
          (t.pageY = t.clientY + e.window.document.documentElement.scrollTop),
          t
        ),
      },
      _m = {
        center: 'translate(-50%,-50%)',
        top: 'translate(-50%,0)',
        'top-left': 'translate(0,0)',
        'top-right': 'translate(-100%,0)',
        bottom: 'translate(-50%,-100%)',
        'bottom-left': 'translate(0,-100%)',
        'bottom-right': 'translate(-100%,-100%)',
        left: 'translate(0,-50%)',
        right: 'translate(-100%,-50%)',
      };
    class um extends e.Evented {
      constructor(t) {
        if (
          (super(),
          (arguments[0] instanceof e.window.HTMLElement || 2 === arguments.length) &&
            (t = e.extend({ element: t }, arguments[1])),
          e.bindAll(
            [
              '_update',
              '_onMove',
              '_onUp',
              '_addDragHandler',
              '_onMapClick',
              '_onKeyPress',
              '_clearFadeTimer',
            ],
            this,
          ),
          (this._lngLat = new e.LngLat(0, 0)),
          (this._anchor = (t && t.anchor) || 'top-left'),
          (this._color = (t && t.color) || '#3FB1CE'),
          (this._scale = (t && t.scale) || 1),
          (this._draggable = (t && t.draggable) || !1),
          (this._clickTolerance = (t && t.clickTolerance) || 0),
          (this._isDragging = !1),
          (this._state = 'inactive'),
          (this.heightToSurface = 0),
          (this._rotation = (t && t.rotation) || 0),
          (this._rotationAlignment = (t && t.rotationAlignment) || 'auto'),
          (this._pitchAlignment =
            t && t.pitchAlignment && 'auto' !== t.pitchAlignment
              ? t.pitchAlignment
              : this._rotationAlignment),
          (this._updateMoving = () => this._update(!0)),
          t && t.element)
        )
          (this._element = t.element),
            (this._offset = e.pointGeometry3d.convert((t && t.offset) || [0, 0]));
        else {
          (this._defaultMarker = !0), (this._element = Ur.create('div'));
          const i = 41,
            s = 27,
            r = Ur.createNS('http://www.w3.org/2000/svg', 'svg');
          r.setAttributeNS(null, 'height', `${i}px`),
            r.setAttributeNS(null, 'width', `${s}px`),
            r.setAttributeNS(null, 'viewBox', `0 0 ${s} ${i}`);
          const n = Ur.createNS('http://www.w3.org/2000/svg', 'g');
          n.setAttributeNS(null, 'stroke', 'none'),
            n.setAttributeNS(null, 'stroke-width', '1'),
            n.setAttributeNS(null, 'fill', 'none'),
            n.setAttributeNS(null, 'fill-rule', 'evenodd');
          const o = Ur.createNS('http://www.w3.org/2000/svg', 'g');
          o.setAttributeNS(null, 'fill-rule', 'nonzero');
          const a = Ur.createNS('http://www.w3.org/2000/svg', 'g');
          a.setAttributeNS(null, 'transform', 'translate(3.0, 29.0)'),
            a.setAttributeNS(null, 'fill', '#000000');
          const l = [
            { rx: '10.5', ry: '5.25002273' },
            { rx: '10.5', ry: '5.25002273' },
            { rx: '9.5', ry: '4.77275007' },
            { rx: '8.5', ry: '4.29549936' },
            { rx: '7.5', ry: '3.81822308' },
            { rx: '6.5', ry: '3.34094679' },
            { rx: '5.5', ry: '2.86367051' },
            { rx: '4.5', ry: '2.38636864' },
          ];
          for (const e of l) {
            const t = Ur.createNS('http://www.w3.org/2000/svg', 'ellipse');
            t.setAttributeNS(null, 'opacity', '0.04'),
              t.setAttributeNS(null, 'cx', '10.5'),
              t.setAttributeNS(null, 'cy', '5.80029008'),
              t.setAttributeNS(null, 'rx', e.rx),
              t.setAttributeNS(null, 'ry', e.ry),
              a.appendChild(t);
          }
          const h = Ur.createNS('http://www.w3.org/2000/svg', 'g');
          h.setAttributeNS(null, 'fill', this._color);
          const c = Ur.createNS('http://www.w3.org/2000/svg', 'path');
          c.setAttributeNS(
            null,
            'd',
            'M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z',
          ),
            h.appendChild(c);
          const _ = Ur.createNS('http://www.w3.org/2000/svg', 'g');
          _.setAttributeNS(null, 'opacity', '0.25'), _.setAttributeNS(null, 'fill', '#000000');
          const u = Ur.createNS('http://www.w3.org/2000/svg', 'path');
          u.setAttributeNS(
            null,
            'd',
            'M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z',
          ),
            _.appendChild(u);
          const d = Ur.createNS('http://www.w3.org/2000/svg', 'g');
          d.setAttributeNS(null, 'transform', 'translate(6.0, 7.0)'),
            d.setAttributeNS(null, 'fill', '#FFFFFF');
          const m = Ur.createNS('http://www.w3.org/2000/svg', 'g');
          m.setAttributeNS(null, 'transform', 'translate(8.0, 8.0)');
          const p = Ur.createNS('http://www.w3.org/2000/svg', 'circle');
          p.setAttributeNS(null, 'fill', '#000000'),
            p.setAttributeNS(null, 'opacity', '0.25'),
            p.setAttributeNS(null, 'cx', '5.5'),
            p.setAttributeNS(null, 'cy', '5.5'),
            p.setAttributeNS(null, 'r', '5.4999962');
          const f = Ur.createNS('http://www.w3.org/2000/svg', 'circle');
          f.setAttributeNS(null, 'fill', '#FFFFFF'),
            f.setAttributeNS(null, 'cx', '5.5'),
            f.setAttributeNS(null, 'cy', '5.5'),
            f.setAttributeNS(null, 'r', '5.4999962'),
            m.appendChild(p),
            m.appendChild(f),
            o.appendChild(a),
            o.appendChild(h),
            o.appendChild(_),
            o.appendChild(d),
            o.appendChild(m),
            r.appendChild(o),
            r.setAttributeNS(null, 'height', i * this._scale + 'px'),
            r.setAttributeNS(null, 'width', s * this._scale + 'px'),
            this._element.appendChild(r),
            (this._offset = e.pointGeometry3d.convert(
              (t && t.offset) || [-13.5 * this._scale, -35 * this._scale],
            ));
        }
        this._element.hasAttribute('aria-label') ||
          this._element.setAttribute('aria-label', 'Map marker'),
          this._element.classList.add('minemap-marker'),
          this._element.addEventListener('dragstart', (e) => {
            e.preventDefault();
          }),
          this._element.addEventListener('mousedown', (e) => {
            'INPUT' !== e.view.document.activeElement.tagName && e.preventDefault();
          });
        const i = this._element.classList;
        for (const e in _m) i.remove(`minemap-marker-anchor-${e}`);
        i.add(`minemap-marker-anchor-${this._anchor}`),
          (this._popup = null),
          this.updateBoundingVolume();
      }
      addTo(e) {
        return (
          e === this._map ||
            (this.remove(),
            (this._map = e),
            e.getCanvasContainer().appendChild(this._element),
            e.on('move', this._updateMoving),
            e.on('moveend', this._update),
            e.on('remove', this._clearFadeTimer),
            this.setDraggable(this._draggable),
            this._update(),
            this._map.on('click', this._onMapClick),
            e.__markerList.push(this)),
          this
        );
      }
      remove() {
        if (this._map) {
          for (let e = 0; e < this._map.__markerList.length; e++)
            this._map.__markerList[e] === this && this._map.__markerList.splice(e, 1);
          this._map.off('click', this._onMapClick),
            this._map.off('move', this._updateMoving),
            this._map.off('moveend', this._update),
            this._map.off('mousedown', this._addDragHandler),
            this._map.off('touchstart', this._addDragHandler),
            this._map.off('mouseup', this._onUp),
            this._map.off('touchend', this._onUp),
            this._map.off('mousemove', this._onMove),
            this._map.off('touchmove', this._onMove),
            this._map.off('remove', this._clearFadeTimer),
            delete this._map;
        }
        return (
          this._clearFadeTimer(),
          Ur.remove(this._element),
          this._popup && this._popup.remove(),
          this
        );
      }
      getLngLat() {
        return this._lngLat;
      }
      setLngLat(t) {
        return (
          (t = e.LngLat.convert(t)),
          (this._lngLat = t),
          (this._pos = null),
          this.updateBoundingVolume(),
          this._popup && this._popup.setLngLat(this._lngLat),
          this._update(!0),
          this
        );
      }
      getAltitude() {
        return this.heightToSurface;
      }
      setAltitude(e) {
        return (
          (this.heightToSurface = e),
          this.updateBoundingVolume(),
          (this._pos = null),
          this._popup && this._popup.setAltitude(this.heightToSurface),
          this._update(),
          this
        );
      }
      getElement() {
        return this._element;
      }
      setPopup(e) {
        if (
          (this._popup &&
            (this._popup.remove(),
            (this._popup = null),
            this._element.removeAttribute('role'),
            this._element.removeEventListener('keypress', this._onKeyPress),
            this._originalTabIndex || this._element.removeAttribute('tabindex')),
          e)
        ) {
          if (!('offset' in e.options)) {
            const t = 38.1,
              i = 13.5,
              s = Math.sqrt(Math.pow(i, 2) / 2);
            e.options.offset = this._defaultMarker
              ? {
                  top: [0, 0],
                  'top-left': [0, 0],
                  'top-right': [0, 0],
                  bottom: [0, -t],
                  'bottom-left': [s, -1 * (t - i + s)],
                  'bottom-right': [-s, -1 * (t - i + s)],
                  left: [i, -1 * (t - i)],
                  right: [-i, -1 * (t - i)],
                }
              : this._offset;
          }
          (e._markerBinded = !0),
            (this._popup = e),
            this._lngLat && this._popup.setLngLat(this._lngLat),
            this._element.setAttribute('role', 'button'),
            (this._originalTabIndex = this._element.getAttribute('tabindex')),
            this._originalTabIndex || this._element.setAttribute('tabindex', '0'),
            this._element.addEventListener('keypress', this._onKeyPress),
            this._element.setAttribute('aria-expanded', 'false');
        }
        return this;
      }
      _onKeyPress(e) {
        const t = e.code,
          i = e.charCode || e.keyCode;
        ('Space' !== t && 'Enter' !== t && 32 !== i && 13 !== i) || this.togglePopup();
      }
      _onMapClick(e) {
        const t = e.originalEvent.target,
          i = this._element;
        this._popup && (t === i || i.contains(t)) && this.togglePopup();
      }
      getPopup() {
        return this._popup;
      }
      togglePopup() {
        const e = this._popup;
        return e
          ? (e.isOpen()
              ? (e.remove(), this._element.setAttribute('aria-expanded', 'false'))
              : (e.addTo(this._map), this._element.setAttribute('aria-expanded', 'true')),
            this)
          : this;
      }
      _clearFadeTimer() {
        this._fadeTimer && (clearTimeout(this._fadeTimer), (this._fadeTimer = null));
      }
      #ne() {
        const t = this._pos || new e.pointGeometry3d(0, 0),
          i = this.#oe(),
          s = this.#ae();
        this._element.style.transform = `${_m[this._anchor]} translate(${t.x}px, ${
          t.y
        }px) rotateX(${i}deg) rotateZ(${s}deg)`;
      }
      #oe() {
        return 'viewport' === this._pitchAlignment || 'auto' === this._pitchAlignment
          ? 0
          : 'map' === this._pitchAlignment
          ? this._map.getPitch()
          : 0;
      }
      #ae() {
        return 'viewport' === this._rotationAlignment || 'auto' === this._rotationAlignment
          ? this._rotation
          : 'map' === this._rotationAlignment
          ? this._rotation - this._map.getBearing()
          : 0;
      }
      #le() {
        const t = this._map.transform.activeCamera.frustumCrate.cullingVolume.computeVisibility(
          this.boundingVolume,
        );
        this._element.style.visibility = t === e.INTERSECTION.OUTSIDE ? 'hidden' : 'visible';
      }
      #he() {
        return 'viewport' === this._rotationAlignment ||
          'auto' === this._rotationAlignment ||
          'map' === this._rotationAlignment ||
          'map' === this._pitchAlignment
          ? this._offset
          : e.pointGeometry3d.convert([0, 0]);
      }
      _update(t) {
        if ((e.window.cancelAnimationFrame(this._updateFrameId), !this._map)) return;
        (this._pos = this._map.project(this._lngLat, this.heightToSurface)._add(this._offset)),
          this.#le(),
          !0 === t
            ? (this._updateFrameId = e.window.requestAnimationFrame(() => {
                this._element &&
                  this._pos &&
                  this._anchor &&
                  ((this._pos = this._pos.round()), this.#ne());
              }))
            : (this._pos = this._pos.round());
        const i = this.#he(),
          s = (Math.abs(i.x) / parseFloat(Ur.getAllStyle(this._element).width)) * 100,
          r = (Math.abs(i.y) / parseFloat(Ur.getAllStyle(this._element).height)) * 100;
        Ur.setTransformOrigin(this._element, `${s}% ${r}%`),
          this._map._requestDomTask(() => {
            this._element && this._pos && this._anchor && this.#ne();
          });
      }
      getOffset() {
        return this._offset;
      }
      setOffset(t) {
        return (this._offset = e.pointGeometry3d.convert(t)), this._update(), this;
      }
      updateBoundingVolume() {
        this.boundingVolume = new e.BoundingSphere(
          e.Vector3.fromDegrees(this._lngLat.lng, this._lngLat.lat, this.heightToSurface),
          100,
        );
      }
      _onMove(t) {
        if (!this._isDragging) {
          const e = this._clickTolerance || this._map._clickTolerance;
          this._isDragging = t.point.dist(this._pointerdownPos) >= e;
        }
        if (!this._isDragging) return;
        this._pos = t.point.sub(this._positionDelta);
        const i = new e.Ellipsoid(
          e.WGS84_RADIUS_X + this.heightToSurface,
          e.WGS84_RADIUS_Y + this.heightToSurface,
          e.WGS84_RADIUS_Z + this.heightToSurface,
        );
        (this._lngLat = this._map.unproject(this._pos, i)),
          this._lngLat &&
            (this.setLngLat(this._lngLat),
            this.updateBoundingVolume(),
            (this._element.style.pointerEvents = 'none'),
            'pending' === this._state &&
              ((this._state = 'active'), this.fire(new e.Event('dragstart'))),
            this.fire(new e.Event('drag')));
      }
      _onUp() {
        (this._element.style.pointerEvents = 'auto'),
          (this._positionDelta = null),
          (this._pointerdownPos = null),
          (this._isDragging = !1),
          this._map.off('mousemove', this._onMove),
          this._map.off('touchmove', this._onMove),
          'active' === this._state && this.fire(new e.Event('dragend')),
          (this._state = 'inactive');
      }
      _addDragHandler(e) {
        this._element.contains(e.originalEvent.target) &&
          (e.preventDefault(),
          (this._positionDelta = e.point.sub(this._pos).add(this._offset)),
          (this._pointerdownPos = e.point),
          (this._state = 'pending'),
          this._map.on('mousemove', this._onMove),
          this._map.on('touchmove', this._onMove),
          this._map.once('mouseup', this._onUp),
          this._map.once('touchend', this._onUp));
      }
      setDraggable(e) {
        return (
          (this._draggable = !!e),
          this._map &&
            (e
              ? (this._map.on('mousedown', this._addDragHandler),
                this._map.on('touchstart', this._addDragHandler))
              : (this._map.off('mousedown', this._addDragHandler),
                this._map.off('touchstart', this._addDragHandler))),
          this
        );
      }
      enableDragging() {
        return this.setDraggable(!0), this;
      }
      disableDragging() {
        return this.setDraggable(!1), this;
      }
      isDraggable() {
        return this._draggable;
      }
      getDraggable() {
        return this.isDraggable();
      }
      getMap() {
        return this._map;
      }
      setRotation(e) {
        return (this._rotation = e || 0), this._update(), this;
      }
      getRotation() {
        return this._rotation;
      }
      setRotationAlignment(e) {
        return (this._rotationAlignment = e || 'auto'), this._update(), this;
      }
      getRotationAlignment() {
        return this._rotationAlignment;
      }
      setPitchAlignment(e) {
        return (
          (this._pitchAlignment = e && 'auto' !== e ? e : this._rotationAlignment),
          this._update(),
          this
        );
      }
      getPitchAlignment() {
        return this._pitchAlignment;
      }
    }
    class dm {
      constructor() {
        (this.startTime = mm()),
          (this.oldTime = this.startTime),
          (this.totalTime = 0),
          (this._running = !1),
          (this.needClearTime = !0),
          (this._pause = !1),
          (this.delta = 0),
          (this.counter = 0);
      }
      update(t) {
        if (this._running) {
          const i = e.defaultValue(t, mm());
          this.needClearTime
            ? (this.needClearTime = !1)
            : ((this.delta = (i - this.oldTime) / 1e3),
              (this.counter += (i - this.oldTime) / 1e3),
              (this.totalTime += this.delta)),
            (this.oldTime = i);
        }
      }
      reset() {
        return (
          (this.startTime = mm()),
          (this.oldTime = this.startTime),
          (this.totalTime = 0),
          (this._running = !1),
          (this.needClearTime = !0),
          (this._pause = !1),
          (this.delta = 0),
          (this.counter = 0),
          this.totalTime
        );
      }
      get state() {
        return this._running;
      }
      set state(e) {
        (this._running = e), e || (this.needClearTime = !0);
      }
      pauseTimer() {
        this.state = !1;
      }
      resumeTimer() {
        this.state = !0;
      }
      getDelta() {
        let e = 0;
        return this._running && (e = this.delta), e;
      }
    }
    function mm() {
      return ('undefined' == typeof performance ? Date : performance).now();
    }
    const pm = {
        'FullscreenControl.Enter': 'Enter fullscreen',
        'FullscreenControl.Exit': 'Exit fullscreen',
        'GeolocateControl.FindMyLocation': 'Find my location',
        'GeolocateControl.LocationNotAvailable': 'Location not available',
        'GeolocateControl.Geolocate': 'Geolocate',
        'LogoControl.Title': 'MineMap logo',
        'NavigationControl.ResetBearing': 'Reset bearing to north',
        'NavigationControl.ZoomIn': 'Zoom in',
        'NavigationControl.ZoomOut': 'Zoom out',
        'ScaleControl.Feet': 'ft',
        'ScaleControl.Meters': 'm',
        'ScaleControl.Kilometers': 'km',
        'ScaleControl.Miles': 'mi',
        'ScaleControl.NauticalMiles': 'nm',
        'ScrollZoomBlocker.CtrlMessage': 'Use ctrl + scroll to zoom the map',
        'ScrollZoomBlocker.CmdMessage': 'Use ⌘ + scroll to zoom the map',
        'TouchPanBlocker.Message': 'Use two fingers to move the map',
      },
      fm = [
        'u_VIDEOMATCH_MVPMATRIX',
        'u_VIDEOMATCH_RTP',
        'u_ClipColors',
        'u_VideoSampler',
        'u_HAS_VIDEOMATCHMAP',
        'u_Alpha',
        'u_ActiveClipVideoTexture',
        'u_ClipVideo',
        'u_ClipMatrix',
        'u_MaskSample',
        'u_TextureSize',
      ];
    class gm {
      constructor(e, t) {
        (this._videoManager = e),
          (this._usedVideos = []),
          (this._videoUniform = void 0),
          (this.type = t),
          'Raster' === this.type
            ? (this._rasterTiles = [])
            : '3DTiles' === this.type
            ? (this._selectedTiles = [])
            : '3DModel' === this.type
            ? (this._selectedModelTiles = [])
            : 'Polygon' === this.type && (this._selectPolygons = []);
      }
      update(t) {
        '3DModel' !== this.type && '3DTiles' !== this.type
          ? (this.selectTiles(t),
            this._usedVideos.length < 1 ||
              (e.defined(this._videoUniform) ||
                (this._videoUniform = this.getVideoUniformsCallback()),
              this.addUniforms()))
          : (this._usedVideos = []);
      }
      addUniforms() {
        if ('Raster' === this.type)
          for (let t = 0; t < this._rasterTiles.length; t++)
            (this._rasterTiles[t]._material._uniforms = e.combineInternalMap(
              this._rasterTiles[t]._material._uniforms,
              this._videoUniform,
            )),
              (this._rasterTiles[t]._material.defines = { NUM_VIDEOS: this._usedVideos.length });
        else if ('3DTiles' === this.type) {
          if (this._selectedTiles.length > 0)
            for (let t = 0; t < this._selectedTiles.length; t++) {
              const i = this._selectedTiles[t]._material;
              (i._uniforms = e.combineInternalMap(i._uniforms, this._videoUniform)),
                (i.defines = { NUM_VIDEOS: this._usedVideos.length });
            }
        } else if ('3DModel' === this.type) {
          if (this._selectedModelTiles.length > 0)
            for (let t = 0; t < this._selectedModelTiles.length; t++) {
              const i = this._selectedModelTiles[t]._material;
              (i._uniforms = e.combineInternalMap(i._uniforms, this._videoUniform)),
                (i.defines = { NUM_VIDEOS: this._usedVideos.length });
            }
        } else if ('Polygon' === this.type && this._selectPolygons.length > 0)
          for (let t = 0; t < this._selectPolygons.length; t++) {
            const i = this._selectPolygons[t]._material;
            (i._uniforms = e.combineInternalMap(i._uniforms, this._videoUniform)),
              (i.defines = { NUM_VIDEOS: this._usedVideos.length });
          }
      }
      removeUniforms() {
        if ('Raster' === this.type) {
          if (this._rasterTiles.length > 0) {
            for (let t = 0; t < this._rasterTiles.length; t++)
              if (
                e.defined(
                  this._rasterTiles[t]._material && this._rasterTiles[t]._material._uniforms,
                )
              ) {
                for (let e = 0; e < fm.length; e++)
                  this._rasterTiles[t]._material._uniforms.delete(fm[e]);
                this._rasterTiles[t]._material.defines = { NUM_VIDEOS: 0 };
              }
            this._rasterTiles = [];
          }
        } else if ('3DTiles' === this.type) {
          if (this._selectedTiles.length > 0) {
            for (let e = 0; e < this._selectedTiles.length; e++) {
              const t = this._selectedTiles[e]._material;
              if (null != t && null != t._uniforms) {
                for (let e = 0; e < fm.length; e++) t._uniforms.delete(fm[e]);
                t.defines = { NUM_VIDEOS: 0 };
              }
            }
            this._selectedTiles = [];
          }
        } else if ('3DModel' === this.type) {
          if (this._selectedModelTiles.length > 0) {
            for (let e = 0; e < this._selectedModelTiles.length; e++) {
              const t = this._selectedModelTiles[e]._material;
              if (null != t && null != t._uniforms) {
                for (let e = 0; e < fm.length; e++) t._uniforms.delete(fm[e]);
                t.defines = { NUM_VIDEOS: 0 };
              }
            }
            this._selectedModelTiles = [];
          }
        } else if ('Polygon' === this.type && this._selectPolygons.length > 0) {
          for (let e = 0; e < this._selectPolygons.length; e++) {
            const t = this._selectPolygons[e]._material;
            for (let e = 0; e < fm.length; e++) t._uniforms.delete(fm[e]);
            t.defines = { NUM_VIDEOS: 0 };
          }
          this._selectPolygons = [];
        }
      }
      selectTiles(t) {
        let i, s;
        if (((this._usedVideos = []), e.defined(t.style))) {
          for (let e = 0; e < t.style._order.length; e++)
            (i = t.style._layers[t.style._order[e]]),
              (s = t.style.sourceCaches[i.source]),
              'raster' === i.type && 'Raster' === this.type && this.#ce(i, s);
          'Polygon' === this.type && this.#_e(t);
        }
      }
      #ce(e, t) {
        let i,
          s = [];
        if (t && t.getVisibleCoordinates) {
          (s = t.getVisibleCoordinates(!1)), (i = e.id);
          const r = this._videoManager.getAll(),
            n =
              r.length <= this._videoManager._maxUsedVideoUnit
                ? r.length
                : this._videoManager._maxUsedVideoUnit;
          for (let e = 0; e < n; e++) {
            if (!r[e].usedRaster || !r[e].enabled) continue;
            const n = r[e]._perspectiveCamera.frustumCrate.cullingVolume;
            let o = !1;
            for (let e = 0; e < s.length; e++) {
              const r = t.getTile(s[e]).primitiveMap.get(i);
              void 0 !== r &&
                -1 !== (n ? n.computeVisibility(r.boundingBox) : -1) &&
                (this._rasterTiles.push(r), (o = !0));
            }
            o && this._usedVideos.push(r[e]);
          }
        }
      }
      select3DModel(t) {
        e.defined(t) && t.length > 0 && this.#ue(t),
          this._usedVideos.length < 1 ||
            (e.defined(this._videoUniform) ||
              (this._videoUniform = this.getVideoUniformsCallback()),
            this.addUniforms());
      }
      #ue(e) {
        let t;
        const i = this._videoManager.getAll(),
          s =
            i.length <= this._videoManager._maxUsedVideoUnit
              ? i.length
              : this._videoManager._maxUsedVideoUnit;
        for (let r = 0; r < s; r++) {
          if (!i[r].used3DModel || !i[r].enabled) continue;
          let s = !1;
          const n = i[r]._perspectiveCamera.frustumCrate.cullingVolume;
          if (e.length > 0)
            for (let i = 0; i < e.length; i++)
              (t = e[i]),
                void 0 !== t &&
                  (t.updateMatrixWorld(!0),
                  -1 !== (n ? n.computeVisibility(t.boundingVolume) : -1) &&
                    (this._selectedModelTiles.push(t), (s = !0)));
          s && this._usedVideos.push(i[r]);
        }
      }
      select3DTiles(t) {
        e.defined(t) && t.length > 0 && this.#de(t),
          this._usedVideos.length < 1 ||
            (e.defined(this._videoUniform) ||
              (this._videoUniform = this.getVideoUniformsCallback()),
            this.addUniforms());
      }
      #de(e) {
        let t;
        const i = this._videoManager.getAll(),
          s =
            i.length <= this._videoManager._maxUsedVideoUnit
              ? i.length
              : this._videoManager._maxUsedVideoUnit;
        for (let r = 0; r < s; r++) {
          if (!i[r].used3DTiles || !i[r].enabled) continue;
          let s = !1;
          const n = i[r]._perspectiveCamera.frustumCrate.cullingVolume;
          if (e.length > 0)
            for (let i = 0; i < e.length; i++)
              (t = e[i]),
                void 0 !== t &&
                  (t.updateMatrixWorld(!0),
                  -1 !== (n ? n.computeVisibility(t.boundingVolume) : -1) &&
                    (this._selectedTiles.push(t), (s = !0)));
          s && this._usedVideos.push(i[r]);
        }
      }
      #_e(e) {
        let t;
        const i = e.style.primitiveCollection.getAll(),
          s = this._videoManager.getAll(),
          r =
            s.length <= this._videoManager._maxUsedVideoUnit
              ? s.length
              : this._videoManager._maxUsedVideoUnit;
        for (let e = 0; e < r; e++) {
          if (!s[e].usedPolygon || !s[e].enabled) continue;
          let r = !1;
          const n = s[e]._perspectiveCamera.frustumCrate.cullingVolume;
          if (i.length > 0)
            for (let e = 0; e < i.length; e++)
              (t = i[e]),
                void 0 !== t &&
                  t.usedVideoProjection &&
                  (i[e].updateMatrixWorld(!0),
                  -1 !== (n ? n.computeVisibility(t.boundingVolume) : -1) &&
                    (-1 === this._selectPolygons.indexOf(t) && this._selectPolygons.push(t),
                    (r = !0)));
          r && this._usedVideos.push(s[e]);
        }
      }
      getVideoUniformsCallback() {
        const t = this;
        let i = [],
          s = [],
          r = [],
          n = [],
          o = [],
          a = [],
          l = [];
        return new Map([
          [
            'u_VIDEOMATCH_MVPMATRIX',
            () => {
              const e = t._usedVideos,
                s = e.length;
              i = [];
              for (let t = 0; t < s; t++) {
                const s = e[t];
                s.enabled && i.push(s.videoMatrix);
              }
              return i;
            },
          ],
          [
            'u_VIDEOMATCH_RTP',
            () => {
              const e = t._usedVideos,
                i = e.length;
              s = [];
              for (let t = 0; t < i; t++) {
                const i = e[t];
                i.enabled && s.push(i.cartographic);
              }
              return s;
            },
          ],
          [
            'u_ClipColors',
            () => {
              const e = t._usedVideos,
                i = e.length;
              r = [];
              for (let t = 0; t < i; t++) {
                const i = e[t];
                i.enabled && r.push(i._clipColor);
              }
              return r;
            },
          ],
          [
            'u_VideoSampler',
            () => {
              const e = t._usedVideos,
                i = e.length;
              n = [];
              for (let t = 0; t < i; t++) {
                const i = e[t];
                void 0 !== i.videoTexture && i.enabled && n.push(i.videoTexture);
              }
              return n;
            },
          ],
          [
            'u_HAS_VIDEOMATCHMAP',
            () => {
              const e = t._usedVideos,
                i = e.length;
              o = [];
              for (let t = 0; t < i; t++) {
                const i = e[t].enabled;
                i && o.push(i);
              }
              return o;
            },
          ],
          [
            'u_Alpha',
            () => {
              const e = t._usedVideos,
                i = e.length;
              a = [];
              for (let t = 0; t < i; t++) {
                const i = e[t];
                i.enabled && a.push(i._alpha);
              }
              return a;
            },
          ],
          [
            'u_ActiveClipVideoTexture',
            () => {
              const e = t._usedVideos,
                i = e.length;
              l = [];
              for (let t = 0; t < i; t++)
                e[t].enabled &&
                  l.push(
                    e[t]._clip &&
                      this._videoManager._clipManager.getByName(e[t].uniqueId).length > 0,
                  );
              return l;
            },
          ],
          ['u_ClipVideo', () => t._videoManager.enableClip],
          ['u_ClipMatrix', () => t._videoManager._projectionMatrix],
          [
            'u_MaskSample',
            () => {
              const e = t._usedVideos,
                i = e.length;
              n = [];
              for (let t = 0; t < i; t++) {
                const i = e[t];
                void 0 !== i.videoTexture && i.enabled && n.push(i.videoTexture);
              }
              const s = t._videoManager._clipFill.framebuffer.getColorTexture(0);
              return s.bind(), s;
            },
          ],
          [
            'u_TextureSize',
            () =>
              new e.Vector2(
                t._videoManager._clipFill.framebuffer.width,
                t._videoManager._clipFill.framebuffer.height,
              ),
          ],
        ]);
      }
    }
    class ym extends e.Geometry {
      constructor(t) {
        super({}),
          (this.type = 'FrustumGeometry'),
          (this.primitiveType = e.WebGLConstants.TRIANGLES),
          this.setData(t);
      }
      setData(t) {
        super.setData({}),
          (this.near = t.near),
          (this.far = t.far),
          (this.frustumType = t.type),
          (this.position = new e.Vector3()),
          (this.quaternion = new e.Quaternion()),
          (this.camera = t),
          (this._usedDoublePrecision = !1),
          this._vertexArray
            ? (this._vertexArray.clear(), this._indices.clear())
            : ((this._vertexArray = this._usedDoublePrecision
                ? new e.StructArrayLayout11f44()
                : new e.StructArrayLayout3f2f3f32()),
              (this._indices = new e.StructArrayLayout3ui6())),
          (this.numberOfPlanes = 6),
          this.parse(),
          this.computeBoundingSphere(),
          this.computeBoundingBox();
      }
      parse() {
        let e = new Float64Array(72);
        (e = this.computeNearFarPlanes(
          this.position,
          this.quaternion,
          this.frustumType,
          this.camera,
          e,
        )),
          (e = this.computerOthersPlans(e)),
          (this.vertices = e),
          this.computerNormalAndUvAndIndices();
        for (let e = 0; e < this.indices.length; e += 3)
          this._indices.emplaceBack(this.indices[e], this.indices[e + 2], this.indices[e + 1]);
        this.emplaceVertexBufferTriangle(), (this.needUpdate = !0);
      }
      computeNearFarPlanes(t, i, s, r, n, o, a, l) {
        const h = new e.Matrix3(),
          c = new e.Matrix4(),
          _ = new e.Matrix4();
        (this.scratchXDirection = new e.Vector3()),
          (this.scratchYDirection = new e.Vector3()),
          (this.scratchZDirection = new e.Vector3());
        const u = new Array(3),
          d = new Array(4);
        (d[0] = new e.Vector4(-1, -1, 1, 1)),
          (d[1] = new e.Vector4(1, -1, 1, 1)),
          (d[2] = new e.Vector4(1, 1, 1, 1)),
          (d[3] = new e.Vector4(-1, 1, 1, 1));
        const m = new e.Matrix3().fromQuaternion(i, h);
        let p = e.defaultValue(o, this.scratchXDirection),
          f = e.defaultValue(a, this.scratchYDirection),
          g = e.defaultValue(l, this.scratchZDirection);
        (p = e.Matrix3.getColumn(m, 0, p)),
          (f = e.Matrix3.getColumn(m, 1, f)),
          (g = e.Matrix3.getColumn(m, 2, g)),
          e.Vector3.normalize(p, p),
          e.Vector3.normalize(f, f),
          e.Vector3.normalize(g, g),
          e.Vector3.negate(p, p),
          e.Vector3.negate(g, g);
        const y = e.Matrix4.computeView(t, g, f, p, c),
          T = new Array(4);
        for (let t = 0; t < 4; ++t) T[t] = new e.Vector4();
        let x, v;
        if ('PerspectiveCamera' === this.frustumType) {
          const t = e.Matrix4.multiply(_, y, r.frustumCrate.frustum.projectionMatrix);
          v = e.Matrix4.inverse(t, _);
        } else 'OrthographicCamera' === this.frustumType && (x = e.Matrix4.inverseTransformation(y, _));
        e.defined(v)
          ? ((u[0] = this.near), (u[1] = this.far))
          : ((u[0] = 0), (u[1] = this.near), (u[2] = this.far));
        for (let i = 0; i < 2; ++i)
          for (let s = 0; s < 4; ++s) {
            let o = e.Vector4.clone(d[s], T[s]);
            if (e.defined(v)) {
              (o = e.Matrix4.multiplyByVector(v, o, o)),
                e.Vector3.multiplyByScalar(o, 1 / o.w, o),
                e.Vector3.subtract(o, t, o),
                e.Vector3.normalize(o, o);
              const s = e.Vector3.dot(g, o);
              e.Vector3.multiplyByScalar(o, u[i] / s, o), e.Vector3.add(o, t, o);
            } else {
              e.defined(r.frustumCrate.frustum._offCenterFrustum) &&
                (r.frustumCrate.frustum = r.frustumCrate.frustum._offCenterFrustum);
              const t = u[i],
                s = u[i + 1];
              (o.x =
                0.5 *
                (o.x * (r.frustumCrate.frustum.right - r.frustumCrate.frustum.left) +
                  r.frustumCrate.frustum.left +
                  r.frustumCrate.frustum.right)),
                (o.y =
                  0.5 *
                  (o.y * (r.frustumCrate.frustum.top - r.frustumCrate.frustum.bottom) +
                    r.frustumCrate.frustum.bottom +
                    r.frustumCrate.frustum.top)),
                (o.z = 0.5 * (o.z * (t - s) - t - s)),
                (o.w = 1),
                e.Matrix4.multiplyByVector(x, o, o);
            }
            (n[12 * i + 3 * s] = o.x), (n[12 * i + 3 * s + 1] = o.y), (n[12 * i + 3 * s + 2] = o.z);
          }
        return n;
      }
      computerOthersPlans(e) {
        let t = 24;
        return (
          (e[t] = e[12]),
          (e[t + 1] = e[13]),
          (e[t + 2] = e[14]),
          (e[t + 3] = e[0]),
          (e[t + 4] = e[1]),
          (e[t + 5] = e[2]),
          (e[t + 6] = e[9]),
          (e[t + 7] = e[10]),
          (e[t + 8] = e[11]),
          (e[t + 9] = e[21]),
          (e[t + 10] = e[22]),
          (e[t + 11] = e[23]),
          (t += 12),
          (e[t] = e[15]),
          (e[t + 1] = e[16]),
          (e[t + 2] = e[17]),
          (e[t + 3] = e[3]),
          (e[t + 4] = e[4]),
          (e[t + 5] = e[5]),
          (e[t + 6] = e[0]),
          (e[t + 7] = e[1]),
          (e[t + 8] = e[2]),
          (e[t + 9] = e[12]),
          (e[t + 10] = e[13]),
          (e[t + 11] = e[14]),
          (t += 12),
          (e[t] = e[3]),
          (e[t + 1] = e[4]),
          (e[t + 2] = e[5]),
          (e[t + 3] = e[15]),
          (e[t + 4] = e[16]),
          (e[t + 5] = e[17]),
          (e[t + 6] = e[18]),
          (e[t + 7] = e[19]),
          (e[t + 8] = e[20]),
          (e[t + 9] = e[6]),
          (e[t + 10] = e[7]),
          (e[t + 11] = e[8]),
          (t += 12),
          (e[t] = e[6]),
          (e[t + 1] = e[7]),
          (e[t + 2] = e[8]),
          (e[t + 3] = e[18]),
          (e[t + 4] = e[19]),
          (e[t + 5] = e[20]),
          (e[t + 6] = e[21]),
          (e[t + 7] = e[22]),
          (e[t + 8] = e[23]),
          (e[t + 9] = e[9]),
          (e[t + 10] = e[10]),
          (e[t + 11] = e[11]),
          e
        );
      }
      getAttributes(t, i, s, r, n, o, a, l) {
        const h = (t / 3) * 2;
        for (let n = 0; n < 4; ++n)
          e.defined(i) && ((i[t] = o.x), (i[t + 1] = o.y), (i[t + 2] = o.z)),
            e.defined(s) && ((s[t] = a.x), (s[t + 1] = a.y), (s[t + 2] = a.z)),
            e.defined(r) && ((r[t] = l.x), (r[t + 1] = l.y), (r[t + 2] = l.z)),
            (t += 3);
        (n[h] = 0),
          (n[h + 1] = 0),
          (n[h + 2] = 1),
          (n[h + 3] = 0),
          (n[h + 4] = 1),
          (n[h + 5] = 1),
          (n[h + 6] = 0),
          (n[h + 7] = 1);
      }
      computerNormalAndUvAndIndices() {
        const t = new Float32Array(12 * this.numberOfPlanes),
          i = new Float32Array(12 * this.numberOfPlanes),
          s = new Float32Array(12 * this.numberOfPlanes),
          r = new Float32Array(8 * this.numberOfPlanes),
          n = this.scratchXDirection,
          o = this.scratchYDirection,
          a = this.scratchZDirection,
          l = new e.Vector3(),
          h = new e.Vector3(),
          c = new e.Vector3(),
          _ = e.Vector3.negate(n, l),
          u = e.Vector3.negate(o, h),
          d = e.Vector3.negate(a, c);
        let m = 0;
        this.getAttributes(m, t, i, s, r, a, _, o),
          (m += 12),
          this.getAttributes(m, t, i, s, r, _, d, o),
          (m += 12),
          this.getAttributes(m, t, i, s, r, u, d, _),
          (m += 12),
          this.getAttributes(m, t, i, s, r, n, a, o),
          (m += 12),
          this.getAttributes(m, t, i, s, r, o, a, _),
          (this.indices = new Uint16Array(6 * this.numberOfPlanes)),
          (this.normals = t),
          (this.uvs = r);
        for (let e = 0; e < this.numberOfPlanes; ++e) {
          const t = 6 * e,
            i = 4 * e;
          (this.indices[t] = i),
            (this.indices[t + 1] = i + 1),
            (this.indices[t + 2] = i + 2),
            (this.indices[t + 3] = i),
            (this.indices[t + 4] = i + 2),
            (this.indices[t + 5] = i + 3);
        }
      }
      update(t) {
        if (this.needUpdate && t.painter) {
          this.needUpdate = !1;
          const i = t.painter.context;
          this._vertBuffer && this._indexBuffer
            ? (this._vertBuffer.updateData(this._vertexArray),
              this._indexBuffer.updateData(this._indices))
            : ((this._vertBuffer = i.createVertexBuffer(
                this._vertexArray,
                this._usedDoublePrecision ? e.layout.members : e.layout$1.members,
                this.dynamicDraw,
              )),
              (this._indexBuffer = i.createIndexBuffer(this._indices, this.dynamicDraw))),
            (this._segmentVector = e.SegmentVector.simpleSegment(
              0,
              0,
              this.vertices.length / 3,
              this.indices.length / 3,
            ));
        }
      }
      serialize() {
        return { type: this.type, camera: this.camera.serialize() };
      }
      destroy() {
        super.destroy(),
          (this.needUpdate = null),
          (this.indices = null),
          (this.vertices = null),
          (this.uvs = null),
          (this.vertices = null);
      }
    }
    class Tm extends e.Geometry {
      constructor(t) {
        super({}),
          (this.type = 'FrustumOutlineGeometry'),
          (this.primitiveType = e.WebGLConstants.LINES),
          this.setData(t);
      }
      setData(t) {
        super.setData({}),
          (this.frustumType = t.type),
          (this.position = new e.Vector3()),
          (this.quaternion = new e.Quaternion()),
          (this.camera = t),
          (this.numberOfPlanes = 6),
          (this.vertices = new Float64Array(24)),
          (this.indices = new Uint16Array(24)),
          (this._usedDoublePrecision = !1),
          this._vertexArray
            ? (this._vertexArray.clear(), this._indices.clear())
            : ((this._vertexArray = this._usedDoublePrecision
                ? new e.StructArrayLayout3f3f24()
                : new e.StructArrayLayout3f12()),
              (this._indices = new e.StructArrayLayout2ui4())),
          (this.needUpdate = !0),
          this.parse(),
          this.computeBoundingSphere(),
          this.computeBoundingBox();
      }
      parse() {
        this.#me(), this.#pe(), this.#fe();
      }
      update(t) {
        if (this.needUpdate && t.painter) {
          this.needUpdate = !1;
          const i = t.painter.context;
          this._vertBuffer && this._indexBuffer
            ? (this._vertBuffer.updateData(this._vertexArray),
              this._indexBuffer.updateData(this._indices))
            : ((this._vertBuffer = i.createVertexBuffer(
                this._vertexArray,
                this._usedDoublePrecision ? Z_.members : X_.members,
                this.dynamicDraw,
              )),
              (this._indexBuffer = i.createIndexBuffer(this._indices, this.dynamicDraw))),
            (this._segmentVector = e.SegmentVector.simpleSegment(
              0,
              0,
              this.vertices.length / 3,
              this.indices.length / 2,
            ));
        }
      }
      #fe() {
        this.emplaceVertexBufferOfLines();
        for (let e = 0; e < this.indices.length; e += 2)
          this._indices.emplaceBack(this.indices[e], this.indices[e + 1]);
      }
      #me() {
        const t = new e.Matrix3(),
          i = new e.Matrix3().fromQuaternion(this.quaternion, t),
          s = new e.Matrix4(),
          r = new Array(4);
        (r[0] = new e.Vector4(-1, -1, 1, 1)),
          (r[1] = new e.Vector4(1, -1, 1, 1)),
          (r[2] = new e.Vector4(1, 1, 1, 1)),
          (r[3] = new e.Vector4(-1, 1, 1, 1));
        const n = new Array(4);
        for (let t = 0; t < 4; ++t) n[t] = new e.Vector4();
        let o = new e.Vector3(),
          a = new e.Vector3(),
          l = new e.Vector3();
        (o = e.Matrix3.getColumn(i, 0, o)),
          (a = e.Matrix3.getColumn(i, 1, a)),
          (l = e.Matrix3.getColumn(i, 2, l)),
          e.Vector3.normalize(o, o),
          e.Vector3.normalize(a, a),
          e.Vector3.normalize(l, l),
          e.Vector3.negate(o, o),
          e.Vector3.negate(l, l);
        const h = e.Matrix4.computeView(this.position, l, a, o, new e.Matrix4());
        let c, _;
        if ('PerspectiveCamera' === this.frustumType) {
          const t = e.Matrix4.multiply(s, this.camera.frustumCrate.frustum.projectionMatrix, h);
          _ = e.Matrix4.inverse(t, s);
        } else c = e.Matrix4.inverseTransformation(h, s);
        const u = new Array(3);
        e.defined(_)
          ? ((u[0] = this.camera.near), (u[1] = this.camera.far))
          : ((u[0] = 0), (u[1] = this.camera.near), (u[2] = this.camera.far));
        for (let t = 0; t < 2; ++t)
          for (let i = 0; i < 4; ++i) {
            let s = e.Vector4.clone(r[i], n[i]);
            if (e.defined(_)) {
              (s = e.Matrix4.multiplyByVector(_, s, s)),
                e.Vector3.multiplyByScalar(s, 1 / s.w, s),
                e.Vector3.subtract(s, this.position, s),
                e.Vector3.normalize(s, s);
              const i = e.Vector3.dot(l, s);
              e.Vector3.multiplyByScalar(s, u[t] / i, s), e.Vector3.add(s, this.position, s);
            } else {
              e.defined(this.camera.frustumCrate.frustum._offCenterFrustum) &&
                (this.camera.frustumCrate.frustum =
                  this.camera.frustumCrate.frustum._offCenterFrustum);
              const i = u[t],
                r = u[t + 1];
              (s.x =
                0.5 *
                (s.x *
                  (this.camera.frustumCrate.frustum.right - this.camera.frustumCrate.frustum.left) +
                  this.camera.frustumCrate.frustum.left +
                  this.camera.frustumCrate.frustum.right)),
                (s.y =
                  0.5 *
                  (s.y *
                    (this.camera.frustumCrate.frustum.top -
                      this.camera.frustumCrate.frustum.bottom) +
                    this.camera.frustumCrate.frustum.bottom +
                    this.camera.frustumCrate.frustum.top)),
                (s.z = 0.5 * (s.z * (i - r) - i - r)),
                (s.w = 1),
                e.Matrix4.multiplyByVector(c, s, s);
            }
            (this.vertices[12 * t + 3 * i] = s.x),
              (this.vertices[12 * t + 3 * i + 1] = s.y),
              (this.vertices[12 * t + 3 * i + 2] = s.z);
          }
      }
      #pe() {
        let e,
          t,
          i = 0;
        for (; i < 2; ++i)
          (e = 8 * i),
            (t = 4 * i),
            (this.indices[e] = t),
            (this.indices[e + 1] = t + 1),
            (this.indices[e + 2] = t + 1),
            (this.indices[e + 3] = t + 2),
            (this.indices[e + 4] = t + 2),
            (this.indices[e + 5] = t + 3),
            (this.indices[e + 6] = t + 3),
            (this.indices[e + 7] = t);
        for (i = 0; i < 2; ++i)
          (e = 8 * (2 + i)),
            (t = 4 * i),
            (this.indices[e] = t),
            (this.indices[e + 1] = t + 4),
            (this.indices[e + 2] = t + 1),
            (this.indices[e + 3] = t + 5),
            (this.indices[e + 4] = t + 2),
            (this.indices[e + 5] = t + 6),
            (this.indices[e + 6] = t + 3),
            (this.indices[e + 7] = t + 7);
      }
      serialize() {
        return { type: this.type, camera: this.camera.serialize() };
      }
      destroy() {
        super.destroy(),
          (this.frustumType = void 0),
          (this.position = void 0),
          (this.quaternion = void 0),
          (this.camera = void 0),
          (this.type = void 0),
          (this.primitiveType = void 0),
          (this.numberOfPlanes = void 0),
          (this.vertices = void 0),
          (this.indices = void 0),
          (this._vertexArray = void 0),
          (this._indices = void 0),
          (this.needUpdate = void 0);
      }
    }
    const xm = new Uint32Array(1);
    class vm extends e.Evented {
      constructor(t) {
        if ((super(), (this.videoTextureFun = t.videoTextureFun), !t.location))
          throw new Error('location is null!');
        if (!Array.isArray(t.location)) throw new Error('location is not array!');
        if (
          ((this._location = [parseFloat(t.location[0]), parseFloat(t.location[1])]),
          (this.altitude = e.defaultValue(parseFloat(t.altitude), 60)),
          (this._oldAltitude = this._altitude),
          (this._aspect = e.defaultValue(
            t.aspect,
            e.window.document.body.clientWidth / e.window.document.body.clientHeight,
          )),
          (this._oldAspect = this._aspect),
          (this._fov = e.defaultValue(t.fov, 45)),
          (this._oldFov = this._fov),
          (this._near = e.defaultValue(t.near, 0.1)),
          (this._oldNear = this._near),
          (this._far = e.defaultValue(t.far, this._altitude + 100)),
          (this._oldFar = this._far),
          (this._alpha = e.defaultValue(t.alpha, 1)),
          (this._enabled = e.defaultValue(t.enabled, !0)),
          (this._visible = !1),
          (this.uniqueId = (xm[0]++, xm[0])),
          (this._heading = e.defaultValue(t.heading, 0)),
          (this._oldHeading = this._heading),
          (this._pitch = e.defaultValue(t.pitch, 0)),
          (this._oldPitch = this._pitch),
          (this._roll = e.defaultValue(t.roll, 0)),
          (this._oldRoll = this._roll),
          (this.videoTexture = void 0),
          (this.customOptions = t.customOptions),
          (this._videoManager = void 0),
          (this._clip = e.defaultValue(t.clip, !0)),
          (this._clipColor = this.#ge()),
          (this._clipRegions = e.defaultValue([t.clipRegions], [])),
          (this._shouldAddClipRegion = this._clipRegions.length > 0),
          (this._camTransformMatrix = void 0),
          (this._debugVideo = !1),
          (this.debugVideo = e.defaultValue(t.debugVideo, !1)),
          (this._debugFrustum = void 0),
          (this._debugFrustumOutline = void 0),
          t.minzoom > t.maxzoom)
        )
          throw new Error('minzoom must be less than maxzoom');
        (this._minzoom = e.defaultValue(t.minzoom, 0)),
          (this._maxzoom = e.defaultValue(t.maxzoom, 22)),
          (this._used3DModel = e.defaultValue(t.used3DModel, !0)),
          (this._used3DTiles = e.defaultValue(t.used3DTiles, !0)),
          (this._usedPolygon = e.defaultValue(t.usedPolygon, !0)),
          (this._usedRaster = e.defaultValue(t.usedRaster, !0));
        const i = e.defaultValue(t.callback, () => {});
        this.on('visible', i),
          (this._perspectiveCamera = new n(this._fov, this._aspect, this._near, this._far)),
          (this.videoMatrix = void 0),
          this.#ye();
      }
      get alpha() {
        return this._alpha;
      }
      set alpha(t) {
        e.isNumber(t) && (this._alpha = t);
      }
      get altitude() {
        return this._altitude;
      }
      set altitude(t) {
        e.isNumber(t) && (this._altitude = t);
      }
      get aspect() {
        return this._aspect;
      }
      set aspect(t) {
        e.isNumber(t) && (this._aspect = t);
      }
      get enabled() {
        return this._enabled;
      }
      set enabled(t) {
        e.isBoolean(t) && (this._enabled = t),
          e.defined(this._debugFrustum) &&
            ((this._debugFrustum.show = t), (this._debugFrustumOutline.show = t));
      }
      get far() {
        return this._far;
      }
      set far(t) {
        e.isNumber(t) && (this._far = t);
      }
      get fov() {
        return this._fov;
      }
      set fov(t) {
        e.isNumber(t) && (this._fov = t);
      }
      get heading() {
        return this._heading;
      }
      set heading(t) {
        e.isNumber(t) && (this._heading = t);
      }
      get location() {
        return this._location;
      }
      set location(e) {
        Array.isArray(e) && (this._location = e);
      }
      get near() {
        return this._near;
      }
      set near(t) {
        e.isNumber(t) && (this._near = t);
      }
      get pitch() {
        return this._pitch;
      }
      set pitch(t) {
        e.isNumber(t) && (this._pitch = t);
      }
      get roll() {
        return this._roll;
      }
      set roll(t) {
        e.isNumber(t) && (this._roll = t);
      }
      get used3DModel() {
        return this._used3DModel;
      }
      set used3DModel(t) {
        e.isBoolean(t) && (this._used3DModel = t);
      }
      get used3DTiles() {
        return this._used3DTiles;
      }
      set used3DTiles(t) {
        e.isBoolean(t) && (this._used3DTiles = t);
      }
      get usedPolygon() {
        return this._usedPolygon;
      }
      set usedPolygon(t) {
        e.isBoolean(t) && (this._usedPolygon = t);
      }
      get usedRaster() {
        return this._usedRaster;
      }
      set usedRaster(t) {
        e.isBoolean(t) && (this._usedRaster = t);
      }
      get visible() {
        return this._visible;
      }
      get minzoom() {
        return this._minzoom;
      }
      set minzoom(t) {
        e.isNumber(t) && (this._minzoom = t);
      }
      get maxzoom() {
        return this._maxzoom;
      }
      set maxzoom(t) {
        e.isNumber(t) && (this._maxzoom = t);
      }
      #Te(e) {
        const t = e.style.getNearestTileZoom();
        return t <= this._maxzoom && t >= this._minzoom;
      }
      update(t, i) {
        this.#Te(t) &&
          this._enabled &&
          (e.defined(this._videoManager) || (this._videoManager = i),
          this._shouldAddClipRegion &&
            (this.removeClipRegion(),
            this._videoManager._clipManager.add({
              positions: this._clipRegions,
              uniqueId: this.uniqueId,
              clipColor: this._clipColor,
            }),
            (this._shouldAddClipRegion = !1),
            (this._clipRegions = [])),
          this.#xe(t),
          this.#ve(t),
          this.#be(t),
          this.debugVideo !== this._debugVideo &&
            (this.debugVideo ? this.#we(t) : this.#Ce(t), (this._debugVideo = this.debugVideo)),
          e.defined(this._debugFrustum) &&
            e.defined(t.frameState.camera) &&
            (this._debugFrustum.update(t, t.frameState),
            this._debugFrustumOutline.update(t, t.frameState)));
      }
      #we(t) {
        (this._debugFrustum = new e.Primitive({
          geometry: new ym(this._perspectiveCamera),
          material: e.StandardMaterial.fromType('Color', { color: new e.Color(0, 1, 1, 0.1) }),
          name: `debugVideo_${this.uniqueId}`,
          modelMatrix: this._camTransformMatrix,
        })),
          t.style.addPrimitive(this._debugFrustum),
          (this._debugFrustumOutline = new e.Primitive({
            geometry: new Tm(this._perspectiveCamera),
            material: e.StandardMaterial.fromType('Color', {
              color: new e.Color(1, 0, 0, 1),
              lightingModel: e.LightingModelType.NONE,
            }),
            name: `debugVideo_${this.uniqueId}`,
            modelMatrix: this._camTransformMatrix,
          })),
          t.style.addPrimitive(this._debugFrustumOutline);
      }
      #Ce(e) {
        e.style.removePrimitive(this._debugFrustum),
          (this._debugFrustum = void 0),
          e.style.removePrimitive(this._debugFrustumOutline),
          (this._debugFrustumOutline = void 0);
      }
      addClipRegion(e) {
        if (!(e instanceof Array)) throw new Error('请正确添加视频裁剪区域位置数组！');
        this._clipRegions.push(e), (this._shouldAddClipRegion = !0);
      }
      getClipRegion() {
        return e.defined(this._videoManager)
          ? this._videoManager._clipManager.getByName(this.uniqueId)
          : [];
      }
      removeClipRegion() {
        e.defined(this._videoManager)
          ? this._videoManager._clipManager.removeByName(this.uniqueId)
          : ((this._clipRegions = []), (this._shouldAddClipRegion = !1));
      }
      positioning(e, t) {
        if (!Array.isArray(e)) throw new Error('请输入正确视频点坐标!');
        if (!Array.isArray(t)) throw new Error('请输入正确球面点坐标!');
        const i = parseFloat(t[0] - e[0]),
          s = parseFloat(t[1] - e[1]);
        this.location = [this.location[0] + i, this.location[1] + s];
      }
      #xe(e) {
        (this._location === this._oldLocation &&
          this._heading === this._oldHeading &&
          this._pitch === this._oldPitch &&
          this._roll === this._oldRoll &&
          this._fov === this._oldFov &&
          this._altitude === this._oldAltitude &&
          this._near === this._oldNear &&
          this._far === this._oldFar &&
          this._aspect === this._oldAspect) ||
          (this.#ye(),
          this._debugFrustum &&
            (this._fov !== this._oldFov ||
            this._aspect !== this._oldAspect ||
            this._near !== this._oldNear ||
            this._far !== this._oldFar
              ? (this.#Ce(e), this.#we(e))
              : (this._debugFrustum.setMatrix(this._camTransformMatrix),
                this._debugFrustum.updateMatrixWorld(!0),
                this._debugFrustumOutline.setMatrix(this._camTransformMatrix),
                this._debugFrustumOutline.updateMatrixWorld(!0))),
          (this._oldLocation = this._location),
          (this._oldHeading = this._heading),
          (this._oldPitch = this._pitch),
          (this._oldRoll = this._roll),
          (this._oldLocation = this._location),
          (this._oldAltitude = this._altitude),
          (this._oldFov = this._fov),
          (this._oldAspect = this._aspect),
          (this._oldNear = this._near),
          (this._oldFar = this._far));
      }
      #ye() {
        const t = e.Vector3.fromDegrees(this.location[0], this.location[1], this.altitude);
        (this._camTransformMatrix = e.Transforms.headingPitchRollToFixedFrame(
          t,
          new e.HeadingPitchRoll(
            e.CONSTS.CesiumMath.toRadians(this.heading),
            e.CONSTS.CesiumMath.toRadians(this.pitch),
            e.CONSTS.CesiumMath.toRadians(this.roll),
          ),
        )),
          (this.cartographic = new e.Vector3(
            this._camTransformMatrix[12],
            this._camTransformMatrix[13],
            this._camTransformMatrix[14],
          ));
        const i = this._camTransformMatrix.clone();
        (i[12] = 0),
          (i[13] = 0),
          (i[14] = 0),
          i.invert(),
          (this.videoMatrix = new e.Matrix4()
            .perspective({
              fov: this.fov * e.CONSTS.TRANSFORM.DEG_TO_RAD,
              aspect: this.aspect,
              near: this.near,
              far: this.far,
            })
            .multiplyRight(i)),
          this._perspectiveCamera.updatePerspectiveOptions({
            fov: this._fov,
            aspect: this._aspect,
            near: this._near,
            far: this.far,
          }),
          this._perspectiveCamera.setMatrix(this._camTransformMatrix.clone());
        const s = [],
          r = new e.Quaternion().fromHeadingPitchRoll(
            new e.HeadingPitchRoll(
              e.CONSTS.CesiumMath.toRadians(this.heading),
              e.CONSTS.CesiumMath.toRadians(this.pitch),
              e.CONSTS.CesiumMath.toRadians(this.roll),
            ),
          ),
          n = new ym(this._perspectiveCamera);
        n.computeNearFarPlanes(
          this._perspectiveCamera.position,
          r,
          'PerspectiveCamera',
          this._perspectiveCamera,
          s,
        ),
          n.computerOthersPlans(s);
        const o = [];
        for (let t = 0; t < s.length; t += 3) o.push(e.Vector3.unpack(s, t));
        this._boundingSphere = e.OrientedBoundingBox.fromPoints(o);
      }
      #ve(t) {
        const i =
          -1 !==
          t.transform.activeCamera.frustumCrate.cullingVolume.computeVisibility(
            this._boundingSphere,
          );
        this._visible !== i && ((this._visible = i), this.fire(new e.Event('visible')));
      }
      #be(t) {
        if (
          (e.defined(this.videoTexture) ||
            (this.videoTexture = new e.Texture({
              context: t.context,
              image: void 0,
              pixelFormat: e.WebGLConstants.RGBA,
            })),
          e.defined(this.videoTextureFun) && this._enabled)
        ) {
          const t = this.videoTextureFun();
          e.defined(t) &&
            0 !== t.videoHeight &&
            0 !== t.videoWidth &&
            (this.videoTexture.upload(t),
            (this.videoTexture._hasSetSampler = !1),
            this.videoTexture.bind(e.WebGLConstants.LINEAR, e.WebGLConstants.CLAMP_TO_EDGE));
        }
      }
      #ge() {
        const t = e.Color.fromRgba(this.uniqueId);
        return (t.a = 1), t;
      }
      destroy() {
        (this._location = void 0),
          (this._altitude = void 0),
          (this._oldAltitude = void 0),
          (this._aspect = void 0),
          (this._oldAspect = void 0),
          (this._fov = void 0),
          (this._oldFov = void 0),
          (this._near = void 0),
          (this._oldNear = void 0),
          (this._far = void 0),
          (this._oldFar = void 0),
          (this._alpha = void 0),
          (this._enabled = void 0),
          (this.uniqueId = void 0),
          (this._heading = void 0),
          (this._oldHeading = void 0),
          (this._pitch = void 0),
          (this._oldPitch = void 0),
          (this._roll = void 0),
          (this._oldRoll = void 0);
      }
    }
    class bm {
      constructor(e) {
        (this._clipRegions = []),
          (this._clipPrimitives = []),
          (this._painter = void 0),
          (this._videoManager = e.videoManager);
      }
      get length() {
        return this._clipPrimitives.length;
      }
      add(e) {
        this._clipRegions.push(e);
      }
      remove(e) {
        const t = this.indexOf(e);
        return -1 !== t && (this.removeByIndex(t), !0);
      }
      removeByName(e) {
        const t = this.getByName(e);
        if (t.length > 0) for (let e = 0; e < t.length; e++) this.remove(t[e]);
      }
      removeByIndex(t) {
        const i = this.getByIndex(t);
        e.defined(i) && (this._clipPrimitives.splice(t, 1), this.removePrimitiveFromScene(i));
      }
      removeAll() {
        for (let e = this._clipPrimitives.length; e >= 0; e--)
          this.remove(this._clipPrimitives[e - 1]);
      }
      removePrimitiveFromScene(e) {
        this._painter && (this._painter.style.removePrimitiveForPreRender(e), e.destroy());
      }
      indexOf(e) {
        return this._clipPrimitives.indexOf(e);
      }
      getByName(e) {
        const t = [];
        return (
          this._clipPrimitives.forEach((i) => {
            i.name === e && t.push(i);
          }),
          t
        );
      }
      getByIndex(e) {
        return this._clipPrimitives[e];
      }
      getAll() {
        return this._clipPrimitives;
      }
      createPrimitives() {
        for (let e = 0; e < this._clipRegions.length; e++)
          this.createPrimitive(this._clipRegions.splice(0, 1)[0]);
      }
      _updateExtraCamera() {
        if (0 === this._clipPrimitives.length) return;
        const t = this._painter,
          i = this._clipPrimitives,
          s = [1 / 0, 1 / 0, 1 / 0],
          r = [-1 / 0, -1 / 0, -1 / 0];
        let n = 0;
        for (let o = 0; o < i.length; o++) {
          const a = i[o];
          if (
            t.frameState.camera.frustumCrate.cullingVolume.computeVisibility(a.boundingBox) ==
            e.INTERSECTION.OUTSIDE
          )
            continue;
          n++;
          const l = a.boundingBox.getBoundingMaximum(),
            h = l.boundingMinValue,
            c = l.boundingMaxValue;
          h[0] < s[0] && (s[0] = h[0]),
            h[1] < s[1] && (s[1] = h[1]),
            h[2] < s[2] && (s[2] = h[2]),
            c[0] > r[0] && (r[0] = c[0]),
            c[1] > r[1] && (r[1] = c[1]),
            c[2] > r[2] && (r[2] = c[2]);
        }
        if (0 === n) return;
        const a = [(s[0] + r[0]) / 2, (s[1] + r[1]) / 2, (s[2] + r[2]) / 2];
        1 === n &&
          ((s[0] -= 2 * (a[0] - s[0])),
          (s[1] -= 2 * (a[1] - s[1])),
          (s[2] -= 2 * (a[2] - s[2])),
          (r[0] += 2 * (r[0] - a[0])),
          (r[1] += 2 * (r[1] - a[1])),
          (r[2] += 2 * (r[2] - a[2])));
        const l = Math.max(r[0] - s[0], r[1] - s[1], r[2] - s[2]),
          h = new o(l, t.style.map.transform.width / t.style.map.transform.height, 1, 1e4),
          c = e.Transforms.cartesian3ToCartographic(a),
          _ = e.Transforms.cartographicToCartesian3([c[0], c[1], c[2] + 50]),
          u = e.Transforms.localFrameToFixedFrame(_);
        h.setMatrix(u);
        for (let e = 0; e < i.length; e++) i[e]._material._extraCamera = h;
        this._extraCameraOfOrthographic = h;
      }
      createPrimitive(t) {
        if (e.defined(t.positions) && Array.isArray(t.positions[0])) {
          const i = new e.Primitive({
            geometry: new e.PolygonGeometry({
              polygonHierarchy: { positions: e.Vector3.fromDegreesArrayHeights(t.positions[0]) },
            }),
            material: e.StandardMaterial.fromType('Color', {
              color: t.clipColor,
              lightingModel: e.LightingModelType.NONE,
            }),
            framebuffer: this._videoManager._clipFill.framebuffer.framebuffer,
            name: t.uniqueId,
          });
          (i.visible = !1),
            this._painter.style.addPrimitiveForPreRender(i),
            this._clipPrimitives.push(i);
        }
      }
      update(t) {
        let i;
        e.defined(this._painter) || (this._painter = t),
          this._clipRegions.length > 0 && this.createPrimitives(),
          this._updateExtraCamera();
        for (let t = 0; t < this._clipPrimitives.length; t++)
          (i = 0 === t ? { color: new e.Color(0, 0, 0, 1), depth: 1, stencil: 0 } : void 0),
            (this._clipPrimitives[t].clearStates = i);
      }
      destroy() {
        this._painter = void 0;
      }
    }
    class wm {
      constructor() {
        (this._videos = []),
          (this._videoModelMaterial = new gm(this, '3DModel')),
          (this._videoRasterMaterial = new gm(this, 'Raster')),
          (this._videoTilesMaterial = new gm(this, '3DTiles')),
          (this._videoPolygonMaterial = new gm(this, 'Polygon')),
          (this._enabled = !0),
          (this._maxUsedVideoUnit = 0),
          (this._enabledClip = !0),
          (this._clipManager = new bm({ videoManager: this })),
          (this._clipFill = new Cu()),
          (this._projectionMatrix = void 0);
      }
      get enabled() {
        return this._enabled;
      }
      set enabled(t) {
        if (e.isBoolean(t)) {
          this._enabled = t;
          for (let e = 0; e < this.length; e++) this._videos[e].enabled = t;
        }
      }
      get enableClip() {
        return this._enabledClip;
      }
      set enableClip(t) {
        e.isBoolean(t) && (this._enabledClip = t);
      }
      get length() {
        return this._videos.length;
      }
      get enabledLength() {
        let e = 0;
        for (let t = 0; t < this._videos.length; t++) this._videos[t].enabled && e++;
        return e;
      }
      add(t, i) {
        if (!(t instanceof vm)) return console.error('当前添加的不是视频文件，请检查！'), !1;
        const s = e.defined(i);
        if (s) {
          if (i < 0) throw new Error('index must be greater than or equal to zero.');
          if (i > this._videos.length)
            throw new Error('index must be less than or equal to the number of videos.');
        }
        return s ? this._videos.splice(i, 0, t) : this._videos.push(t), !0;
      }
      lower(e) {
        const t = this.indexOf(e);
        this.#Se(t, t - 1);
      }
      raise(e) {
        const t = this.indexOf(e);
        this.#Se(t, t + 1);
      }
      #Se(t, i) {
        const s = this._videos;
        if ((t = e.clamp(t, 0, s.length - 1)) === (i = e.clamp(i, 0, s.length - 1))) return;
        const r = s[t];
        (s[t] = s[i]), (s[i] = r);
      }
      remove(e) {
        const t = this.indexOf(e);
        return -1 !== t && (e.removeClipRegion(), this._videos.splice(t, 1), !0);
      }
      removeById(e) {
        const t = this.getById(e);
        this.remove(t);
      }
      removeAll() {
        for (let e = 0; e < this.length; e++) this.getByIndex(e).removeClipRegion();
        (this._videos = []),
          (this._videoModelMaterial._selectedModelTiles = []),
          (this._videoRasterMaterial._rasterTiles = []),
          (this._videoTilesMaterial._selectedTiles = []),
          (this._videoPolygonMaterial._selectPolygons = []);
      }
      removeAllClipRegions() {
        this._clipManager.removeAll();
      }
      getById(e) {
        let t;
        return (
          this._videos.forEach((i) => {
            i.uniqueId === e && (t = i);
          }),
          t
        );
      }
      getByIndex(e) {
        return this._videos[e];
      }
      getAll() {
        return this._videos;
      }
      contains(e) {
        return -1 !== this.indexOf(e);
      }
      containsById(e) {
        return -1 !== this.getById(e);
      }
      indexOf(e) {
        return this._videos.indexOf(e);
      }
      indexOfById(e) {
        return this.containsById(e) ? this.indexOf(this.getById(e)) : -1;
      }
      update(e) {
        if (
          (this._videoModelMaterial.removeUniforms(),
          this._videoRasterMaterial.removeUniforms(),
          this._videoTilesMaterial.removeUniforms(),
          this._videoPolygonMaterial.removeUniforms(),
          !this._enabled || this.length < 1)
        )
          return;
        this._clipManager.update(e), this.#Ee(e), this._clipFill.update(e), this.#Pe(e);
        const t = this.length;
        for (let i = 0; i < t; i++) this.getByIndex(i).update(e, this);
        this._videoModelMaterial.update(e),
          this._videoRasterMaterial.update(e),
          this._videoTilesMaterial.update(e),
          this._videoPolygonMaterial.update(e);
      }
      clear3DModel() {
        this._videoModelMaterial.removeUniforms(),
          !this._enabled || this.length < 1 || (this._videoModelMaterial._usedVideos = []);
      }
      update3DModel(e) {
        !this._enabled || this.length < 1 || this._videoModelMaterial.select3DModel(e);
      }
      clear3DTiles() {
        this._videoTilesMaterial.removeUniforms(),
          !this._enabled || this.length < 1 || (this._videoTilesMaterial._usedVideos = []);
      }
      update3DTiles(e) {
        !this._enabled || this.length < 1 || this._videoTilesMaterial.select3DTiles(e);
      }
      #Pe(t) {
        let i,
          s,
          r,
          n = [],
          o = 0,
          a = 0,
          l = 0,
          h = 0;
        for (let c = 0; c < t.style._order.length; c++) {
          if (
            ((i = t.style._layers[t.style._order[c]]),
            (s = t.style.sourceCaches[i.source]),
            'raster' === i.type)
          ) {
            if (s && s.getVisibleCoordinates) {
              (n = s.getVisibleCoordinates(!1)), (r = i.id);
              for (let i = 0; i < n.length; i++) {
                const s = t.rasterPlotter._drawCommands.get(r),
                  a = s ? s.get(n[i].key) : void 0;
                if (void 0 !== a) {
                  const t = a._material._uniforms.entries();
                  for (;;) {
                    const i = t.next();
                    if (i.done) break;
                    const s = i.value[0],
                      r = i.value[1]();
                    r instanceof e.Texture
                      ? h++
                      : r instanceof Array &&
                        r[0] instanceof e.Texture &&
                        'u_VideoSampler' !== s &&
                        (h += r.length);
                  }
                  o = Math.max(o, h);
                  break;
                }
              }
            }
          } else if ('3d-tiles' === i.type) {
            const t = s.tileset3d;
            if (e.defined(t)) {
              const i = t.selectedTiles;
              let s = [];
              for (let e = 0; e < i.length; e++) {
                let t = [];
                'cmpt' === i[e].content.type
                  ? i[e].content.tiles.forEach((e) => {
                      t = t.concat(e.gltf.meshes);
                    })
                  : (t = t.concat(i[e].content.gltf.meshes));
                for (let e = 0; e < t.length; e++) s = s.concat(t[e].primitives);
              }
              if (e.defined(s))
                for (let t = 0; t < s.length; t++)
                  if (void 0 !== s[t] && e.defined(s[t]._material.pickColor)) {
                    const i = s[t]._material._uniforms.entries();
                    for (;;) {
                      const t = i.next();
                      if (t.done) break;
                      const s = t.value[0],
                        r = t.value[1];
                      if (r instanceof Function) {
                        const t = r();
                        t instanceof e.Texture
                          ? h++
                          : t instanceof Array &&
                            t[0] instanceof e.Texture &&
                            'u_VideoSampler' !== s &&
                            (h += t.length);
                      }
                    }
                    a = Math.max(a, h);
                    break;
                  }
            }
          } else if ('3d-model' === i.type) {
            let t = [];
            for (let e = 0; e < s._cesiumTiles.length; e++)
              t = t.concat(s._cesiumTiles[0].primitives);
            for (let i = 0; i < t.length; i++)
              if (void 0 !== t[i] && e.defined(t[i]._material.pickColor)) {
                const s = t[i]._material._uniforms.entries();
                for (;;) {
                  const t = s.next();
                  if (t.done) break;
                  const i = t.value[0],
                    r = t.value[1];
                  if (r instanceof Function) {
                    const t = r();
                    t instanceof e.Texture
                      ? h++
                      : t instanceof Array &&
                        t[0] instanceof e.Texture &&
                        'u_VideoSampler' !== i &&
                        (h += t.length);
                  }
                }
                l = Math.max(l, h);
                break;
              }
          }
          h = 0;
        }
        const c = Math.max(o, a, l),
          _ = t.context.gl.getParameter(e.WebGLConstants.MAX_TEXTURE_IMAGE_UNITS) - c;
        this._maxUsedVideoUnit = _;
      }
      #Ee(t) {
        e.defined(t.frameState.camera) &&
          this._clipManager._extraCameraOfOrthographic &&
          (this._projectionMatrix = this._clipManager._extraCameraOfOrthographic
            .getVPMatrix()
            .clone());
      }
      serialize() {
        const e = [];
        for (let t = 0; t < this.length; t++) {
          const i = this.getByIndex(t);
          e[t] = {
            location: i.location,
            altitude: i.altitude,
            aspect: i.aspect,
            fov: i.fov,
            alpha: i.alpha,
            heading: i.heading,
            pitch: i.pitch,
            roll: i.roll,
            near: i.near,
            enabled: i.enabled,
            far: i.far,
            customOptions: i.customOptions,
            minzoom: i.minzoom,
            maxzoom: i.maxzoom,
            used3DModel: i.used3DModel,
            used3DTiles: i.used3DTiles,
            usedRaster: i.usedRaster,
            usedPolygon: i.usedPolygon,
            debugVideo: i.debugVideo,
          };
        }
        return e.length > 0 ? e : void 0;
      }
    }
    class Cm {
      constructor() {
        (this.mViewshedVisibleColor = new e.Vector3(0, 0, 0)),
          (this.mViewshedInVisibleColor = new e.Vector3(0, 0, 0)),
          (this.mViewshedVisibleDefaultColor = new e.Vector3(0, 1, 0)),
          (this.mViewshedInVisibleDefaultColor = new e.Vector3(1, 0, 0)),
          (this.mCurNodeCountRender = 0),
          (this.mSceneLightDir3 = new e.Vector3(0, 0, 1)),
          (this.shadowOff = 0.0025),
          (this.shadowMapInvScale = 0.3),
          (this.mShadowCenter = new e.Vector3()),
          (this.mShadowCenterLocal = new e.Vector3()),
          (this.mShadowCenterMode = !1),
          (this.globalInnerColor = new e.Vector4(41 / 255, 52 / 255, 71 / 255, 8)),
          (this.globalOuterColor = new e.Vector4(166 / 255, 184 / 255, 213 / 255, 0)),
          (this.globalOuterPara = new e.Vector4(543146, 2.3, 6, 0)),
          (this.globalLightPercent = new e.Vector4(1, 0.01, 3.5, 1.2)),
          (this.nightGlobalPer = new e.Vector2(0.01, 0.1)),
          (this.nightVisible = !0);
      }
      getGlobalInnerColor() {
        return this.globalInnerColor;
      }
      getGlobalOuterColor() {
        return this.globalOuterColor;
      }
      getGlobalLightPercent() {
        return this.globalLightPercent;
      }
      setViewshedVisibleColor(e) {
        this.mViewshedVisibleColor.set(e[0], e[1], e[2]);
      }
      setViewshedInVisibleColor(e) {
        this.mViewshedInVisibleColor.set(e[0], e[1], e[2]);
      }
      setShadowCenterLngLat(t, i) {
        this.mShadowCenterLngLat = t;
        const s = e.Transforms.cartographicToCartesian3(new e.Vector3(t[0], t[1], 0));
        this.mShadowCenter.set(s[0], s[1], s[2]), (this.mShadowRadius = i);
      }
    }
    class Sm {
      constructor(t) {
        if (
          ((t = e.defined(t) ? t : {}),
          e.defined(t.geometry) && !(t.geometry instanceof e.Geometry))
        )
          throw new Error('Geometry is not valid!');
        if (
          ((this._geometry = e.defaultValue(t.geometry, new e.Geometry({}))),
          e.defined(t.color) && !(t.color instanceof e.Color) && 'string' != typeof t.color)
        )
          throw new Error('Color type must be Color or String!');
        if (
          ((this._color = e.Color.parse(e.defaultValue(t.color, new e.Color(1, 0, 0, 0.3)))),
          e.defined(t.opacity) && !e.isNumber(t.opacity))
        )
          throw new Error("'opacity' option must be a number!");
        if (
          ((this._opacity = e.defaultValue(t.opacity, 1)),
          e.defined(t.modelMatrix) && !(t.modelMatrix instanceof e.Matrix4))
        )
          throw new Error("'modelMatrix' is not valid");
        if (
          ((this._modelMatrix = e.defaultValue(t.modelMatrix, e.Matrix4.IDENTITY)),
          e.defined(t.enabled) && !e.isBoolean(t.enabled))
        )
          throw new Error("'enabled' option must be true or false!");
        (this._enabled = e.defaultValue(t.enabled, !0)),
          (this._initialized = !1),
          (this._geometryUpdated = !1),
          (this._colorUpdated = !1),
          (this._opacityUpdated = !1),
          (this._modelMatrixUpdated = !1),
          (this.id = e.uuid());
      }
      get geometry() {
        return this._geometry;
      }
      set geometry(t) {
        if (!(t instanceof e.Geometry)) throw new Error('Geometry is not valid!');
        (this._geometry = t), (this._geometryUpdated = !1);
      }
      get color() {
        return this._color;
      }
      set color(t) {
        if (!(t instanceof e.Color || 'string' == typeof t))
          throw new Error('Color type must be Color or String!');
        (this._color = e.Color.parse(t)), (this._colorUpdated = !1);
      }
      get opacity() {
        return this._opacity;
      }
      set opacity(t) {
        if (!e.isNumber(t)) throw new Error("'opacity' option must be a number!");
        (this._opacity = t), (this._opacityUpdated = !1);
      }
      get modelMatrix() {
        return this._modelMatrix;
      }
      set modelMatrix(t) {
        if (!(t instanceof e.Matrix4)) throw new Error('Model matrix is not valid!');
        (this._modelMatrix = t), (this._modelMatrixUpdated = !1);
      }
      get enabled() {
        return this._enabled;
      }
      set enabled(t) {
        if (!e.isBoolean(t)) throw new Error("'enabled' option must be true or false!");
        this._enabled = t;
      }
      #Me() {
        (this._passFrontRenderState = {}),
          (this._passFrontRenderState.blending = e.renderStateEnum.disableBlending),
          (this._passFrontRenderState.cull = e.renderStateEnum.disableCull),
          (this._passFrontRenderState.depthTest = e.renderStateEnum.enableDepthTest),
          (this._passFrontRenderState.depthRange = e.renderStateEnum.depthRange),
          (this._passFrontRenderState.depthMask = e.renderStateEnum.disableDepthMask),
          (this._passFrontRenderState.stencilTest =
            e.renderStateEnum.enableClassificationStencilTest),
          (this._passFrontRenderState.stencilMask = e.renderStateEnum.enableStencilMask),
          (this._passFrontRenderState.colorMask = e.renderStateEnum.disabledColorMask),
          (this._passBackRenderState = {}),
          (this._passBackRenderState.blending = e.renderStateEnum.enableBlending),
          (this._passBackRenderState.cull = e.renderStateEnum.disableCull),
          (this._passBackRenderState.depthTest = e.renderStateEnum.disableDepthTest),
          (this._passBackRenderState.depthRange = e.renderStateEnum.depthRange),
          (this._passBackRenderState.depthMask = e.renderStateEnum.disableDepthMask),
          (this._passBackRenderState.stencilTest = e.renderStateEnum.openClassificationStencilTest),
          (this._passBackRenderState.colorMask = e.renderStateEnum.enableColorMask),
          (this._passBackRenderState.stencilMask = e.renderStateEnum.enableStencilMask),
          (this._material = e.StandardMaterial.fromType('Color', {
            color: this._color,
            opacity: this._opacity,
            lightingModel: e.LightingModelType.NONE,
            doubleSided: !0,
          })),
          (this._primitive = new e.Primitive({
            geometry: this._geometry,
            material: this._material,
            modelMatrix: this._modelMatrix,
          })),
          (this._initialized = !0),
          (this._geometryUpdated = !0),
          (this._colorUpdated = !0),
          (this._opacityUpdated = !0),
          (this._modelMatrixUpdated = !0);
      }
      #Ae() {
        (this._primitive._geometry = this._geometry), (this._geometryUpdated = !0);
      }
      #Re() {
        this._material.updateProperty({ color: this._color }), (this._colorUpdated = !0);
      }
      #Ie() {
        this._material.updateProperty({ opacity: this._opacity }), (this._opacityUpdated = !0);
      }
      #Oe() {
        this._primitive.setMatrix(this._modelMatrix),
          this._primitive.updateMatrixWorld(!0),
          (this._primitive.modelMatrix = this._modelMatrix),
          (this._modelMatrixUpdated = !0);
      }
      update() {
        this._initialized
          ? (this._geometryUpdated || this.#Ae(),
            this._colorUpdated || this.#Re(),
            this._opacityUpdated || this.#Ie(),
            this._modelMatrixUpdated || this.#Oe())
          : this.#Me();
      }
      render(e) {
        this._enabled &&
          ((this._primitive.framebuffer = e.mainPass.framebuffer.framebuffer),
          (this._material.renderState = this._passFrontRenderState),
          this._primitive.update(e, e.frameState),
          this._primitive.render(e, { id: 'highlightFront' }, e.frameState),
          (this._material.renderState = this._passBackRenderState),
          this._primitive.update(e, e.frameState),
          this._primitive.render(e, { id: 'highlightBack' }, e.frameState),
          (this._primitive.framebuffer = null));
      }
      destroy() {
        this._initialized
          ? this._primitive instanceof e.Primitive && this._primitive.destroy()
          : (this._geometry instanceof e.Geometry && this._geometry.destroy(),
            this._material instanceof e.Material && this._material.destroy()),
          (this._primitive = void 0),
          (this._material = void 0),
          (this._geometry = void 0),
          (this._passFrontRenderState = void 0),
          (this._passBackRenderState = void 0),
          (this._enabled = void 0),
          (this._color = void 0),
          (this._modelMatrix = void 0),
          (this._initialized = void 0),
          (this._geometryUpdated = void 0),
          (this._colorUpdated = void 0),
          (this._opacityUpdated = void 0),
          (this._modelMatrixUpdated = void 0),
          (this.id = void 0);
      }
    }
    const Em = e.CONSTS.CesiumMath;
    class Pm extends e.Geometry {
      constructor(t) {
        super(t),
          (this.type = 'PolygonOutlineGeometry'),
          (this.primitiveType = e.WebGLConstants.LINES),
          this.setData(t);
      }
      setData(t) {
        if (!e.defined(t.polygonHierarchy) || !e.defined(t.polygonHierarchy.positions))
          throw new Error('positions must be defined!');
        if (t.perPositionHeight && e.defined(t.height))
          throw new Error('Cannot use both options.perPositionHeight and options.height');
        if (
          e.defined(t.arcType) &&
          t.arcType !== e.ARCTYPE.GEODESIC &&
          t.arcType !== e.ARCTYPE.RHUMB
        )
          throw new Error(
            'Invalid arcType. Valid options are minemap.ARCTYPE.GEODESIC and minemap.ARCTYPE.RHUMB.',
          );
        if (e.defined(t.perPositionHeight) && t.perPositionHeight && e.defined(t.height))
          throw new Error('Cannot use both options.perPositionHeight and options.height');
        (this._polygonHierarchy = t.polygonHierarchy),
          (this._ellipsoid = e.defaultValue(t.ellipsoid, e.Ellipsoid.WGS84)),
          (this._granularity = e.defaultValue(t.granularity, Em.RADIANS_PER_DEGREE)),
          (this._perPositionHeight = e.defaultValue(t.perPositionHeight, !1)),
          (this._perPositionHeightExtrude = this._perPositionHeight && e.defined(t.extrudedHeight)),
          (this._arcType = e.defaultValue(t.arcType, e.ARCTYPE.GEODESIC)),
          (this._referenceCenter = e.defaultValue(t.referenceCenter, new e.Vector3()));
        let i = e.defaultValue(t.height, 0),
          s = e.defaultValue(t.extrudedHeight, i);
        if (!this._perPositionHeightExtrude) {
          const e = Math.max(i, s);
          (s = Math.min(i, s)), (i = e);
        }
        (this._height = i),
          (this._extrudedHeight = s),
          (this.vertices = void 0),
          (this.indices = void 0),
          (this._usedDoublePrecision = !e.defined(t.referenceCenter)),
          this._vertexArray
            ? (this._vertexArray.clear(), this._indices.clear())
            : ((this._vertexArray = this._usedDoublePrecision
                ? new e.StructArrayLayout3f3f24()
                : new e.StructArrayLayout3f12()),
              (this._indices = new e.StructArrayLayout2ui4())),
          this._polygonHierarchy.positions.length < 3 ||
            ((this.needUpdate = !0),
            this.#v(),
            this.computeBoundingSphere(),
            this.computeBoundingBox());
      }
      #v() {
        const t = this._ellipsoid,
          i = this._granularity,
          s = this._perPositionHeight,
          r = this._arcType,
          n = e.PolygonGeometryLibrary.polygonOutlinesFromHierarchy(this._polygonHierarchy, !s, t);
        if (0 === n.length) return;
        let o;
        const a = [],
          l = Em.chordLength(i, t.maximumRadius),
          h = this._height,
          c = this._extrudedHeight;
        if (this._perPositionHeightExtrude || !Em.equalsEpsilon(h, c, 0, Em.EPSILON2))
          for (let i = 0; i < n.length; i++)
            (o = e.PolygonGeometryLibrary.createOutlineGeometryFromPositionsExtruded(
              t,
              n[i],
              l,
              s,
              r,
            )),
              (o = e.PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(o, h, c, t, s)),
              a.push(o);
        else
          for (let i = 0; i < n.length; i++)
            (o = e.PolygonGeometryLibrary.createOutlineGeometryFromPositions(t, n[i], l, s, r)),
              (o.positions = e.PolygonPipeline.scaleToGeodeticHeight(o.positions, h, t, !s)),
              a.push(o);
        const _ = e.PolygonGeometryLibrary.combineGeometries(a);
        (this.indices = _.indices),
          (this.vertices = e.PolygonPipeline.scaleToGeodeticHeight(
            _.positions,
            h,
            this._ellipsoid,
            !this._perPositionHeight,
          ));
        for (let e = 0; e < this.vertices.length / 3; e++)
          (this.vertices[3 * e] = this.vertices[3 * e] - this._referenceCenter[0]),
            (this.vertices[3 * e + 1] = this.vertices[3 * e + 1] - this._referenceCenter[1]),
            (this.vertices[3 * e + 2] = this.vertices[3 * e + 2] - this._referenceCenter[2]);
        this.emplaceVertexBufferOfLines();
        for (let e = 0; e < this.indices.length / 2; e++)
          this._indices.emplaceBack(this.indices[2 * e], this.indices[2 * e + 1]);
      }
      update(t) {
        if (this.needUpdate && t.painter) {
          this.needUpdate = !1;
          const i = t.painter.context;
          this._vertBuffer && this._indexBuffer
            ? (this._vertBuffer.updateData(this._vertexArray),
              this._indexBuffer.updateData(this._indices))
            : ((this._vertBuffer = i.createVertexBuffer(
                this._vertexArray,
                this._usedDoublePrecision ? Z_.members : X_.members,
                this.dynamicDraw,
              )),
              (this._indexBuffer = i.createIndexBuffer(this._indices, this.dynamicDraw))),
            (this._segmentVector = e.SegmentVector.simpleSegment(
              0,
              0,
              this.vertices.length / 3,
              this.indices.length / 2,
            ));
        }
      }
      serialize() {
        const t = {
          type: this.type,
          polygonHierarchy: e.PolygonPipeline.hierarchyPack(this._polygonHierarchy, {}),
          perPositionHeight: this._perPositionHeight,
          arcType: this._arcType,
        };
        return (
          (this._perPositionHeightExtrude ||
            !e.CONSTS.CesiumMath.equalsEpsilon(
              this._height,
              this._extrudedHeight,
              0,
              e.CONSTS.CesiumMath.EPSILON2,
            )) &&
            (t.extrudedHeight = this._extrudedHeight),
          this._perPositionHeight || (t.height = this._height),
          t
        );
      }
      destroy() {
        return (
          super.destroy(),
          (this._polygonHierarchy = void 0),
          (this._ellipsoid = void 0),
          (this._granularity = void 0),
          (this._perPositionHeight = void 0),
          (this._perPositionHeightExtrude = void 0),
          (this._arcType = void 0),
          (this._height = void 0),
          (this._extrudedHeight = void 0),
          (this.vertices = void 0),
          (this.indices = void 0),
          (this._vertexArray = void 0),
          (this._indices = void 0),
          (this.type = void 0),
          (this.primitiveType = void 0),
          (this.needUpdate = void 0),
          (this._vertBuffer = void 0),
          (this._indexBuffer = void 0),
          (this._segmentVector = void 0),
          (this.boundingBox = void 0),
          (this.boundingSphere = void 0),
          e.destroyObject(this)
        );
      }
    }
    var Mm = function (e, t) {
      if (null === e) throw new Error('No coordinates passed');
      for (var i = 0; i < e.length; i++)
        for (var s = e[i], r = 0; r < s[s.length - 1].length; r++) {
          if (s.length < 4)
            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');
          if (s[s.length - 1][r] !== s[0][r])
            throw new Error('First and last Position are not equivalent.');
        }
      var n = { type: 'Feature', geometry: { type: 'Polygon', coordinates: e }, properties: t };
      return n.properties || (n.properties = {}), n;
    };
    class Am {
      constructor(t) {
        if (e.defined(t.baseHeight) && !e.isNumber(t.baseHeight))
          throw new Error("'baseHeight' must be a number");
        if (((this._baseHeight = e.defaultValue(t.baseHeight, void 0)), e.defined(t.minHeight))) {
          if (!e.isNumber(t.minHeight)) throw new Error("'minHeight' must be a number");
          if (t.minHeight > this._baseHeight)
            throw new Error("'minHeight' must not be bigger than 'baseHeight'");
        }
        if (((this._minHeight = e.defaultValue(t.minHeight, void 0)), e.defined(t.maxHeight))) {
          if (!e.isNumber(t.maxHeight)) throw new Error("'maxHeight' must be a number");
          if (t.maxHeight < this._baseHeight)
            throw new Error("'maxHeight' must not be smaller than 'baseHeight'");
        }
        (this._maxHeight = e.defaultValue(t.maxHeight, void 0)),
          (this.fillColor = e.defaultValue(t.fillColor, new e.Color(0, 1, 0, 1))),
          (this.fillOpacity = e.defaultValue(t.fillOpacity, 0.5)),
          (this.cutColor = e.defaultValue(t.cutColor, new e.Color(0.7, 0.4, 0.2, 1))),
          (this.cutOpacity = e.defaultValue(t.cutOpacity, 0.5)),
          (this.baseColor = e.defaultValue(t.baseColor, new e.Color(0.2, 0, 1, 1))),
          (this.baseOpacity = e.defaultValue(t.baseOpacity, 0.5)),
          (this._baseMaterial = e.StandardMaterial.fromType('Color', {
            color: this._baseColor,
            opacity: this._baseOpacity,
            lightingModel: e.LightingModelType.NONE,
            doubleSided: !0,
          })),
          (this._baseMaterialUpdated = !1),
          (this.baseOutlineColor = e.defaultValue(t.baseOutlineColor, new e.Color(1, 1, 1, 1))),
          (this.baseOutlineOpacity = e.defaultValue(t.baseOutlineOpacity, 1)),
          (this._baseOutlineMaterial = e.StandardMaterial.fromType('Color', {
            color: this._baseOutlineColor,
            opacity: this._baseOutlineOpacity,
            lightingModel: e.LightingModelType.NONE,
            doubleSided: !0,
          })),
          (this.wallColor = e.defaultValue(t.wallColor, new e.Color(0, 0.7, 0, 1))),
          (this.wallOpacity = e.defaultValue(t.wallOpacity, 0.5)),
          (this._wallMaterial = e.StandardMaterial.fromType('Color', {
            color: this._wallColor,
            opacity: this._wallOpacity,
            lightingModel: e.LightingModelType.NONE,
            doubleSided: !0,
          })),
          (this._wallMaterial.renderState.depthMask = !1),
          (this._wallMaterialUpdated = !1),
          (this.wallOutlineColor = e.defaultValue(t.wallOutlineColor, new e.Color(0, 0, 0, 1))),
          (this.wallOutlineOpacity = e.defaultValue(t.wallOutlineOpacity, 1)),
          (this._wallOutlineMaterial = e.StandardMaterial.fromType('Color', {
            color: this._wallOutlineColor,
            opacity: this._wallOutlineOpacity,
            lightingModel: e.LightingModelType.NONE,
            doubleSided: !0,
          })),
          (this._wallOutlineMaterialUpdated = !1),
          (this.positions = e.defaultValue(t.positions, [])),
          (this.enabled = e.defaultValue(t.enabled, !0)),
          (this.id = e.uuid());
      }
      get positions() {
        return this._positions;
      }
      set positions(t) {
        if (!(t instanceof Array)) throw new Error('positions is not type of Array!');
        if (0 !== t.length && t.length < 3)
          throw new Error("positions' length must greater than 2!");
        if (0 !== t.length && !this._baseHeight) {
          let i = 0;
          for (let s = 0; s < t.length; s++) i += e.Cartographic.fromVector3(t[s]).height;
          (i /= t.length), (this._baseHeight = i);
        }
        this._minHeight || (this._minHeight = this._baseHeight - 500),
          this._maxHeight || (this._maxHeight = this._baseHeight + 500),
          (this._positions = t),
          (this._sameHeightPositions = Am.updateHeight(this._positions, this._baseHeight)),
          this.#Le(),
          this.#De(),
          this.#Be(),
          this.#Ve();
      }
      get baseHeight() {
        return this._baseHeight;
      }
      set baseHeight(t) {
        if (e.isNumber(t)) this._baseHeight = t;
        else {
          if (t) throw new Error('baseHeight must be a number or empty');
          {
            let i = 0;
            for (let s = 0; s < this._positions.length; s++)
              i += e.Cartographic.fromVector3(t[s]).height;
            (i /= this._positions.length), (this._baseHeight = i);
          }
        }
        (this._sameHeightPositions = Am.updateHeight(this._positions, this._baseHeight)),
          this.#Le(),
          this.#De(),
          this.#Be(),
          this.#Ve();
      }
      get minHeight() {
        return this._minHeight;
      }
      set minHeight(t) {
        if (!e.isNumber(t)) throw new Error("'minHeight' must be a number");
        if (t > this._baseHeight)
          throw new Error("'minHeight' must not be bigger than 'baseHeight'");
        (this._minHeight = t), this.#De(), this.#Be();
      }
      get maxHeight() {
        return this._maxHeight;
      }
      set maxHeight(t) {
        if (!e.isNumber(t)) throw new Error("'maxHeight' must be a number");
        if (t < this._baseHeight)
          throw new Error("'maxHeight' must not be smaller than 'baseHeight'");
        (this._maxHeight = t), this.#Le(), this.#Be();
      }
      get fillColor() {
        return this._fillColor;
      }
      set fillColor(t) {
        if (!(t instanceof e.Color || 'string' == typeof t))
          throw new Error("'fillColor' type must be Color or String!");
        (this._fillColor = e.Color.parse(t)),
          this._fillHighlight && (this._fillHighlight.color = this._fillColor);
      }
      get fillOpacity() {
        return this._fillOpacity;
      }
      set fillOpacity(t) {
        if (!e.isNumber(t)) throw new Error("'fillOpacity' option must be a number!");
        (this._fillOpacity = t),
          this._fillHighlight && (this._fillHighlight.opacity = this._fillOpacity);
      }
      get cutColor() {
        return this._cutColor;
      }
      set cutColor(t) {
        if (!(t instanceof e.Color || 'string' == typeof t))
          throw new Error("'cutColor' type must be Color or String!");
        (this._cutColor = e.Color.parse(t)),
          this._cutHighlight && (this._cutHighlight.color = this._cutColor);
      }
      get cutOpacity() {
        return this._cutOpacity;
      }
      set cutOpacity(t) {
        if (!e.isNumber(t)) throw new Error("'cutOpacity' option must be a number!");
        (this._cutOpacity = t),
          this._cutHighlight && (this._cutHighlight.opacity = this._cutOpacity);
      }
      get baseColor() {
        return this._baseColor;
      }
      set baseColor(t) {
        if (!(t instanceof e.Color || 'string' == typeof t))
          throw new Error("'baseColor' type must be Color or String!");
        (this._baseColor = e.Color.parse(t)), (this._baseMaterialUpdated = !1);
      }
      get baseOpacity() {
        return this._baseOpacity;
      }
      set baseOpacity(t) {
        if (!e.isNumber(t)) throw new Error("'baseOpacity' option must be a number!");
        (this._baseOpacity = t), (this._baseMaterialUpdated = !1);
      }
      get baseOutlineColor() {
        return this._baseOutlineColor;
      }
      set baseOutlineColor(t) {
        if (!(t instanceof e.Color || 'string' == typeof t))
          throw new Error("'baseOutlineColor' type must be Color or String!");
        (this._baseOutlineColor = e.Color.parse(t)), (this._baseOutlineMaterialUpdated = !1);
      }
      get baseOutlineOpacity() {
        return this._baseOutlineOpacity;
      }
      set baseOutlineOpacity(t) {
        if (!e.isNumber(t)) throw new Error("'baseOutlineOpacity' option must be a number!");
        (this._baseOutlineOpacity = t), (this._baseOutlineMaterialUpdated = !1);
      }
      get wallColor() {
        return this._wallColor;
      }
      set wallColor(t) {
        if (!(t instanceof e.Color || 'string' == typeof t))
          throw new Error("'wallColor' type must be Color or String!");
        (this._wallColor = e.Color.parse(t)), (this._wallMaterialUpdated = !1);
      }
      get wallOpacity() {
        return this._wallOpacity;
      }
      set wallOpacity(t) {
        if (!e.isNumber(t)) throw new Error("'wallOpacity' option must be a number!");
        (this._wallOpacity = t), (this._wallMaterialUpdated = !1);
      }
      get wallOutlineColor() {
        return this._wallOutlineColor;
      }
      set wallOutlineColor(t) {
        if (!(t instanceof e.Color || 'string' == typeof t))
          throw new Error("'wallOutlineColor' type must be Color or String!");
        (this._wallOutlineColor = e.Color.parse(t)), (this._wallOutlineMaterialUpdated = !1);
      }
      get wallOutlineOpacity() {
        return this._wallOutlineOpacity;
      }
      set wallOutlineOpacity(t) {
        if (!e.isNumber(t)) throw new Error("'wallOutlineOpacity' option must be a number!");
        (this._wallOutlineOpacity = t), (this._wallOutlineMaterialUpdated = !1);
      }
      get enabled() {
        return this._enabled;
      }
      set enabled(t) {
        if (!e.isBoolean(t)) throw new Error("'enabled' option must be true or false!");
        this._enabled = t;
      }
      static updateHeight(t, i) {
        if (0 === t.length) return [];
        let s = [];
        for (let r = 0; r < t.length; r++) {
          const n = e.Transforms.cartesian3ToCartographic(t[r]);
          s = s.concat([n[0], n[1], i]);
        }
        return e.Vector3.fromDegreesArrayHeights(s);
      }
      #Le() {
        (this._cutGeometry = Am.createPolygon(this._sameHeightPositions, this._maxHeight)),
          this._cutHighlight
            ? (this._cutHighlight.geometry = this._cutGeometry)
            : (this._cutHighlight = new Sm({
                geometry: this._cutGeometry,
                color: this._cutColor,
                opacity: this._cutOpacity,
              }));
      }
      #De() {
        (this._fillGeometry = Am.createPolygon(this._sameHeightPositions, this._minHeight)),
          this._fillHighlight
            ? (this._fillHighlight.geometry = this._fillGeometry)
            : (this._fillHighlight = new Sm({
                geometry: this._fillGeometry,
                color: this._fillColor,
                opacity: this._fillOpacity,
              }));
      }
      #Be() {
        const e = Am.updateHeight(this._positions, this._minHeight);
        (this._wallGeometry = Am.createPolygon(e, this._maxHeight, !0, !1)),
          (this._wallGeometryUpdated = !1),
          (this._wallOutlineGeometry = Am.createPolygonOutline(e, this._maxHeight, !0, !1)),
          (this._wallOutlineGeometryUpdated = !1);
      }
      #Ve() {
        (this._baseGeometry = Am.createPolygon(this._sameHeightPositions, this._baseHeight, !1)),
          (this._baseGeometryUpdated = !1),
          (this._baseOutlineGeometry = Am.createPolygonOutline(
            this._sameHeightPositions,
            this._baseHeight,
            !1,
          )),
          (this._baseOutlineGeometryUpdated = !1);
      }
      static createPolygon(t, i, s = !0, r = !0) {
        return new e.PolygonGeometry(
          0 === t.length
            ? { polygonHierarchy: { positions: [] }, arcType: e.ARCTYPE.GEODESIC }
            : {
                polygonHierarchy: { positions: t },
                perPositionHeight: !0,
                extrudedHeight: s ? i : void 0,
                closeTop: !!r,
                closeBottom: !!r,
                arcType: e.ARCTYPE.GEODESIC,
              },
        );
      }
      static createPolygonOutline(t, i, s = !0, r = !0) {
        return new Pm(
          0 === t.length
            ? { polygonHierarchy: { positions: [] }, arcType: e.ARCTYPE.GEODESIC }
            : {
                polygonHierarchy: { positions: t },
                perPositionHeight: !0,
                extrudedHeight: s ? i : void 0,
                closeTop: !!r,
                closeBottom: !!r,
                arcType: e.ARCTYPE.GEODESIC,
              },
        );
      }
      get json() {
        const t = [];
        for (let i = 0; i < this._positions.length; i++) {
          const s = e.Transforms.cartesian3ToCartographic(this._positions[i]);
          t.push([s[0], s[1]]);
        }
        return 0 === t.length ? void 0 : Mm([[...t, t[0]]]);
      }
      update() {
        this._cutHighlight.update(),
          this._fillHighlight.update(),
          this._base
            ? (this._baseGeometryUpdated ||
                ((this._base._geometry = this._baseGeometry), (this._baseGeometryUpdated = !0)),
              this._baseMaterialUpdated ||
                (this._baseMaterial.updateProperty({
                  color: this._baseColor,
                  opacity: this._baseOpacity,
                }),
                (this._baseMaterialUpdated = !0)))
            : ((this._base = new e.Primitive({
                geometry: this._baseGeometry,
                material: this._baseMaterial,
              })),
              (this._baseGeometryUpdated = !0),
              (this._baseMaterialUpdated = !0)),
          this._wall
            ? (this._wallGeometryUpdated ||
                ((this._wall._geometry = this._wallGeometry), (this._wallGeometryUpdated = !0)),
              this._wallMaterialUpdated ||
                (this._wallMaterial.updateProperty({
                  color: this._wallColor,
                  opacity: this._wallOpacity,
                }),
                (this._wallMaterialUpdated = !0)))
            : ((this._wall = new e.Primitive({
                geometry: this._wallGeometry,
                material: this._wallMaterial,
              })),
              (this._wallGeometryUpdated = !0),
              (this._wallMaterialUpdated = !0)),
          this._baseOutline
            ? (this._baseOutlineGeometryUpdated ||
                ((this._baseOutline._geometry = this._baseOutlineGeometry),
                (this._baseOutlineGeometryUpdated = !0)),
              this._baseOutlineMaterialUpdated ||
                (this._baseOutlineMaterial.updateProperty({
                  color: this._baseOutlineColor,
                  opacity: this._baseOutlineOpacity,
                }),
                (this._baseOutlineMaterialUpdated = !0)))
            : ((this._baseOutline = new e.Primitive({
                geometry: this._baseOutlineGeometry,
                material: this._baseOutlineMaterial,
              })),
              (this._baseOutlineGeometryUpdated = !0),
              (this._baseOutlineMaterialUpdated = !0)),
          this._wallOutline
            ? (this._wallOutlineGeometryUpdated ||
                ((this._wallOutline._geometry = this._wallOutlineGeometry),
                (this._wallOutlineGeometryUpdated = !0)),
              this._wallOutlineMaterialUpdated ||
                (this._wallOutlineMaterial.updateProperty({
                  color: this._wallOutlineColor,
                  opacity: this._wallOutlineOpacity,
                }),
                (this._wallOutlineMaterialUpdated = !0)))
            : ((this._wallOutline = new e.Primitive({
                geometry: this._wallOutlineGeometry,
                material: this._wallOutlineMaterial,
              })),
              (this._wallOutlineGeometryUpdated = !0),
              (this._wallOutlineMaterialUpdated = !0));
      }
      render(e) {
        this._enabled &&
          (this._cutHighlight.render(e),
          this._fillHighlight.render(e),
          (this._base.framebuffer = e.mainPass.framebuffer.framebuffer),
          this._base.update(e, e.frameState),
          this._base.render(e, { id: 'base' }, e.frameState),
          (this._base.framebuffer = null),
          (this._wall.framebuffer = e.mainPass.framebuffer.framebuffer),
          this._wall.update(e, e.frameState),
          this._wall.render(e, { id: 'wall' }, e.frameState),
          (this._wall.framebuffer = null),
          (this._baseOutline.framebuffer = e.mainPass.framebuffer.framebuffer),
          this._baseOutline.update(e, e.frameState),
          this._baseOutline.render(e, { id: 'baseOutline' }, e.frameState),
          (this._baseOutline.framebuffer = null),
          (this._wallOutline.framebuffer = e.mainPass.framebuffer.framebuffer),
          this._wallOutline.update(e, e.frameState),
          this._wallOutline.render(e, { id: 'wallOutline' }, e.frameState),
          (this._wallOutline.framebuffer = null));
      }
      destroy() {
        (this._positions = void 0),
          (this._baseHeight = void 0),
          (this._minHeight = void 0),
          (this._maxHeight = void 0),
          this._fillHighlight && this._fillHighlight.destroy(),
          this._cutHighlight && this._cutHighlight.destroy(),
          this._base && this._base instanceof e.Primitive
            ? this._base.destroy()
            : (this._baseGeometry &&
                this._baseGeometry instanceof e.Geometry &&
                this._baseGeometry.destroy(),
              this._baseMaterial &&
                this._baseMaterial instanceof e.Material &&
                this._baseMaterial.destroy()),
          this._baseOutline && this._baseOutline instanceof e.Primitive
            ? this._baseOutline.destroy()
            : (this._baseOutlineGeometry &&
                this._baseOutlineGeometry instanceof e.Geometry &&
                this._baseOutlineGeometry.destroy(),
              this._baseOutlineMaterial &&
                this._baseOutlineMaterial instanceof e.Material &&
                this._baseOutlineMaterial.destroy()),
          this._wall && this._wall instanceof e.Primitive
            ? this._wall.destroy()
            : (this._wallGeometry &&
                this._wallGeometry instanceof e.Geometry &&
                this._wallGeometry.destroy(),
              this._wallMaterial &&
                this._wallMaterial instanceof e.Material &&
                this._wallMaterial.destroy()),
          this._wallOutline && this._wallOutline instanceof e.Primitive
            ? this._wallOutline.destroy()
            : (this._wallOutlineGeometry &&
                this._wallOutlineGeometry instanceof e.Geometry &&
                this._wallOutlineGeometry.destroy(),
              this._wallOutlineMaterial &&
                this._wallOutlineMaterial instanceof e.Material &&
                this._wallOutlineMaterial.destroy()),
          (this._fillColor = void 0),
          (this._fillOpacity = void 0),
          (this._fillHighlight = void 0),
          (this._cutColor = void 0),
          (this._cutOpacity = void 0),
          (this._cutHighlight = void 0),
          (this._baseColor = void 0),
          (this._baseOpacity = void 0),
          (this._base = void 0),
          (this._baseGeometry = void 0),
          (this._baseMaterial = void 0),
          (this._baseGeometryUpdated = void 0),
          (this._baseMaterialUpdated = void 0),
          (this._baseOutlineColor = void 0),
          (this._baseOutlineOpacity = void 0),
          (this._baseOutlineGeometry = void 0),
          (this._baseOutlineMaterial = void 0),
          (this._baseOutlineGeometryUpdated = void 0),
          (this._baseOutlineMaterialUpdated = void 0),
          (this._wallColor = void 0),
          (this._wallOpacity = void 0),
          (this._wall = void 0),
          (this._wallGeometry = void 0),
          (this._wallMaterial = void 0),
          (this._wallGeometryUpdated = void 0),
          (this._wallMaterialUpdated = void 0),
          (this._wallOutlineColor = void 0),
          (this._wallOutlineOpacity = void 0),
          (this._wallOutlineGeometry = void 0),
          (this._wallOutlineMaterial = void 0),
          (this._wallOutlineGeometryUpdated = void 0),
          (this._wallOutlineMaterialUpdated = void 0),
          (this._enabled = void 0),
          (this.id = void 0);
      }
    }
    class Rm {
      constructor(e) {
        (this._painter = e), (this._cutFills = []);
      }
      get length() {
        return this._cutFills.length;
      }
      add(t, i) {
        if (!(t instanceof Am))
          return console.error('The current addition is not of type CutFill!'), !1;
        const s = e.defined(i);
        if (s) {
          if (i < 0) throw new Error('index must be greater than or equal to zero.');
          if (i > this._cutFills.length)
            throw new Error('index must be less than or equal to the number of CutFill.');
        }
        return s ? this._cutFills.splice(i, 0, t) : this._cutFills.push(t), !0;
      }
      getById(e) {
        let t;
        return (
          this._cutFills.forEach((i) => {
            i.id === e && (t = i);
          }),
          t
        );
      }
      getByIndex(t) {
        if (e.isNumber(t) && !(t > this.length)) return this._cutFills[t];
      }
      indexOf(e) {
        return this._cutFills.indexOf(e);
      }
      remove(e) {
        const t = this.indexOf(e);
        return -1 !== t && (this._cutFills.splice(t, 1), e.destroy(), !0);
      }
      removeById(e) {
        const t = this.getById(e);
        this.remove(t);
      }
      removeByIndex(t) {
        if (e.isNumber(t)) {
          if (t < 0) throw new Error('index must be greater than or equal to zero.');
          if (t > this._cutFills.length)
            throw new Error('index must be less than or equal to the number of CutFill.');
          const e = this.getByIndex(t);
          this.remove(e);
        }
        return !1;
      }
      removeAll() {
        for (; this.length > 0; ) this.removeByIndex(0);
        this._cutFills = [];
      }
      update(e) {
        for (let t = 0; t < this.length; t++) this.getByIndex(t).update(e);
      }
      serialize() {
        const t = [];
        for (let i = 0; i < this.length; i++) {
          const s = this.getByIndex(i),
            r = [];
          for (let t = 0; t < s.positions.length; t++)
            r.push(e.Vector3.pack(s.positions[t], new Array(3)));
          const n = {
            positions: r,
            baseHeight: s.baseHeight,
            minHeight: s.minHeight,
            maxHeight: s.maxHeight,
            fillColor: e.Color.pack(s.fillColor, new Array(4)),
            fillOpacity: s.fillOpacity,
            cutColor: e.Color.pack(s.cutColor, new Array(4)),
            cutOpacity: s.cutOpacity,
            baseColor: e.Color.pack(s.baseColor, new Array(4)),
            baseOpacity: s.baseOpacity,
            baseOutlineColor: e.Color.pack(s.baseOutlineColor, new Array(4)),
            baseOutlineOpacity: s.baseOutlineOpacity,
            wallColor: e.Color.pack(s.wallColor, new Array(4)),
            wallOpacity: s.wallOpacity,
            wallOutlineColor: e.Color.pack(s.wallOutlineColor, new Array(4)),
            wallOutlineOpacity: s.wallOutlineOpacity,
            enabled: s.enabled,
          };
          t.push(n);
        }
        return t.length > 0 ? t : void 0;
      }
    }
    const Im = {};
    function Om(t, i) {
      return (
        e.CONSTS.CesiumMath.equalsEpsilon(t.latitude, i.latitude, e.CONSTS.CesiumMath.EPSILON10) &&
        e.CONSTS.CesiumMath.equalsEpsilon(t.longitude, i.longitude, e.CONSTS.CesiumMath.EPSILON10)
      );
    }
    Im.computePositions = function (t, i, s, r, n, o) {
      const a = (function (t, i, s, r) {
        const n = new e.Cartographic(),
          o = new e.Cartographic(),
          a = (i = e.arrayRemoveDuplicates(i, e.Vector3.equalsEpsilon)).length;
        if (a < 2) return;
        const l = e.defined(r),
          h = e.defined(s),
          c = new Array(a),
          _ = new Array(a),
          u = new Array(a),
          d = i[0];
        c[0] = d;
        const m = t.cartesianToCartographic(d, n);
        e.fromCartographicToRadians(m, m),
          h && (m.height = s[0]),
          (_[0] = m.height),
          (u[0] = l ? r[0] : 0);
        let p = _[0] === u[0],
          f = 1;
        for (let n = 1; n < a; ++n) {
          const a = i[n],
            d = t.cartesianToCartographic(a, o);
          e.fromCartographicToRadians(d, d),
            h && (d.height = s[n]),
            (p = p && 0 === d.height),
            Om(m, d)
              ? m.height < d.height && (_[f - 1] = d.height)
              : ((c[f] = a),
                (_[f] = d.height),
                (u[f] = l ? r[n] : 0),
                (p = p && _[f] === u[f]),
                e.Cartographic.clone(d, m),
                ++f);
        }
        return p || f < 2
          ? void 0
          : ((c.length = f),
            (_.length = f),
            (u.length = f),
            { positions: c, topHeights: _, bottomHeights: u });
      })(t, i, s, r);
      if (!e.defined(a)) return;
      (s = a.topHeights), (r = a.bottomHeights);
      const l = (i = a.positions).length,
        h = l - 2;
      let c, _;
      const u = e.CONSTS.CesiumMath.chordLength(n, t.maximumRadius),
        d = { positions: void 0, height: void 0, granularity: void 0, ellipsoid: void 0 };
      if (((d.minDistance = u), (d.ellipsoid = t), o)) {
        let t,
          n = 0;
        for (t = 0; t < l - 1; t++) n += e.PolylinePipeline.numberOfPoints(i[t], i[t + 1], u) + 1;
        (c = new Float64Array(3 * n)), (_ = new Float64Array(3 * n));
        const o = new Array(2),
          a = new Array(2);
        (d.positions = o), (d.height = a);
        let h = 0;
        for (t = 0; t < l - 1; t++) {
          (o[0] = i[t]), (o[1] = i[t + 1]), (a[0] = s[t]), (a[1] = s[t + 1]);
          const n = e.PolylinePipeline.generateArc(d);
          c.set(n, h),
            (a[0] = r[t]),
            (a[1] = r[t + 1]),
            _.set(e.PolylinePipeline.generateArc(d), h),
            (h += n.length);
        }
      } else
        (d.positions = i),
          (d.height = s),
          (c = new Float64Array(e.PolylinePipeline.generateArc(d))),
          (d.height = r),
          (_ = new Float64Array(e.PolylinePipeline.generateArc(d)));
      return { bottomPositions: _, topPositions: c, numCorners: h };
    };
    class Lm extends e.Geometry {
      constructor(t) {
        if ((super(t), !e.defined(t.positions))) throw new Error('options.positions is required.');
        if (e.defined(t.maximumHeights) && t.maximumHeights.length !== t.positions.length)
          throw new Error(
            'options.positions and options.maximumHeights must have the same length.',
          );
        if (e.defined(t.minimumHeights) && t.minimumHeights.length !== t.positions.length)
          throw new Error(
            'options.positions and options.minimumHeights must have the same length.',
          );
        (this._indices = new e.StructArrayLayout3ui6()),
          (this.primitiveType = e.WebGLConstants.TRIANGLES),
          (this.type = 'WallGeometry'),
          (this._usedDoublePrecision = !0),
          (this._vertexArray = new e.StructArrayLayout11f44()),
          this.updateProperty(t);
      }
      updateProperty(e) {
        this.setData(e);
      }
      setData(t) {
        (this.vertices = void 0),
          (this.indices = void 0),
          (this.normals = void 0),
          (this.uvs = void 0),
          this._vertexArray
            ? (this._vertexArray.clear(), this._indices.clear())
            : ((this._indices = new e.StructArrayLayout3ui6()),
              (this._vertexArray = new e.StructArrayLayout11f44())),
          (this._positions = t.positions),
          (this._maximumHeights = t.maximumHeights),
          (this._minimumHeights = t.minimumHeights),
          (this._granularity = e.defaultValue(
            t.granularity,
            e.CONSTS.CesiumMath.RADIANS_PER_DEGREE,
          )),
          (this._ellipsoid = e.defaultValue(t.ellipsoid, e.Ellipsoid.WGS84)),
          (this._needUpdate = !0),
          this.#v(),
          this.computeBoundingSphere(),
          this.computeBoundingBox();
      }
      static fromConstantHeights(t) {
        const i = t.positions;
        if (!e.defined(i)) throw new Error('options.positions is required.');
        let s, r;
        const n = t.minimumHeight,
          o = t.maximumHeight,
          a = e.defined(n),
          l = e.defined(o);
        if (a || l) {
          const e = i.length;
          (s = a ? new Array(e) : void 0), (r = l ? new Array(e) : void 0);
          for (let t = 0; t < e; ++t) a && (s[t] = n), l && (r[t] = o);
        }
        return new Lm({ positions: i, maximumHeights: r, minimumHeights: s });
      }
      #v() {
        const t = new e.Vector3(),
          i = new e.Vector3(),
          s = new e.Vector3(),
          r = new e.Vector3(),
          n = this._ellipsoid,
          o = Im.computePositions(
            n,
            this._positions,
            this._maximumHeights,
            this._minimumHeights,
            this._granularity,
            !0,
          );
        if (!e.defined(o)) return;
        const a = o.bottomPositions,
          l = o.topPositions,
          h = o.numCorners;
        let c = l.length,
          _ = 2 * c,
          u = 0;
        for (let t = 0; t < c / 3; t++)
          u = Math.max(
            u,
            e.Vector3.distance(e.Vector3.fromArray(l, 3 * t), e.Vector3.fromArray(a, 3 * t)),
          );
        const d = new Float64Array(_),
          m = new Float32Array(_),
          p = new Float32Array((_ / 3) * 2);
        let f,
          g = 0,
          y = 0,
          T = 0,
          x = new e.Vector3(),
          v = !0;
        c /= 3;
        let b = 0;
        const w = 1 / (c - h - 1);
        for (f = 0; f < c; ++f) {
          const o = 3 * f,
            h = e.Vector3.fromArray(l, o, t),
            _ = e.Vector3.fromArray(a, o, i);
          (d[g++] = _.x),
            (d[g++] = _.y),
            (d[g++] = _.z),
            (d[g++] = h.x),
            (d[g++] = h.y),
            (d[g++] = h.z),
            (p[T++] = b),
            (p[T++] = 0),
            (p[T++] = b),
            (p[T++] = e.Vector3.distance(h, _) / u);
          let C = e.Vector3.clone(e.Vector3.ZERO, r);
          const S = e.Vector3.subtract(h, n.geodeticSurfaceNormal(h, i), i);
          if ((f + 1 < c && (C = e.Vector3.fromArray(l, o + 3, r)), v)) {
            const i = e.Vector3.subtract(C, h, s),
              r = e.Vector3.subtract(S, h, t);
            (x = e.Vector3.normalize(e.Vector3.cross(r, i, x), x)), (v = !1);
          }
          e.Vector3.equalsEpsilon(h, C, e.CONSTS.CesiumMath.EPSILON10) ? (v = !0) : (b += w),
            (m[y++] = x.x),
            (m[y++] = x.y),
            (m[y++] = x.z),
            (m[y++] = x.x),
            (m[y++] = x.y),
            (m[y++] = x.z);
        }
        const C = _ / 3;
        _ -= 6 * (h + 1);
        const S = new Uint16Array(_);
        let E = 0;
        for (f = 0; f < C - 2; f += 2) {
          const s = f,
            r = f + 2,
            n = e.Vector3.fromArray(d, 3 * s, t),
            o = e.Vector3.fromArray(d, 3 * r, i);
          if (e.Vector3.equalsEpsilon(n, o, e.CONSTS.CesiumMath.EPSILON10)) continue;
          const a = f + 1,
            l = f + 3;
          (S[E++] = s), (S[E++] = a), (S[E++] = l), (S[E++] = s), (S[E++] = l), (S[E++] = r);
        }
        (this.vertices = d), (this.indices = S), (this.normals = m), (this.uvs = p);
        for (let e = 0; e < S.length; e += 3) this._indices.emplaceBack(S[e], S[e + 1], S[e + 2]);
        const P = new e.Vector3();
        for (let t = 0; t < this.vertices.length; t += 3)
          e.Vector3.fromArray(this.vertices, t, P),
            (this.vertices[t] = P.x),
            (this.vertices[t + 1] = P.y),
            (this.vertices[t + 2] = P.z);
        this.emplaceVertexBufferTriangle();
      }
      update(t) {
        if (this._needUpdate && t.painter) {
          const i = t.painter.context;
          this._vertBuffer
            ? (this._vertBuffer.updateData(this._vertexArray),
              this._indexBuffer.updateData(this._indices))
            : ((this._vertBuffer = i.createVertexBuffer(
                this._vertexArray,
                e.layout.members,
                this.dynamicDraw,
              )),
              (this._indexBuffer = i.createIndexBuffer(this._indices, this.dynamicDraw))),
            (this._segmentVector = e.SegmentVector.simpleSegment(
              0,
              0,
              this.vertices.length / 3,
              this.indices.length / 3,
            )),
            (this._needUpdate = !1);
        }
      }
      serialize() {
        return {
          type: this.type,
          positions: this._positions,
          maximumHeights: this._maximumHeights,
          minimumHeights: this._minimumHeights,
        };
      }
      destroy() {
        return (
          super.destroy(),
          (this._vertBuffer = void 0),
          (this._indexBuffer = void 0),
          (this._segmentVector = void 0),
          (this._needUpdate = void 0),
          (this._positions = void 0),
          (this._maximumHeights = void 0),
          (this._minimumHeights = void 0),
          (this._granularity = void 0),
          (this._ellipsoid = void 0),
          (this.vertices = void 0),
          (this.indices = void 0),
          (this.normals = void 0),
          (this.uvs = void 0),
          (this._vertexArray = void 0),
          (this._indices = void 0),
          (this.primitiveType = void 0),
          (this.type = void 0),
          this._segmentVector?.destroy(),
          (this._segmentVector = void 0),
          e.destroyObject(this)
        );
      }
    }
    class Dm extends e.Material {
      constructor(t) {
        super(t),
          (this.frame = void 0),
          (this._texType = e.defaultValue(t.texType, void 0)),
          (this._flowOptions = void 0);
      }
      update(e, t, i = {}) {
        super.update(e, t, i);
      }
      #Ne(t) {
        this._uniforms.set('u_TexOffsetScale', () => {
          const i = new e.Vector4(0, 0, 1, 1);
          return (
            t && t.texCoordOffset && t.texCoordOffset[0] && (i.x = t.texCoordOffset[0]),
            t && t.texCoordOffset && t.texCoordOffset[1] && (i.y = t.texCoordOffset[1]),
            t && t.texCoordRepeat && t.texCoordRepeat[0] && (i.z = t.texCoordRepeat[0]),
            t && t.texCoordRepeat && t.texCoordRepeat[1] && (i.w = t.texCoordRepeat[1]),
            i
          );
        }),
          this._uniforms.set('u_TexRotate', () => {
            const i = new e.Vector3(0.5, 0.5, 0);
            return (
              t && t.texCoordCenter && t.texCoordCenter[0] && (i.x = t.texCoordCenter[0]),
              t && t.texCoordCenter && t.texCoordCenter[1] && (i.y = t.texCoordCenter[1]),
              t && t.texCoordRotation && (i.z = t.texCoordRotation * e.CONSTS.TRANSFORM.DEG_TO_RAD),
              i
            );
          });
      }
      flowTexture(t) {
        t.speed || (t.speed = 1),
          t.rotation || (t.rotation = 0),
          t.direction || (t.direction = 'right'),
          t.texRepeat || (t.repeat = [0, 0]),
          t.speed > 10 && (t.speed = 10),
          t.speed < 1 && (t.speed = 1);
        const i = 50 / t.speed,
          s = new e.Vector4(0, 0, 1, 1),
          r = Date.now(),
          n = this;
        (n._flowOptions = t),
          (function o() {
            if (Date.now() - r >= i) {
              switch ((s.x > 1 && (s.x = s.x - 1), s.y > 1 && (s.y = s.y - 1), t.direction)) {
                case 'right':
                  s.x = s.x - 1 / 60 + 1;
                  break;
                case 'left':
                default:
                  s.x += 1 / 60;
                  break;
                case 'up':
                  s.y = s.y - 1 / 60 + 1;
                  break;
                case 'down':
                  s.y += 1 / 60;
              }
              n.#Ne({
                texCoordCenter: [0.5, 0.5],
                texCoordRotation: t.rotation,
                texCoordOffset: [s.x, s.y],
                texCoordRepeat: t.texRepeat,
              });
            }
            n.frame && e.window.cancelAnimationFrame(n.frame),
              (n.frame = e.window.requestAnimationFrame(o));
          })();
      }
      updateTexture(e, t) {
        let i;
        switch (e) {
          case 'Color':
            i = Dm.fromType('Color', {
              color: t.baseColor,
              opacity: t.opacity,
              lightingModel: t.lightingModel,
              doubleSided: t.doubleSided,
            });
            break;
          case 'Texture':
            i = Dm.fromType('Texture', {
              baseColorTexture: t.baseColorTexture,
              opacity: t.opacity,
              lightingModel: t.lightingModel,
              doubleSided: t.doubleSided,
            });
        }
        return i;
      }
      updateProperty(t) {
        if (t.color) {
          const i = e.Color.parse(t.color);
          this._uniforms.set('u_Color', () => e.Vector4.fromColor(i, !1));
        }
        t.baseColorTexture &&
          (this._uniforms.set('u_BaseColorSampler', () =>
            Dm.bindTextureSampler(t.baseColorTexture),
          ),
          Dm.buildDefines(this, t)),
          t.opacity && this._uniforms.set('u_Opacity', () => t.opacity),
          this.#Ne(t);
      }
      static buildDefines(e, t = {}) {
        const i = {};
        (i.PHONG_LIGHT = t.phongLight), (i.HAS_BASECOLORMAP = t.hasBaseColorMap), (e.defines = i);
      }
      get texType() {
        return this._texType;
      }
      set texType(e) {
        this._texType = e;
      }
      static fromType(t, i) {
        const s = Dm.getPresetMaterial(t, i),
          r = new Dm({
            renderState: i.renderState ? i.renderState : s.renderState,
            defines: i.defines,
            type: 'StandardMaterial',
            texType: t,
            baseColorTexture: s.baseColorTexture,
            color: s.color,
            doubleSided: s.doubleSided,
            opacity: s.opacity,
            lightingModel: s.lightingModel,
          });
        Dm.buildDefines(r, s.microDefineOptions),
          e.PhongLightSetter.setPhongLightUniform({ material: r });
        for (const e in s.uniforms) r._uniforms.set(`u_${e}`, s.uniforms[e]);
        return r.#Ne(null), r;
      }
      static bindTextureSampler(t) {
        return (
          (t.sampler = {
            minificationFilter: t.minFilter || e.WebGLConstants.LINEAR_MIPMAP_NEAREST,
            magnificationFilter: t.magFilter || e.WebGLConstants.LINEAR,
            wrapS: t.wrapS || e.WebGLConstants.REPEAT,
            wrapT: t.wrapT || e.WebGLConstants.REPEAT,
          }),
          t
        );
      }
      static getPresetMaterial(t, i) {
        const s = e.defaultValue(i?.lightingModel, e.LightingModelType.PHONG),
          r = {
            renderState: e.Material.getDefaultRenderState(),
            videoOptions: {},
            uniforms: {},
            microDefineOptions: {
              phongLight: s === e.LightingModelType.PHONG,
              hasBaseColorMap: e.defaultValue(!!i.baseColorTexture, !1),
            },
            color: void 0,
            opacity: void 0,
          };
        (r.renderState.polygonOffset = { enabled: !0, factor: 1, units: 1 }),
          (r.renderState.cull.enabled = e.defaultValue(!i.doubleSided, !0));
        const n = e.defaultValue(i?.opacity, 1),
          o = e.Color.parse(e.defaultValue(i?.color, new e.Color(1, 0, 0, 1)));
        switch (
          ((r.color = o),
          (r.doubleSided = e.defaultValue(i.doubleSided, !1)),
          (r.opacity = n),
          (r.lightingModel = s),
          (r.baseColorTexture = i.baseColorTexture),
          t)
        ) {
          case 'Color':
            r.uniforms = { Color: () => e.Vector4.fromColor(o, !1), Opacity: () => n };
            break;
          case 'Texture':
            r.uniforms = {
              BaseColorSampler: () => Dm.bindTextureSampler(i.baseColorTexture),
              Color: () => new e.Vector4(o.r, o.g, o.b, o.a),
              Opacity: () => n,
            };
            break;
          default:
            throw new Error(`material with type '${t}' does not exist.`);
        }
        return r;
      }
      serialize() {
        const t = {
          type: 'StandardMaterial',
          texTYpe: this._texType,
          opacity: this._opacity,
          doubleSided: this._doubleSided,
          lightingModel: this._lightingModel,
        };
        return (
          'Color' === this._texType
            ? (t.color = e.Color.pack(this._color, new Array(4)))
            : 'Texture' === this._texType && (t.texUrl = this._baseColorTexture.texUrl),
          e.defined(this._flowOptions) && (t.flowOptions = this._flowOptions),
          t
        );
      }
      destroy() {
        return super.destroy(), e.window.cancelAnimationFrame(this.frame), e.destroyObject(this);
      }
    }
    class Bm {
      constructor(t) {
        if (e.defined(t.positions)) {
          if (!(t.positions instanceof Array))
            throw new Error('options.positions is not type of Array!');
          if (t.positions.length < 3)
            throw new Error("options.positions's length must greater than 2!");
          t.positions.forEach((t) => {
            if (!(t instanceof e.Vector3))
              throw new Error('options.positions contains the type of not Vector3!');
          });
        }
        if (
          ((this.bottomTextureUrl = t.bottomTextureUrl),
          (this.sideTextureUrl = t.sideTextureUrl),
          (this._minHeight = 0),
          (this._maxHeights = []),
          (this._wallPositions = []),
          (this._positions = e.defaultValue(t.positions, void 0)),
          (this.positions = this._positions),
          (this._shadowVolumePositions = []),
          (this._positionsUpdated = !1),
          e.defined(t.depth) && !e.isNumber(t.depth))
        )
          throw new Error('options.depth contains the type of not Number!');
        if (
          ((this._depth = e.defaultValue(t.depth, 100)),
          (this.depth = this._depth),
          (this._depthUpdated = !1),
          e.defined(t.sampleDistance) && !e.isNumber(t.sampleDistance))
        )
          throw new Error('options.sampleDistance is not a Number!');
        if (
          ((this._sampleDistance = e.defaultValue(t.sampleDistance, 5)),
          (this.sampleDistance = this._sampleDistance),
          (this._sampleDistanceUpdated = !1),
          e.defined(t.enabled) && !e.isBoolean(t.enabled))
        )
          throw new Error('options.sampleDistance is not a bool!');
        (this._enabled = e.defaultValue(t.enabled, !0)),
          (this._bodyMaterial = void 0),
          (this._bodyPrimitive = void 0),
          (this._bottomMaterial = void 0),
          (this._bottomPrimitive = void 0),
          (this._backPrimitive = void 0),
          (this._frontPrimitive = void 0),
          (this._initialized = !1),
          (this.id = e.uuid());
      }
      get depth() {
        return this._depth;
      }
      set depth(t) {
        e.isNumber(t) && t >= 0 && ((this._depth = t), (this._depthUpdated = !1));
      }
      get enabled() {
        return this._enabled;
      }
      set enabled(t) {
        e.isBoolean && (this._enabled = t);
      }
      get positions() {
        return this._positions;
      }
      set positions(t) {
        (t instanceof Array || t.length > 2) &&
          (t.forEach((t) => {
            if (!(t instanceof e.Vector3))
              throw new Error('positions contains the type of not Vector3!');
          }),
          (this._positions = t),
          this._positions.push(t[0]),
          (this._positionsUpdated = !1));
      }
      get sampleDistance() {
        return this._sampleDistance;
      }
      set sampleDistance(t) {
        e.isNumber(t) &&
          ((this._sampleDistance = Math.max(t, 1)), (this._sampleDistanceUpdated = !1));
      }
      #ke(t) {
        const i = this;
        this._shadowVolumePositions = [];
        const s = new e.Cartographic(),
          r = [];
        let n;
        this.positions.forEach((t) => {
          e.Cartographic.fromVector3(t, void 0, s),
            i._maxHeights.push(s.height),
            r.push(s.height),
            (n = e.Cartographic.fromVector3(t)),
            i._shadowVolumePositions.push(e.Vector3.fromRadians(n.longitude, n.latitude, 9e3));
        }),
          (this._minHeight = r.sort((e, t) => e - t)[0] - this._depth);
        const o = e.Vector3.unpackArray(
          e.PolylinePipeline.generateArc({
            positions: this.positions,
            minDistance: this.sampleDistance,
          }),
        );
        this._wallPositions = [];
        for (let i = 0; i < o.length; i++) {
          const s = e.Cartographic.fromVector3(o[i]),
            r = (180 * s.longitude) / Math.PI,
            n = (180 * s.latitude) / Math.PI;
          if (t.style.terrainSourceCache.isTerrain()) {
            const i = vo(
              new e.Vector3(r, n, 0),
              e.Vector3.fromDegrees(r, n, 1e4),
              t.style.terrainSourceCache.supplier,
            );
            e.defined(i.intersectionPoint) && this._wallPositions.push(i.intersectionPoint);
          } else this._wallPositions.push(e.Vector3.fromDegrees(r, n, 0));
        }
      }
      #Fe(t) {
        e.defined(this._bottomMaterial) ||
          (this._bottomMaterial = Dm.fromType('Texture', {
            baseColorTexture: new ks().load({
              map: t._map,
              texUrl: this.bottomTextureUrl || vr('minemap://assets/DigBottom.jpg'),
            }),
            lightingModel: e.LightingModelType.NONE,
            doubleSided: !0,
          })),
          e.defined(this._bodyMaterial) ||
            (this._bodyMaterial = Dm.fromType('Texture', {
              baseColorTexture: new ks().load({
                map: t._map,
                texUrl: this.sideTextureUrl || vr('minemap://assets/DigBody.jpg'),
                flipY: !0,
              }),
              lightingModel: e.LightingModelType.NONE,
              doubleSided: !0,
            }));
      }
      #Ge(t) {
        e.defined(this._bodyPrimitive) && t._map.removePrimitive(this._bodyPrimitive),
          (this._bodyPrimitive = new e.Primitive({
            geometry: Lm.fromConstantHeights({
              positions: this._wallPositions,
              maximumHeights: this._maxHeights,
              minimumHeight: this._minHeight,
            }),
            material: this._bodyMaterial,
            name: 'excavationBody',
            classificationType: e.ClassificationType.IGNORECLASSIFICATION,
          })),
          t._map.addPrimitive(this._bodyPrimitive);
      }
      #Ue(t) {
        e.defined(this._bottomPrimitive) && t._map.removePrimitive(this._bottomPrimitive);
        const i = [];
        for (let t = 0; t < this._positions.length - 1; t++)
          i.push(e.Vector3.clone(this._positions[t]));
        (this._bottomPrimitive = new e.Primitive({
          geometry: new e.PolygonGeometry({
            polygonHierarchy: { positions: i },
            height: this._minHeight,
          }),
          material: this._bottomMaterial,
          name: 'excavationBottom',
          classificationType: e.ClassificationType.IGNORECLASSIFICATION,
        })),
          t._map.addPrimitive(this._bottomPrimitive);
      }
      #ze() {
        const t = new e.PolygonGeometry({
          polygonHierarchy: { positions: this._shadowVolumePositions },
          extrudedHeight: -this._depth,
          perPositionHeight: !0,
        });
        (this._frontPrimitive = new e.Primitive({
          geometry: t,
          material: Dm.fromType('Color', {
            renderState: {
              colorMask: { red: !1, green: !1, blue: !1, alpha: !1 },
              cull: { enabled: !0, face: e.WebGLConstants.FRONT },
              depthMask: !1,
              depthTest: { enabled: !0, func: e.WebGLConstants.LESS },
              stencilMask: 255,
              stencilTest: {
                enabled: !0,
                frontFunction: e.WebGLConstants.ALWAYS,
                frontOperation: {
                  fail: e.WebGLConstants.KEEP,
                  zFail: e.WebGLConstants.KEEP,
                  zPass: e.WebGLConstants.KEEP,
                },
                backOperation: {
                  fail: e.WebGLConstants.KEEP,
                  zFail: e.WebGLConstants.DECR_WRAP,
                  zPass: e.WebGLConstants.KEEP,
                },
                reference: 0,
                mask: 255,
              },
            },
          }),
        })),
          (this._backPrimitive = new e.Primitive({
            geometry: t,
            material: Dm.fromType('Color', {
              renderState: {
                colorMask: { red: !1, green: !1, blue: !1, alpha: !1 },
                cull: { enabled: !0, face: e.WebGLConstants.BACK },
                depthMask: !1,
                depthTest: { enabled: !0, func: e.WebGLConstants.LESS },
                depthRange: { near: 0, far: 1 },
                stencilMask: 255,
                stencilTest: {
                  enabled: !0,
                  frontFunction: e.WebGLConstants.ALWAYS,
                  frontOperation: {
                    fail: e.WebGLConstants.KEEP,
                    zFail: e.WebGLConstants.INCR_WRAP,
                    zPass: e.WebGLConstants.KEEP,
                  },
                  backOperation: {
                    fail: e.WebGLConstants.KEEP,
                    zFail: e.WebGLConstants.KEEP,
                    zPass: e.WebGLConstants.KEEP,
                  },
                  reference: 0,
                  mask: 255,
                },
              },
            }),
          }));
      }
      #q(e) {
        this.#ke(e), this.#Fe(e), this.#Ge(e), this.#Ue(e), this.#ze();
      }
      #Me(e) {
        this.#q(e),
          (this._initialized = !0),
          (this._positionsUpdated = !0),
          (this._sampleDistanceUpdated = !0),
          (this._depthUpdated = !0);
      }
      update(t) {
        this._enabled &&
          e.defined(this._positions) &&
          ((this._initialized &&
            this._positionsUpdated &&
            this._sampleDistanceUpdated &&
            this._depthUpdated) ||
            this.#Me(t),
          e.defined(this._backPrimitive) &&
            e.defined(this._frontPrimitive) &&
            (this._backPrimitive.update(t, t.frameState),
            this._backPrimitive.render(t, { id: 'shadowVolumeBack' }, t.frameState),
            this._frontPrimitive.update(t, t.frameState),
            this._frontPrimitive.render(t, { id: 'shadowVolumeFront' }, t.frameState)));
      }
      destroy() {
        return (
          (this._minHeight = void 0),
          (this._maxHeights = void 0),
          (this._wallPositions = void 0),
          (this._positions = void 0),
          (this._shadowVolumePositions = void 0),
          (this._positionsUpdated = void 0),
          (this._depth = void 0),
          (this._depthUpdated = void 0),
          (this._sampleDistance = void 0),
          (this._sampleDistanceUpdated = void 0),
          (this._enabled = void 0),
          this._bodyPrimitive.destroy(),
          (this._bodyPrimitive = void 0),
          (this._bodyMaterial = void 0),
          this._bottomPrimitive.destroy(),
          (this._bottomPrimitive = void 0),
          (this._bottomMaterial = void 0),
          this._backPrimitive.destroy(),
          this._frontPrimitive.destroy(),
          (this._initialized = void 0),
          e.destroyObject(this)
        );
      }
    }
    class Vm {
      constructor(e) {
        (this._painter = e), (this._excavations = []), (this._terrainCreated = !1);
      }
      get length() {
        return this._excavations.length;
      }
      add(t, i) {
        if (!(t instanceof Bm))
          return console.error('The current addition is not of type Excavation!'), !1;
        const s = e.defined(i);
        if (s) {
          if (i < 0) throw new Error('index must be greater than or equal to zero.');
          if (i > this._excavations.length)
            throw new Error('index must be less than or equal to the number of Excavation.');
        }
        return s ? this._excavations.splice(i, 0, t) : this._excavations.push(t), !0;
      }
      getById(e) {
        let t;
        return (
          this._excavations.forEach((i) => {
            i.id === e && (t = i);
          }),
          t
        );
      }
      getByIndex(t) {
        if (e.isNumber(t) && !(t > this.length)) return this._excavations[t];
      }
      indexOf(e) {
        return this._excavations.indexOf(e);
      }
      remove(e) {
        const t = this.indexOf(e);
        return -1 !== t && (this.#He(e), this._excavations.splice(t, 1), !0);
      }
      removeById(e) {
        const t = this.getById(e);
        this.remove(t);
      }
      removeByIndex(t) {
        if (e.isNumber(t)) {
          if (t < 0) throw new Error('index must be greater than or equal to zero.');
          if (t > this._excavations.length)
            throw new Error('index must be less than or equal to the number of Excavation.');
          const e = this.getByIndex(t);
          this.remove(e);
        }
        return !1;
      }
      removeAll() {
        for (let e = 0; e < this.length; e++) this.#He(this.getByIndex(e));
        this._excavations = [];
      }
      #He(e) {
        this._painter._map.removePrimitive(e._bottomPrimitive),
          this._painter._map.removePrimitive(e._bodyPrimitive);
      }
      update(t, i, s) {
        if (!this._terrainCreated) {
          if (t.style.terrainSourceCache.isTerrain() && !t.style.terrainSourceCache.loaded())
            return;
          this._terrainCreated = !0;
        }
        const r = {
          colorMask: { red: !1, green: !1, blue: !1, alpha: !1 },
          depthTest: { enabled: !0 },
        };
        let n, o;
        for (let e = 0; e < i.length; e++)
          (n = i[e]),
            (o = n._material.renderState),
            (n._material._renderState = r),
            n.update(t, t.frameState),
            n.render(t, s, t.frameState),
            (n._material._renderState = o);
        t.clearStencil();
        for (let e = 0; e < this.length; e++) this.getByIndex(e).update(t);
        e.RenderState.applyRenderState(
          t.context,
          e.RenderState.fromCache({
            colorMask: { red: !0, green: !0, blue: !0, alpha: !0 },
            depthMask: !0,
          }),
        ),
          t.context.clear({ depth: 1 });
      }
      serialize() {
        const t = [];
        for (let i = 0; i < this.length; i++) {
          const s = this.getByIndex(i),
            r = [];
          for (let t = 0; t < s.positions.length; t++) {
            let i = s.positions[t];
            (i = e.Cartographic.fromVector3(i)),
              (i.x = e.CONSTS.CesiumMath.toDegrees(i.x)),
              (i.y = e.CONSTS.CesiumMath.toDegrees(i.y)),
              e.Vector3.pack(i, r, r.length);
          }
          t[i] = {
            positions: r,
            depth: s.depth,
            sampleDistance: s.sampleDistance,
            enabled: s.enabled,
          };
        }
        return t.length > 0 ? t : void 0;
      }
    }
    const Nm = { VISIBLE_DOME: 0, HIDDEN_DOME: 1, ALL_DOME: 2 };
    class km extends e.Pass {
      constructor(t) {
        super(t),
          (this.camera = t.camera),
          (this.framebuffer = void 0),
          (this.width = t.width),
          (this.height = t.height),
          (this.frameState = void 0),
          (this.replaceMaterial = new e.DepthMaterial({}));
      }
      #U({ context: t, width: i, height: s }) {
        const r = new e.Sampler({
          minificationFilter: e.TextureMinificationFilter.NEAREST,
          magnificationFilter: e.TextureMagnificationFilter.NEAREST,
        });
        this.framebuffer = new e.Framebuffer({
          context: t,
          width: i,
          height: s,
          colorTextures: [
            new e.Texture({
              image: null,
              context: t,
              width: i,
              height: s,
              pixelFormat: e.WebGLConstants.RGBA,
            }),
          ],
          depthStencilTexture: new e.Texture({
            context: t,
            width: i,
            height: s,
            minFilter: e.WebGLConstants.LINEAR,
            magFilter: e.WebGLConstants.LINEAR,
            pixelFormat: e.PixelFormat.DEPTH_STENCIL,
            pixelDatatype: e.PixelDatatype.UNSIGNED_INT_24_8,
            sampler: r,
            anisotropy: 1,
          }),
        });
      }
      update(t, i, s) {
        const r = t.context;
        e.defined(this.frameState) || (this.frameState = new Vs(this.passType)),
          (this.frameState.overrideMaterial = this.replaceMaterial),
          e.defined(this.framebuffer) || this.#U({ context: r, width: i, height: s }),
          this.frameState.update({ framebuffer: this.framebuffer, camera: this.camera }),
          this.frameState.bindFramebuffer(r);
      }
      render(t) {
        const i = t.context,
          s = i.bindFramebuffer.get();
        this.update(t, this.width, this.height),
          e.RenderState.applyRenderState(
            i,
            e.RenderState.fromCache({
              blending: e.renderStateEnum.enableBlending,
              depthMask: !0,
              depthTest: { enabled: !0, depthTest: e.WebGLConstants.LESS },
              viewport: { x: 0, y: 0, width: this.width, height: this.height },
            }),
          ),
          i.clear({ depth: 1 }),
          t.renderGroup.update({
            layers: t.style._layers,
            orders: t.style._order,
            frameState: this.frameState,
          }),
          t.renderGroup.render({ layers: t.style._layers, frameState: this.frameState }),
          (this.frameState.overrideMaterial = void 0),
          i.bindFramebuffer.set(s),
          e.RenderState.applyRenderState(
            i,
            e.RenderState.fromCache({ viewport: { x: 0, y: 0, width: t.width, height: t.height } }),
          );
      }
    }
    class Fm {
      constructor(t) {
        if (e.defined(t.viewPosition) && !(t.viewPosition instanceof e.Vector3))
          throw new Error('viewerPosition is not type of Vector3!');
        if (
          ((this._viewPosition = e.defaultValue(t.viewPosition, new e.Vector3())),
          (this._radius = e.defaultValue(t.radius, 100)),
          (this._domeType = e.defaultValue(t.domeType, Nm.ALL_DOME)),
          (this._visible = e.defaultValue(t.visible, !0)),
          (this._visibleAreaColor = e.defaultValue(
            e.Color.parse(t.visibleAreaColor),
            new e.Color(0, 1, 0, 1),
          )),
          (this._hiddenAreaColor = e.defaultValue(
            e.Color.parse(t.hiddenAreaColor),
            new e.Color(1, 0, 0, 1),
          )),
          (this._startAngle = e.defaultValue(t.startAngle, 0)),
          (this._endAngle = e.defaultValue(t.endAngle, 360)),
          (this._isClosed = e.defaultValue(t.isClosed, !1)),
          (this._sholdCalculateVisibleRatio = e.defaultValue(t.sholdCalculateVisibleRatio, !0)),
          (this._hasCalculated = !1),
          (this._visibleRatio = 0),
          e.defined(t.ratioCalculated) && !(t.ratioCalculated instanceof Function))
        )
          throw new Error('options.ratioCalculated is not a function!');
        (this.ratioCalculatedCallback = e.defaultValue(t.ratioCalculated, void 0)),
          (this._pointIndicator = void 0),
          (this._indicatorVisible = e.defaultValue(t.indicatorVisible, 10)),
          (this._indicatorSize = e.defaultValue(t.indicatorSize, 10)),
          (this._indicatorColor = e.Color.parse(t.indicatorColor) || new e.Color(1, 0, 0, 1)),
          (this._indicatorOutlineColor =
            e.Color.parse(t.indicatorOutlineColor) || new e.Color(0, 0, 0, 0)),
          (this._indicatorOutlineWidth = e.defaultValue(t.indicatorOutlineWidth, 0)),
          (this._initialized = !1),
          (this._worldMatrix = new e.Matrix4()),
          (this._geometry = void 0),
          (this._viewDomeCommand = void 0),
          (this._calculateFramebuffers = []),
          (this._calculateCommands = []),
          (this._renderTextureMatrix = []),
          (this._viewshedPass = []),
          (this._windowSize = { height: 0, width: 0 }),
          (this.id = e.uuid());
      }
      get viewPosition() {
        return this._viewPosition;
      }
      set viewPosition(t) {
        if (t instanceof e.Vector3) {
          this._viewPosition = t;
          const i = e.Vector3.fromDegrees(t.x, t.y, t.z);
          (this._worldMatrix = e.Transforms.headingPitchRollToFixedFrame(
            i,
            new e.HeadingPitchRoll(0, 0, 0),
          )),
            (this._initialized = !1),
            (this._hasCalculated = !1);
        }
      }
      get radius() {
        return this._radius;
      }
      set radius(t) {
        e.isNumber(t) && ((this._radius = t), (this._initialized = !1), (this._hasCalculated = !1));
      }
      get domeType() {
        return this._domeType;
      }
      set domeType(e) {
        this._domeType = e;
      }
      get visible() {
        return this._visible;
      }
      set visible(t) {
        e.isBoolean(t) && (this._visible = t);
      }
      get sholdCalculateVisibleRatio() {
        return this._sholdCalculateVisibleRatio;
      }
      set sholdCalculateVisibleRatio(t) {
        e.isBoolean(t) && (this._sholdCalculateVisibleRatio = t);
      }
      get visibleRatio() {
        return this._visibleRatio;
      }
      get visibleAreaColor() {
        return this._visibleAreaColor;
      }
      set visibleAreaColor(t) {
        const i = e.Color.parse(t);
        e.defined(i) && (this._visibleAreaColor = i);
      }
      get hiddenAreaColor() {
        return this._hiddenAreaColor;
      }
      set hiddenAreaColor(t) {
        const i = e.Color.parse(t);
        e.defined(i) && (this._hiddenAreaColor = i);
      }
      get startAngle() {
        return this._startAngle;
      }
      set startAngle(t) {
        if (e.isNumber(t)) {
          let e = Math.max(0, Math.min(360, t));
          (e = Math.min(this._endAngle, e)),
            (this._startAngle = e),
            (this._initialized = !1),
            (this._hasCalculated = !1);
        }
      }
      get endAngle() {
        return this._endAngle;
      }
      set endAngle(t) {
        if (e.isNumber(t)) {
          let e = Math.max(0, Math.min(360, t));
          (e = Math.max(this._startAngle, e)),
            (this._endAngle = e),
            (this._initialized = !1),
            (this._hasCalculated = !1);
        }
      }
      get isClosed() {
        return this._isClosed;
      }
      set isClosed(t) {
        e.isBoolean(t) &&
          ((this._isClosed = t), (this._initialized = !1), (this._hasCalculated = !1));
      }
      get indicatorVisible() {
        return this._indicatorVisible;
      }
      set indicatorVisible(t) {
        e.isBoolean(t) && ((this._indicatorVisible = t), this.#We());
      }
      get indicatorSize() {
        return this._indicatorSize;
      }
      set indicatorSize(t) {
        e.isNumber(t) && ((this._indicatorSize = t), this.#We());
      }
      get indicatorColor() {
        return this._indicatorColor;
      }
      set indicatorColor(t) {
        const i = e.Color.parse(t);
        e.defined(i) && ((this._indicatorColor = e.Color.parse(i)), this.#We());
      }
      get indicatorOutlineColor() {
        return this._indicatorOutlineColor;
      }
      set indicatorOutlineColor(t) {
        (this._indicatorOutlineColor = e.Color.parse(t)), this.#We();
      }
      get indicatorOutlineWidth() {
        return this._indicatorOutlineWidth;
      }
      set indicatorOutlineWidth(e) {
        (this._indicatorOutlineWidth = e), this.#We();
      }
      #We() {
        if (!this._indicatorVisible) return;
        const t = e.Vector3.fromDegrees(
          this._viewPosition.x,
          this._viewPosition.y,
          this._viewPosition.z,
        );
        e.defined(this._pointIndicator)
          ? (this._pointIndicator.remove(this._pointPrimitive, !0),
            (this._pointPrimitive = new va({
              show: !0,
              position: t,
              pixelSize: this._indicatorSize,
              color: this._indicatorColor,
              outlineColor: this._indicatorOutlineColor,
              outlineWidth: this._indicatorOutlineWidth,
            })),
            this._pointIndicator.add(this._pointPrimitive))
          : ((this._pointIndicator = new Sa()),
            (this._pointPrimitive = new va({
              show: !0,
              position: t,
              pixelSize: this._indicatorSize,
              color: this._indicatorColor,
              outlineColor: this._indicatorOutlineColor,
              outlineWidth: this._indicatorOutlineWidth,
            })),
            this._pointIndicator.add(this._pointPrimitive));
      }
      #je(e) {
        if (!this._indicatorVisible) return;
        this._pointIndicator.update(e);
        const t = this._pointIndicator.getTranslucentPrimitives();
        for (let i = 0; i < t.length; i++)
          t[i].update(e, e.frameState, {}), (t[i].framebuffer = e.mainPass.framebuffer.framebuffer);
        for (let i = 0; i < t.length; i++)
          t[i].render(e, { id: 'viewdom-indicator' }, e.frameState), (t[i].framebuffer = null);
      }
      #qe(t) {
        (this._viewshedPass = []),
          (this._renderTextureMatrix = [
            new e.Matrix4(),
            new e.Matrix4(),
            new e.Matrix4(),
            new e.Matrix4(),
            new e.Matrix4(),
          ]);
        const i = new e.Matrix4();
        for (let s = 0; s < 5; s++) {
          const r = new n(90, 1, 0.001 * this._radius, Math.max(this._radius + 100, 10)),
            o = e.Transforms.headingPitchRollToFixedFrame(
              e.Vector3.fromDegrees(this.viewPosition.x, this.viewPosition.y, this.viewPosition.z),
              new e.HeadingPitchRoll(
                e.CONSTS.CesiumMath.toRadians(90 * s),
                e.CONSTS.CesiumMath.toRadians(4 === s ? 180 : 90),
                e.CONSTS.CesiumMath.toRadians(0),
              ),
            );
          r.setMatrix(o),
            e.Matrix4.multiply(i, r.getViewMatrix(), this._worldMatrix),
            e.Matrix4.multiply(this._renderTextureMatrix[s], r.getProjectionMatrix(), i),
            (this._viewshedPass[s] = new km({
              camera: r,
              context: t.context,
              width: 2048,
              height: 2048,
              passType: e.RenderPassConsts.VIEWSHED_PASS,
            }));
        }
      }
      #Xe(t, i, s, r, n, o) {
        const a = ((n - r) * e.CONSTS.CesiumMath.RADIANS_PER_DEGREE) / i,
          l = Math.PI / (2 * t);
        let h = 0,
          c = 0,
          _ = !1;
        !o || (0 === r && 360 === n) || (_ = !0);
        const u = new Array(3 * (_ ? (t + 1) * i + 1 : (t + 1) * i));
        let d = 0;
        for (let n = 0; n < i; n++) {
          c = n * a + r * e.CONSTS.CesiumMath.RADIANS_PER_DEGREE;
          for (let e = 0; e <= t; e++)
            (h = e * l),
              (u[d++] = s * Math.sin(h) * Math.cos(c)),
              (u[d++] = s * Math.sin(h) * Math.sin(c)),
              (u[d++] = s * Math.cos(h));
        }
        return _ && ((u[d++] = 0), (u[d++] = 0), (u[d++] = 0)), u;
      }
      #Ze(e, t, i, s, r) {
        const n = 0 == i && 360 == s ? t : t - 1;
        let o;
        const a = [];
        for (o = 0; o < e; o++)
          for (let i = 0; i < n; i++) {
            const s = o + i * (e + 1),
              r = s + 1,
              n = i == t - 1 ? o + 1 : s + e + 2;
            a.push(s), a.push(r), a.push(n), a.push(s), a.push(n), a.push(n - 1);
          }
        if (r && (0 != i || 360 != s)) {
          const i = (e + 1) * t,
            s = n * (e + 1);
          for (o = 0; o < e; o++)
            a.push(o), a.push(o + 1), a.push(i), a.push(o + s + 1), a.push(o + s), a.push(i);
        }
        return a;
      }
      #$e(t) {
        e.defined(this._geometry) && this._geometry.destroy(),
          e.defined(this._viewDomeCommand) &&
            ((this._viewDomeCommand.material = void 0), (this._viewDomeCommand = void 0));
        const i = e.Vector3.fromDegrees(
          this.viewPosition.x,
          this.viewPosition.y,
          this.viewPosition.z,
        );
        this._worldMatrix = e.Transforms.headingPitchRollToFixedFrame(
          i,
          new e.HeadingPitchRoll(0, 0, 0),
        );
        const s = this.#Xe(129, 129, 1, this._startAngle, this._endAngle, this._isClosed),
          r = new e.StructArrayLayout3f2f3f32();
        for (let e = 0; e < s.length; e += 3)
          r.emplaceBack(s[e], s[e + 1], s[e + 2], 0, 0, 0, 0, 0);
        const n = this.#Ze(129, 129, this._startAngle, this._endAngle, this._isClosed),
          o = new e.StructArrayLayout3ui6();
        for (let e = 0; e < n.length; e += 3) o.emplaceBack(n[e], n[e + 1], n[e + 2]);
        this._geometry = new e.Geometry({
          primitiveType: e.WebGLConstants.TRIANGLES,
          vertBuffer: t.context.createVertexBuffer(r, e.layout$1.members),
          indexBuffer: t.context.createIndexBuffer(o),
          segmentVector: e.SegmentVector.simpleSegment(0, 0, s.length / 3, n.length / 3),
        });
        const a = new Map([
          [
            'u_ModelViewProjectionMatrix',
            () => t.frameState.camera.getVPMatrix().multiplyRight(this._worldMatrix),
          ],
          ['u_Radius', () => this._radius],
          ['u_VisibleAreaColor', () => e.Vector4.fromColor(this._visibleAreaColor, !1)],
          ['u_HiddenAreaColor', () => e.Vector4.fromColor(this._hiddenAreaColor, !1)],
          ['u_DomeType', () => this._domeType],
        ]);
        for (let e = 0; e < 5; e++)
          a.set(`u_TexWorldViewProjMatrix${e}`, () => this._renderTextureMatrix[e]),
            a.set(`u_DepthMap${e}`, () => this._viewshedPass[e].framebuffer.depthStencilTexture);
        this._viewDomeCommand = {
          painter: t,
          framebuffer: t.mainPass.framebuffer.framebuffer,
          layer: { id: 'viewDomeAnalysis' },
          geometry: this._geometry,
          material: {
            renderState: {
              blending: e.renderStateEnum.enableBlending,
              depthTest: e.renderStateEnum.enableDepthTest,
            },
            _uniforms: a,
            _shaderSource: new e.ShaderSource({ type: 'viewDomeAnalysis' }),
          },
        };
      }
      #Ke(t) {
        const i = new e.Sampler({
          minificationFilter: e.TextureMinificationFilter.NEAREST,
          magnificationFilter: e.TextureMagnificationFilter.NEAREST,
        });
        (this._calculateCommands = []), (this._calculateFramebuffers = []);
        for (let s = 0; s < 5; s++) {
          const r = new e.Texture({
              context: t.context,
              width: 2048,
              height: 2048,
              minFilter: e.WebGLConstants.NEAREST,
              magFilter: e.WebGLConstants.NEAREST,
              pixelFormat: e.PixelFormat.RGBA,
              pixelDatatype: e.PixelDatatype.UNSIGNED_BYTE,
              sampler: i,
              anisotropy: 1,
            }),
            o = new e.Framebuffer({ context: t.context, colorTextures: [r] });
          this._calculateFramebuffers.push(o);
          const a = new n(90, 1, 0.1, Math.max(this._radius, 1)),
            l = 4 === s ? 180 : Math.PI / 2,
            h = (Math.PI / 2) * s,
            c = new e.Matrix4().rotateX(l).rotateY(h);
          a.setMatrix(c);
          const _ = new Map([
            ['u_ModelViewProjectionMatrix', () => a.getVPMatrix()],
            ['u_DepthMap', () => this._viewshedPass[s].framebuffer.depthStencilTexture],
          ]);
          this._calculateCommands.push({
            painter: t,
            framebuffer: this._calculateFramebuffers[s].framebuffer,
            layer: { id: 'viewDomeCalculateAnalysis' },
            geometry: this._geometry,
            material: {
              renderState: {
                blending: e.renderStateEnum.disableBlending,
                depthTest: e.renderStateEnum.enableDepthTest,
              },
              _uniforms: _,
              _shaderSource: new e.ShaderSource({ type: 'viewDomeCalculateAnalysis' }),
            },
          });
        }
      }
      #Ye(t) {
        this._visibleRatio = 0;
        const i = [];
        for (let s = 0; s < this._calculateCommands.length; s++)
          t.frameState.update({ framebuffer: this._calculateFramebuffers[s] }),
            t.frameState.bindFramebuffer(t.context),
            t.context.clear({ color: e.Color.transparent, depth: 1, stencil: 0 }),
            t.context.draw(this._calculateCommands[s]),
            i.push(
              e.readPixel(
                { x: 0, y: 2048 / e.window.devicePixelRatio, height: 2048, width: 2048 },
                t.context,
                this._calculateFramebuffers[s],
                2048,
                e.WebGLConstants.UNSIGNED_BYTE,
                16777216,
              ),
            ),
            t.context.bindFramebuffer.set(null);
        (this._hasCalculated = !0),
          (this.workerID = t.style.dispatcher.send(
            'caculateViewdomeRatio',
            { data: i },
            (t, i) => {
              (this._visibleRatio = i),
                e.defined(this.ratioCalculatedCallback) &&
                  this.ratioCalculatedCallback(this._visibleRatio);
            },
            void 0,
          ));
      }
      update(e) {
        if (
          this._visible &&
          ((this._windowSize.height === e.height && this._windowSize.width === e.width) ||
            ((this._windowSize.height = e.height),
            (this._windowSize.width = e.width),
            (this._initialized = !1)),
          !this._initialized)
        ) {
          this.#We(), this.#$e(e), this.#qe(e), this.#Ke(e);
          for (let t = 0; t < this._viewshedPass.length; t++) this._viewshedPass[t].render(e);
          this._initialized = !0;
        }
      }
      render(e) {
        this._visible &&
          (this.#je(e),
          this._sholdCalculateVisibleRatio && !this._hasCalculated && this.#Ye(e),
          e.context.draw(this._viewDomeCommand));
      }
      destroy() {
        (this._viewPosition = void 0),
          (this._radius = void 0),
          (this._domeType = void 0),
          (this._visible = void 0),
          (this._visibleAreaColor = void 0),
          (this._hiddenAreaColor = void 0),
          (this._startAngle = void 0),
          (this._endAngle = void 0),
          (this._isClosed = void 0),
          (this._sholdCalculateVisibleRatio = void 0),
          (this._hasCalculated = void 0),
          (this._visibleRatio = void 0),
          (this.ratioCalculatedCallback = void 0),
          e.defined(this._pointIndicator) &&
            (this._pointIndicator.removeAll(!0), (this._pointIndicator = void 0)),
          (this._indicatorSize = void 0),
          (this._indicatorColor = void 0),
          (this._indicatorOutlineColor = void 0),
          (this._indicatorOutlineWidth = void 0),
          (this._initialized = void 0),
          (this._worldMatrix = void 0),
          e.defined(this._geometry) && (this._geometry.destroy(), (this._geometry = void 0)),
          (this._viewDomeCommand.material = void 0),
          (this._viewDomeCommand = void 0);
        for (let e = 0; e < this._calculateFramebuffers; e++)
          this._calculateFramebuffers[e].destroy(!1);
        this._calculateFramebuffers = [];
        for (let e = 0; e < this._calculateCommands; e++)
          (this._calculateCommands[e].material = void 0), (this._calculateCommands[e] = void 0);
        (this._calculateCommands = []), (this._renderTextureMatrix = []);
        for (let e = 0; e < this._viewshedPass; e++)
          this._viewshedPass[e].destroy(), (this._viewshedPass[e] = void 0);
        return (this._viewshedPass = []), e.destroyObject(this);
      }
    }
    class Gm {
      constructor() {
        this._viewDomes = [];
      }
      get length() {
        return this._viewDomes.length;
      }
      add(t, i) {
        if (!(t instanceof Fm))
          return console.error('The current addition is not of type ViewDome!'), !1;
        const s = e.defined(i);
        if (s) {
          if (i < 0) throw new Error('index must be greater than or equal to zero.');
          if (i > this._viewDomes.length)
            throw new Error('index must be less than or equal to the number of ViewDome.');
        }
        return s ? this._viewDomes.splice(i, 0, t) : this._viewDomes.push(t), !0;
      }
      getById(e) {
        let t;
        return (
          this._viewDomes.forEach((i) => {
            i.id === e && (t = i);
          }),
          t
        );
      }
      getByIndex(t) {
        if (e.isNumber(t) && !(t > this.length)) return this._viewDomes[t];
      }
      indexOf(e) {
        return this._viewDomes.indexOf(e);
      }
      remove(e) {
        const t = this.indexOf(e);
        return -1 !== t && (this._viewDomes.splice(t, 1), !0);
      }
      removeById(e) {
        const t = this.getById(e);
        this.remove(t);
      }
      removeByIndex(t) {
        if (e.isNumber(t)) {
          if (t < 0) throw new Error('index must be greater than or equal to zero.');
          if (t > this._viewDomes.length)
            throw new Error('index must be less than or equal to the number of ViewDome.');
          const e = this.getByIndex(t);
          this.remove(e);
        }
        return !1;
      }
      removeAll() {
        for (let e = 0; e < this.length; e++) this._viewDomes[e].destroy();
        this._viewDomes = [];
      }
      update(e) {
        for (let t = 0; t < this.length; t++) this.getByIndex(t).update(e);
      }
      serialize() {
        const t = [];
        for (let i = 0; i < this.length; i++) {
          const s = this.getByIndex(i),
            r = {
              viewPosition: e.Vector3.pack(s.viewPosition, new Array(3)),
              radius: s.radius,
              domeType: s.domeType,
              visible: s.visible,
              visibleAreaColor: e.Color.pack(s.visibleAreaColor, new Array(4)),
              hiddenAreaColor: e.Color.pack(s.hiddenAreaColor, new Array(4)),
              startAngle: s.startAngle,
              endAngle: s.endAngle,
              isClosed: s.isClosed,
              sholdCalculateVisibleRatio: s.sholdCalculateVisibleRatio,
              indicatorVisible: s.indicatorVisible,
              indicatorSize: s.indicatorSize,
              indicatorColor: e.Color.pack(s.indicatorColor, new Array(4)),
              indicatorOutlineColor: e.Color.pack(s.indicatorOutlineColor, new Array(4)),
              indicatorOutlineWidth: s.indicatorOutlineWidth,
            };
          t.push(r);
        }
        return t.length > 0 ? t : void 0;
      }
    }
    class Um extends e.Geometry {
      constructor() {
        super(), (this.vertices = new Float64Array(633)), (this.indices = new Uint16Array(408));
        const t = this.indices;
        let i = 0;
        (t[i++] = 0),
          (t[i++] = 1),
          (t[i++] = 0),
          (t[i++] = 21),
          (t[i++] = 0),
          (t[i++] = 85),
          (t[i++] = 0),
          (t[i++] = 105);
        let s = 0;
        for (let e = 0; e < 5; ++e) {
          s++;
          for (let e = 0; e < 20; ++e) (t[i++] = s++), (t[i++] = s);
        }
        s++;
        for (let e = 0; e < 20; ++e) for (let e = 0; e < 5; ++e) (t[i++] = s), (t[i++] = 5 + s++);
        (this._boundingSphere = void 0),
          (this.type = 'Viewshed3DHintLineGeometry'),
          (this._usedDoublePrecision = !1),
          (this._vertexArray = this._usedDoublePrecision
            ? new e.StructArrayLayout3f3f24()
            : new e.StructArrayLayout3f12()),
          (this._indices = new e.StructArrayLayout2ui4());
        for (let e = 0; e < this.indices.length / 2; e++)
          this._indices.emplaceBack(this.indices[2 * e], this.indices[2 * e + 1]);
        (this.primitiveType = e.WebGLConstants.LINES),
          (this._vertBuffer = void 0),
          (this._indexBuffer = void 0),
          (this._segmentVector = void 0),
          (this.needUpdate = !0),
          (this._ready = !1);
      }
      updatePositions(t) {
        const i = t.verticalFov,
          s = t.distance,
          r = t.modelMatrix,
          n = this.vertices,
          o = e.CONSTS.CesiumMath.toRadians(t.horizontalFov),
          a = e.CONSTS.CesiumMath.toRadians(i),
          l = s * Math.tan(0.5 * o),
          h = s * Math.tan(0.5 * a),
          c = new e.Vector3(-l, -h, -s),
          _ = new e.Vector3(l, h, 0);
        e.Matrix4.multiplyByPoint(r, c, c),
          e.Matrix4.multiplyByPoint(r, _, _),
          (this._boundingSphere = e.BoundingSphere.fromCornerPoints(c, _));
        let u = 0;
        (n[u++] = 0), (n[u++] = 0), (n[u++] = 0);
        const d = Math.PI - 0.5 * o;
        let m,
          p,
          f = o / 4;
        for (let e = 0; e < 5; ++e) {
          m = d + e * f;
          const t = h / (s / Math.cos(m)),
            i = Math.atan(t),
            r = -i,
            o = i / 10;
          for (let e = 0; e < 21; ++e)
            (p = r + e * o),
              (n[u++] = s * Math.cos(p) * Math.sin(m)),
              (n[u++] = s * Math.sin(p)),
              (n[u++] = s * Math.cos(p) * Math.cos(m));
        }
        f = o / 20;
        for (let e = 0; e < 21; ++e) {
          m = d + e * f;
          const t = h / (s / Math.cos(m)),
            i = Math.atan(t),
            r = -i,
            o = i / 2;
          for (let e = 0; e < 5; ++e)
            (p = r + e * o),
              (n[u++] = s * Math.cos(p) * Math.sin(m)),
              (n[u++] = s * Math.sin(p)),
              (n[u++] = s * Math.cos(p) * Math.cos(m));
        }
        this.emplaceVertexBufferOfLines();
      }
      update(t) {
        if (this.needUpdate && t.painter) {
          this.needUpdate = !1;
          const i = t.painter.context;
          e.defined(this._vertBuffer) && this._vertBuffer.destroy(),
            (this._vertBuffer = i.createVertexBuffer(
              this._vertexArray,
              this._usedDoublePrecision ? Z_.members : X_.members,
              !0,
            )),
            (this._indexBuffer = i.createIndexBuffer(this._indices, !1)),
            (this._segmentVector = e.SegmentVector.simpleSegment(
              0,
              0,
              this.vertices.length / 3,
              this.indices.length / 2,
            )),
            (this._ready = !0);
        }
      }
      destroy() {
        return (
          (this.vertices = void 0),
          (this.indices = void 0),
          (this._boundingSphere = void 0),
          (this.type = void 0),
          (this._vertexArray = void 0),
          (this._indexBuffer = void 0),
          (this._segmentVector = void 0),
          (this._indices = void 0),
          (this.primitiveType = void 0),
          (this._vertBuffer = void 0),
          (this.needUpdate = void 0),
          (this._ready = void 0),
          e.destroyObject(this)
        );
      }
    }
    class zm {
      constructor(t) {
        if (
          ((t = e.defined(t) ? t : {}),
          e.defined(t.viewerPosition) && !(t.viewerPosition instanceof e.Vector3))
        )
          throw new Error('viewerPosition is not type of Vector3!');
        if (
          ((this._viewerPosition = e.defaultValue(t.viewerPosition, new e.Vector3(0, 0, 0))),
          e.defined(t.direction) && (t.direction > 360 || t.direction < 0))
        )
          throw new Error('direction should be between 0 and 360!');
        if (
          ((this._direction = e.defaultValue(t.direction, 0)),
          e.defined(t.pitch) && (t.pitch > 180 || t.pitch < 0))
        )
          throw new Error('pitch should be between 0 and 180!');
        if (
          ((this._pitch = e.defaultValue(t.pitch, 90)),
          e.defined(t.horizontalFov) && (t.horizontalFov > 180 || t.horizontalFov < 0))
        )
          throw new Error('horizontalFov should be between 0 and 180!');
        if (
          ((this._horizontalFov = e.defaultValue(t.horizontalFov, 60)),
          e.defined(t.verticalFov) && (t.verticalFov > 180 || t.verticalFov < 0))
        )
          throw new Error('horizontalFov should be between 0 and 180!');
        if (
          ((this._verticalFov = e.defaultValue(t.verticalFov, 60)),
          e.defined(t.distance) && t.distance <= 0)
        )
          throw new Error('distance should be greater than 0!');
        if (
          ((this._distance = e.defaultValue(t.distance, 100)),
          e.defined(t.visibleAreaColor) &&
            !(t.visibleAreaColor instanceof e.Color) &&
            'string' != typeof t.visibleAreaColor)
        )
          throw new Error('visibleAreaColor type must be Color or String!');
        if (
          ((this._visibleAreaColor = e.Color.parse(
            e.defaultValue(t.visibleAreaColor, new e.Color(0, 1, 0, 0.3)),
          )),
          e.defined(t.hiddenAreaColor) &&
            !(t.hiddenAreaColor instanceof e.Color) &&
            'string' != typeof t.hiddenAreaColor)
        )
          throw new Error('hiddenAreaColor type must be Color or String!');
        if (
          ((this._hiddenAreaColor = e.Color.parse(
            e.defaultValue(t.hiddenAreaColor, new e.Color(1, 0, 0, 0.3)),
          )),
          e.defined(t.lineColor) &&
            !(t.lineColor instanceof e.Color) &&
            'string' != typeof t.lineColor)
        )
          throw new Error('lineColor type must be Color  or String!');
        (this._lineColor = e.Color.parse(e.defaultValue(t.lineColor, new e.Color(1, 1, 1, 1)))),
          (this._aspectRatio = this.#Qe()),
          (this._targetPoint = new e.Vector3(0, 0, 0)),
          (this._modelMatrix = new e.Matrix4()),
          (this._hintLine = void 0),
          (this._hintLineUpdated = !1),
          (this._cameraUpdated = !1),
          (this._depthCamera = void 0),
          (this.viewshedPass = void 0),
          (this._initialized = !1),
          (this._visible = !1),
          (this._currentFrustum = new e.Vector2()),
          (this._textureViewMatrix = new e.Matrix4()),
          (this._textureProjMatrix = new e.Matrix4()),
          (this._sceneDepthTexture = void 0),
          (this._analysisCommand = void 0),
          (this._mixDrawCommand = void 0),
          (this._resultFrameBuffer = []),
          (this._resultTextures = []),
          (this._lastResultTexture = void 0),
          (this.id = e.uuid());
      }
      get direction() {
        return this._direction;
      }
      set direction(t) {
        e.isNumber(t) &&
          ((this._direction = t),
          (this._direction =
            (this._direction >= 0 ? this._direction : (this._direction += 360)) < 360
              ? this._direction
              : (this._direction -= 360)),
          (this._cameraUpdated = !1),
          (this._hintLineUpdated = !1));
      }
      get distance() {
        return this._distance;
      }
      set distance(t) {
        e.isNumber(t) &&
          ((this._distance = t), (this._cameraUpdated = !1), (this._hintLineUpdated = !1));
      }
      get hiddenAreaColor() {
        return this._hiddenAreaColor;
      }
      set hiddenAreaColor(t) {
        (t instanceof e.Color || 'string' == typeof t) &&
          (this._hiddenAreaColor = e.Color.parse(t));
      }
      get horizontalFov() {
        return this._horizontalFov;
      }
      set horizontalFov(t) {
        e.isNumber(t) &&
          t > 0 &&
          t < 180 &&
          ((this._horizontalFov = t),
          this.#Qe(),
          (this._cameraUpdated = !1),
          (this._hintLineUpdated = !1));
      }
      get lineColor() {
        return this._lineColor;
      }
      set lineColor(t) {
        (t instanceof e.Color || 'string' == typeof t) &&
          ((this._lineColor = e.Color.parse(t)),
          e.defined(this._hintLine) &&
            (this._hintLine._material.destroy(),
            (this._hintLine._material = void 0),
            (this._hintLine._material = e.StandardMaterial.fromType('Color', {
              color: this._lineColor,
              lightingModel: e.LightingModelType.NONE,
            }))));
      }
      get pitch() {
        return this._pitch;
      }
      set pitch(t) {
        e.isNumber(t) &&
          e.isNumber(t) &&
          t >= 0 &&
          t <= 180 &&
          ((this._pitch = t), (this._cameraUpdated = !1), (this._hintLineUpdated = !1));
      }
      get verticalFov() {
        return this._verticalFov;
      }
      set verticalFov(t) {
        e.isNumber(t) &&
          t > 0 &&
          t < 180 &&
          ((this._verticalFov = t),
          this.#Qe(),
          (this._cameraUpdated = !1),
          (this._hintLineUpdated = !1));
      }
      get viewerPosition() {
        return this._viewerPosition;
      }
      set viewerPosition(t) {
        t instanceof e.Vector3 &&
          ((this._viewerPosition = t), (this._cameraUpdated = !1), (this._hintLineUpdated = !1));
      }
      get visibleAreaColor() {
        return this._visibleAreaColor;
      }
      set visibleAreaColor(t) {
        (t instanceof e.Color || 'string' == typeof t) &&
          (this._visibleAreaColor = e.Color.parse(t));
      }
      #Qe() {
        this._aspectRatio =
          Math.tan(0.5 * this._horizontalFov * e.CONSTS.CesiumMath.RADIANS_PER_DEGREE) /
          Math.tan(0.5 * this._verticalFov * e.CONSTS.CesiumMath.RADIANS_PER_DEGREE);
      }
      #Me(t) {
        e.defined(this._depthCamera) ||
          (this._depthCamera = new n(
            this._verticalFov,
            this._aspectRatio,
            0.001 * this._distance,
            this._distance,
          )),
          e.defined(this.viewshedPass) ||
            (this.viewshedPass = new km({
              camera: this._depthCamera,
              context: t.context,
              width: 2048,
              height: 2048,
              passType: e.RenderPassConsts.VIEWSHED_PASS,
            })),
          (this._initialized = !0);
      }
      setTargetPoint(t) {
        (this._distance = e.Vector3.distance(
          e.Vector3.fromDegrees(
            this._viewerPosition.x,
            this._viewerPosition.y,
            this._viewerPosition.z,
          ),
          e.Vector3.fromDegrees(t.x, t.y, t.z),
        )),
          (this._distance = this._distance < 1 ? 1 : this._distance);
        const i = new e.Vector3(),
          s = e.Transforms.eastNorthUpToFixedFrame(
            e.Vector3.fromDegrees(
              this._viewerPosition.x,
              this._viewerPosition.y,
              this._viewerPosition.z,
            ),
          );
        e.Matrix4.inverse(s, s),
          e.Matrix4.multiplyByPoint(s, e.Vector3.fromDegrees(t.x, t.y, t.z), i),
          e.Vector3.normalize(i, i),
          (this._direction = e.CONSTS.CesiumMath.toDegrees(Math.atan2(i.x, i.y))),
          (this._direction =
            (this._direction >= 0 ? this._direction : (this._direction += 360)) < 360
              ? this._direction
              : (this._direction -= 360)),
          (this.pitch = e.CONSTS.CesiumMath.toDegrees(Math.asin(i.z)) + 90);
      }
      update(t) {
        this._initialized || this.#Me(t),
          this._cameraUpdated || this.#Je(),
          this._hintLineUpdated ||
            (e.defined(this._hintLine) ||
              (this._hintLine = new e.Primitive({
                geometry: new Um(),
                material: e.StandardMaterial.fromType('Color', {
                  color: this._lineColor,
                  lightingModel: e.LightingModelType.NONE,
                }),
                name: 'Viewshed3DHintLine',
                modelMatrix: this._modelMatrix,
              })),
            this.#et(t)),
          this._visible &&
            (e.Matrix4.multiply(
              this._textureViewMatrix,
              t.transform.activeCamera.projectionMatrix,
              t.transform.activeCamera.getViewMatrix(),
            ),
            e.Matrix4.inverse(this._textureViewMatrix, this._textureViewMatrix),
            e.Matrix4.multiply(
              this._textureViewMatrix,
              this._depthCamera.getViewMatrix(),
              this._textureViewMatrix,
            ),
            e.Matrix4.clone(this._depthCamera.projectionMatrix, this._textureProjMatrix),
            this.viewshedPass.render(t));
      }
      #et(t) {
        (this._hintLine._geometry.needUpdate = !0),
          this._hintLine._geometry.updatePositions({
            horizontalFov: this._horizontalFov,
            verticalFov: this._verticalFov,
            distance: this._distance,
            modelMatrix: this._modelMatrix,
          }),
          this._hintLine.setMatrix(this._modelMatrix),
          this._hintLine.updateMatrixWorld(!0),
          (this._hintLine._modelMatrix = this._modelMatrix),
          t.transform.activeCamera.frustumCrate.cullingVolume.computeVisibility(
            this._hintLine._geometry._boundingSphere,
          ) !== e.INTERSECTION.OUTSIDE
            ? ((this._visible = !0), (this._hintLineUpdated = !0))
            : (this._visible = !1);
      }
      #Je() {
        const t = e.Transforms.headingPitchRollToFixedFrame(
            e.Vector3.fromDegrees(
              this._viewerPosition.x,
              this._viewerPosition.y,
              this._viewerPosition.z,
            ),
            new e.HeadingPitchRoll(
              e.CONSTS.CesiumMath.toRadians(this.direction),
              e.CONSTS.CesiumMath.toRadians(this.pitch),
              0,
            ),
          ),
          i =
            Math.tan(0.5 * this._horizontalFov * e.CONSTS.CesiumMath.RADIANS_PER_DEGREE) /
            Math.tan(0.5 * this._verticalFov * e.CONSTS.CesiumMath.RADIANS_PER_DEGREE);
        this._depthCamera.updatePerspectiveOptions({
          fov: this._verticalFov,
          aspect: i,
          near: 0.001 * this._distance,
          far: this.distance,
        }),
          this._depthCamera.setMatrix(t),
          (this._modelMatrix = t),
          (this._cameraUpdated = !0),
          e.defined(this.viewshedPass) && (this.viewshedPass.camera = this._depthCamera);
      }
      render(t) {
        const i = t.width,
          s = t.height;
        if (
          0 === this._resultTextures.length ||
          this._resultTextures[0].width != i ||
          this._resultTextures[0].height != s
        ) {
          (this._resultTextures = []), (this._resultFrameBuffer = []);
          const r = new e.Sampler({
            minificationFilter: e.TextureMinificationFilter.NEAREST,
            magnificationFilter: e.TextureMagnificationFilter.NEAREST,
          });
          for (let n = 0; n < 2; ++n) {
            const n = new e.Texture({
              context: t.context,
              width: i,
              height: s,
              minFilter: e.WebGLConstants.NEAREST,
              magFilter: e.WebGLConstants.NEAREST,
              pixelFormat: e.PixelFormat.RGBA,
              pixelDatatype: e.PixelDatatype.UNSIGNED_BYTE,
              sampler: r,
              anisotropy: 1,
            });
            this._resultTextures.push(n);
            const o = new e.Framebuffer({ context: t.context, colorTextures: [n] });
            this._resultFrameBuffer.push(o);
          }
        }
        const r = t.context.bindFramebuffer.get();
        t.frameState.update({ framebuffer: this._resultFrameBuffer[0] }),
          t.frameState.bindFramebuffer(t.context),
          t.context.clear({ color: e.Color.black }),
          (this._lastResultTexture = this._resultTextures[0]),
          this.#tt(this, t),
          t.frameState.update({ framebuffer: null }),
          t.frameState.bindFramebuffer(t.context),
          t.context.bindFramebuffer.set(r),
          e.defined(this._mixDrawCommand) || (this._mixDrawCommand = this.#it(this, t)),
          t.context.draw(this._mixDrawCommand),
          this._hintLine.update(t, t.frameState, { hasMixedContent: !1 }),
          t.context.draw({
            painter: t,
            framebuffer: t.mainPass.framebuffer.framebuffer,
            layer: { id: 'Viewshed3DHintLine' },
            geometry: this._hintLine._geometry,
            material: this._hintLine._material,
          });
      }
      #tt(t, i) {
        if (!this._visible) return;
        const s = this._resultFrameBuffer[1];
        i.frameState.update({ framebuffer: s }),
          i.frameState.bindFramebuffer(i.context),
          i.context.clear({ color: e.Color.black }),
          e.defined(this._analysisCommand) || (this._analysisCommand = this.#st(t, this, i)),
          (t._analysisCommand.framebuffer = s.framebuffer),
          i.context.draw(t._analysisCommand),
          (this._lastResultTexture = s._colorTextures[0]);
      }
      #st(t, i, s) {
        const r = new Map([
          [
            'u_DepthTexture',
            () =>
              s.depthPass.framebuffer
                .getColorTexture(0)
                .bind(e.WebGLConstants.LINEAR, e.WebGLConstants.CLAMP_TO_EDGE),
          ],
          ['u_ViewshedDepthTexture', () => t.viewshedPass.framebuffer.depthStencilTexture],
          ['u_textureViewMatrix', () => t._textureViewMatrix],
          ['u_textureProjMatrix', () => t._textureProjMatrix],
          ['u_farDist', () => t._distance],
          [
            'u_ModelViewProjectionMatrix',
            () =>
              new e.Matrix4().ortho({
                left: 0,
                right: s.context.drawingBufferWidth,
                bottom: s.context.drawingBufferHeight,
                top: 0,
                near: 0,
                far: 1,
              }),
          ],
          [
            'u_World',
            () => new e.Vector2(s.context.drawingBufferWidth, s.context.drawingBufferHeight),
          ],
          [
            'u_CurrentFrustum',
            () => (
              (t._currentFrustum.x = s.transform.near),
              (t._currentFrustum.y = s.transform.far),
              t._currentFrustum
            ),
          ],
        ]);
        return {
          painter: s,
          framebuffer: void 0,
          layer: { id: 'viewshedAnalysis' },
          geometry: new e.ViewportQuadGeometry(s),
          material: {
            renderState: e.RenderState.fromCache({ depthTest: { enabled: !1 }, depthMask: !1 }),
            _uniforms: r,
            _shaderSource: new e.ShaderSource({ type: 'viewshedAnalysis' }),
          },
        };
      }
      #it(t, i) {
        const s = new Map([
          ['u_resultTexture', () => t._lastResultTexture],
          ['u_visibleAreaColor', () => e.Vector4.fromColor(t._visibleAreaColor, !1)],
          ['u_hiddenAreaColor', () => e.Vector4.fromColor(t._hiddenAreaColor, !1)],
          [
            'u_ModelViewProjectionMatrix',
            () =>
              new e.Matrix4().ortho({
                left: 0,
                right: i.context.drawingBufferWidth,
                bottom: i.context.drawingBufferHeight,
                top: 0,
                near: 0,
                far: 1,
              }),
          ],
          [
            'u_World',
            () => new e.Vector2(i.context.drawingBufferWidth, i.context.drawingBufferHeight),
          ],
        ]);
        return {
          painter: i,
          framebuffer: i.mainPass.framebuffer.framebuffer,
          layer: { id: 'viewshed' },
          geometry: new e.ViewportQuadGeometry(i),
          material: {
            renderState: { blending: e.renderStateEnum.enableBlending },
            _uniforms: s,
            _shaderSource: new e.ShaderSource({ type: 'viewshedMix' }),
          },
        };
      }
      destroy() {
        return (
          (this._viewerPosition = void 0),
          (this._direction = void 0),
          (this._pitch = void 0),
          (this._horizontalFov = void 0),
          (this._verticalFov = void 0),
          (this._distance = void 0),
          (this._visibleAreaColor = void 0),
          (this._hiddenAreaColor = void 0),
          (this._aspectRatio = void 0),
          (this._targetPoint = void 0),
          (this._modelMatrix = void 0),
          this._hintLine.destroy(),
          (this._hintLine = void 0),
          (this._hintLineUpdated = void 0),
          (this._lineColor = void 0),
          (this._cameraUpdated = void 0),
          (this._depthCamera = void 0),
          this.viewshedPass.destroy(),
          (this.viewshedPass = void 0),
          (this._initialized = void 0),
          (this._visible = void 0),
          (this._textureViewMatrix = void 0),
          (this._textureProjMatrix = void 0),
          (this._sceneDepthTexture = void 0),
          (this._analysisCommand = void 0),
          (this._mixDrawCommand = void 0),
          (this._resultFrameBuffer = void 0),
          (this._resultTextures = void 0),
          (this._lastResultTexture = void 0),
          e.destroyObject(this)
        );
      }
    }
    class Hm {
      constructor(e) {
        (this._painter = e), (this._viewshed3ds = []);
      }
      get length() {
        return this._viewshed3ds.length;
      }
      add(t, i) {
        if (!(t instanceof zm))
          return console.error('The current addition is not of type Viewshed3D!'), !1;
        const s = e.defined(i);
        if (s) {
          if (i < 0) throw new Error('index must be greater than or equal to zero.');
          if (i > this._viewshed3ds.length)
            throw new Error('index must be less than or equal to the number of Viewshed3D.');
        }
        return s ? this._viewshed3ds.splice(i, 0, t) : this._viewshed3ds.push(t), !0;
      }
      getById(e) {
        let t;
        return (
          this._viewshed3ds.forEach((i) => {
            i.id === e && (t = i);
          }),
          t
        );
      }
      getByIndex(t) {
        if (e.isNumber(t) && !(t > this.length)) return this._viewshed3ds[t];
      }
      indexOf(e) {
        return this._viewshed3ds.indexOf(e);
      }
      remove(e) {
        const t = this.indexOf(e);
        return (
          -1 !== t &&
          (this._painter.style.removePrimitive(e._hintLine), this._viewshed3ds.splice(t, 1), !0)
        );
      }
      removeById(e) {
        const t = this.getById(e);
        this.remove(t);
      }
      removeByIndex(t) {
        if (e.isNumber(t)) {
          if (t < 0) throw new Error('index must be greater than or equal to zero.');
          if (t > this._viewshed3ds.length)
            throw new Error('index must be less than or equal to the number of Viewshed3D.');
          const e = this.getByIndex(t);
          this.remove(e);
        }
        return !1;
      }
      removeAll() {
        for (let e = 0; e < this.length; e++) this._viewshed3ds[e].destroy();
        this._viewshed3ds = [];
      }
      update(e) {
        for (let t = 0; t < this.length; t++) this.getByIndex(t).update(e);
      }
      serialize() {
        const t = [];
        for (let i = 0; i < this.length; i++) {
          const s = this.getByIndex(i),
            r = {
              viewerPosition: e.Vector3.pack(s.viewerPosition, new Array(3)),
              direction: s.direction,
              distance: s.distance,
              pitch: s.pitch,
              horizontalFov: s.horizontalFov,
              verticalFov: s.verticalFov,
              visibleAreaColor: e.Color.pack(s.visibleAreaColor, new Array(4)),
              hiddenAreaColor: e.Color.pack(s.hiddenAreaColor, new Array(4)),
              lineColor: e.Color.pack(s.lineColor, new Array(4)),
            };
          t.push(r);
        }
        return t.length > 0 ? t : void 0;
      }
    }
    function Wm(t) {
      return !(function (t) {
        return 'undefined' == typeof window || 'undefined' == typeof document
          ? 'not a browser'
          : Array.prototype &&
            Array.prototype.every &&
            Array.prototype.filter &&
            Array.prototype.forEach &&
            Array.prototype.indexOf &&
            Array.prototype.lastIndexOf &&
            Array.prototype.map &&
            Array.prototype.some &&
            Array.prototype.reduce &&
            Array.prototype.reduceRight &&
            Array.isArray
          ? Function.prototype && Function.prototype.bind
            ? Object.keys &&
              Object.create &&
              Object.getPrototypeOf &&
              Object.getOwnPropertyNames &&
              Object.isSealed &&
              Object.isFrozen &&
              Object.isExtensible &&
              Object.getOwnPropertyDescriptor &&
              Object.defineProperty &&
              Object.defineProperties &&
              Object.seal &&
              Object.freeze &&
              Object.preventExtensions
              ? 'JSON' in window && 'parse' in JSON && 'stringify' in JSON
                ? (function () {
                    if (!('Worker' in window && 'Blob' in window && 'URL' in window)) return !1;
                    var e,
                      t,
                      i = new Blob([''], { type: 'text/javascript' }),
                      s = URL.createObjectURL(i);
                    try {
                      (t = new Worker(s)), (e = !0);
                    } catch (t) {
                      e = !1;
                    }
                    return t && t.terminate(), URL.revokeObjectURL(s), e;
                  })()
                  ? 'Uint8ClampedArray' in window
                    ? ArrayBuffer.isView
                      ? (function () {
                          var e = document.createElement('canvas');
                          e.width = e.height = 1;
                          var t = e.getContext('2d');
                          if (!t) return !1;
                          var i = t.getImageData(0, 0, 1, 1);
                          return i && i.width === e.width;
                        })()
                        ? (void 0 === jm[(i = t && t.failIfMajorPerformanceCaveat)] &&
                            (jm[i] = (function (t) {
                              var i,
                                s = (function (e) {
                                  var t = document.createElement('canvas'),
                                    i = Object.create(Wm.webGLContextAttributes);
                                  return (
                                    (i.failIfMajorPerformanceCaveat = e),
                                    t.getContext('webgl', i) ||
                                      t.getContext('experimental-webgl', i)
                                  );
                                })(t);
                              if (!s) return !1;
                              try {
                                i = s.createShader(e.WebGLConstants.VERTEX_SHADER);
                              } catch (e) {
                                return !1;
                              }
                              return (
                                !(!i || s.isContextLost()) &&
                                (s.shaderSource(i, 'void main() {}'),
                                s.compileShader(i),
                                !0 === s.getShaderParameter(i, e.WebGLConstants.COMPILE_STATUS))
                              );
                            })(i)),
                          jm[i]
                            ? document.documentMode
                              ? 'insufficient ECMAScript 6 support'
                              : void 0
                            : 'insufficient WebGL support')
                        : 'insufficient Canvas/getImageData support'
                      : 'insufficient ArrayBuffer support'
                    : 'insufficient Uint8ClampedArray support'
                  : 'insufficient worker support'
                : 'insufficient JSON support'
              : 'insufficient Object support'
            : 'insufficient Function support'
          : 'insufficent Array support';
        var i;
      })(t);
    }
    var jm = {};
    Wm.webGLContextAttributes = { antialias: !1, alpha: !0, stencil: !0, depth: !0 };
    class qm extends e.Material {
      constructor(e) {
        super(e), this.createUniforms(e.painter), (this.cloudTime = 0);
      }
      update(e, t, i = {}) {
        super.update(e, t, i), this.cloudTime++;
      }
      createUniforms(t) {
        this._uniforms.set(
          'u_earthMap',
          () => (
            this.earthTexture.bind(e.WebGLConstants.LINEAR, e.WebGLConstants.REPEAT),
            this.earthTexture
          ),
        ),
          this._uniforms.set(
            'u_earthCloudMap',
            () => (
              this.earthCloudTexture.bind(e.WebGLConstants.LINEAR, e.WebGLConstants.REPEAT),
              this.earthCloudTexture
            ),
          ),
          this._uniforms.set(
            'u_earthNightMap',
            () => (
              this.nightTexture.bind(e.WebGLConstants.LINEAR, e.WebGLConstants.REPEAT),
              this.nightTexture
            ),
          ),
          this._uniforms.set('u_earthTime', () => this.cloudTime / 1e3),
          this._uniforms.set('u_DayTexPercent', () =>
            e.clamp(0.25 * (t.style.getNearestTileZoom() - 1), 0, 1),
          ),
          this._uniforms.set(
            'u_GlobalInnerColor',
            () => t._map.directionLightParameter.globalInnerColor,
          ),
          this._uniforms.set('u_LightPer', () => t._map.directionLightParameter.globalLightPercent),
          this._uniforms.set(
            'u_NightGlobalPer',
            () => t._map.directionLightParameter.nightGlobalPer,
          ),
          this._uniforms.set('u_NightVisible', () => t._map.directionLightParameter.nightVisible);
      }
      destroy() {}
    }
    class Xm extends e.Material {
      constructor(t) {
        super(t);
        const i = t.painter;
        (this._renderState = {
          depthTest: { enabled: !0, func: e.WebGLConstants.LESS },
          cull: { enabled: !1 },
          blending: {
            enabled: !0,
            color: { red: 0, green: 0, blue: 0, alpha: 0 },
            equationRgb: e.WebGLConstants.FUNC_ADD,
            equationAlpha: e.WebGLConstants.FUNC_ADD,
            functionSourceRgb: e.WebGLConstants.SRC_ALPHA,
            functionSourceAlpha: e.WebGLConstants.ONE,
            functionDestinationRgb: e.WebGLConstants.ONE_MINUS_SRC_ALPHA,
            functionDestinationAlpha: e.WebGLConstants.ONE_MINUS_SRC_ALPHA,
          },
        }),
          this.createUniforms(i);
      }
      update(e, t, i = {}) {
        super.update(e, t, i);
      }
      createUniforms(t) {
        this._uniforms.set(
          'u_GlobalOuterColor',
          () => t._map.directionLightParameter.globalOuterColor,
        ),
          this._uniforms.set(
            'u_GlobalOuterPara',
            () => t._map.directionLightParameter.globalOuterPara,
          ),
          this._uniforms.set('u_DayTexPercent', () =>
            e.clamp(0.25 * (t.style.getNearestTileZoom() - 1), 0, 1),
          );
      }
      destroy() {}
    }
    class Zm {
      constructor(t) {
        (this.type = 'scene-object'),
          (this.id = 'earthCrate-MinemapInternal'),
          (this.isSceneObject = !0),
          (this.visible = !0),
          (this.minzoom = t.minzoom ? t.minzoom : 0),
          (this.maxzoom = t.maxzoom ? t.maxzoom : 3),
          (t.radius = t.radius || e.CONSTS.TRANSFORM.R),
          (t.widthSegments = t.widthSegments || 128),
          (t.heightSegments = t.heightSegments || 64),
          (this.url = t.url),
          (this.cloudImageUrl = t.cloudImageUrl),
          (this.nightImageUrl = t.nightImageUrl),
          (this.cloudSpeed = t.cloudSpeed),
          (this.geometry = new Vn(t));
      }
      #rt(t) {
        if (this.url) {
          const i = new Promise((i, s) => {
              this.url
                ? e.getImage(t._transformRequest(this.url, e.ResourceType.Image), (r, n) => {
                    r && s(r);
                    const o = new e.Texture({
                      context: t.painter.context,
                      image: n,
                      pixelFormat: e.WebGLConstants.RGB,
                      useMipmap: !1,
                    });
                    o.bind(e.WebGLConstants.LINEAR, e.WebGLConstants.REPEAT),
                      (this.material.earthTexture = o),
                      i(!0);
                  })
                : i(!0);
            }),
            s = new Promise((i, s) => {
              this.cloudImageUrl
                ? e.getImage(
                    t._transformRequest(this.cloudImageUrl, e.ResourceType.Image),
                    (r, n) => {
                      r && s(r);
                      const o = new e.Texture({
                        context: t.painter.context,
                        image: n,
                        pixelFormat: e.WebGLConstants.RGBA,
                        useMipmap: !1,
                      });
                      o.bind(e.WebGLConstants.LINEAR, e.WebGLConstants.REPEAT),
                        (this.material.earthCloudTexture = o),
                        i(!0);
                    },
                  )
                : i(!0);
            }),
            r = new Promise((i, s) => {
              this.nightImageUrl
                ? e.getImage(
                    t._transformRequest(this.nightImageUrl, e.ResourceType.Image),
                    (r, n) => {
                      r && s(r);
                      const o = new e.Texture({
                        context: t.painter.context,
                        image: n,
                        pixelFormat: e.WebGLConstants.RGBA,
                        useMipmap: !1,
                      });
                      o.bind(e.WebGLConstants.LINEAR, e.WebGLConstants.REPEAT),
                        (this.material.nightTexture = o),
                        i(!0);
                    },
                  )
                : i(!0);
            });
          Promise.all([i, s, r]).then(() => {
            (this.material.defines = L_.getEarthMaterialDefinition(this.material)),
              (this._ready = !0),
              t.triggerRepaint();
          });
        } else this._ready = !0;
      }
      onAdd(t) {
        this.painter = t.painter;
        const i = this.painter._map.directionLightParameter;
        e.defined(this.cloudSpeed) && (i.globalLightPercent.y = this.cloudSpeed),
          (this.material = new qm({ type: 'sphere', painter: this.painter })),
          (this.primitive = new e.Primitive({
            material: this.material,
            geometry: this.geometry,
            modelMatrix: new e.Matrix4(),
          })),
          (this.primitive._afterRenderFunction = () => {
            this.painter.context.clear({ depth: 1, stencil: 0 });
          }),
          (this.sphereAtmosphereMaterial = new Xm({
            type: 'sphereAtmosphere',
            painter: this.painter,
          })),
          (this.sphereAtmospherePrimitive = new e.Primitive({
            material: this.sphereAtmosphereMaterial,
            geometry: this.geometry,
            modelMatrix: new e.Matrix4(),
          })),
          (this.sphereAtmospherePrimitive._afterRenderFunction = () => {
            this.painter.context.clear({ depth: 1, stencil: 0 });
          }),
          this.primitive._geometry.update({ painter: this.painter }),
          this.#rt(t);
      }
      destroy() {
        this.primitive.destroy();
      }
      setNightVisible(e) {
        this.painter._map.directionLightParameter.nightVisible = e;
      }
      loaded() {
        return this._ready;
      }
      collect() {
        if (this._ready) {
          let e = !0;
          const t = this.painter.style.getNearestTileZoom();
          return (
            t < this.minzoom && (e = !1),
            t > this.maxzoom && (e = !1),
            this.visible && e ? [this.sphereAtmospherePrimitive, this.primitive] : []
          );
        }
        return [];
      }
    }
    class $m {
      constructor(e) {
        (this.collection = []), (this._map = e);
      }
      add(e) {
        this.collection.push(e);
      }
      remove(e, t) {
        if (!t) throw new Error('请输入minemap的Map实例化对象！');
        let i = -1;
        for (let t = 0; t < this.collection.length; t++) this.collection[t].id === e && (i = t);
        return -1 != i && (this.collection[i].destroy(t), this.collection.splice(i, 1), !0);
      }
      removeAll() {
        for (let e = 0; e < this.collection.length; e++) this.collection[e].destroy(this._map);
        this.collection = [];
      }
    }
    class Km extends e.Geometry {
      constructor(e) {
        super(e), this.setData(e);
      }
      setData(t) {
        super.setData(t),
          (this.positions = t.positions),
          (this.colors = t.colors),
          (this.arcType = e.defaultValue(t.arcType, e.ARCTYPE.NONE)),
          (this.colorsPerVertex = t.colorsPerVertex),
          (this.type = 'SimplePolylineGeometry'),
          (this._usedDoublePrecision = !e.defined(t.referenceCenter)),
          this._vertexArray
            ? this._vertexArray.clear()
            : (this._vertexArray = this._usedDoublePrecision
                ? new e.StructArrayLayout3f3f24()
                : new e.StructArrayLayout3f12()),
          (this.primitiveType = e.WebGLConstants.LINE_STRIP),
          (this.perSegmentColors = e.defined(t.colors) && !this.colorsPerVertex),
          (this.granularity = e.CONSTS.CesiumMath.RADIANS_PER_DEGREE),
          (this.ellipsoid = e.Ellipsoid.WGS84),
          (this.minDistance = 2 * this.ellipsoid.maximumRadius * Math.sin(0.5 * this.granularity)),
          (this._referenceCenter = e.defaultValue(t.referenceCenter, new e.Vector3())),
          this.parse();
      }
      updateProperty(e) {
        this.setData(e);
      }
      parse() {
        let t;
        const i = this.positions.length;
        let s, r, n, o, a, l;
        this.needUpdate = !0;
        let h = 0;
        const c = e.CONSTS.CesiumMath.chordLength(this.granularity, this.ellipsoid.maximumRadius);
        if (this.arcType === e.ARCTYPE.GEODESIC || this.arcType === e.ARCTYPE.RHUMB) {
          let o;
          this.arcType === e.ARCTYPE.GEODESIC
            ? ((o = c),
              (s = e.PolylinePipeline.numberOfPoints),
              (r = e.PolylinePipeline.generateArc))
            : ((o = this.granularity),
              (s = e.PolylinePipeline.numberOfPointsRhumbLine),
              (r = e.PolylinePipeline.generateRhumbArc));
          const _ = e.PolylinePipeline.extractHeights(this.positions, this.ellipsoid),
            u = new Array(2),
            d = new Array(2),
            m = {
              positions: u,
              height: d,
              ellipsoid: void 0,
              minDistance: void 0,
              granularity: void 0,
            };
          if (
            (this.arcType === e.ARCTYPE.GEODESIC
              ? (m.minDistance = c)
              : (m.granularity = this.granularity),
            (m.ellipsoid = this.ellipsoid),
            this.perSegmentColors)
          ) {
            let r = 0;
            for (t = 0; t < i - 1; t++) r += s(this.positions[t], this.positions[t + 1], o) + 1;
            (n = new Float64Array(3 * r)),
              (a = new Uint8Array(4 * r)),
              (m.positions = u),
              (m.height = d);
            let c = 0;
            for (t = 0; t < i - 1; ++t) {
              (u[0] = this.positions[t]),
                (u[1] = this.positions[t + 1]),
                (d[0] = _[t]),
                (d[1] = _[t + 1]);
              const i = e.PolylinePipeline.generateArc(m);
              if (e.defined(this.colors)) {
                const s = i.length / 3;
                l = this.colors[t];
                for (let t = 0; t < s; ++t)
                  (a[c++] = e.Color.floatToByte(l.red)),
                    (a[c++] = e.Color.floatToByte(l.green)),
                    (a[c++] = e.Color.floatToByte(l.blue)),
                    (a[c++] = e.Color.floatToByte(l.alpha));
              }
              n.set(i, h), (h += i.length);
            }
          } else if (
            ((m.positions = this.positions),
            (m.height = _),
            (n = new Float64Array(r(m))),
            e.defined(this.colors))
          ) {
            for (a = new Uint8Array((n.length / 3) * 4), t = 0; t < i - 1; ++t)
              h = this.interpolateColors(
                this.positions[t],
                this.positions[t + 1],
                this.colors[t],
                this.colors[t + 1],
                this.minDistance,
                a,
                h,
              );
            const s = this.colors[i - 1];
            (a[h++] = e.Color.floatToByte(s.red)),
              (a[h++] = e.Color.floatToByte(s.green)),
              (a[h++] = e.Color.floatToByte(s.blue)),
              (a[h++] = e.Color.floatToByte(s.alpha));
          }
          this.vertices = n;
        } else {
          (o = this.perSegmentColors ? 2 * i - 2 : i),
            (n = new Float64Array(3 * o)),
            (a = e.defined(this.colors) ? new Uint8Array(4 * o) : void 0);
          let s = 0,
            r = 0;
          for (t = 0; t < i; ++t) {
            const o = this.positions[t];
            if (
              (this.perSegmentColors &&
                t > 0 &&
                (e.Vector3.pack(o, n, s),
                (s += 3),
                (l = this.colors[t - 1]),
                (a[r++] = e.Color.floatToByte(l.red)),
                (a[r++] = e.Color.floatToByte(l.green)),
                (a[r++] = e.Color.floatToByte(l.blue)),
                (a[r++] = e.Color.floatToByte(l.alpha))),
              this.perSegmentColors && t === i - 1)
            )
              break;
            e.Vector3.pack(o, n, s),
              (s += 3),
              e.defined(this.colors) &&
                ((l = this.colors[t]),
                (a[r++] = e.Color.floatToByte(l.red)),
                (a[r++] = e.Color.floatToByte(l.green)),
                (a[r++] = e.Color.floatToByte(l.blue)),
                (a[r++] = e.Color.floatToByte(l.alpha)));
          }
          this.vertices = n;
        }
        for (let e = 0; e < this.vertices.length / 3; e++)
          (this.vertices[3 * e] = this.vertices[3 * e] - this._referenceCenter[0]),
            (this.vertices[3 * e + 1] = this.vertices[3 * e + 1] - this._referenceCenter[1]),
            (this.vertices[3 * e + 2] = this.vertices[3 * e + 2] - this._referenceCenter[2]);
        this.computeBoundingSphere(), this.computeBoundingBox(), this.emplaceVertexBufferOfLines();
      }
      interpolateColors(t, i, s, r, n, o, a) {
        const l = e.PolylinePipeline.numberOfPoints(t, i, n);
        let h;
        const c = s.red,
          _ = s.green,
          u = s.blue,
          d = s.alpha,
          m = r.red,
          p = r.green,
          f = r.blue,
          g = r.alpha;
        if (e.Color.equals(s, r)) {
          for (h = 0; h < l; h++)
            (o[a++] = e.Color.floatToByte(c)),
              (o[a++] = e.Color.floatToByte(_)),
              (o[a++] = e.Color.floatToByte(u)),
              (o[a++] = e.Color.floatToByte(d));
          return a;
        }
        const y = (m - c) / l,
          T = (p - _) / l,
          x = (f - u) / l,
          v = (g - d) / l;
        let b = a;
        for (h = 0; h < l; h++)
          (o[b++] = e.Color.floatToByte(c + h * y)),
            (o[b++] = e.Color.floatToByte(_ + h * T)),
            (o[b++] = e.Color.floatToByte(u + h * x)),
            (o[b++] = e.Color.floatToByte(d + h * v));
        return b;
      }
      update(t) {
        if (this.needUpdate && t.painter) {
          this.needUpdate = !1;
          const i = t.painter.context;
          this._vertBuffer
            ? this._vertBuffer.updateData(this._vertexArray)
            : (this._vertBuffer = i.createVertexBuffer(
                this._vertexArray,
                this._usedDoublePrecision ? Z_.members : X_.members,
                this.dynamicDraw,
              )),
            (this._segmentVector = e.SegmentVector.simpleSegment(
              0,
              0,
              this.vertices.length / 3,
              this.vertices.length / 3 / 2,
            ));
        }
      }
      serialize() {
        const t = [];
        for (let i = 0; i < this.positions.length; i++)
          t.push(e.Vector3.pack(this.positions[i], new Array(3)));
        return { type: this.type, positions: t, arcType: this.arcType };
      }
      destroy() {
        super.destroy(),
          (this.vertices = null),
          (this.indices = null),
          (this.ellipsoid = null),
          (this.positions = null),
          (this.colors = null),
          (this.arcType = null),
          (this.colorsPerVertex = null),
          (this.type = null),
          (this._vertexArray = null),
          (this.primitiveType = null),
          (this.perSegmentColors = null),
          (this.granularity = null),
          (this.minDistance = null);
      }
    }
    class Ym {
      constructor(t) {
        (this._visibleColor = e.Color.parse(
          e.defaultValue(t.visibleColor, new e.Color(0, 1, 0, 1)),
        )),
          (this._hiddenColor = e.Color.parse(
            e.defaultValue(t.hiddenColor, new e.Color(1, 0, 0, 1)),
          )),
          (this._lineWidth = e.defaultValue(t.lineWidth, 1)),
          (this._viewerPosition = new e.Vector3(e.defaultValue(t.viewerPosition, [0, 0, 0]))),
          (this._targetPointsMap = new Map()),
          (this._targets = []),
          (this.targets = e.defaultValue(t.targets, this._targets)),
          (this._barrierPointMap = new Map()),
          (this._initialized = !1),
          (this._resultTextures = []),
          (this._mainCameraInvisibleDetection = !!t.mainCameraInvisibleDetection),
          (this._indicatorSize = e.defaultValue(t.indicatorSize, 10)),
          (this._indicatorColor = e.Color.parse(t.indicatorColor) || new e.Color(0.5, 0, 0, 1)),
          (this._indicatorOutlineColor =
            e.Color.parse(t.indicatorOutlineColor) || new e.Color(0, 0.6, 1, 0.5)),
          (this._indicatorOutlineWidth = e.defaultValue(t.indicatorOutlineWidth, 2)),
          (this.id = e.uuid());
      }
      get targets() {
        const t = [];
        return (
          this._targetPointsMap.forEach((i, s) => {
            t.push({ name: s, position: e.Vector3.pack(i.position, new Array(3)) });
          }),
          t
        );
      }
      set targets(e) {
        if (e instanceof Array) for (let t = 0; t < e.length; t++) this.addTargetPoint(e[t]);
      }
      set mainCameraInvisibleDetection(e) {
        this._mainCameraInvisibleDetection = e;
      }
      get mainCameraInvisibleDetection() {
        return this._mainCameraInvisibleDetection;
      }
      set indicatorSize(e) {
        (this._indicatorSize = e), this.#We();
      }
      get indicatorSize() {
        return this._indicatorSize;
      }
      set indicatorColor(t) {
        (this._indicatorColor = e.Color.parse(t)), this.#We();
      }
      get indicatorColor() {
        return this._indicatorColor;
      }
      set indicatorOutlineColor(t) {
        (this._indicatorOutlineColor = e.Color.parse(t)), this.#We();
      }
      get indicatorOutlineColor() {
        return this._indicatorOutlineColor;
      }
      set indicatorOutlineWidth(e) {
        (this._indicatorOutlineWidth = e), this.#We();
      }
      get indicatorOutlineWidth() {
        return this._indicatorOutlineWidth;
      }
      #We() {
        const t = e.Vector3.fromDegrees(
          this._viewerPosition.x,
          this._viewerPosition.y,
          this._viewerPosition.z,
        );
        (this.rtcModelMatrix = new e.Matrix4().translate(t)),
          (this.rtcPosition = t),
          e.defined(this._pointIndicator)
            ? (this._pointIndicator.remove(this._pointPrimitive, !0),
              (this._pointPrimitive = new va({
                show: !0,
                position: t,
                pixelSize: this._indicatorSize,
                color: this._indicatorColor,
                outlineColor: this._indicatorOutlineColor,
                outlineWidth: this._indicatorOutlineWidth,
              })),
              this._pointIndicator.add(this._pointPrimitive))
            : ((this._pointIndicator = new Sa()),
              (this._pointPrimitive = new va({
                show: !0,
                position: t,
                pixelSize: this._indicatorSize,
                color: this._indicatorColor,
                outlineColor: this._indicatorOutlineColor,
                outlineWidth: this._indicatorOutlineWidth,
              })),
              this._pointIndicator.add(this._pointPrimitive));
      }
      #Me(t) {
        this.#We();
        const i = this._targetPointsMap.values();
        for (;;) {
          const s = i.next();
          if (s.done) break;
          const r = s.value;
          if (!e.defined(r.camera)) {
            const t = e.Vector3.distance(
              e.Vector3.fromDegrees(
                this._viewerPosition.x,
                this._viewerPosition.y,
                this._viewerPosition.z,
              ),
              e.Vector3.fromDegrees(r.position.x, r.position.y, r.position.z),
            );
            (r.distance = t), (r.camera = new n(60, 1, 0.001 * t, t));
          }
          e.defined(r.viewshedPass) ||
            (r.viewshedPass = new km({
              camera: r.camera,
              context: t.context,
              width: 2048,
              height: 2048,
              passType: e.RenderPassConsts.VIEWSHED_PASS,
            }));
        }
        this._initialized = !0;
      }
      get viewerPosition() {
        return this._viewerPosition;
      }
      set viewerPosition(t) {
        this._viewerPosition = new e.Vector3(t[0], t[1], t[2]);
        const i = this._targetPointsMap.values();
        for (;;) {
          const e = i.next();
          if (e.done) break;
          e.value.needsUpdate = !0;
        }
        this.#We();
      }
      set visibleColor(t) {
        this._visibleColor = e.Color.parse(t);
      }
      get visibleColor() {
        return this._visibleColor;
      }
      set hiddenColor(t) {
        this._hiddenColor = e.Color.parse(t);
      }
      get hiddenColor() {
        return this._hiddenColor;
      }
      addTargetPoint(t) {
        if (!t.position) throw new Error('当前添加的点位数据为空', t, 'method: addTargetPoint');
        this._targetPointsMap.set(t.name, {
          name: t.name,
          position: new e.Vector3(t.position),
          needsUpdate: !0,
        }),
          (this._initialized = !1);
      }
      updateTargetPoint(e) {
        if (this._targetPointsMap.has(e.name)) {
          const t = this._targetPointsMap.get(e.name);
          (t.position = e.position), (t.needsUpdate = !0);
        }
      }
      getBarrierPoint(e) {
        return this._barrierPointMap.get(e);
      }
      removeTargetPoint(e) {
        const t = this._barrierPointMap.get(e.name);
        return (
          t?.viewshedPass?.destroy(),
          this._barrierPointMap.delete(e.name),
          this._targetPointsMap.delete(e.name)
        );
      }
      removeAllTargetPoint() {
        const e = this._targetPointsMap.values();
        for (;;) {
          const t = e.next();
          if (t.done) break;
          t.value.viewshedPass.destroy();
        }
        this._barrierPointMap.clear(), this._targetPointsMap.clear();
      }
      update(e) {
        this._initialized || this.#Me(e),
          this._targetPointsMap.forEach((t, i) => {
            this.#nt(i), t.viewshedPass.render(e);
          });
      }
      render(t) {
        const i = t.width,
          s = t.height;
        if (
          0 === this._resultTextures.length ||
          this._resultTextures[0].width != i ||
          this._resultTextures[0].height != s
        ) {
          (this._resultTextures = []), (this._resultFrameBuffer = []);
          const r = new e.Sampler({
            minificationFilter: e.TextureMinificationFilter.NEAREST,
            magnificationFilter: e.TextureMagnificationFilter.NEAREST,
          });
          for (let n = 0; n < 2; ++n) {
            const n = new e.Texture({
              context: t.context,
              width: i,
              height: s,
              minFilter: e.WebGLConstants.NEAREST,
              magFilter: e.WebGLConstants.NEAREST,
              pixelFormat: e.PixelFormat.RGBA,
              pixelDatatype: e.PixelDatatype.UNSIGNED_BYTE,
              sampler: r,
              anisotropy: 1,
            });
            this._resultTextures.push(n);
            const o = new e.Framebuffer({ context: t.context, colorTextures: [n] });
            this._resultFrameBuffer.push(o);
          }
        }
        const r = t.context.bindFramebuffer.get();
        t.frameState.update({ framebuffer: this._resultFrameBuffer[0] }),
          t.frameState.bindFramebuffer(t.context),
          t.context.clear({ color: e.Color.black }),
          (this._lastResultTexture = this._resultTextures[0]);
        const n = this._targetPointsMap.values();
        t.frameState.update({ framebuffer: this._resultFrameBuffer[1] }),
          t.frameState.bindFramebuffer(t.context),
          t.context.clear({ color: e.Color.transparent });
        let o = !1;
        for (;;) {
          const e = n.next();
          if (e.done) break;
          o = this.#tt(e.value, t) || o;
        }
        o &&
          (t.frameState.update({ framebuffer: null }),
          t.frameState.bindFramebuffer(t.context),
          t.context.bindFramebuffer.set(r),
          e.defined(this._mixDrawCommand) || (this._mixDrawCommand = this.#it(this, t)),
          t.context.draw(this._mixDrawCommand)),
          this._pointIndicator.update(t);
        const a = this._pointIndicator.getTranslucentPrimitives();
        for (let e = 0; e < a.length; e++)
          a[e].update(t, t.frameState, {}), (a[e].framebuffer = t.mainPass.framebuffer.framebuffer);
        for (let e = 0; e < a.length; e++)
          a[e].render(t, { id: 'sightline-indicator' }, t.frameState), (a[e].framebuffer = null);
      }
      #tt(t, i) {
        if (
          (e.defined(t._analysisCommand) || (t._analysisCommand = this.#st(t, i)),
          i.transform.activeCamera.frustumCrate.cullingVolume.computeVisibility(
            t._analysisCommand.geometry.boundingSphere.clone().transform(this.rtcModelMatrix),
          ) === e.INTERSECTION.OUTSIDE)
        )
          return (this._visible = !1), !1;
        const s = this._resultFrameBuffer[1];
        return (
          (t._analysisCommand.framebuffer = s.framebuffer),
          i.context.draw(t._analysisCommand),
          (this._lastResultTexture = s._colorTextures[0]),
          !0
        );
      }
      #st(t, i) {
        const s = this,
          r = new Map([
            [
              'u_DepthTexture',
              () =>
                i.depthPass.framebuffer
                  .getColorTexture(0)
                  .bind(e.WebGLConstants.LINEAR, e.WebGLConstants.CLAMP_TO_EDGE),
            ],
            ['u_ViewshedDepthTexture', () => t.viewshedPass.framebuffer.depthStencilTexture],
            ['u_HiddenColor', () => e.Vector4.fromColor(s._hiddenColor, !1)],
            ['u_VisibleColor', () => e.Vector4.fromColor(s._visibleColor, !1)],
            [
              'u_ModelViewProjectionMatrix',
              () => i.transform.activeCamera.getVPMatrix().multiplyRight(s.rtcModelMatrix),
            ],
            [
              'u_ModelViewProjectionMatrixOnViewshed',
              () => t.camera.getVPMatrix().multiplyRight(s.rtcModelMatrix),
            ],
            ['u_MainCameraDetection', () => s._mainCameraInvisibleDetection],
          ]),
          n = e.Vector3.fromDegreesArrayHeights([...this._viewerPosition, ...t.position]),
          o = new Km({
            positions: n,
            width: 10,
            arcType: e.ARCTYPE.NONE,
            referenceCenter: new e.Vector3(s.rtcPosition),
          });
        return (
          o.update({ painter: i }),
          {
            painter: i,
            framebuffer: void 0,
            layer: { id: 'sightlineAnalysis' },
            geometry: o,
            material: {
              renderState: {
                depthTest: { enabled: !1 },
                depthMask: !1,
                blending: e.renderStateEnum.enableBlending,
              },
              _uniforms: r,
              _shaderSource: new e.ShaderSource({ type: 'sightlineAnalysis' }),
            },
          }
        );
      }
      #it(t, i) {
        const s = this,
          r = new Map([
            ['u_resultTexture', () => s._lastResultTexture],
            [
              'u_ModelViewProjectionMatrix',
              () =>
                new e.Matrix4().ortho({
                  left: 0,
                  right: i.context.drawingBufferWidth,
                  bottom: i.context.drawingBufferHeight,
                  top: 0,
                  near: 0,
                  far: 1,
                }),
            ],
            [
              'u_World',
              () => new e.Vector2(i.context.drawingBufferWidth, i.context.drawingBufferHeight),
            ],
          ]);
        return {
          painter: i,
          framebuffer: i.mainPass.framebuffer.framebuffer,
          layer: { id: 'sightlineMix' },
          geometry: new e.ViewportQuadGeometry(i),
          material: {
            renderState: { blending: e.renderStateEnum.enableBlending },
            _uniforms: r,
            _shaderSource: new e.ShaderSource({ type: 'sightlineMix' }),
          },
        };
      }
      #nt(t) {
        const i = this._targetPointsMap.get(t),
          s = this.#ot(i.position),
          r = e.Vector3.fromDegrees(
            this._viewerPosition.x,
            this._viewerPosition.y,
            this._viewerPosition.z,
          ),
          n = e.Transforms.headingPitchRollToFixedFrame(
            r,
            new e.HeadingPitchRoll(
              e.CONSTS.CesiumMath.toRadians(s.x),
              e.CONSTS.CesiumMath.toRadians(s.y),
              0,
            ),
          ),
          o = e.Vector3.distance(
            r,
            e.Vector3.fromDegrees(i.position.x, i.position.y, i.position.z),
          );
        (i.distance = o),
          i.camera.updatePerspectiveOptions({ near: 0.5, far: o <= 1 ? 1 : o }),
          i.camera.setMatrix(n);
      }
      #ot(t) {
        const i = new e.Vector3(),
          s = e.Transforms.eastNorthUpToFixedFrame(
            e.Vector3.fromDegrees(
              this._viewerPosition.x,
              this._viewerPosition.y,
              this._viewerPosition.z,
            ),
          );
        e.Matrix4.inverse(s, s),
          e.Matrix4.multiplyByPoint(s, e.Vector3.fromDegrees(t.x, t.y, t.z), i),
          e.Vector3.normalize(i, i);
        let r = e.CONSTS.CesiumMath.toDegrees(Math.atan2(i.x, i.y));
        r = (r >= 0 ? r : (r += 360)) < 360 ? r : (r -= 360);
        const n = e.CONSTS.CesiumMath.toDegrees(Math.asin(i.z)) + 90;
        return new e.Vector2(r, n);
      }
      destroy() {
        this.removeAllTargetPoint(),
          this._mixDrawCommand &&
            (this._mixDrawCommand.geometry.destroy(), (this._mixDrawCommand.material = void 0)),
          this._pointIndicator.removeAll(!0);
        for (let e = 0; e < this._resultFrameBuffer.length; e++)
          this._resultFrameBuffer[e].destroy();
        this._resultFrameBuffer = [];
        for (let e = 0; e < this._resultTextures.length; e++) this._resultTextures[e].destroy();
        (this._resultTextures = []),
          (this._visibleColor = null),
          (this._hiddenColor = null),
          (this._viewerPosition = null);
      }
    }
    class Qm {
      constructor(e) {
        (this._painter = e), (this._sightlines = []);
      }
      get length() {
        return this._sightlines.length;
      }
      add(t, i) {
        if (!(t instanceof Ym))
          return console.error('The current addition is not of type Sightline!'), !1;
        const s = e.defined(i);
        if (s) {
          if (i < 0) throw new Error('index must be greater than or equal to zero.');
          if (i > this._sightlines.length)
            throw new Error('index must be less than or equal to the number of Sightline.');
        }
        return s ? this._sightlines.splice(i, 0, t) : this._sightlines.push(t), !0;
      }
      getById(e) {
        let t;
        return (
          this._sightlines.forEach((i) => {
            i.id === e && (t = i);
          }),
          t
        );
      }
      getByIndex(t) {
        if (e.isNumber(t) && !(t > this.length)) return this._sightlines[t];
      }
      indexOf(e) {
        return this._sightlines.indexOf(e);
      }
      remove(e) {
        const t = this.indexOf(e);
        return -1 !== t && (this._sightlines.splice(t, 1), e.destroy(), !0);
      }
      removeById(e) {
        const t = this.getById(e);
        this.remove(t);
      }
      removeByIndex(t) {
        if (e.isNumber(t)) {
          if (t < 0) throw new Error('index must be greater than or equal to zero.');
          if (t > this._sightlines.length)
            throw new Error('index must be less than or equal to the number of Sightline.');
          const e = this.getByIndex(t);
          this.remove(e);
        }
        return !1;
      }
      removeAll() {
        for (; this.length > 0; ) this.removeByIndex(0);
        this._sightlines = [];
      }
      update(e) {
        for (let t = 0; t < this.length; t++) this.getByIndex(t).update(e);
      }
      serialize() {
        const t = [];
        for (let i = 0; i < this.length; i++) {
          const s = this.getByIndex(i),
            r = {
              viewerPosition: e.Vector3.pack(s.viewerPosition, new Array(3)),
              targets: s.targets,
              visibleColor: e.Color.pack(s.visibleColor, new Array(4)),
              hiddenColor: e.Color.pack(s.hiddenColor, new Array(4)),
              indicatorSize: s.indicatorSize,
              indicatorColor: e.Color.pack(s.indicatorColor, new Array(4)),
              indicatorOutlineColor: e.Color.pack(s.indicatorOutlineColor, new Array(4)),
              indicatorOutlineWidth: s.indicatorOutlineWidth,
              mainCameraInvisibleDetection: s.mainCameraInvisibleDetection,
            };
          t.push(r);
        }
        return t.length > 0 ? t : void 0;
      }
    }
    class Jm extends Sm {
      constructor(t) {
        if (
          ((t = e.defined(t) ? t : {}),
          e.defined(t.validColor) &&
            !(t.validColor instanceof e.Color) &&
            'string' != typeof t.validColor)
        )
          throw new Error("'validColor' type must be Color or String!");
        const i = e.Color.parse(e.defaultValue(t.validColor, new e.Color(0, 1, 0, 1)));
        if (e.defined(t.validOpacity) && !e.isNumber(t.validOpacity))
          throw new Error("'validOpacity' option must be a number!");
        const s = e.defaultValue(t.validOpacity, 0.5);
        if (
          e.defined(t.validOutlineColor) &&
          !(t.validOutlineColor instanceof e.Color) &&
          'string' != typeof t.validOutlineColor
        )
          throw new Error("'validOutlineColor' type must be Color or String!");
        const r = e.Color.parse(e.defaultValue(t.validOutlineColor, new e.Color(0, 0, 0, 1)));
        if (e.defined(t.validOutlineOpacity) && !e.isNumber(t.validOutlineOpacity))
          throw new Error("'validOutlineOpacity' option must be a number!");
        const n = e.defaultValue(t.validOutlineOpacity, 1);
        if (
          e.defined(t.invalidColor) &&
          !(t.invalidColor instanceof e.Color) &&
          'string' != typeof t.invalidColor
        )
          throw new Error("'invalidColor' type must be Color or String!");
        if (
          ((t.color = e.Color.parse(e.defaultValue(t.invalidColor, new e.Color(1, 0, 0, 1)))),
          e.defined(t.invalidOpacity) && !e.isNumber(t.invalidOpacity))
        )
          throw new Error("'invalidOpacity' option must be a number!");
        if (
          ((t.opacity = e.defaultValue(t.invalidOpacity, 0.5)),
          e.defined(t.baseHeight) && !e.isNumber(t.baseHeight))
        )
          throw new Error("'baseHeight' must be a number");
        const o = e.defaultValue(t.baseHeight, void 0);
        if (e.defined(t.limitHeight) && !e.isNumber(t.limitHeight))
          throw new Error("'limitHeight' must be a number");
        const a = e.defaultValue(t.limitHeight, 0);
        if (e.defined(t.positions)) {
          if (!(t.positions instanceof Array)) throw new Error("'positions' is not type of Array!");
          if (0 !== t.positions.length && t.positions.length < 3)
            throw new Error("'positions' length must greater than 2!");
        }
        const l = e.defaultValue(t.positions, []);
        if (e.defined(t.extrudeValidArea) && !e.isBoolean(t.extrudeValidArea))
          throw new Error("'extrudeValidArea' option must be true or false!");
        const h = e.defaultValue(t.extrudeValidArea, !0);
        super(t),
          (this._extrudeValidArea = h),
          (this._validColor = i),
          (this._validOpacity = s),
          (this._validMaterial = e.StandardMaterial.fromType('Color', {
            color: this._validColor,
            opacity: this._validOpacity,
            lightingModel: e.LightingModelType.NONE,
            doubleSided: !0,
          })),
          (this._validGeometryUpdated = !1),
          (this._validMaterialUpdated = !1),
          (this._validOutlineColor = r),
          (this._validOutlineOpacity = n),
          (this._validOutlineMaterial = e.StandardMaterial.fromType('Color', {
            color: this._validOutlineColor,
            opacity: this._validOutlineOpacity,
            lightingModel: e.LightingModelType.NONE,
            doubleSided: !0,
          })),
          (this._validOutlineGeometryUpdated = !1),
          (this._validOutlineMaterialUpdated = !1),
          (this._baseHeight = o),
          (this._limitHeight = a),
          (this.positions = l);
      }
      get invalidColor() {
        return this._color;
      }
      set invalidColor(e) {
        this.color = e;
      }
      get invalidOpacity() {
        return this._opacity;
      }
      set invalidOpacity(e) {
        this.opacity = e;
      }
      get validColor() {
        return this._validColor;
      }
      set validColor(t) {
        if (!(t instanceof e.Color || 'string' == typeof t))
          throw new Error("'validColor' type must be Color or String!");
        (this._validColor = e.Color.parse(t)), (this._validMaterialUpdated = !1);
      }
      get validOpacity() {
        return this._validOpacity;
      }
      set validOpacity(t) {
        if (!e.isNumber(t)) throw new Error("'validOpacity' option must be a number!");
        (this._validOpacity = t), (this._validMaterialUpdated = !1);
      }
      get validOutlineColor() {
        return this._validOutlineColor;
      }
      set validOutlineColor(t) {
        if (!(t instanceof e.Color || 'string' == typeof t))
          throw new Error("'validOutlineColor' type must be Color or String!");
        (this._validOutlineColor = e.Color.parse(t)), (this._validOutlineMaterialUpdated = !1);
      }
      get validOutlineOpacity() {
        return this._validOutlineOpacity;
      }
      set validOutlineOpacity(t) {
        if (!e.isNumber(t)) throw new Error("'validOutlineOpacity' option must be a number!");
        (this._validOutlineOpacity = t), (this._validOutlineMaterialUpdated = !1);
      }
      get baseHeight() {
        return this._baseHeight;
      }
      set baseHeight(t) {
        if (e.isNumber(t))
          (this._baseHeight = t),
            (this.geometry = Jm.createInvalidArea(
              this._positions,
              this._baseHeight,
              this._limitHeight,
            )),
            this.#at();
        else {
          if (t) throw new Error('baseHeight must be a number or empty');
          if (0 === this._positions.length) this._baseHeight = void 0;
          else {
            let t = +Number.MAX_VALUE;
            for (let i = 0; i < this._positions.length; i++) {
              const s = e.Cartographic.fromVector3(this._positions[i]).height;
              t = Math.min(t, s);
            }
            this._baseHeight = t;
          }
          (this.geometry = Jm.createInvalidArea(
            this._positions,
            this._baseHeight,
            this._limitHeight,
          )),
            this.#at();
        }
      }
      get positions() {
        return this._positions;
      }
      set positions(t) {
        if (!(t instanceof Array)) throw new Error('positions is not type of Array!');
        if (0 !== t.length && t.length < 3)
          throw new Error("positions' length must greater than 2!");
        if (0 !== t.length && !this._baseHeight) {
          let i = +Number.MAX_VALUE;
          for (let s = 0; s < t.length; s++) {
            const r = e.Cartographic.fromVector3(t[s]).height;
            i = Math.min(i, r);
          }
          this._baseHeight = i;
        }
        (this._positions = t),
          (this.geometry = Jm.createInvalidArea(
            this._positions,
            this._baseHeight,
            this._limitHeight,
          )),
          this.#at();
      }
      get limitHeight() {
        return this._limitHeight;
      }
      set limitHeight(t) {
        if (!e.isNumber(t)) throw new Error('limitHeight must be a number');
        (this._limitHeight = t),
          (this.geometry = Jm.createInvalidArea(
            this._positions,
            this._baseHeight,
            this._limitHeight,
          )),
          this.#at();
      }
      get extrudeValidArea() {
        return this._extrudeValidArea;
      }
      set extrudeValidArea(t) {
        if (!e.isBoolean(t)) throw new Error("'extrudeValidArea' option must be true or false!");
        (this._extrudeValidArea = t), this.#at();
      }
      #at() {
        const { polygon: e, outline: t } = Jm.createValidArea(
          this._positions,
          this._baseHeight,
          this._limitHeight,
          this._extrudeValidArea,
        );
        (this._validGeometry = e),
          (this._validGeometryUpdated = !1),
          (this._validOutlineGeometry = t),
          (this._validOutlineGeometryUpdated = !1);
      }
      update() {
        super.update(),
          this._validArea
            ? (this._validGeometryUpdated ||
                ((this._validArea._geometry = this._validGeometry),
                (this._validGeometryUpdated = !0)),
              this._validMaterialUpdated ||
                (this._validMaterial.updateProperty({
                  color: this._validColor,
                  opacity: this._validOpacity,
                }),
                (this._validMaterialUpdated = !0)))
            : ((this._validArea = new e.Primitive({
                geometry: this._validGeometry,
                material: this._validMaterial,
              })),
              (this._validGeometryUpdated = !0),
              (this._validMaterialUpdated = !0)),
          this._validOutline
            ? (this._validOutlineGeometryUpdated ||
                ((this._validOutline._geometry = this._validOutlineGeometry),
                (this._validOutlineGeometryUpdated = !0)),
              this._validOutlineMaterialUpdated ||
                (this._validOutlineMaterial.updateProperty({
                  color: this._validOutlineColor,
                  opacity: this._validOutlineOpacity,
                }),
                (this._validOutlineMaterialUpdated = !0)))
            : ((this._validOutline = new e.Primitive({
                geometry: this._validOutlineGeometry,
                material: this._validOutlineMaterial,
              })),
              (this._validOutlineGeometryUpdated = !0),
              (this._validOutlineMaterialUpdated = !0));
      }
      render(e) {
        super.render(e),
          this._enabled &&
            ((this._validArea.framebuffer = e.mainPass.framebuffer.framebuffer),
            this._validArea.update(e, e.frameState),
            this._validArea.render(e, { id: 'validArea' }, e.frameState),
            (this._validArea.framebuffer = null),
            (this._validOutline.framebuffer = e.mainPass.framebuffer.framebuffer),
            this._validOutline.update(e, e.frameState),
            this._validOutline.render(e, { id: 'validOutline' }, e.frameState),
            (this._validOutline.framebuffer = null));
      }
      destroy() {
        super.destroy(),
          (this._positions = void 0),
          (this._baseHeight = void 0),
          (this._limitHeight = void 0),
          this._validArea && this._validArea instanceof e.Primitive
            ? this._validArea.destroy()
            : (this._validGeometry &&
                this._validGeometry instanceof e.Geometry &&
                this._validGeometry.destroy(),
              this._validMaterial &&
                this._validMaterial instanceof e.Material &&
                this._validMaterial.destroy()),
          this._validOutline && this._validOutline instanceof e.Primitive
            ? this._validOutline.destroy()
            : (this._validOutlineGeometry &&
                this._validOutlineGeometry instanceof e.Geometry &&
                this._validOutlineGeometry.destroy(),
              this._validOutlineMaterial &&
                this._validOutlineMaterial instanceof e.Material &&
                this._validOutlineMaterial.destroy()),
          (this._extrudeValidArea = void 0),
          (this._validColor = void 0),
          (this._validOpacity = void 0),
          (this._validArea = void 0),
          (this._validGeometry = void 0),
          (this._validMaterial = void 0),
          (this._validGeometryUpdated = void 0),
          (this._validMaterialUpdated = void 0),
          (this._validOutlineColor = void 0),
          (this._validOutlineOpacity = void 0),
          (this._validOutlineGeometry = void 0),
          (this._validOutlineMaterial = void 0),
          (this._validOutlineGeometryUpdated = void 0),
          (this._validOutlineMaterialUpdated = void 0);
      }
      static createValidArea(t, i, s, r = !0) {
        if (0 === t.length)
          return {
            polygon: new e.PolygonGeometry({
              polygonHierarchy: { positions: [] },
              arcType: e.ARCTYPE.GEODESIC,
            }),
            outline: new Pm({ polygonHierarchy: { positions: [] }, arcType: e.ARCTYPE.GEODESIC }),
          };
        if (r) {
          let r = [];
          for (let s = 0; s < t.length; s++) {
            const n = e.Transforms.cartesian3ToCartographic(t[s]);
            r = r.concat([n[0], n[1], i]);
          }
          return (
            (r = e.Vector3.fromDegreesArrayHeights(r)),
            {
              polygon: new e.PolygonGeometry({
                polygonHierarchy: { positions: r },
                perPositionHeight: !0,
                extrudedHeight: i + s,
                arcType: e.ARCTYPE.GEODESIC,
              }),
              outline: new Pm({
                polygonHierarchy: { positions: r },
                perPositionHeight: !0,
                extrudedHeight: i + s,
                arcType: e.ARCTYPE.GEODESIC,
              }),
            }
          );
        }
        return {
          polygon: new e.PolygonGeometry({
            polygonHierarchy: { positions: t },
            height: i + s,
            arcType: e.ARCTYPE.GEODESIC,
          }),
          outline: new Pm({
            polygonHierarchy: { positions: t },
            height: i + s,
            arcType: e.ARCTYPE.GEODESIC,
          }),
        };
      }
      static createInvalidArea(t, i, s) {
        if (0 === t.length)
          return new e.PolygonGeometry({
            polygonHierarchy: { positions: [] },
            arcType: e.ARCTYPE.GEODESIC,
          });
        let r = [];
        for (let n = 0; n < t.length; n++) {
          const o = e.Transforms.cartesian3ToCartographic(t[n]);
          r = r.concat([o[0], o[1], i + s]);
        }
        return (
          (r = e.Vector3.fromDegreesArrayHeights(r)),
          new e.PolygonGeometry({
            polygonHierarchy: { positions: r },
            perPositionHeight: !0,
            extrudedHeight: 1e4,
            arcType: e.ARCTYPE.GEODESIC,
          })
        );
      }
    }
    class ep {
      constructor(e) {
        (this._painter = e), (this._highlights = []);
      }
      get length() {
        return this._highlights.length;
      }
      add(t, i) {
        if (!(t instanceof Sm))
          return console.error('The current addition is not of type Highlight!'), !1;
        const s = e.defined(i);
        if (s) {
          if (i < 0) throw new Error('index must be greater than or equal to zero.');
          if (i > this._highlights.length)
            throw new Error('index must be less than or equal to the number of Highlight.');
        }
        return s ? this._highlights.splice(i, 0, t) : this._highlights.push(t), !0;
      }
      getById(e) {
        let t;
        return (
          this._highlights.forEach((i) => {
            i.id === e && (t = i);
          }),
          t
        );
      }
      getByIndex(t) {
        if (e.isNumber(t) && !(t > this.length)) return this._highlights[t];
      }
      indexOf(e) {
        return this._highlights.indexOf(e);
      }
      remove(e) {
        const t = this.indexOf(e);
        return -1 !== t && (this._highlights.splice(t, 1), e.destroy(), !0);
      }
      removeById(e) {
        const t = this.getById(e);
        this.remove(t);
      }
      removeByIndex(t) {
        if (e.isNumber(t)) {
          if (t < 0) throw new Error('index must be greater than or equal to zero.');
          if (t > this._highlights.length)
            throw new Error('index must be less than or equal to the number of Highlight.');
          const e = this.getByIndex(t);
          this.remove(e);
        }
        return !1;
      }
      removeAll() {
        for (; this.length > 0; ) this.removeByIndex(0);
        this._highlights = [];
      }
      update(e) {
        for (let t = 0; t < this.length; t++) this.getByIndex(t).update(e);
      }
      serialize() {
        const t = [];
        for (let i = 0; i < this.length; i++) {
          const s = this.getByIndex(i),
            r = [];
          for (let t = 0; t < s.positions.length; t++)
            r.push(e.Vector3.pack(s.positions[t], new Array(3)));
          const n = {
            positions: r,
            baseHeight: s.baseHeight,
            limitHeight: s.limitHeight,
            invalidColor: e.Color.pack(s.invalidColor, new Array(4)),
            invalidOpacity: s.invalidOpacity,
            validColor: e.Color.pack(s.validColor, new Array(4)),
            validOpacity: s.validOpacity,
            validOutlineColor: e.Color.pack(s.validOutlineColor, new Array(4)),
            validOutlineOpacity: s.validOutlineOpacity,
            extrudeValidArea: s.extrudeValidArea,
            enabled: s.enabled,
          };
          t[i] = n;
        }
        return t.length > 0 ? t : void 0;
      }
    }
    var tp = 6371008.8,
      ip = {
        centimeters: 100 * tp,
        centimetres: 100 * tp,
        degrees: tp / 111325,
        feet: 3.28084 * tp,
        inches: 39.37 * tp,
        kilometers: tp / 1e3,
        kilometres: tp / 1e3,
        meters: tp,
        metres: tp,
        miles: tp / 1609.344,
        millimeters: 1e3 * tp,
        millimetres: 1e3 * tp,
        nauticalmiles: tp / 1852,
        radians: 1,
        yards: 1.0936 * tp,
      };
    function sp(e, t, i) {
      void 0 === i && (i = {});
      var s = { type: 'Feature' };
      return (
        (0 === i.id || i.id) && (s.id = i.id),
        i.bbox && (s.bbox = i.bbox),
        (s.properties = t || {}),
        (s.geometry = e),
        s
      );
    }
    function rp(e, t, i) {
      if ((void 0 === i && (i = {}), e.length < 2))
        throw new Error('coordinates must be an array of two or more positions');
      return sp({ type: 'LineString', coordinates: e }, t, i);
    }
    function np(e, t) {
      void 0 === t && (t = 'kilometers');
      var i = ip[t];
      if (!i) throw new Error(t + ' units is invalid');
      return e * i;
    }
    function op(e) {
      return ((e % 360) * Math.PI) / 180;
    }
    function ap(e, t, i) {
      if ((void 0 === t && (t = 'kilometers'), void 0 === i && (i = 'kilometers'), !(e >= 0)))
        throw new Error('length must be a positive number');
      return np(
        (function (e, t) {
          void 0 === t && (t = 'kilometers');
          var i = ip[t];
          if (!i) throw new Error(t + ' units is invalid');
          return e / i;
        })(e, t),
        i,
      );
    }
    function lp(e) {
      return !isNaN(e) && null !== e && !Array.isArray(e);
    }
    function hp(e) {
      if (!e) throw new Error('coord is required');
      if (!Array.isArray(e)) {
        if ('Feature' === e.type && null !== e.geometry && 'Point' === e.geometry.type)
          return e.geometry.coordinates;
        if ('Point' === e.type) return e.coordinates;
      }
      if (Array.isArray(e) && e.length >= 2 && !Array.isArray(e[0]) && !Array.isArray(e[1]))
        return e;
      throw new Error('coord must be GeoJSON Point or an Array of numbers');
    }
    function cp(e, t, i) {
      if (!e) throw new Error('No feature passed');
      if (!i) throw new Error('.featureOf() requires a name');
      if (!e || 'Feature' !== e.type || !e.geometry)
        throw new Error('Invalid input to ' + i + ', Feature with geometry required');
      if (!e.geometry || e.geometry.type !== t)
        throw new Error(
          'Invalid input to ' + i + ': must be a ' + t + ', given ' + e.geometry.type,
        );
    }
    function _p(e) {
      return 'Feature' === e.type ? e.geometry : e;
    }
    function up(e, t, i) {
      void 0 === i && (i = {});
      var s = hp(e),
        r = hp(t),
        n = op(r[1] - s[1]),
        o = op(r[0] - s[0]),
        a = op(s[1]),
        l = op(r[1]),
        h = Math.pow(Math.sin(n / 2), 2) + Math.pow(Math.sin(o / 2), 2) * Math.cos(a) * Math.cos(l);
      return np(2 * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h)), i.units);
    }
    function dp(e, t, i) {
      if (null !== e)
        for (
          var s,
            r,
            n,
            o,
            a,
            l,
            h,
            c,
            _ = 0,
            u = 0,
            d = e.type,
            m = 'FeatureCollection' === d,
            p = 'Feature' === d,
            f = m ? e.features.length : 1,
            g = 0;
          g < f;
          g++
        ) {
          a = (c =
            !!(h = m ? e.features[g].geometry : p ? e.geometry : e) &&
            'GeometryCollection' === h.type)
            ? h.geometries.length
            : 1;
          for (var y = 0; y < a; y++) {
            var T = 0,
              x = 0;
            if (null !== (o = c ? h.geometries[y] : h)) {
              l = o.coordinates;
              var v = o.type;
              switch (((_ = !i || ('Polygon' !== v && 'MultiPolygon' !== v) ? 0 : 1), v)) {
                case null:
                  break;
                case 'Point':
                  if (!1 === t(l, u, g, T, x)) return !1;
                  u++, T++;
                  break;
                case 'LineString':
                case 'MultiPoint':
                  for (s = 0; s < l.length; s++) {
                    if (!1 === t(l[s], u, g, T, x)) return !1;
                    u++, 'MultiPoint' === v && T++;
                  }
                  'LineString' === v && T++;
                  break;
                case 'Polygon':
                case 'MultiLineString':
                  for (s = 0; s < l.length; s++) {
                    for (r = 0; r < l[s].length - _; r++) {
                      if (!1 === t(l[s][r], u, g, T, x)) return !1;
                      u++;
                    }
                    'MultiLineString' === v && T++, 'Polygon' === v && x++;
                  }
                  'Polygon' === v && T++;
                  break;
                case 'MultiPolygon':
                  for (s = 0; s < l.length; s++) {
                    for (x = 0, r = 0; r < l[s].length; r++) {
                      for (n = 0; n < l[s][r].length - _; n++) {
                        if (!1 === t(l[s][r][n], u, g, T, x)) return !1;
                        u++;
                      }
                      x++;
                    }
                    T++;
                  }
                  break;
                case 'GeometryCollection':
                  for (s = 0; s < o.geometries.length; s++)
                    if (!1 === dp(o.geometries[s], t, i)) return !1;
                  break;
                default:
                  throw new Error('Unknown Geometry Type');
              }
            }
          }
        }
    }
    function mp(e, t) {
      !(function (e, t) {
        !(function (e, t) {
          var i,
            s,
            r,
            n,
            o,
            a,
            l,
            h,
            c,
            _,
            u = 0,
            d = 'FeatureCollection' === e.type,
            m = 'Feature' === e.type,
            p = d ? e.features.length : 1;
          for (i = 0; i < p; i++) {
            for (
              h = d ? e.features[i].properties : m ? e.properties : {},
                c = d ? e.features[i].bbox : m ? e.bbox : void 0,
                _ = d ? e.features[i].id : m ? e.id : void 0,
                o = (l =
                  !!(a = d ? e.features[i].geometry : m ? e.geometry : e) &&
                  'GeometryCollection' === a.type)
                  ? a.geometries.length
                  : 1,
                r = 0;
              r < o;
              r++
            )
              if (null !== (n = l ? a.geometries[r] : a))
                switch (n.type) {
                  case 'Point':
                  case 'LineString':
                  case 'MultiPoint':
                  case 'Polygon':
                  case 'MultiLineString':
                  case 'MultiPolygon':
                    if (!1 === t(n, u, h, c, _)) return !1;
                    break;
                  case 'GeometryCollection':
                    for (s = 0; s < n.geometries.length; s++)
                      if (!1 === t(n.geometries[s], u, h, c, _)) return !1;
                    break;
                  default:
                    throw new Error('Unknown Geometry Type');
                }
              else if (!1 === t(null, u, h, c, _)) return !1;
            u++;
          }
        })(e, function (e, i, s, r, n) {
          var o,
            a = null === e ? null : e.type;
          switch (a) {
            case null:
            case 'Point':
            case 'LineString':
            case 'Polygon':
              return !1 !== t(sp(e, s, { bbox: r, id: n }), i, 0) && void 0;
          }
          switch (a) {
            case 'MultiPoint':
              o = 'Point';
              break;
            case 'MultiLineString':
              o = 'LineString';
              break;
            case 'MultiPolygon':
              o = 'Polygon';
          }
          for (var l = 0; l < e.coordinates.length; l++)
            if (!1 === t(sp({ type: o, coordinates: e.coordinates[l] }, s), i, l)) return !1;
        });
      })(e, function (e, i, s) {
        var r = 0;
        if (e.geometry) {
          var n = e.geometry.type;
          if ('Point' !== n && 'MultiPoint' !== n) {
            var o,
              a = 0,
              l = 0,
              h = 0;
            return (
              !1 !==
                dp(e, function (n, c, _, u, d) {
                  if (void 0 === o || i > a || u > l || d > h)
                    return (o = n), (a = i), (l = u), (h = d), void (r = 0);
                  var m = rp([o, n], e.properties);
                  if (!1 === t(m, i, s, d, r)) return !1;
                  r++, (o = n);
                }) && void 0
            );
          }
        }
      });
    }
    function pp(e, t, i) {
      if (
        (void 0 === i && (i = {}),
        i.method || (i.method = 'geodesic'),
        i.units || (i.units = 'kilometers'),
        !e)
      )
        throw new Error('pt is required');
      if (
        (Array.isArray(e)
          ? (e = (function (e, t, i) {
              if ((void 0 === i && (i = {}), !e)) throw new Error('coordinates is required');
              if (!Array.isArray(e)) throw new Error('coordinates must be an Array');
              if (e.length < 2) throw new Error('coordinates must be at least 2 numbers long');
              if (!lp(e[0]) || !lp(e[1])) throw new Error('coordinates must contain numbers');
              return sp({ type: 'Point', coordinates: e }, void 0, i);
            })(e))
          : 'Point' === e.type
          ? (e = sp(e))
          : cp(e, 'Point', 'point'),
        !t)
      )
        throw new Error('line is required');
      Array.isArray(t)
        ? (t = rp(t))
        : 'LineString' === t.type
        ? (t = sp(t))
        : cp(t, 'LineString', 'line');
      var s = 1 / 0,
        r = e.geometry.coordinates;
      return (
        mp(t, function (e) {
          var t = (function (e, t, i, s) {
            var r = [i[0] - t[0], i[1] - t[1]],
              n = fp([e[0] - t[0], e[1] - t[1]], r);
            if (n <= 0) return gp(e, t, { method: s.method, units: 'degrees' });
            var o = fp(r, r);
            if (o <= n) return gp(e, i, { method: s.method, units: 'degrees' });
            var a = n / o;
            return gp(e, [t[0] + a * r[0], t[1] + a * r[1]], {
              method: s.method,
              units: 'degrees',
            });
          })(r, e.geometry.coordinates[0], e.geometry.coordinates[1], i);
          t < s && (s = t);
        }),
        ap(s, 'degrees', i.units)
      );
    }
    function fp(e, t) {
      return e[0] * t[0] + e[1] * t[1];
    }
    function gp(e, t, i) {
      return 'planar' === i.method
        ? (function (e, t, i) {
            void 0 === i && (i = {});
            var s = hp(e),
              r = hp(t);
            return (
              (r[0] += r[0] - s[0] > 180 ? -360 : s[0] - r[0] > 180 ? 360 : 0),
              ap(
                (function (e, t, i) {
                  var s = (i = void 0 === i ? tp : Number(i)),
                    r = (e[1] * Math.PI) / 180,
                    n = (t[1] * Math.PI) / 180,
                    o = n - r,
                    a = (Math.abs(t[0] - e[0]) * Math.PI) / 180;
                  a > Math.PI && (a -= 2 * Math.PI);
                  var l = Math.log(Math.tan(n / 2 + Math.PI / 4) / Math.tan(r / 2 + Math.PI / 4)),
                    h = Math.abs(l) > 1e-11 ? o / l : Math.cos(r);
                  return Math.sqrt(o * o + h * h * a * a) * s;
                })(s, r),
                'meters',
                i.units,
              )
            );
          })(e, t, i)
        : up(e, t, i);
    }
    function yp(e, t) {
      return e.length > 1
        ? (function (e, t, i) {
            return void 0 === i && (i = {}), sp({ type: 'MultiLineString', coordinates: e }, t, i);
          })(e, t)
        : rp(e[0], t);
    }
    var Tp =
        Array.isArray ||
        function (e) {
          return '[object Array]' === Object.prototype.toString.call(e);
        },
      xp = function (e, t) {
        if (!Tp(e)) throw new Error('Coordinates must be an array');
        if (e.length < 2) throw new Error('Coordinates must be at least 2 numbers long');
        return {
          type: 'Feature',
          geometry: { type: 'Point', coordinates: e },
          properties: t || {},
        };
      },
      vp = function (e, t) {
        if (!e) throw new Error('No coordinates passed');
        return {
          type: 'Feature',
          geometry: { type: 'LineString', coordinates: e },
          properties: t || {},
        };
      };
    const bp = 'geometry的数据更新已经全面采用了setData,参数不变，方法名变更了，建议修改';
    class wp extends e.Geometry {
      constructor(e) {
        super(e), (this.type = 'BoxGeometry'), this.setData(e);
      }
      parse() {
        super.parse(),
          (this.indices = []),
          (this.vertices = []),
          (this.normals = []),
          (this.uvs = []),
          (this.needUpdate = !0),
          (this._ready = !0),
          (this.numberOfVertices = 0),
          (this.groupStart = 0),
          this.buildPlane(
            'z',
            'y',
            'x',
            -1,
            -1,
            this.depth,
            this.height,
            this.width,
            this.depthSegments,
            this.heightSegments,
            0,
          ),
          this.buildPlane(
            'z',
            'y',
            'x',
            1,
            -1,
            this.depth,
            this.height,
            -this.width,
            this.depthSegments,
            this.heightSegments,
            1,
          ),
          this.buildPlane(
            'x',
            'z',
            'y',
            1,
            1,
            this.width,
            this.depth,
            this.height,
            this.widthSegments,
            this.depthSegments,
            2,
          ),
          this.buildPlane(
            'x',
            'z',
            'y',
            1,
            -1,
            this.width,
            this.depth,
            -this.height,
            this.widthSegments,
            this.depthSegments,
            3,
          ),
          this.buildPlane(
            'x',
            'y',
            'z',
            1,
            -1,
            this.width,
            this.height,
            this.depth,
            this.widthSegments,
            this.heightSegments,
            4,
          ),
          this.buildPlane(
            'x',
            'y',
            'z',
            -1,
            -1,
            this.width,
            this.height,
            -this.depth,
            this.widthSegments,
            this.heightSegments,
            5,
          );
        for (let e = 0; e < this.indices.length; e += 3)
          this._indices.emplaceBack(this.indices[e], this.indices[e + 1], this.indices[e + 2]);
        this.emplaceVertexBufferTriangle();
      }
      buildPlane(t, i, s, r, n, o, a, l, h, c, _) {
        const u = o / h,
          d = a / c,
          m = o / 2,
          p = a / 2,
          f = l / 2,
          g = h + 1,
          y = c + 1;
        let T,
          x,
          v = 0,
          b = 0;
        const w = new e.Vector3();
        for (x = 0; x < y; x++) {
          const e = x * d - p;
          for (T = 0; T < g; T++)
            (w[t] = (T * u - m) * r),
              (w[i] = e * n),
              (w[s] = f),
              this.vertices.push(w.x, w.y, w.z),
              (w[t] = 0),
              (w[i] = 0),
              (w[s] = l > 0 ? 1 : -1),
              this.normals.push(w.x, w.y, w.z),
              this.uvs.push(T / h),
              this.uvs.push(1 - x / c),
              (v += 1);
        }
        for (x = 0; x < c; x++)
          for (T = 0; T < h; T++) {
            const e = this.numberOfVertices + T + g * (x + 1),
              t = this.numberOfVertices + (T + 1) + g * (x + 1),
              i = this.numberOfVertices + (T + 1) + g * x;
            this.indices.push(this.numberOfVertices + T + g * x, e, i),
              this.indices.push(e, t, i),
              (b += 6);
          }
        (this.groupStart += b), (this.numberOfVertices += v);
      }
      setData(t) {
        (this.width = t.width ? t.width : 1),
          (this.height = t.height ? t.height : 1),
          (this.depth = t.depth ? t.depth : 1),
          (this.widthSegments = t.widthSegments ? Math.floor(t.widthSegments) : 1),
          (this.heightSegments = t.heightSegments ? Math.floor(t.heightSegments) : 1),
          (this.depthSegments = t.depthSegments ? Math.floor(t.depthSegments) : 1),
          (this._usedDoublePrecision = !1),
          this._vertexArray
            ? (this._vertexArray.clear(), this._indices.clear())
            : ((this._vertexArray = this._usedDoublePrecision
                ? new e.StructArrayLayout11f44()
                : new e.StructArrayLayout3f2f3f32()),
              (this._indices = new e.StructArrayLayout3ui6())),
          (this._ready = !1),
          (this.primitiveType = e.WebGLConstants.TRIANGLES),
          this.parse(),
          this.computeBoundingSphere(),
          this.computeBoundingBox();
      }
      updateBoxGeometry(e) {
        console.warn(bp), this.setData(e);
      }
      update(t) {
        if (this._ready && this.needUpdate && t.painter) {
          (this._ready = !1), (this.needUpdate = !1);
          const i = t.painter.context;
          this._vertBuffer && this._indexBuffer
            ? (this._vertBuffer.updateData(this._vertexArray),
              this._indexBuffer.updateData(this._indices))
            : ((this._vertBuffer = i.createVertexBuffer(
                this._vertexArray,
                this._usedDoublePrecision ? e.layout.members : e.layout$1.members,
                this.dynamicDraw,
              )),
              (this._indexBuffer = i.createIndexBuffer(this._indices, this.dynamicDraw))),
            (this._segmentVector = e.SegmentVector.simpleSegment(
              0,
              0,
              this.vertices.length / 3,
              this.indices.length / 3,
            ));
        }
      }
      serialize() {
        return { type: this.type, width: this.width, height: this.height, depth: this.depth };
      }
      destroy() {
        super.destroy(),
          (this.width = void 0),
          (this.height = void 0),
          (this.depth = void 0),
          (this.widthSegments = void 0),
          (this.heightSegments = void 0),
          (this.depthSegments = void 0),
          (this.type = void 0),
          (this._vertexArray = void 0),
          (this._indices = void 0),
          (this._ready = void 0),
          (this.needUpdate = void 0),
          (this.primitiveType = void 0);
      }
    }
    class Cp extends e.Geometry {
      constructor(t) {
        super(t),
          (this.type = 'ConeGeometry'),
          (this.primitiveType = e.WebGLConstants.TRIANGLES),
          this.setData(t);
      }
      setData(t) {
        super.setData(t),
          (this.radiusTop = 0),
          (this.radiusBottom = t.radiusBottom ? t.radiusBottom : 0),
          (this.height = t.height ? t.height : 1),
          (this.radialSegments = Math.floor(t.radialSegments ? t.radialSegments : 8)),
          (this.heightSegments = Math.floor(t.heightSegments ? t.heightSegments : 1)),
          (this.openEnded = !!t.openEnded && t.openEnded),
          (this.thetaStart = t.thetaStart ? t.thetaStart : 0),
          (this.thetaLength = t.thetaLength ? t.thetaLength : 2 * Math.PI),
          this._vertexArray
            ? (this._vertexArray.clear(), this._indices.clear())
            : ((this._vertexArray = new e.StructArrayLayout3f2f3f32()),
              (this._indices = new e.StructArrayLayout3ui6())),
          (this._ready = !1),
          this.parse(),
          this.computeBoundingSphere(),
          this.computeBoundingBox();
      }
      parse() {
        this.#X(), (this._ready = !0), (this.needUpdate = !0);
        for (let e = 0; e < this.indices.length; e += 3)
          this._indices.emplaceBack(this.indices[e], this.indices[e + 1], this.indices[e + 2]);
        for (let e = 0; e < this.normals.length / 3; e++)
          this._vertexArray.emplaceBack(
            this.vertices[3 * e],
            this.vertices[3 * e + 1],
            this.vertices[3 * e + 2],
            this.uvs[2 * e],
            this.uvs[2 * e + 1],
            this.normals[3 * e],
            this.normals[3 * e + 1],
            this.normals[3 * e + 2],
          );
      }
      #X() {
        (this.indices = []),
          (this.vertices = []),
          (this.normals = []),
          (this.uvs = []),
          (this.index = 0),
          (this.indexArray = []),
          (this.halfHeight = this.height / 2),
          this.generateTorso(),
          !1 === this.openEnded &&
            (this.radiusTop > 0 && this.generateCap(!0),
            this.radiusBottom > 0 && this.generateCap(!1));
      }
      generateTorso() {
        const t = new e.Vector3(),
          i = new e.Vector3(),
          s = (this.radiusBottom - this.radiusTop) / this.height;
        for (let e = 0; e <= this.heightSegments; e++) {
          const r = [],
            n = e / this.heightSegments,
            o = n * (this.radiusBottom - this.radiusTop) + this.radiusTop;
          for (let e = 0; e <= this.radialSegments; e++) {
            const a = e / this.radialSegments,
              l = a * this.thetaLength + this.thetaStart,
              h = Math.sin(l),
              c = Math.cos(l);
            (i.x = o * h),
              (i.y = -n * this.height + this.halfHeight),
              (i.z = o * c),
              this.vertices.push(i.x, i.y, i.z),
              t.set(h, s, c).normalize(),
              this.normals.push(t.x, t.y, t.z),
              this.uvs.push(a, 1 - n),
              r.push(this.index++);
          }
          this.indexArray.push(r);
        }
        for (let e = 0; e < this.radialSegments; e++)
          for (let t = 0; t < this.heightSegments; t++) {
            const i = this.indexArray[t + 1][e],
              s = this.indexArray[t + 1][e + 1],
              r = this.indexArray[t][e + 1];
            this.indices.push(this.indexArray[t][e], i, r), this.indices.push(i, s, r);
          }
      }
      generateCap(t) {
        const i = this.index,
          s = new e.Vector2(),
          r = new e.Vector3(),
          n = !0 === t ? this.radiusTop : this.radiusBottom,
          o = !0 === t ? 1 : -1;
        for (let e = 1; e <= this.radialSegments; e++)
          this.vertices.push(0, this.halfHeight * o, 0),
            this.normals.push(0, o, 0),
            this.uvs.push(0.5, 0.5),
            this.index++;
        const a = this.index;
        for (let e = 0; e <= this.radialSegments; e++) {
          const t = (e / this.radialSegments) * this.thetaLength + this.thetaStart,
            i = Math.cos(t),
            a = Math.sin(t);
          (r.x = n * a),
            (r.y = this.halfHeight * o),
            (r.z = n * i),
            this.vertices.push(r.x, r.y, r.z),
            this.normals.push(0, o, 0),
            (s.x = 0.5 * i + 0.5),
            (s.y = 0.5 * a * o + 0.5),
            this.uvs.push(s.x, s.y),
            this.index++;
        }
        for (let e = 0; e < this.radialSegments; e++) {
          const s = i + e,
            r = a + e;
          !0 === t ? this.indices.push(r, r + 1, s) : this.indices.push(r + 1, r, s);
        }
      }
      updateConeGeometry(e) {
        console.warn(bp), this.setData(e);
      }
      update(t) {
        if (this._ready && this.needUpdate && t.painter) {
          this.needUpdate = !1;
          const i = t.painter.context;
          this._vertBuffer && this._indexBuffer
            ? (this._vertBuffer.updateData(this._vertexArray),
              this._indexBuffer.updateData(this._indices))
            : ((this._vertBuffer = i.createVertexBuffer(
                this._vertexArray,
                e.layout$1.members,
                this.dynamicDraw,
              )),
              (this._indexBuffer = i.createIndexBuffer(this._indices, this.dynamicDraw))),
            (this._segmentVector = e.SegmentVector.simpleSegment(
              0,
              0,
              this.vertices.length / 3,
              this.indices.length / 3,
            ));
        }
      }
      serialize() {
        return {
          type: this.type,
          radiusTop: this.radiusTop,
          radiusBottom: this.radiusBottom,
          height: this.height,
          radialSegments: this.radialSegments,
          heightSegments: this.heightSegments,
          openEnded: this.openEnded,
          thetaStart: this.thetaStart,
          thetaLength: this.thetaLength,
        };
      }
      destroy() {
        super.destroy(),
          (this._ready = void 0),
          (this.needUpdate = void 0),
          (this._vertexArray = void 0),
          (this.indices = void 0),
          (this.vertices = void 0),
          (this.uvs = void 0);
      }
    }
    class Sp extends e.Geometry {
      constructor(t) {
        super(t),
          (this.type = 'CylinderGeometry'),
          (this.primitiveType = e.WebGLConstants.TRIANGLES),
          this.setData(t);
      }
      setData(t) {
        super.setData(t),
          (this.radiusTop = t.radiusTop ? t.radiusTop : 0),
          (this.radiusBottom = t.radiusBottom ? t.radiusBottom : 0),
          (this.height = t.height ? t.height : 1),
          (this.radialSegments = Math.floor(t.radialSegments ? t.radialSegments : 8)),
          (this.heightSegments = Math.floor(t.heightSegments ? t.heightSegments : 1)),
          (this.openEnded = !!t.openEnded && t.openEnded),
          (this.thetaStart = t.thetaStart ? t.thetaStart : 0),
          (this.thetaLength = t.thetaLength ? t.thetaLength : 2 * Math.PI),
          (this._usedDoublePrecision = !1),
          this._vertexArray
            ? (this._vertexArray.clear(), this._indices.clear())
            : ((this._vertexArray = this._usedDoublePrecision
                ? new e.StructArrayLayout11f44()
                : new e.StructArrayLayout3f2f3f32()),
              (this._indices = new e.StructArrayLayout3ui6())),
          (this._ready = !1),
          this.parse(),
          this.computeBoundingSphere(),
          this.computeBoundingBox();
      }
      parse() {
        this.#X(), (this._ready = !0), (this.needUpdate = !0);
        for (let e = 0; e < this.indices.length; e += 3)
          this._indices.emplaceBack(this.indices[e], this.indices[e + 1], this.indices[e + 2]);
        this.emplaceVertexBufferTriangle();
      }
      #X() {
        (this.indices = []),
          (this.vertices = []),
          (this.normals = []),
          (this.uvs = []),
          (this.index = 0),
          (this.indexArray = []),
          (this.halfHeight = this.height / 2),
          this.generateTorso(),
          !1 === this.openEnded &&
            (this.radiusTop > 0 && this.generateCap(!0),
            this.radiusBottom > 0 && this.generateCap(!1));
      }
      generateTorso() {
        const t = new e.Vector3(),
          i = new e.Vector3(),
          s = (this.radiusBottom - this.radiusTop) / this.height;
        for (let e = 0; e <= this.heightSegments; e++) {
          const r = [],
            n = e / this.heightSegments,
            o = n * (this.radiusBottom - this.radiusTop) + this.radiusTop;
          for (let e = 0; e <= this.radialSegments; e++) {
            const a = e / this.radialSegments,
              l = a * this.thetaLength + this.thetaStart,
              h = Math.sin(l),
              c = Math.cos(l);
            (i.x = o * h),
              (i.y = -n * this.height + this.halfHeight),
              (i.z = o * c),
              this.vertices.push(i.x, i.y, i.z),
              t.set(h, s, c).normalize(),
              this.normals.push(t.x, t.y, t.z),
              this.uvs.push(a, 1 - n),
              r.push(this.index++);
          }
          this.indexArray.push(r);
        }
        for (let e = 0; e < this.radialSegments; e++)
          for (let t = 0; t < this.heightSegments; t++) {
            const i = this.indexArray[t + 1][e],
              s = this.indexArray[t + 1][e + 1],
              r = this.indexArray[t][e + 1];
            this.indices.push(this.indexArray[t][e], i, r), this.indices.push(i, s, r);
          }
      }
      generateCap(t) {
        const i = this.index,
          s = new e.Vector2(),
          r = new e.Vector3(),
          n = !0 === t ? this.radiusTop : this.radiusBottom,
          o = !0 === t ? 1 : -1;
        for (let e = 1; e <= this.radialSegments; e++)
          this.vertices.push(0, this.halfHeight * o, 0),
            this.normals.push(0, o, 0),
            this.uvs.push(0.5, 0.5),
            this.index++;
        const a = this.index;
        for (let e = 0; e <= this.radialSegments; e++) {
          const t = (e / this.radialSegments) * this.thetaLength + this.thetaStart,
            i = Math.cos(t),
            a = Math.sin(t);
          (r.x = n * a),
            (r.y = this.halfHeight * o),
            (r.z = n * i),
            this.vertices.push(r.x, r.y, r.z),
            this.normals.push(0, o, 0),
            (s.x = 0.5 * i + 0.5),
            (s.y = 0.5 * a * o + 0.5),
            this.uvs.push(s.x, s.y),
            this.index++;
        }
        for (let e = 0; e < this.radialSegments; e++) {
          const s = i + e,
            r = a + e;
          !0 === t ? this.indices.push(r, r + 1, s) : this.indices.push(r + 1, r, s);
        }
      }
      update(t) {
        if (this._ready && this.needUpdate && t.painter) {
          this.needUpdate = !1;
          const i = t.painter.context;
          this._vertBuffer && this._indexBuffer
            ? (this._vertBuffer.updateData(this._vertexArray),
              this._indexBuffer.updateData(this._indices))
            : ((this._vertBuffer = i.createVertexBuffer(
                this._vertexArray,
                this._usedDoublePrecision ? e.layout.members : e.layout$1.members,
                this.dynamicDraw,
              )),
              (this._indexBuffer = i.createIndexBuffer(this._indices, this.dynamicDraw))),
            (this._segmentVector = e.SegmentVector.simpleSegment(
              0,
              0,
              this.vertices.length / 3,
              this.indices.length / 3,
            ));
        }
      }
      serialize() {
        return {
          type: this.type,
          radiusTop: this.radiusTop,
          radiusBottom: this.radiusBottom,
          height: this.height,
          radialSegments: this.radialSegments,
          heightSegments: this.heightSegments,
          openEnded: this.openEnded,
          thetaStart: this.thetaStart,
          thetaLength: this.thetaLength,
        };
      }
      destroy() {
        super.destroy(),
          (this._ready = !1),
          (this.needUpdate = !1),
          (this.indices = null),
          (this.vertices = null),
          (this.uvs = null),
          (this.vertices = null);
      }
    }
    class Ep extends e.Geometry {
      constructor(t) {
        super(),
          (this.primitiveType = e.WebGLConstants.TRIANGLES),
          (this.type = 'FenceGeometry'),
          this.setData(t);
      }
      setData(t) {
        if ((super.setData(t), !e.defined(t.positions)))
          throw new Error('options.positions is required.');
        if (e.defined(t.maximumHeights) && t.maximumHeights.length !== t.positions.length)
          throw new Error(
            'options.positions and options.maximumHeights must have the same length.',
          );
        if (e.defined(t.minimumHeights) && t.minimumHeights.length !== t.positions.length)
          throw new Error(
            'options.positions and options.minimumHeights must have the same length.',
          );
        (this._positions = t.positions),
          (this._maximumHeights = t.maximumHeights),
          (this._minimumHeights = t.minimumHeights),
          (this._granularity = e.defaultValue(
            t.granularity,
            e.CONSTS.CesiumMath.RADIANS_PER_DEGREE,
          )),
          (this._ellipsoid = e.defaultValue(t.ellipsoid, e.Ellipsoid.WGS84)),
          (this.vertices = void 0),
          (this.indices = void 0),
          (this.normals = void 0),
          (this.uvs = void 0),
          (this._needUpdate = !0),
          (this._usedDoublePrecision = !1),
          this._vertexArray
            ? (this._vertexArray.clear(), this._indices.clear())
            : ((this._vertexArray = this._usedDoublePrecision
                ? new e.StructArrayLayout11f44()
                : new e.StructArrayLayout3f2f3f32()),
              (this._indices = new e.StructArrayLayout3ui6())),
          this.#v(),
          this.computeBoundingSphere(),
          this.computeBoundingBox();
      }
      static fromConstantHeights(t) {
        const i = t.positions;
        if (!e.defined(i)) throw new Error('options.positions is required.');
        let s, r;
        const n = t.minimumHeight,
          o = t.maximumHeight,
          a = e.defined(n),
          l = e.defined(o);
        if (a || l) {
          const e = i.length;
          (s = a ? new Array(e) : void 0), (r = l ? new Array(e) : void 0);
          for (let t = 0; t < e; ++t) a && (s[t] = n), l && (r[t] = o);
        }
        return new Ep({ positions: i, maximumHeights: r, minimumHeights: s });
      }
      #v() {
        const t = new e.Vector3(),
          i = new e.Vector3(),
          s = new e.Vector3(),
          r = new e.Vector3(),
          n = this._ellipsoid,
          o = Im.computePositions(
            n,
            this._positions,
            this._maximumHeights,
            this._minimumHeights,
            this._granularity,
            !0,
          );
        if (!e.defined(o)) return;
        const a = o.bottomPositions,
          l = o.topPositions,
          h = o.numCorners;
        let c = l.length,
          _ = 2 * c,
          u = 0;
        for (let t = 0; t < c / 3; t++)
          u = Math.max(
            u,
            e.Vector3.distance(e.Vector3.fromArray(l, 3 * t), e.Vector3.fromArray(a, 3 * t)),
          );
        const d = new Float64Array(_),
          m = new Float32Array(_),
          p = new Float32Array((_ / 3) * 2);
        let f,
          g = 0,
          y = 0,
          T = 0,
          x = new e.Vector3(),
          v = !0;
        c /= 3;
        let b = 0;
        const w = 1 / (c - h - 1);
        for (f = 0; f < c; ++f) {
          const o = 3 * f,
            h = e.Vector3.fromArray(l, o, t),
            _ = e.Vector3.fromArray(a, o, i);
          (d[g++] = _.x),
            (d[g++] = _.y),
            (d[g++] = _.z),
            (d[g++] = h.x),
            (d[g++] = h.y),
            (d[g++] = h.z),
            (p[T++] = b),
            (p[T++] = 0),
            (p[T++] = b),
            (p[T++] = e.Vector3.distance(h, _) / u);
          let C = e.Vector3.clone(e.Vector3.ZERO, r);
          const S = e.Vector3.subtract(h, n.geodeticSurfaceNormal(h, i), i);
          if ((f + 1 < c && (C = e.Vector3.fromArray(l, o + 3, r)), v)) {
            const i = e.Vector3.subtract(C, h, s),
              r = e.Vector3.subtract(S, h, t);
            (x = e.Vector3.normalize(e.Vector3.cross(r, i, x), x)), (v = !1);
          }
          e.Vector3.equalsEpsilon(h, C, e.CONSTS.CesiumMath.EPSILON10) ? (v = !0) : (b += w),
            (m[y++] = x.x),
            (m[y++] = x.y),
            (m[y++] = x.z),
            (m[y++] = x.x),
            (m[y++] = x.y),
            (m[y++] = x.z);
        }
        const C = _ / 3;
        _ -= 6 * (h + 1);
        const S = new Uint16Array(_);
        let E = 0;
        for (f = 0; f < C - 2; f += 2) {
          const s = f,
            r = f + 2,
            n = e.Vector3.fromArray(d, 3 * s, t),
            o = e.Vector3.fromArray(d, 3 * r, i);
          if (e.Vector3.equalsEpsilon(n, o, e.CONSTS.CesiumMath.EPSILON10)) continue;
          const a = f + 1,
            l = f + 3;
          (S[E++] = s), (S[E++] = a), (S[E++] = l), (S[E++] = s), (S[E++] = l), (S[E++] = r);
        }
        (this.vertices = d), (this.indices = S), (this.normals = m), (this.uvs = p);
        for (let e = 0; e < S.length; e += 3) this._indices.emplaceBack(S[e], S[e + 1], S[e + 2]);
        const P = new e.Vector3();
        for (let t = 0; t < this.vertices.length; t += 3)
          e.Vector3.fromArray(this.vertices, t, P),
            (this.vertices[t] = P.x),
            (this.vertices[t + 1] = P.y),
            (this.vertices[t + 2] = P.z);
        this.emplaceVertexBufferTriangle();
      }
      update(t) {
        if (this._needUpdate && t.painter) {
          const i = t.painter.context;
          this._vertBuffer && this._indexBuffer
            ? (this._vertBuffer.updateData(this._vertexArray),
              this._indexBuffer.updateData(this._indices))
            : ((this._vertBuffer = i.createVertexBuffer(
                this._vertexArray,
                this._usedDoublePrecision ? e.layout.members : e.layout$1.members,
                this.dynamicDraw,
              )),
              (this._indexBuffer = i.createIndexBuffer(this._indices, this.dynamicDraw))),
            (this._segmentVector = e.SegmentVector.simpleSegment(
              0,
              0,
              this.vertices.length / 3,
              this.indices.length / 3,
            )),
            (this._needUpdate = !1);
        }
      }
      serialize() {
        const t = [];
        for (let i = 0; i < this._positions.length; i++)
          t.push(e.Vector3.pack(this._positions[i], new Array(3)));
        return {
          type: this.type,
          positions: t,
          maximumHeights: this._maximumHeights,
          minimumHeights: this._minimumHeights,
        };
      }
      destroy() {
        return (
          super.destroy(),
          (this._vertBuffer = void 0),
          (this._indexBuffer = void 0),
          (this._segmentVector = void 0),
          (this._needUpdate = void 0),
          (this._positions = void 0),
          (this._maximumHeights = void 0),
          (this._minimumHeights = void 0),
          (this._granularity = void 0),
          (this._ellipsoid = void 0),
          (this.vertices = void 0),
          (this.indices = void 0),
          (this.normals = void 0),
          (this.uvs = void 0),
          (this._vertexArray = void 0),
          (this._indices = void 0),
          (this.primitiveType = void 0),
          (this.type = void 0),
          this._segmentVector?.destroy(),
          (this._segmentVector = void 0),
          e.destroyObject(this)
        );
      }
    }
    class Pp extends e.Geometry {
      constructor(e) {
        super(e), this.setData(e);
      }
      setData(t) {
        if ((super.setData(t), !t.positions)) throw new Error('gradient color 数据为空');
        (this.vertices = t.positions.flat()),
          (this.uvs = t.values),
          (this.index = t.index),
          (this.type = 'GradientColorBoxGeometry'),
          (this._usedDoublePrecision = !1),
          this._vertexArray
            ? (this._vertexArray.clear(), this._indices.clear())
            : ((this._vertexArray = this._usedDoublePrecision
                ? new e.StructArrayLayout11f44()
                : new e.StructArrayLayout3f2f3f32()),
              (this._indices = new e.StructArrayLayout3ui6())),
          (this._needUpdate = !0),
          (this.primitiveType = e.WebGLConstants.TRIANGLES),
          this.parse();
      }
      updateProperty(e) {
        this.setData(e);
      }
      updateGradientColorBoxGeometry(e) {
        console.warn('geometry的数据更新已经全面采用了setData,参数不变，方法名变更了！'),
          this.setData(e);
      }
      parse() {
        for (let e = 0; e < this.index.length; e += 3)
          this._indices.emplaceBack(this.index[e], this.index[e + 1], this.index[e + 2]);
        if (this._usedDoublePrecision) {
          let t, i, s;
          for (let r = 0; r < this.vertices.length; r += 3)
            (t = e.EncodedVector3.encode(this.vertices[r])),
              (i = e.EncodedVector3.encode(this.vertices[r + 1])),
              (s = e.EncodedVector3.encode(this.vertices[r + 2])),
              this._vertexArray.emplaceBack(
                t.high,
                i.high,
                s.high,
                t.low,
                i.low,
                s.low,
                this.uvs[r / 3],
                0,
                0,
                0,
                0,
              );
        } else for (let e = 0; e < this.vertices.length; e += 3) this._vertexArray.emplaceBack(this.vertices[e], this.vertices[e + 1], this.vertices[e + 2], this.uvs[e / 3], 0, 0, 0, 0);
      }
      update(t) {
        if (this._needUpdate && t.painter) {
          const i = t.painter.context;
          this._vertBuffer && this._indexBuffer
            ? (this._vertBuffer.updateData(this._vertexArray),
              this._indexBuffer.updateData(this._indices))
            : ((this._vertBuffer = i.createVertexBuffer(
                this._vertexArray,
                this._usedDoublePrecision ? e.layout.members : e.layout$1.members,
                this.dynamicDraw,
              )),
              (this._indexBuffer = i.createIndexBuffer(this._indices, this.dynamicDraw))),
            (this._segmentVector = e.SegmentVector.simpleSegment(
              0,
              0,
              this.vertices.length / 3,
              this.index.length / 3,
            )),
            (this._needUpdate = !1);
        }
      }
      serialize() {
        return { type: this.type, positions: this.vertices, index: this.index, values: this.uvs };
      }
      destroy() {
        return (
          super.destroy(),
          (this.vertices = void 0),
          (this.uvs = void 0),
          (this.index = void 0),
          (this._vertexArray = void 0),
          (this._indices = void 0),
          (this._needUpdate = !1),
          e.destroyObject(this)
        );
      }
    }
    class Mp extends e.Geometry {
      constructor(t) {
        super(t),
          (this.type = 'PlaneGeometry'),
          (this.primitiveType = e.WebGLConstants.TRIANGLES),
          this.setData(t);
      }
      setData(t) {
        if ((super.setData(t), !e.defined(t.position)))
          throw new Error('options.position is required.');
        if (!e.defined(t.normal)) throw new Error('options.normal is required.');
        if (!e.defined(t.dimensions)) throw new Error('options.dimensions is required.');
        (this._origin = t.position),
          (this._normal = t.normal),
          (this._distance = e.defaultValue(t.distance, 0)),
          (this._dimensions = t.dimensions),
          (this._modelMatrix = void 0),
          (this.vertices = new Float64Array(12)),
          (this.normals = new Float32Array(12)),
          (this.indices = new Uint16Array(6)),
          (this.uvs = new Float32Array(8)),
          this._vertexArray
            ? (this._vertexArray.clear(), this._indices.clear())
            : ((this._vertexArray = new e.StructArrayLayout11f44()),
              (this._indices = new e.StructArrayLayout3ui6())),
          (this.needUpdate = !0),
          (this._usedDoublePrecision = !0),
          this.#v(),
          this.computeBoundingSphere(),
          this.computeBoundingBox();
      }
      updateProperty(e) {
        console.warn('geometry的数据更新已经全面采用了setData,参数不变，方法名变更了！'),
          this.setData(e);
      }
      #v() {
        this.#lt(), this.#ht(), this.#ct(), this.#_t(), this.#pe(), this.#ut(), this.#X();
      }
      #lt() {
        const t = new e.Vector3(),
          i = new e.Vector3(),
          s = new e.Vector3(),
          r = new e.Vector3(),
          n = new e.Matrix3(),
          o = new e.Matrix4(),
          a = this._normal,
          l = e.Vector3.multiplyByScalar(a, -this._distance, s);
        let h = e.Vector3.clone(e.Vector3.UNIT_Z, i);
        e.CONSTS.CesiumMath.equalsEpsilon(
          Math.abs(e.Vector3.dot(h, a)),
          1,
          e.CONSTS.CesiumMath.EPSILON8,
        ) && (h = e.Vector3.clone(e.Vector3.UNIT_Y, h));
        const c = e.Vector3.cross(h, a, t);
        (h = e.Vector3.cross(a, c, h)), e.Vector3.normalize(c, c), e.Vector3.normalize(h, h);
        const _ = new e.Matrix3();
        e.Matrix3.setColumn(_, 0, c, _),
          e.Matrix3.setColumn(_, 1, h, _),
          e.Matrix3.setColumn(_, 2, a, _);
        const u = e.Vector3.fromElements(this._dimensions.x, this._dimensions.y, 1, r),
          d = e.Matrix3.multiplyByScale(_, u, n),
          m = e.Matrix4.fromRotationTranslation(d, l, o);
        (this._modelMatrix = e.Transforms.eastNorthUpToFixedFrame(this._origin, void 0)),
          e.Matrix4.multiplyTransformation(this._modelMatrix, m, this._modelMatrix);
      }
      #ht() {
        const t = new e.Vector3(-0.5, -0.5, 0),
          i = new e.Vector3(0.5, 0.5, 0);
        (this.vertices[0] = t.x),
          (this.vertices[1] = t.y),
          (this.vertices[2] = 0),
          (this.vertices[3] = i.x),
          (this.vertices[4] = t.y),
          (this.vertices[5] = 0),
          (this.vertices[6] = i.x),
          (this.vertices[7] = i.y),
          (this.vertices[8] = 0),
          (this.vertices[9] = t.x),
          (this.vertices[10] = i.y),
          (this.vertices[11] = 0);
      }
      #ct() {
        (this.normals[0] = 0),
          (this.normals[1] = 0),
          (this.normals[2] = 1),
          (this.normals[3] = 0),
          (this.normals[4] = 0),
          (this.normals[5] = 1),
          (this.normals[6] = 0),
          (this.normals[7] = 0),
          (this.normals[8] = 1),
          (this.normals[9] = 0),
          (this.normals[10] = 0),
          (this.normals[11] = 1);
      }
      #_t() {
        (this.uvs[0] = 0),
          (this.uvs[1] = 0),
          (this.uvs[2] = 1),
          (this.uvs[3] = 0),
          (this.uvs[4] = 1),
          (this.uvs[5] = 1),
          (this.uvs[6] = 0),
          (this.uvs[7] = 1);
      }
      #pe() {
        (this.indices[0] = 0),
          (this.indices[1] = 1),
          (this.indices[2] = 2),
          (this.indices[3] = 0),
          (this.indices[4] = 2),
          (this.indices[5] = 3);
      }
      #ut() {
        let t = new e.Vector3(),
          i = this.vertices.length;
        for (let s = 0; s < i; s += 3)
          e.Vector3.unpack(this.vertices, s, t),
            e.Matrix4.multiplyByPoint(this._modelMatrix, t, t),
            e.Vector3.pack(t, this.vertices, s);
        const s = new e.Matrix4(),
          r = new e.Matrix3();
        e.Matrix4.inverse(this._modelMatrix, s),
          e.Matrix4.transpose(s, s),
          e.Matrix4.getMatrix3(s, r),
          (i = this.normals.length);
        for (let s = 0; s < i; s += 3)
          e.Vector3.unpack(this.normals, s, t),
            e.Matrix3.multiplyByVector(r, t, t),
            (t = e.Vector3.normalize(t, t)),
            e.Vector3.pack(t, this.normals, s);
      }
      #X() {
        for (let e = 0; e < this.indices.length; e += 3)
          this._indices.emplaceBack(this.indices[e], this.indices[e + 2], this.indices[e + 1]);
        this.emplaceVertexBufferTriangle();
      }
      update(t) {
        if (this.needUpdate && t.painter) {
          this.needUpdate = !1;
          const i = t.painter.context;
          this._vertBuffer && this._indexBuffer
            ? (this._vertBuffer.updateData(this._vertexArray),
              this._indexBuffer.updateData(this._indices))
            : ((this._vertBuffer = i.createVertexBuffer(
                this._vertexArray,
                e.layout.members,
                this.dynamicDraw,
              )),
              (this._indexBuffer = i.createIndexBuffer(this._indices, this.dynamicDraw))),
            (this._segmentVector = e.SegmentVector.simpleSegment(
              0,
              0,
              this.vertices.length / 3,
              this.indices.length / 3,
            ));
        }
      }
      serialize() {
        return {
          type: this.type,
          position: e.Vector3.pack(this._origin, new Array(3)),
          normal: e.Vector3.pack(this._normal, new Array(3)),
          distance: this._distance,
          dimensions: e.Vector2.pack(this._dimensions, new Array(2)),
        };
      }
      destroy() {
        return (
          super.destroy(),
          (this._origin = void 0),
          (this._dimensions = void 0),
          (this._distance = void 0),
          (this._normal = void 0),
          (this._modelMatrix = void 0),
          (this.vertices = void 0),
          (this.normals = void 0),
          (this.indices = void 0),
          (this.uvs = void 0),
          (this.type = void 0),
          (this.primitiveType = void 0),
          (this._vertexArray = void 0),
          (this._indices = void 0),
          (this.needUpdate = void 0),
          (this._segmentVector = void 0),
          e.destroyObject(this)
        );
      }
    }
    class Ap extends e.Geometry {
      constructor(t) {
        super(t),
          (this.type = 'PlaneOutlineGeometry'),
          (this.primitiveType = e.WebGLConstants.LINE_LOOP),
          this.setData(t);
      }
      setData(t) {
        if ((super.setData(t), !e.defined(t.position)))
          throw new Error('options.position is required.');
        if (!e.defined(t.normal)) throw new Error('options.normal is required.');
        if (!e.defined(t.dimensions)) throw new Error('options.dimensions is required.');
        (this._origin = t.position),
          (this._dimensions = t.dimensions),
          (this._normal = t.normal),
          (this._distance = e.defaultValue(t.distance, 0)),
          (this._modelMatrix = void 0),
          (this.vertices = new Float64Array(12)),
          (this.indices = new Uint16Array(6)),
          this._vertexArray
            ? (this._vertexArray.clear(), this._indices.clear())
            : ((this._vertexArray = new e.StructArrayLayout3f3f24()),
              (this._indices = new e.StructArrayLayout2ui4())),
          (this.needUpdate = !0),
          (this._usedDoublePrecision = !0),
          this.parse(),
          this.computeBoundingSphere(),
          this.computeBoundingBox();
      }
      parse() {
        this.#lt(), this.#ht(), this.#pe(), this.#ut(), this.#X();
      }
      #lt() {
        const t = new e.Vector3(),
          i = new e.Vector3(),
          s = new e.Vector3(),
          r = new e.Vector3(),
          n = new e.Matrix3(),
          o = new e.Matrix4(),
          a = this._normal,
          l = e.Vector3.multiplyByScalar(a, -this._distance, s);
        let h = e.Vector3.clone(e.Vector3.UNIT_Z, i);
        e.CONSTS.CesiumMath.equalsEpsilon(
          Math.abs(e.Vector3.dot(h, a)),
          1,
          e.CONSTS.CesiumMath.EPSILON8,
        ) && (h = e.Vector3.clone(e.Vector3.UNIT_Y, h));
        const c = e.Vector3.cross(h, a, t);
        (h = e.Vector3.cross(a, c, h)), e.Vector3.normalize(c, c), e.Vector3.normalize(h, h);
        const _ = new e.Matrix3();
        e.Matrix3.setColumn(_, 0, c, _),
          e.Matrix3.setColumn(_, 1, h, _),
          e.Matrix3.setColumn(_, 2, a, _);
        const u = e.Vector3.fromElements(this._dimensions.x, this._dimensions.y, 1, r),
          d = e.Matrix3.multiplyByScale(_, u, n),
          m = e.Matrix4.fromRotationTranslation(d, l, o);
        (this._modelMatrix = e.Transforms.eastNorthUpToFixedFrame(this._origin, void 0)),
          e.Matrix4.multiplyTransformation(this._modelMatrix, m, this._modelMatrix);
      }
      #ht() {
        const t = new e.Vector3(-0.5, -0.5, 0),
          i = new e.Vector3(0.5, 0.5, 0);
        (this.vertices[0] = t.x),
          (this.vertices[1] = t.y),
          (this.vertices[2] = t.z),
          (this.vertices[3] = i.x),
          (this.vertices[4] = t.y),
          (this.vertices[5] = t.z),
          (this.vertices[6] = i.x),
          (this.vertices[7] = i.y),
          (this.vertices[8] = t.z),
          (this.vertices[9] = t.x),
          (this.vertices[10] = i.y),
          (this.vertices[11] = t.z);
      }
      #pe() {
        (this.indices[0] = 0),
          (this.indices[1] = 1),
          (this.indices[2] = 1),
          (this.indices[3] = 2),
          (this.indices[4] = 2),
          (this.indices[5] = 3),
          (this.indices[6] = 3),
          (this.indices[7] = 0);
      }
      #ut() {
        const t = new e.Vector3(),
          i = this.vertices.length;
        for (let s = 0; s < i; s += 3)
          e.Vector3.unpack(this.vertices, s, t),
            e.Matrix4.multiplyByPoint(this._modelMatrix, t, t),
            e.Vector3.pack(t, this.vertices, s);
      }
      #X() {
        this.emplaceVertexBufferOfLines();
        for (let e = 0; e < this.indices.length / 2; e++)
          this._indices.emplaceBack(this.indices[2 * e], this.indices[2 * e + 1]);
      }
      update(t) {
        if (this.needUpdate && t.painter) {
          this.needUpdate = !1;
          const i = t.painter.context;
          this._vertBuffer && this._indexBuffer
            ? (this._vertBuffer.updateData(this._vertexArray),
              this._indexBuffer.updateData(this._indices))
            : ((this._vertBuffer = i.createVertexBuffer(
                this._vertexArray,
                Z_.members,
                this.dynamicDraw,
              )),
              (this._indexBuffer = i.createIndexBuffer(this._indices, this.dynamicDraw))),
            (this._segmentVector = e.SegmentVector.simpleSegment(
              0,
              0,
              this.vertices.length / 3,
              this.indices.length / 2,
            ));
        }
      }
      serialize() {
        return {
          type: this.type,
          position: e.Vector3.pack(this._origin, new Array(3)),
          normal: e.Vector3.pack(this._normal, new Array(3)),
          distance: this._distance,
          dimensions: e.Vector2.pack(this._dimensions, new Array(2)),
        };
      }
      destroy() {
        return (
          super.destroy(),
          (this._origin = void 0),
          (this._dimensions = void 0),
          (this._normal = void 0),
          (this._distance = void 0),
          (this._modelMatrix = void 0),
          (this.vertices = void 0),
          (this.indices = void 0),
          (this.type = void 0),
          (this._vertexArray = void 0),
          (this._indices = void 0),
          (this.primitiveType = void 0),
          (this.needUpdate = void 0),
          this._segmentVector?.destroy(),
          (this._segmentVector = void 0),
          e.destroyObject(this)
        );
      }
    }
    class Rp extends e.Geometry {
      constructor(t) {
        if ((super(t), !e.defined(t.positions))) throw new Error('options.positions is required.');
        if (e.defined(t.maximumHeights) && t.maximumHeights.length !== t.positions.length)
          throw new Error(
            'options.positions and options.maximumHeights must have the same length.',
          );
        if (e.defined(t.minimumHeights) && t.minimumHeights.length !== t.positions.length)
          throw new Error(
            'options.positions and options.minimumHeights must have the same length.',
          );
        (this._positions = t.positions),
          (this._maximumHeights = t.maximumHeights),
          (this._minimumHeights = t.minimumHeights),
          (this._granularity = e.defaultValue(
            t.granularity,
            e.CONSTS.CesiumMath.RADIANS_PER_DEGREE,
          )),
          (this._ellipsoid = e.defaultValue(t.ellipsoid, e.Ellipsoid.WGS84)),
          (this.vertices = void 0),
          (this.indices = void 0),
          (this._usedDoublePrecision = !0),
          (this._vertexArray = new e.StructArrayLayout3f3f24()),
          (this._indices = new e.StructArrayLayout2ui4()),
          (this.primitiveType = e.WebGLConstants.LINES),
          (this.type = 'WallOutlineGeometry'),
          this.updateProperty(t);
      }
      updateProperty(e) {
        this.setData(e);
      }
      setData(t) {
        (this.vertices = void 0),
          (this.indices = void 0),
          (this.normals = void 0),
          (this.uvs = void 0),
          this._vertexArray
            ? (this._vertexArray.clear(), this._indices.clear())
            : ((this._indices = new e.StructArrayLayout2ui4()),
              (this._vertexArray = new e.StructArrayLayout3f3f24())),
          (this._positions = t.positions),
          (this._maximumHeights = t.maximumHeights),
          (this._minimumHeights = t.minimumHeights),
          (this._granularity = e.defaultValue(
            t.granularity,
            e.CONSTS.CesiumMath.RADIANS_PER_DEGREE,
          )),
          (this._ellipsoid = e.defaultValue(t.ellipsoid, e.Ellipsoid.WGS84)),
          (this._needUpdate = !0),
          this.parse(),
          this.computeBoundingSphere(),
          this.computeBoundingBox();
      }
      static fromConstantHeights(t) {
        const i = t.positions;
        if (!e.defined(i)) throw new Error('options.positions is required.');
        let s, r;
        const n = t.minimumHeight,
          o = t.maximumHeight,
          a = e.defined(n),
          l = e.defined(o);
        if (a || l) {
          const e = i.length;
          (s = a ? new Array(e) : void 0), (r = l ? new Array(e) : void 0);
          for (let t = 0; t < e; ++t) a && (s[t] = n), l && (r[t] = o);
        }
        return new Rp({
          positions: i,
          maximumHeights: r,
          minimumHeights: s,
          ellipsoid: t.ellipsoid,
        });
      }
      parse() {
        const t = new e.Vector3(),
          i = new e.Vector3(),
          s = Im.computePositions(
            this._ellipsoid,
            this._positions,
            this._maximumHeights,
            this._minimumHeights,
            this._granularity,
            !1,
          );
        if (!e.defined(s)) return;
        const r = s.bottomPositions,
          n = s.topPositions;
        let o = n.length,
          a = 2 * o;
        const l = new Float64Array(a);
        let h,
          c = 0;
        for (o /= 3, h = 0; h < o; ++h) {
          const s = 3 * h,
            o = e.Vector3.fromArray(n, s, t),
            a = e.Vector3.fromArray(r, s, i);
          (l[c++] = a.x),
            (l[c++] = a.y),
            (l[c++] = a.z),
            (l[c++] = o.x),
            (l[c++] = o.y),
            (l[c++] = o.z);
        }
        this.vertices = l;
        const _ = a / 3;
        a = 2 * _ - 4 + _;
        const u = new Uint16Array(a);
        let d = 0;
        for (h = 0; h < _ - 2; h += 2) {
          const s = h,
            r = h + 2,
            n = e.Vector3.fromArray(l, 3 * s, t),
            o = e.Vector3.fromArray(l, 3 * r, i);
          if (e.Vector3.equalsEpsilon(n, o, e.CONSTS.CesiumMath.EPSILON10)) continue;
          const a = h + 1,
            c = h + 3;
          (u[d++] = a), (u[d++] = s), (u[d++] = a), (u[d++] = c), (u[d++] = s), (u[d++] = r);
        }
        for (
          u[d++] = _ - 2,
            u[d++] = _ - 1,
            this.indices = u,
            this.emplaceVertexBufferOfLines(),
            h = 0;
          h < this.indices.length / 2;
          h++
        )
          this._indices.emplaceBack(this.indices[2 * h], this.indices[2 * h + 1]);
      }
      update(t) {
        if (this._needUpdate && t.painter) {
          const i = t.painter.context;
          this._vertBuffer
            ? (this._vertBuffer.updateData(this._vertexArray),
              this._indexBuffer.updateData(this._indices))
            : ((this._vertBuffer = i.createVertexBuffer(
                this._vertexArray,
                Z_.members,
                this.dynamicDraw,
              )),
              (this._indexBuffer = i.createIndexBuffer(this._indices, this.dynamicDraw))),
            (this._segmentVector = e.SegmentVector.simpleSegment(
              0,
              0,
              this.vertices.length / 3,
              this.indices.length / 2,
            )),
            (this._needUpdate = !1);
        }
      }
      serialize() {
        return {
          type: this.type,
          positions: this._positions,
          maximumHeights: this._maximumHeights,
          minimumHeights: this._minimumHeights,
        };
      }
      destroy() {
        return (
          super.destroy(),
          (this._positions = void 0),
          (this._maximumHeights = void 0),
          (this._minimumHeights = void 0),
          (this._granularity = void 0),
          (this._ellipsoid = void 0),
          (this.vertices = void 0),
          (this.indices = void 0),
          (this._vertexArray = void 0),
          (this._indices = void 0),
          (this.primitiveType = void 0),
          (this._needUpdate = void 0),
          (this.type = void 0),
          this._segmentVector?.destroy(),
          (this._segmentVector = void 0),
          e.destroyObject(this)
        );
      }
    }
    class Ip extends e.Material {
      constructor(t) {
        (t.defines = null), (t.type = 'GradientColorBoxMaterial');
        let i =
          'attribute vec3 a_POSITION; \nattribute vec2 a_TEXCOORD_0; \nvarying vec4 v_color; \nuniform mat4 u_ModelViewProjectionMatrix; \nuniform vec3 a_NORMAL; \n';
        (i += 'void main() { \n'),
          (i += 'gl_Position = u_ModelViewProjectionMatrix * vec4(a_POSITION.xyz, 1.0); \n');
        const s = t.gradientColor.slice();
        for (let t = 0; t < s.length - 1; t++) {
          const r = e.Color.parse(s[t][1]),
            n = `vec4(float(${r.r}) , float(${r.g}), float(${r.b}), float(${r.a}))`,
            o = e.Color.parse(s[t + 1][1]);
          (i += `if(float(${s[t][0]}) <= a_TEXCOORD_0.s && a_TEXCOORD_0.s <= float(${
            s[t + 1][0]
          })) \n`),
            (i += '{ \n'),
            (i += `float mixParam = (a_TEXCOORD_0.s - float(${s[t][0]})) / (float(${
              s[t + 1][0]
            }) - float(${s[t][0]})); \n`),
            (i += `v_color = mix(${n}, vec4(float(${o.r}), float(${o.g}), float(${o.b}), float(${o.a})), mixParam);`),
            (i += '} \n');
        }
        (i += '}'),
          (t.fragmentSource =
            'precision highp float;\nvarying vec4 v_color;\n\nvoid main() {\n    gl_FragColor = v_color;\n}'),
          (t.vertexSource = i);
        const r = e.Material.getDefaultRenderState();
        (r.cull.enabled = e.defaultValue(!t.doubleSided, !0)),
          (t.renderState = r),
          super(t),
          (this.gradientColor = e.defaultValue(t.gradientColor, void 0));
      }
      updateMaterialProperty(e) {
        this._shaderSource = void 0;
        const t = new Ip(e);
        this._shaderSource && this._shaderSource.destroy(), (this._shaderSource = t._shaderSource);
      }
      serialize() {
        return {
          type: this.type,
          gradientColor: this.gradientColor,
          doubleSided: this._doubleSided,
        };
      }
      destroy() {}
    }
    class Op extends e.Material {
      constructor(t) {
        (t.type = 'PhongMaterial'),
          super(t),
          (this.color = new e.Color(1, 1, 1).toVector3()),
          (this.specular = new e.Color(0.04313725, 0.04313725, 0.04313725).toVector3()),
          (this.shininess = 30),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.emissive = new e.Color(0, 0, 0).toVector3()),
          (this.emissiveIntensity = 1),
          (this.emissiveMap = null),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalScale = new e.Vector2(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.specularMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.reflectivity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = 'round'),
          (this.wireframeLinejoin = 'round'),
          (this.flatShading = !1),
          (this.fog = !0),
          (this.opacity = 1),
          this.setValues(t);
      }
      setValues(e) {
        super.setValues(e);
      }
      update(e, t, i = {}) {
        super.update(e, t, i),
          this._uniforms.set('u_Color', () => this.color),
          this._uniforms.set('u_Shininess', () => this.shininess),
          this._uniforms.set('u_Opacity', () => this.opacity),
          this._uniforms.set('u_Reflectivity', () => this.reflectivity);
      }
      serialize() {
        return {
          type: this.type,
          color: e.Vector3.pack(this.color, new Array(3)),
          shininess: this.shininess,
          reflectivity: this.reflectivity,
          opacity: this.opacity,
        };
      }
      destroy() {}
    }
    class Lp extends e.Material {
      constructor(t) {
        (t.type = 'WaterMaterial'),
          super(t),
          (this._speed = void 0 !== t.speed ? (1 * t.speed) / 60 : 1 / 60),
          (this._alpha = t.opacity);
        try {
          this._waterColor = e.defined(t.color)
            ? e.Color.parse(t.color).toVector3()
            : new e.Vector3(0, 0, 1);
        } catch (i) {
          if (
            'object' == typeof t.color &&
            e.defined(t.color.r) &&
            e.defined(t.color.g) &&
            e.defined(t.color.b)
          )
            throw new Error('当前类型的Color为非法！请修改为标准的Color Input类型！');
        }
        (this._texture = void 0 !== t.texture ? t.texture : null),
          (this._sunLightDirection =
            void 0 !== t.sunLightDirection ? new e.Vector3(t.sunLightDirection) : null),
          (this._sunLightColor =
            void 0 !== t.sunLightColor
              ? new e.Vector3(t.sunLightColor.r, t.sunLightColor.g, t.sunLightColor.b)
              : new e.Vector3(1, 1, 1)),
          (this._waveSize = e.defaultValue(1 / t.waveSize, 1)),
          (this._time = 0),
          (this._skyColor = e.defined(t.skyColor)
            ? new e.Vector3(t.skyColor.r, t.skyColor.g, t.skyColor.b)
            : new e.Vector3(1, 1, 1)),
          (this._enableSSR = !!e.defined(t.enableSSR) && t.enableSSR),
          this._enableSSR &&
            ((this._colorTexture = null),
            (this._depthTexture = null),
            (this._normalTexture = null),
            (this.SSRState = !1));
      }
      enableSSR() {
        this._enableSSR = !0;
      }
      disableSSR() {
        this._enableSSR = !1;
      }
      update(t, i, s = {}) {
        super.update(t, i, s),
          (t.enableSSR = this._enableSSR),
          this._uniforms.set('u_SkyColor', () => this._skyColor),
          this._uniforms.set('u_Opacity', () => this._alpha),
          this._uniforms.set('u_Time', () => ((this._time = this._time + this._speed), this._time)),
          this._uniforms.set(
            'u_BaseColorSampler',
            () => (
              (this._texture.sampler = {
                minificationFilter: e.WebGLConstants.LINEAR_MIPMAP_LINEAR,
                magnificationFilter: e.WebGLConstants.LINEAR,
                wrapS: e.WebGLConstants.REPEAT,
                wrapT: e.WebGLConstants.REPEAT,
              }),
              this._texture
            ),
          ),
          this._uniforms.set('u_NormalSampler', () => {
            if (this.SSRState) return this._normalTexture;
          }),
          this._uniforms.set('u_ColorSampler', () => {
            if (this.SSRState) return this._colorTexture;
          }),
          this._uniforms.set('u_DepthSampler', () => {
            if (this.SSRState) return this._depthTexture;
          }),
          this._uniforms.set('u_Width', () => t.width),
          this._uniforms.set('u_Height', () => t.height),
          this._uniforms.set('u_Color', () => this._waterColor),
          this._uniforms.set('u_DistortionScale', () => 3.7),
          this._uniforms.set('u_SunColor', () => this._sunLightColor),
          this._uniforms.set('u_SunDirection', () => this._sunLightDirection),
          this._uniforms.set('u_WaveSize', () => this._waveSize);
      }
      serialize() {
        return {
          type: this.type,
          texture: this._texture.serialize(),
          opacity: this._alpha,
          color: e.Vector3.pack(this._waterColor, new Array(3)),
          sunLightColor: e.Vector3.pack(this._sunLightColor, new Array(3)),
          sunLightDirection: e.Vector3.pack(this._sunLightDirection, new Array(3)),
          waveSize: 1 / this._waveSize,
          skyColor: e.Vector3.pack(this._skyColor, new Array(3)),
          speed: 60 * this._speed,
          enableSSR: this._enableSSR,
        };
      }
      destroy() {}
    }
    const Dp = {
        BoxGeometry: wp,
        BoxOutlineGeometry: $_,
        ConeGeometry: Cp,
        CylinderGeometry: Sp,
        FenceGeometry: Ep,
        FrustumGeometry: ym,
        FrustumOutlineGeometry: Tm,
        GradientColorBoxGeometry: Pp,
        PlaneGeometry: Mp,
        PlaneOutlineGeometry: Ap,
        PolygonGeometry: e.PolygonGeometry,
        PolygonOutlineGeometry: Pm,
        PolylineGeometry: e.PolylineGeometry,
        SimplePolylineGeometry: Km,
        SphereGeometry: Vn,
        WallGeometry: Lm,
        WallOutlineGeometry: Rp,
      },
      Bp = {
        GradientColorBoxMaterial: Ip,
        PolylineMaterial: e.PolylineMaterial,
        StandardMaterial: e.StandardMaterial,
        PhongMaterial: Op,
        gltfPBR: Fs,
        WaterMaterial: Lp,
      };
    function Vp(t, i) {
      const s = i.geometry;
      if (!e.defined(s)) throw new Error("geometry's options is not defined!");
      const r = i.material;
      if (!e.defined(s)) throw new Error("material's options is not defined!");
      if (!e.defined(s) && !e.defined(r)) return;
      const a = (function (t) {
          const i = t.type;
          let s;
          switch (i) {
            case 'BoxGeometry':
            case 'ConeGeometry':
            case 'CylinderGeometry':
            case 'GradientColorBoxGeometry':
            case 'SphereGeometry':
              break;
            case 'BoxOutlineGeometry':
              (t.minPoint = e.Vector3.unpack(t.minPoint)),
                (t.maxPoint = e.Vector3.unpack(t.maxPoint));
              break;
            case 'FenceGeometry':
            case 'PolylineGeometry':
            case 'SimplePolylineGeometry':
            case 'WallGeometry':
            case 'WallOutlineGeometry':
              if (e.defined(t.positions))
                for (let i = 0; i < t.positions.length; i++)
                  t.positions[i] = e.Vector3.unpack(t.positions[i]);
              break;
            case 'FrustumGeometry':
            case 'FrustumOutlineGeometry':
              'PerspectiveCamera' === t.camera.type
                ? (s = new n(t.camera.fov, t.camera.aspect, t.camera.near, t.camera.far))
                : 'OrthographicCamera' === t.camera.type &&
                  ((s = new o(t.camera.width, t.camera.aspect, t.camera.near, t.camera.far)),
                  s.setMatrix(new e.Matrix4(t.camera.matrix))),
                (t = s);
              break;
            case 'PlaneGeometry':
            case 'PlaneOutlineGeometry':
              (t.position = e.Vector3.unpack(t.position)),
                (t.normal = e.Vector3.unpack(t.normal)),
                (t.dimensions = e.Vector2.unpack(t.dimensions));
              break;
            case 'PolygonGeometry':
            case 'PolygonOutlineGeometry':
              t.polygonHierarchy = e.PolygonPipeline.hierarchyUnpack(t.polygonHierarchy, {});
              break;
            default:
              throw new Error('Unknown geometry type!');
          }
          return new Dp[i](t);
        })(s),
        l = (function (t, i) {
          const s = t.type;
          let r;
          switch (s) {
            case 'StandardMaterial':
              e.defined(t.color) && (t.color = e.Color.unpack(t.color)),
                e.defined(t.texUrl) &&
                  (t.baseColorTexture = new ks().load({ map: i, texUrl: t.texUrl })),
                (r = Bp[s].fromType(t.texTYpe, t)),
                e.defined(t.flowOptions) && r.flowTexture(t.flowOptions);
              break;
            case 'GradientColorBoxMaterial':
            case 'PolylineMaterial':
            case 'PhongMaterial':
            case 'gltfPBR':
            case 'WaterMaterial':
              e.defined(t.color) && (t.color = e.Color.unpack(t.color).toVector3()),
                e.defined(t.sunLightColor) && (t.sunLightColor = e.Color.unpack(t.sunLightColor)),
                e.defined(t.skyColor) && (t.skyColor = e.Color.unpack(t.skyColor)),
                e.defined(t.texture) &&
                  e.defined(t.texture.texUrl) &&
                  (t.texture = new ks().load({ map: i, texUrl: t.texture.texUrl })),
                e.defined(t.baseColorTextureUrl) &&
                  (t.baseColorTexture = new ks().load({ map: i, texUrl: t.baseColorTextureUrl })),
                e.defined(t.normalTextureUrl) &&
                  (t.normalTexture = new ks().load({ map: i, texUrl: t.normalTextureUrl })),
                e.defined(t.metallicRoughnessTextureUrl) &&
                  (t.metallicRoughnessTexture = new ks().load({
                    map: i,
                    texUrl: t.metallicRoughnessTextureUrl,
                  })),
                (r = new Bp[s](t));
              break;
            default:
              throw new Error('Unknown material type!');
          }
          return r;
        })(r, t),
        h = { geometry: a, material: l },
        c = i.modelMatrix;
      return (
        e.defined(c) && (h.modelMatrix = new e.Matrix4(c)),
        e.defined(i.id) && (h.id = i.id),
        new e.Primitive(h)
      );
    }
    class Np extends vs {
      constructor(e, t) {
        super(e, t),
          (this.type = 'AmbientLight'),
          (this.isAmbientLight = !0),
          (this.castShadow = void 0);
      }
      serialize() {
        return {
          color: e.Vector3.pack(this.color, new Array(3)),
          intensity: this.intensity,
          type: this.type,
        };
      }
    }
    class kp {
      constructor() {}
      static deserialize(t, i, s) {
        if ((e.defined(i.projection) && (t.projection = i.projection), s.useCustomCamera)) {
          const s = i.camera;
          e.defined(s) &&
            t.jumpTo({
              target: s.position,
              bearing: e.defined(s.bearing) ? s.bearing : 0,
              pitch: e.defined(s.pitch) ? s.pitch : 0,
              roll: e.defined(s.roll) ? s.roll : 0,
            });
        }
        !(function (t, i) {
          e.defined(i.metadata) &&
            (i.metadata.nearDetection ? t.enableNearDetection() : t.disableNearDetection(),
            i.metadata.enableNormal ? t.enableNormalPass() : t.disableNormalPass(),
            i.metadata.resolvePass && t.setResolvePass(i.metadata.resolvePass));
        })(t, i),
          e.defined(i.terrain) && t.setTerrain(i.terrain),
          (function (t, i) {
            if (e.defined(i.lights)) {
              let s, r;
              i.lights.forEach((i) => {
                switch (i.type) {
                  case 'AmbientLight':
                    t.addLight(new Np(e.Color.unpack(i.color), i.intensity));
                    break;
                  case 'DirectionalLight':
                    (i.color = e.Color.unpack(i.color)),
                      (s = new Cs(i.color, i.intensity)),
                      s.setPosition(i.lightPosition, i.targetPosition),
                      t.addLight(s);
                    break;
                  case 'PointLight':
                    (i.color = e.Color.unpack(i.color)),
                      (r = new Au(i.color, i.intensity, i.distane, i.decay)),
                      r.setPosition(i.position),
                      t.addLight(r);
                    break;
                  case 'SunLight':
                    (i.color = e.Color.unpack(i.color)),
                      t.addLight(new Ds(i.color, i.intensity, i.timeStamp));
                    break;
                  default:
                    t.enableLight(i.enableLight);
                }
              });
            }
          })(t, i),
          (function (t, i) {
            if (e.defined(i.sceneComponent)) {
              if (e.defined(i.sceneComponent.sceneModels))
                for (let s = 0; s < i.sceneComponent.sceneModels.length; s++) {
                  const r = i.sceneComponent.sceneModels[s];
                  if (e.defined(r.positions))
                    for (let t = 0; t < r.positions.length; t++)
                      r.positions[t] = e.Vector3.unpack(r.positions[t]);
                  if (e.defined(r.rotations))
                    for (let t = 0; t < r.rotations.length; t++)
                      r.rotations[t] = new e.HeadingPitchRoll(
                        r.rotations[t].heading,
                        r.rotations[t].pitch,
                        r.rotations[t].roll,
                      );
                  if (e.defined(r.scales))
                    for (let t = 0; t < r.scales.length; t++)
                      r.scales[t] = e.Vector3.unpack(r.scales[t]);
                  if (e.defined(r.colors))
                    for (let t = 0; t < r.colors.length; t++)
                      r.colors[t] = e.Color.unpack(r.colors[t]);
                  if (
                    ((r.type = '3d-model'),
                    e.defined(r.clippingPlanes) && e.defined(r.clippingPlanes.planes))
                  ) {
                    const t = [];
                    for (let i = 0; i < r.clippingPlanes.planes.length; i++) {
                      const s = r.clippingPlanes.planes[i];
                      (s.position = e.Vector3.unpack(s.position)),
                        (s.normal = e.Vector3.unpack(s.normal)),
                        t.push(new e.ClippingPlane(s));
                    }
                    r.clippingPlanes = new e.ClippingPlaneCollection({
                      modelMatrix: new e.Matrix4(r.clippingPlanes.modelMatrix),
                      edgeColor: e.Color.unpack(r.clippingPlanes.edgeColor),
                      edgeWidth: r.clippingPlanes.edgeWidth,
                      enabled: r.clippingPlanes.enabled,
                      unionClippingRegions: r.clippingPlanes.unionClippingRegions,
                      planes: t,
                    });
                  }
                  t.addSceneComponent(r);
                }
              if (e.defined(i.sceneComponent.sceneTilesets))
                for (let s = 0; s < i.sceneComponent.sceneTilesets.length; s++) {
                  const r = i.sceneComponent.sceneTilesets[s];
                  if (
                    (e.defined(r.translation) && (r.translation = e.Vector3.unpack(r.translation)),
                    e.defined(r.clippingPlanes))
                  ) {
                    const t = [];
                    for (let i = 0; i < r.clippingPlanes.planes.length; i++) {
                      const s = r.clippingPlanes.planes[i];
                      (s.position = e.Vector3.unpack(s.position)),
                        (s.normal = e.Vector3.unpack(s.normal)),
                        t.push(new e.ClippingPlane(s));
                    }
                    r.clippingPlanes = new e.ClippingPlaneCollection({
                      modelMatrix: new e.Matrix4(r.clippingPlanes.modelMatrix),
                      edgeColor: e.Color.unpack(r.clippingPlanes.edgeColor),
                      edgeWidth: r.clippingPlanes.edgeWidth,
                      enabled: r.clippingPlanes.enabled,
                      planes: t,
                    });
                  }
                  t.addSceneComponent(r);
                }
              if (e.defined(i.sceneComponent.primitives))
                for (let e = 0; e < i.sceneComponent.primitives.length; e++)
                  t.addPrimitive(Vp(t, i.sceneComponent.primitives[e]));
              if (e.defined(i.sceneComponent.sceneObjects))
                for (let e = 0; e < i.sceneComponent.sceneObjects.length; e++) {
                  const s = i.sceneComponent.sceneObjects[e];
                  'airLine' == s.type && t.addSceneComponent(new Bh(s));
                }
              const s = i.sceneComponent.skybox;
              e.defined(s) &&
                t.addSceneComponent(
                  new Lh({
                    starrySkyTextureUrls: s.starrySkyTextureUrls,
                    dayTextureUrls: s.dayTextureUrls,
                  }),
                );
            }
          })(t, i),
          (function (t, i) {
            if (e.defined(i.animations))
              for (let e = 0; e < i.animations.length; e++)
                t.animationManager.add(i.animations[e]).then((e) => {
                  e.forEach((e) => {
                    e.play();
                  });
                });
          })(t, i),
          (function (t, i) {
            if (e.defined(i.videoProjection))
              for (let e = 0; e < i.videoProjection.length; e++)
                t.videoManager.add(new vm(i.videoProjection[e]));
          })(t, i),
          (function (t, i) {
            if (e.defined(i.analysis)) {
              if (e.defined(i.analysis.viewDome))
                for (let s = 0; s < i.analysis.viewDome.length; s++) {
                  const r = i.analysis.viewDome[s];
                  (r.viewPosition = e.Vector3.unpack(r.viewPosition)),
                    (r.visibleAreaColor = e.Color.unpack(r.visibleAreaColor)),
                    (r.hiddenAreaColor = e.Color.unpack(r.hiddenAreaColor)),
                    (r.indicatorColor = e.Color.unpack(r.indicatorColor)),
                    (r.indicatorOutlineColor = e.Color.unpack(r.indicatorOutlineColor)),
                    t.analysis.viewDomeCollection.add(new Fm(r));
                }
              if (e.defined(i.analysis.viewshed))
                for (let s = 0; s < i.analysis.viewshed.length; s++) {
                  const r = i.analysis.viewshed[s];
                  (r.viewerPosition = e.Vector3.unpack(r.viewerPosition)),
                    (r.visibleAreaColor = e.Color.unpack(r.visibleAreaColor)),
                    (r.hiddenAreaColor = e.Color.unpack(r.hiddenAreaColor)),
                    (r.lineColor = e.Color.unpack(r.lineColor)),
                    t.analysis.viewshed3DCollection.add(new zm(r));
                }
              if (e.defined(i.analysis.sightLine))
                for (let s = 0; s < i.analysis.sightLine.length; s++) {
                  const r = i.analysis.sightLine[s];
                  (r.viewerPosition = e.Vector3.unpack(r.viewerPosition)),
                    (r.visibleColor = e.Color.unpack(r.visibleColor)),
                    (r.hiddenColor = e.Color.unpack(r.hiddenColor)),
                    (r.indicatorColor = e.Color.unpack(r.indicatorColor)),
                    (r.indicatorOutlineColor = e.Color.unpack(r.indicatorOutlineColor)),
                    t.analysis.sightlineCollection.add(new Ym(r));
                }
              if (e.defined(i.analysis.excavation))
                for (let s = 0; s < i.analysis.excavation.length; s++) {
                  const r = i.analysis.excavation[s];
                  (r.positions = e.Vector3.fromDegreesArrayHeights(r.positions)),
                    t.analysis.excavationCollection.add(new Bm(r));
                }
              if (e.defined(i.analysis.highlight))
                for (let s = 0; s < i.analysis.highlight.length; s++) {
                  const r = i.analysis.highlight[s];
                  for (let t = 0; t < r.positions.length; t++)
                    r.positions[t] = e.Vector3.unpack(r.positions[t]);
                  (r.invalidColor = e.Color.unpack(r.invalidColor)),
                    (r.validColor = e.Color.unpack(r.validColor)),
                    (r.validOutlineColor = e.Color.unpack(r.validOutlineColor)),
                    t.analysis.highlightCollection.add(new Jm(r));
                }
              if (e.defined(i.analysis.cutFill))
                for (let s = 0; s < i.analysis.cutFill.length; s++) {
                  const r = i.analysis.cutFill[s];
                  for (let t = 0; t < r.positions.length; t++)
                    r.positions[t] = e.Vector3.unpack(r.positions[t]);
                  (r.fillColor = e.Color.unpack(r.fillColor)),
                    (r.cutColor = e.Color.unpack(r.cutColor)),
                    (r.baseColor = e.Color.unpack(r.baseColor)),
                    (r.baseOutlineColor = e.Color.unpack(r.baseOutlineColor)),
                    (r.wallColor = e.Color.unpack(r.wallColor)),
                    (r.wallOutlineColor = e.Color.unpack(r.wallOutlineColor)),
                    t.analysis.cutFillCollection.add(new Am(r));
                }
            }
          })(t, i),
          (function (t, i) {
            if (
              (e.defined(i.postProcess) &&
                i.postProcess.blackWhite &&
                t.postProcessStages.add(Fc.createBlackAndWhiteStage()),
              e.defined(i.postProcess) && i.postProcess.bloom && (t.bloom = i.postProcess.bloom),
              e.defined(i.postProcess) && i.postProcess.fxaa && (t.fxaa = i.postProcess.fxaa),
              e.defined(i.postProcess) &&
                i.postProcess.nightVision &&
                t.postProcessStages.add(Fc.createNightVisionStage()),
              e.defined(i.postProcess) && i.postProcess.hdr && (t.hdr = i.postProcess.hdr),
              e.defined(i.postProcess) && e.defined(i.postProcess.fog))
            ) {
              const s = Fc.createFogEffect({
                fogColor: e.Color.unpack(i.postProcess.fog.fogColor),
                fogDensity: i.postProcess.fog.fogDensity,
              });
              t.postProcessStages.add(s);
            }
            e.defined(i.postProcess) &&
              e.defined(i.postProcess.skyline) &&
              t.postProcessStages.add(
                Fc.createSkyline({
                  width: i.postProcess.skyline.width,
                  color: new e.Color(
                    e.Color.floatToByte(i.postProcess.skyline.color[0]),
                    e.Color.floatToByte(i.postProcess.skyline.color[1]),
                    e.Color.floatToByte(i.postProcess.skyline.color[2]),
                    e.Color.floatToByte(i.postProcess.skyline.color[3]),
                  ),
                }),
              );
          })(t, i);
      }
    }
    const Fp = {
        bearing: 0,
        pitch: 0,
        roll: 0,
        minZoom: 0,
        maxZoom: 22,
        minPitch: 0,
        maxPitch: 85,
        interactive: !0,
        scrollZoom: !0,
        boxZoom: !0,
        dragRotate: !0,
        dragPan: !0,
        dragZoom: !1,
        keyboard: !0,
        doubleClickZoom: !0,
        touchZoomRotate: !0,
        touchPitch: !0,
        cooperativeGestures: !1,
        bearingSnap: 7,
        clickTolerance: 3,
        pitchWithRotate: !0,
        hash: !1,
        attributionControl: !1,
        fps: !1,
        failIfMajorPerformanceCaveat: !1,
        preserveDrawingBuffer: !1,
        trackResize: !0,
        refreshExpiredTiles: !0,
        maxTileCacheSize: null,
        transformRequest: null,
        fadeDuration: 300,
        crossSourceCollisions: !0,
        sphereRender: !0,
        projection: e.ProjectionType.MERCATOR,
        localIdeographFontFamily: 'PingFang SC,Microsoft YaHei,微软雅黑,Arial,sans-serif,黑体',
        defaultCursor: null,
        loadIBL: !0,
        logoControl: !0,
        logoUrl: '',
        skyBox: !0,
        earthSkin: !0,
        minHeightToDemSurface: 1,
        lightingModel: e.LightingModelType.NONE,
        cameraController: new (class {
          constructor() {
            (this.colliding = !1),
              (this.cliddingPoint = void 0),
              (this._eventInProgress = void 0),
              (this.enableCollisionDetection = !1),
              (this._minHeightToDemSurface = 1);
          }
          setMapInstance(e) {
            this._map = e;
          }
          set eventInProgress(e) {
            this._eventInProgress = e;
          }
          get eventInProgress() {
            return this._eventInProgress;
          }
          _handleZooming(e) {
            return e;
          }
          _handleBearing(e) {
            return this._map.transform._pinchOperationData._headingDiff > 0
              ? (['rightBottom'].forEach((t) => delete e[t]), e)
              : this._map.transform._pinchOperationData._headingDiff < 0
              ? (['leftBottom'].forEach((t) => delete e[t]), e)
              : void 0;
          }
          _handlePitching(e) {
            return this._map.transform._pinchOperationData._pitchDiff > 0
              ? (['leftTop', 'rightTop'].forEach((t) => delete e[t]), e)
              : this._map.transform._pinchOperationData._pitchDiff < 0
              ? (['leftBottom', 'rightBottom'].forEach((t) => delete e[t]), e)
              : void 0;
          }
          _handlePanning(e) {
            const t = this._map.transform.panDelta;
            return (t.x > 0 && t.y >= 0) || (t.x > 0 && t.y < 0)
              ? (['leftTop', 'leftBottom'].forEach((t) => delete e[t]), e)
              : (t.x < 0 && t.y >= 0) || (t.x < 0 && t.y < 0)
              ? (['rightTop', 'rightBottom'].forEach((t) => delete e[t]), e)
              : 0 === t.x && t.y > 0
              ? (['leftBottom', 'rightBottom'].forEach((t) => delete e[t]), e)
              : 0 === t.x && t.y < 0
              ? (['leftTop', 'rightTop'].forEach((t) => delete e[t]), e)
              : void 0;
          }
          _handleMoving(e) {
            switch (this.eventInProgress.originalEvent.key) {
              case 'ArrowLeft':
                return ['rightTop', 'rightBottom'].forEach((t) => delete e[t]), e;
              case 'ArrowRight':
                return ['leftTop', 'leftBottom'].forEach((t) => delete e[t]), e;
              case 'ArrowUp':
                return ['leftBottom', 'rightBottom'].forEach((t) => delete e[t]), e;
              case 'ArrowDown':
                return ['leftTop', 'rightTop'].forEach((t) => delete e[t]), e;
              default:
                return;
            }
          }
          _handleCollisionPoints() {
            const e = this._map.painter.getClipPointsPosition();
            if (void 0 !== e)
              switch (
                ('scrollZoom' !== this.eventInProgress.handlerName &&
                  (this._map.transform.zoomDelta = 0),
                this.eventInProgress.handlerName)
              ) {
                case 'scrollZoom':
                  return this._handleZooming(e);
                case 'keyboard':
                  return this._handleMoving(e);
                case 'mousePan':
                  return this._handlePanning(e);
                case 'mouseRotate':
                  return this._handleBearing(e);
                case 'mousePitch':
                  return this._handlePitching(e);
                default:
                  return;
              }
          }
          checkColliding(e, t, i, s) {
            if (!this.eventInProgress) return !1;
            const r = this._map.painter.getClipPointsPosition();
            if (void 0 === r) return !1;
            if (t) {
              for (const e in r)
                if (r[e] && s - r[e][2] < this._map.transform._minHeightToDemSurface)
                  return (this.cliddingPoint = r[e]), !0;
              const n = this._getIntersectionOfPosition(e, s, t, i);
              return !(
                !Number.isFinite(n.intersectionZ) ||
                !(n.isUnderground || n.intersectionZ < this._map.transform._minHeightToDemSurface)
              );
            }
            for (const e in r)
              if (r[e] && s - r[e][2] < this._map.transform._minHeightToDemSurface)
                return (this.cliddingPoint = r[e]), !0;
            return !1;
          }
          adjustCameraHeight(t, i, s, r) {
            const n = this._handleCollisionPoints();
            if (void 0 === n) return t;
            const o = this._getIntersectionOfPosition(t, t[2], s, r);
            if (i) {
              for (const i in n) {
                const s = this._map.painter.getClipPointsOnScreen()[i],
                  r = this._map.painter.getFeatureByGPUPick(s);
                if (r && r.boundingBox) {
                  this._map.transform._justTerrain = !1;
                  const s = e.Transforms.cartesian3ToCartographic(r.boundingBox.center);
                  if (t[2] - o.intersectionZ < n[i][2])
                    return (
                      (t[2] =
                        s[2] +
                        r.boundingBox.halfSize[2] +
                        this._map.transform._minHeightToDemSurface),
                      (this._map.transform._cameraHeightConvertedZoom = e.getZoomFromDistance(
                        this._map.transform._fov,
                        t[2] + e.CONSTS.TRANSFORM.R,
                        e.CONSTS.TRANSFORM.R,
                      )),
                      t
                    );
                } else if (r && r._content) {
                  this._map.transform._justTerrain = !1;
                  const s = r._content._url.split('?')[0],
                    a = this._map.style.tilesetCollection._data;
                  let l = [];
                  for (const e of a) l = l.concat(e[1]._opaqueList, e[1]._translucentList);
                  const h = l.find((e) => e._owner.tileID === s);
                  if (h) {
                    const s = e.Transforms.cartesian3ToCartographic(h.boundingBox.center);
                    if (t[2] - o.intersectionZ < n[i][2])
                      return (
                        (t[2] =
                          s[2] +
                          h.boundingBox.halfSize[2] +
                          this._map.transform._minHeightToDemSurface),
                        (this._map.transform._cameraHeightConvertedZoom = e.getZoomFromDistance(
                          this._map.transform._fov,
                          t[2] + e.CONSTS.TRANSFORM.R,
                          e.CONSTS.TRANSFORM.R,
                        )),
                        t
                      );
                  }
                }
              }
              if (
                Number.isFinite(
                  o.intersectionZ || o.intersectionZ < this._map.transform._minHeightToDemSurface,
                )
              )
                return (
                  o.isUnderground
                    ? (this._map.transform._position[2] =
                        o.intersectionZ + this._map.transform._minHeightToDemSurface)
                    : (this._map.transform._position[2] +=
                        this._map.transform._minHeightToDemSurface - o.intersectionZ),
                  (this._cameraHeightConvertedZoom = e.getZoomFromDistance(
                    this._map.transform._fov,
                    this._map.transform._position[2] + e.CONSTS.TRANSFORM.R,
                    e.CONSTS.TRANSFORM.R,
                  )),
                  t
                );
            } else
              for (const i in n) {
                this._map.transform._justTerrain = !1;
                const s = this._map.painter.getClipPointsOnScreen()[i],
                  r = this._map.painter.getFeatureByGPUPick(s);
                if (r && r.boundingBox) {
                  const i =
                    e.Transforms.cartesian3ToCartographic(r.boundingBox.center)[2] +
                    r.boundingBox.halfSize[2];
                  if (t[2] < i)
                    return (
                      (t[2] = i + this._map.transform._minHeightToDemSurface),
                      (this._map.transform._cameraHeightConvertedZoom = e.getZoomFromDistance(
                        this._map.transform._fov,
                        t[2] + e.CONSTS.TRANSFORM.R,
                        e.CONSTS.TRANSFORM.R,
                      )),
                      t
                    );
                } else if (r && r._content) {
                  const i = r._content._url.split('?')[0],
                    s = this._map.style.tilesetCollection._data;
                  let n = [];
                  for (const e of s) n = n.concat(e[1]._opaqueList, e[1]._translucentList);
                  const o = n.find((e) => e._owner.tileID === i);
                  if (o) {
                    const i =
                      e.Transforms.cartesian3ToCartographic(o.boundingBox.center)[2] +
                      o.boundingBox.halfSize[2];
                    if (t[2] < i)
                      return (
                        (t[2] = i + this._map.transform._minHeightToDemSurface),
                        (this._map.transform._cameraHeightConvertedZoom = e.getZoomFromDistance(
                          this._map.transform._fov,
                          t[2] + e.CONSTS.TRANSFORM.R,
                          e.CONSTS.TRANSFORM.R,
                        )),
                        t
                      );
                  }
                }
                return t;
              }
          }
          _getIntersectionOfPosition(t, i, s, r) {
            if (s) {
              const n = e.Vector3.fromDegrees(t[0], t[1], i);
              return vo(new e.Vector3(t[0], t[1], i), n, s, r);
            }
            return { intersectionZ: 1 / 0, intersectionPoint: null, isUnderground: !1 };
          }
        })(),
      },
      { HTMLImageElement: Gp, HTMLElement: Up, ImageBitmap: zp } = e.window;
    class Hp extends Kd {
      constructor(t) {
        if ('undefined' == typeof global && !Wm(void 0))
          throw new Error('minemap.js is not supported in the current environment');
        if (
          ((t = e.extend({}, Fp, t)),
          e.defined(t.center) ||
            e.defined(t.zoom) ||
            e.defined(t.position) ||
            ((t.center = [0, 0]), (t.zoom = 0)),
          e.defined(t.center) && e.defined(t.zoom) && e.defined(t.position))
        )
          throw new Error('You must specify either center and zoom, or position');
        if (null != t.minZoom && null != t.maxZoom && t.minZoom > t.maxZoom)
          throw new Error('maxZoom must be greater than or equal to minZoom');
        if (null != t.minPitch && null != t.maxPitch && t.minPitch > t.maxPitch)
          throw new Error('maxPitch must be greater than or equal to minPitch');
        if (null != t.minPitch && t.minPitch < 0)
          throw new Error('minPitch must be greater than or equal to 0');
        if (null != t.maxPitch && t.maxPitch > 85)
          throw new Error('maxPitch must be less than or equal to 85');
        const i = new om(
          t.minZoom,
          t.maxZoom,
          t.projection,
          t.minPitch,
          t.maxPitch,
          t.cameraController,
        );
        (i.minHeightToDemSurface = t.minHeightToDemSurface),
          super(i, t),
          (this.spaceErrorScale = t.spaceErrorScale),
          (this.lightingModel = t.lightingModel),
          (this.manageRequestPerformance = { enabled: !1, duration: 3 }),
          (this._logDepth = t.logDepth || !1),
          (this._canvasTransparent = void 0 === t.canvasTransparent || t.canvasTransparent),
          (this.fPMode = t.fPMode || !1),
          (this.testMode = t.testMode || !1),
          (this._shadowFlag = !1),
          (this._viewShedFlag = !1),
          (this.mapProjection = new nm(t, this)),
          (this._interactive = t.interactive),
          (this._maxTileCacheSize = t.maxTileCacheSize),
          (this._failIfMajorPerformanceCaveat = t.failIfMajorPerformanceCaveat),
          (this._preserveDrawingBuffer = t.preserveDrawingBuffer),
          (this._trackResize = t.trackResize),
          (this._bearingSnap = t.bearingSnap),
          (this._refreshExpiredTiles = t.refreshExpiredTiles),
          (this._fadeDuration = t.fadeDuration),
          (this._crossSourceCollisions = t.crossSourceCollisions),
          (this._crossFadingFactor = 1),
          (this._collectResourceTiming = t.collectResourceTiming),
          (this._renderTaskQueue = new rm()),
          (this._domRenderTaskQueue = new rm()),
          (this._fxaaRender = t.fxaa || !1),
          (this._bloomRender = t.bloom || !1),
          (this._bloomOptions = { step: 9, extent: 6 }),
          (this._requestInterval = e.defaultValue(t.requestInterval, 60)),
          (this._controls = []),
          (this.__markerList = []),
          (this.__popupList = []),
          (this._particleSystemCollection = new $m(this)),
          (this.isLatLon = 'LATLON' === t.projection),
          (this._tilingScheme = 'LATLON' === t.projection ? new hn() : new ln()),
          (this._loadIBL = t.loadIBL),
          (this._cooperativeGestures = t.cooperativeGestures),
          (this._locale = e.extend({}, pm, t.locale)),
          (this._clickTolerance = t.clickTolerance),
          (this._containerWidth = 0),
          (this._containerHeight = 0),
          (this._showDebugBoundingBox = e.defaultValue(t.showDebugBoundingBox, !1)),
          (this._shadows = t.shadows || !1),
          t.cameraController.setMapInstance(this),
          (this.cameraController = t.cameraController),
          (this._shadowsType = this._shadows
            ? t.shadowsType || e.ShadowsType.ShadowMapping
            : e.ShadowsType.NONE),
          (this._time = t.time),
          (this._nearDetection = !!t.nearDetection && t.nearDetection),
          (this._enableNormal = !!t.enableNormal && t.enableNormal),
          (this._resolvePass = t.resolvePass ? t.resolvePass : 'main');
        const s = t.transformRequest;
        if (
          ((this._transformRequest = s
            ? (e, t) => s(e, t) || { url: e, type: t }
            : (e) => ({ url: e })),
          (this.timer = new dm()),
          (this._SSAASamples = t.SSAASamples ? t.SSAASamples : 1),
          (this._trackingOptions = null),
          (this._roamingOptions = null),
          'string' == typeof t.container)
        ) {
          if (((this._container = e.window.document.getElementById(t.container)), !this._container))
            throw new Error(`Container '${t.container}' not found.`);
        } else {
          if (!(t.container instanceof Up))
            throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
          this._container = t.container;
        }
        if (
          (this._container.childNodes.length > 0 &&
            e.warnOnce(
              "The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the MineMap Supported plugin instead.",
            ),
          t.maxBounds && this.setMaxBounds(t.maxBounds),
          e.bindAll(
            [
              '_onWindowOnline',
              '_onWindowResize',
              '_onMapScroll',
              '_contextLost',
              '_contextRestored',
              '_update',
              '_render',
              '_onData',
              '_onDataLoading',
            ],
            this,
          ),
          this._setupContainer(),
          this._setupPainter(),
          void 0 === this.painter)
        )
          throw new Error('Failed to initialize WebGL.');
        this.on('move', () => this._update(!1)),
          this.on('moveend', () => this._update(!1)),
          this.on('zoom', () => this._update(!0)),
          void 0 !== e.window &&
            (e.window.addEventListener('online', this._onWindowOnline, !1),
            e.window.addEventListener('resize', this._onWindowResize, !1),
            e.window.addEventListener('orientationchange', this._onWindowResize, !1),
            e.window.addEventListener('webkitfullscreenchange', this._onWindowResize, !1)),
          (this.handlers = new Pd(this, t)),
          (this._hash = t.hash && new Du().addTo(this)),
          (this._hash && this._hash._onHashChange()) ||
            (e.defined(t.center) && e.defined(t.zoom) && !e.defined(t.position)
              ? this.jumpTo({
                  center: t.center,
                  zoom: t.zoom,
                  bearing: t.bearing,
                  pitch: t.pitch,
                  roll: t.roll,
                })
              : this.jumpTo({
                  target: t.position,
                  bearing: t.bearing,
                  pitch: t.pitch,
                  roll: t.roll,
                }),
            t.bounds &&
              (this.resize(),
              this.fitBounds(t.bounds, e.extend({}, t.fitBoundsOptions, { duration: 0 })))),
          this.resize(),
          (this.directionLightParameter = new Cm()),
          (this.animationManager = new Lr(this)),
          (this.videoManager = new wm()),
          (this.analysis = {
            cutFillCollection: new Rm(this.painter),
            excavationCollection: new Vm(this.painter),
            highlightCollection: new ep(this.painter),
            sightlineCollection: new Qm(this.painter),
            viewDomeCollection: new Gm(this.painter),
            viewshed3DCollection: new Hm(this.painter),
          }),
          t.style &&
            this.setStyle(t.style, {
              localIdeographFontFamily: t.localIdeographFontFamily,
              projection: t.projection,
            }),
          t.attributionControl && this.addControl(new Yd()),
          t.fps && this.addFPSControl(),
          t.logoControl && this.addControl(new Qd(), t.logoPosition, t.logoUrl),
          this.on('style.load', () => {
            if (Object.getOwnPropertyDescriptor(this, 'testMode').hasOwnProperty('get'))
              throw new Error(
                'The introduction framework modifies the properties of minemap itself. Please check whether the instantiated object uses the Object.defineproperty method (P.S. may be due to Vue or React)',
              );
            this.transform.unmodified && this.jumpTo(this.style.stylesheet);
          }),
          this.on('data', this._onData),
          this.on('dataloading', this._onDataLoading),
          this.on('processStyleJson', this._processStyleJson),
          (this._overviewMapOptions = t),
          t.overviewMap
            ? ((this._overviewMap = !0), this.addOverviewMap())
            : (this._overviewMap = !1),
          this.setCursor(t.defaultCursor);
        const { skyBox: r, earthSkin: n } = t;
        this.#dt(r, n), this.setTime();
      }
      enableRequestManage() {
        this.manageRequestPerformance.enabled = !0;
      }
      disableRequestManage() {
        this.manageRequestPerformance.enabled = !1;
      }
      setRequestManageDuration(e) {
        this.manageRequestPerformance.duration = e;
      }
      #dt(e, t) {
        const i = `${pr.SRC_URL}/assets`;
        if (e) {
          const e = new Lh({
            starrySkyTextureUrls: {
              nx: `${i}/tycho2t3_80_pz/tycho2t3_80_mx.jpg`,
              px: `${i}/tycho2t3_80_pz/tycho2t3_80_px.jpg`,
              ny: `${i}/tycho2t3_80_pz/tycho2t3_80_my.jpg`,
              py: `${i}/tycho2t3_80_pz/tycho2t3_80_py.jpg`,
              nz: `${i}/tycho2t3_80_pz/tycho2t3_80_mz.jpg`,
              pz: `${i}/tycho2t3_80_pz/tycho2t3_80_pz.jpg`,
            },
            dayTextureUrls: {
              nx: `${i}/penguins-skybox-pack/penguins (44)/yonder_lf.jpg`,
              px: `${i}/penguins-skybox-pack/penguins (44)/yonder_rt.jpg`,
              ny: `${i}/penguins-skybox-pack/penguins (44)/yonder_dn.jpg`,
              py: `${i}/penguins-skybox-pack/penguins (44)/yonder_up.jpg`,
              nz: `${i}/penguins-skybox-pack/penguins (44)/yonder_ft.jpg`,
              pz: `${i}/penguins-skybox-pack/penguins (44)/yonder_bk.jpg`,
            },
          });
          this.addSceneComponent(e);
        }
        if (t) {
          const e = new Zm({
            url: `${i}/Earth_Diffuse22.png`,
            cloudImageUrl: `${i}/Earth_Clouds4.png`,
            nightImageUrl: `${i}/imageNightLightEarth.png`,
            widthSegments: 128,
            heightSegments: 64,
          });
          this.addSceneComponent(e);
        }
      }
      getCurrentLocation() {
        return {
          center: this.getCenter().toArray(),
          zoom: this.getZoom(),
          pitch: this.getPitch(),
          bearing: this.getBearing(),
          roll: this.getRoll(),
        };
      }
      __onMove() {
        this.overviewMapInstance.setCenter(this.getCenter()),
          this.overviewMapInstance.setBearing(this.getBearing()),
          this.overviewMapInstance.setZoom(this.getZoom() < 6 ? 3 : this.getZoom() - 4);
      }
      disableDrag() {
        this.dragPan.disable();
      }
      enableDrag() {
        this.dragPan.enable();
      }
      setCursor(e) {
        this._canvas.style.cursor = e || '';
      }
      getZoomFromDistance(t) {
        return e.getZoomFromDistance(
          this.transform._fov,
          e.CONSTS.TRANSFORM.R + t,
          e.CONSTS.TRANSFORM.R,
        );
      }
      getZoomFromDistanceForUser() {
        console.error('很抱歉，当前方法已经迁移，调用新的方法getZoomFromDistance');
      }
      getDistanceFromZoom(t) {
        return (
          e.getDistanceFromZoom(this.transform._fov, t, e.CONSTS.TRANSFORM.R) - e.CONSTS.TRANSFORM.R
        );
      }
      getDistanceFromZoomForUser(e) {
        console.error('很抱歉，当前方法已经迁移，调用新的方法getDistanceFromZoom');
      }
      getCursor() {
        return this.getCanvas().style.cursor;
      }
      setZoomAndCenter(e, t) {
        this.jumpTo({ center: t, zoom: e });
      }
      getAllMarkers() {
        return this.__markerList;
      }
      addMarker(t) {
        !e.arrayInclude(this.__markerList, t) &&
          t instanceof um &&
          (this.__markerList.push(t), t.addTo(this));
      }
      addMarkers(e) {
        for (let t = 0; t < e.length; t++) this.addMarker(e[t]);
      }
      removeMarker(e) {
        e instanceof um && e.remove();
      }
      removeMarkers(e) {
        if (e)
          for (let t = 0; t < e.length; t++) {
            this.removeMarker(e[t]);
            for (let i = 0; i < this.__markerList.length; i++)
              e[t] === this.__markerList[i] && this.__markerList.splice(i, 1);
          }
        else {
          for (let e = 0; e < this.__markerList.length; e++)
            this.removeMarker(this.__markerList[e]);
          this.__markerList = [];
        }
      }
      removeOverviewMap() {
        this.overviewMapInstance &&
          (this._overviewDrag && this._overviewDrag.remove(),
          this.off('moveend', this.__onMove),
          this.overviewMapInstance.remove(),
          (this.overviewMapInstance = null),
          this.getContainer().parentNode.parentNode.removeChild(this._overviewMapElement),
          (this._overviewMapElement = null));
      }
      updateOverviewMap(e) {
        this.overviewMapInstance.getLayer(e.id) ||
          (void 0 === this.overviewMapInstance.getSource(e.source) &&
            this.overviewMapInstance.style.addSource(e.source, this.getSource(e.source)._options),
          this.overviewMapInstance.style.addLayer(e),
          this.overviewMapInstance._update(!0));
      }
      addOverviewMap() {
        this.overviewMapInstance ||
          ((this._overviewMapElement = e.window.document.createElement('div')),
          (this._overviewMapElement.id = `overviewMap_${Math.random()}`),
          (this._overviewMapElement.style.position = 'absolute'),
          (this._overviewMapElement.style.width = '160px'),
          (this._overviewMapElement.style.height = '160px'),
          (this._overviewMapElement.style.bottom = '0px'),
          (this._overviewMapElement.style.right = '0px'),
          (this._overviewMapElement.style.zIndex = 200),
          (this._overviewMapElement.style.boxSizing = 'border-box'),
          (this._overviewMapElement.style.border = '2px solid rgba(187,187,187,0.5)'),
          (this._overviewMapElement.style.borderRadius = '2px'),
          this.getContainer().parentNode.parentNode.appendChild(this._overviewMapElement),
          (this.overviewMapInstance = new Hp({
            container: this._overviewMapElement,
            style: this._overviewMapOptions.style,
            center: this.getCenter(),
            zoom: this.getZoom() < 7 ? 3 : this.getZoom() - 4,
            pitch: 0,
            dragPan: !1,
            doubleClickZoom: !1,
            scrollZoom: !1,
            dragRotate: !1,
            dragZoom: !1,
            maxZoom: 22,
            minZoom: 3,
            logoControl: !1,
            preserveDrawingBuffer: !0,
            projection: this.isLatLon ? 'LATLON' : 'MERCATOR',
          })),
          this.on('moveend', this.__onMove),
          setTimeout(() => {
            const t = e.window.document.createElement('div');
            this.overviewMapInstance.getCanvas().style.cursor = '';
            const i = this.getBounds();
            let s = this.overviewMapInstance.project(i.getSouthWest()),
              r = this.overviewMapInstance.project(i.getNorthEast());
            r.y <= 45 && (r = new e.pointGeometry3d(r.x, 45)),
              s.x <= 45 && (s = new e.pointGeometry3d(45, s.y)),
              (t.style.top = `${Math.round(r.y)}px`),
              (t.style.left = `${Math.round(s.x)}px`),
              (t.style.width = `${Math.round(160 - 2 * s.x)}px`),
              (t.style.height = `${Math.round(160 - 2 * r.y)}px`),
              (t.style.border = '2px solid red'),
              (t.style.position = 'absolute'),
              this._overviewMapElement.appendChild(t),
              cm.init({
                handler: this._overviewMapElement,
                root: t,
                restrictX: 2 * Math.round(s.x),
                restrictY: 2 * Math.round(r.y),
                cb: (e, i) => {
                  if (e - Math.round(s.x) != 0 || i - Math.round(r.y) != 0) {
                    const n = this.overviewMapInstance.unproject([
                      e - Math.round(s.x) + 80,
                      i - Math.round(r.y) + 80,
                    ]);
                    this.flyTo({ center: n, bearing: this.overviewMapInstance.getBearing() }),
                      (t.style.top = `${Math.round(r.y)}px`),
                      (t.style.left = `${Math.round(s.x)}px`);
                  }
                },
              });
            const n = Object.keys(this.getAllLayers()).reduce(
              (e, t) => (
                ('raster' !== this.getAllLayers()[t].type &&
                  'vector' !== this.getAllLayers()[t].type) ||
                  (e[t] = this.getAllLayers()[t]),
                e
              ),
              {},
            );
            if (Object.keys(n).length > 0)
              for (const e in n) {
                const t = n[e].source;
                this.overviewMapInstance.style.addSource(t, this.getSource(t)._options),
                  this.overviewMapInstance.addLayer({
                    id: e,
                    type: n[e].type,
                    source: t,
                    minzoom: n[e].minzoom,
                    maxzoom: n[e].maxzoom,
                  });
              }
          }, 100));
      }
      openOverviewMap(e) {
        (this._overviewMap = e),
          this.overviewMapInstance
            ? (this._overviewMapElement.style.display = 'block')
            : this.addOverviewMap();
      }
      closeOverviewMap() {
        this.overviewMapInstance && (this._overviewMapElement.style.display = 'none');
      }
      getOverviewMap() {
        return this._overviewMap;
      }
      addControl(t, i, s) {
        if (
          (void 0 === i && (i = t.getDefaultPosition ? t.getDefaultPosition() : 'top-right'),
          !t || !t.onAdd)
        )
          return this.fire(
            new e.ErrorEvent(
              new Error(
                'Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.',
              ),
            ),
          );
        const r = t.onAdd(this, s);
        this._controls.push(t);
        const n = this._controlPositions[i];
        return (
          -1 !== i.indexOf('bottom') ? n.insertBefore(r, n.firstChild) : n.appendChild(r), this
        );
      }
      convertV34Pos2V4(t) {
        return e.V34Pos2V4PosUtil(t, e.CONSTS.TRANSFORM.FOV_IN_RADIANS);
      }
      removeControl(t) {
        if (!t || !t.onRemove)
          return this.fire(
            new e.ErrorEvent(
              new Error(
                'Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.',
              ),
            ),
          );
        const i = this._controls.indexOf(t);
        return i > -1 && this._controls.splice(i, 1), t.onRemove(this), this;
      }
      hasControl(e) {
        return this._controls.indexOf(e) > -1;
      }
      resize(t) {
        if (
          (this._updateContainerDimensions(),
          this._containerWidth === this.transform.width &&
            this._containerHeight === this.transform.height)
        )
          return this;
        this._resizeCanvas(this._containerWidth, this._containerHeight),
          this.transform.resize(this._containerWidth, this._containerHeight),
          this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
        const i = !this._moving;
        return (
          i && this.fire(new e.Event('movestart', t)).fire(new e.Event('move', t)),
          this.fire(new e.Event('resize', t)),
          i && this.fire(new e.Event('moveend', t)),
          this
        );
      }
      getBounds() {
        return new e.LngLatBounds()
          .extend(this.transform.pointLocation(new e.pointGeometry3d(0, 0)))
          .extend(this.transform.pointLocation(new e.pointGeometry3d(this.transform.width, 0)))
          .extend(
            this.transform.pointLocation(
              new e.pointGeometry3d(this.transform.width, this.transform.height),
            ),
          )
          .extend(this.transform.pointLocation(new e.pointGeometry3d(0, this.transform.height)));
      }
      getMaxBounds() {
        return this.transform.latRange &&
          2 === this.transform.latRange.length &&
          this.transform.lngRange &&
          2 === this.transform.lngRange.length
          ? new e.LngLatBounds(
              [this.transform.lngRange[0], this.transform.latRange[0]],
              [this.transform.lngRange[1], this.transform.latRange[1]],
            )
          : null;
      }
      setMaxBounds(t) {
        if (t) {
          const i = e.LngLatBounds.convert(t);
          (this.transform.lngRange = [i.getWest(), i.getEast()]),
            (this.transform.latRange = [i.getSouth(), i.getNorth()]),
            this._update();
        } else null == t && ((this.transform.lngRange = null), this._update());
        return this;
      }
      setMinZoom(e) {
        if ((e = null == e ? 0 : e) >= 0 && e <= this.transform.maxZoom)
          return (
            (this.transform.minZoom = e),
            this._update(),
            this.getZoom() < e && this.setZoom(e),
            this
          );
        throw new Error('minZoom must be between 0 and the current maxZoom, inclusive');
      }
      getMinZoom() {
        return this.transform.minZoom;
      }
      setMaxZoom(e) {
        if ((e = null == e ? 22 : e) >= this.transform.minZoom)
          return (
            (this.transform.maxZoom = e),
            this._update(),
            this.getZoom() > e && this.setZoom(e),
            this
          );
        throw new Error('maxZoom must be greater than the current minZoom');
      }
      getMaxZoom() {
        return this.transform.maxZoom;
      }
      project(t, i) {
        return this.transform.locationPoint(e.LngLat.convert(t), i);
      }
      unproject(t, i) {
        return this.transform.pointLocation(e.pointGeometry3d.convert(t), i);
      }
      isMoving() {
        return this._moving || (this.handlers && this.handlers.isMoving());
      }
      isZooming() {
        return this._zooming || (this.handlers && this.handlers.isZooming());
      }
      isRotating() {
        return this._rotating || (this.handlers && this.handlers.isRotating());
      }
      _createDelegatedListener(e, t, i) {
        if ('mouseenter' === e || 'mouseover' === e) {
          let s = !1;
          const r = (r) => {
              const n = t.filter((e) => this.getLayer(e)),
                o = n.length ? this.queryRenderedFeatures(r.point, { layers: n }) : [];
              o.length
                ? s || ((s = !0), i.call(this, new Hu(e, this, r.originalEvent, { features: o })))
                : (s = !1);
            },
            n = () => {
              s = !1;
            };
          return { layers: new Set(t), listener: i, delegates: { mousemove: r, mouseout: n } };
        }
        if ('mouseleave' === e || 'mouseout' === e) {
          let s = !1;
          const r = (r) => {
              const n = t.filter((e) => this.getLayer(e));
              (n.length ? this.queryRenderedFeatures(r.point, { layers: n }) : []).length
                ? (s = !0)
                : s && ((s = !1), i.call(this, new Hu(e, this, r.originalEvent)));
            },
            n = (t) => {
              s && ((s = !1), i.call(this, new Hu(e, this, t.originalEvent)));
            };
          return { layers: new Set(t), listener: i, delegates: { mousemove: r, mouseout: n } };
        }
        {
          const s = (e) => {
            const s = t.filter((e) => this.getLayer(e)),
              r = s.length ? this.queryRenderedFeatures(e.point, { layers: s }) : [];
            r.length && ((e.features = r), i.call(this, e), delete e.features);
          };
          return { layers: new Set(t), listener: i, delegates: { [e]: s } };
        }
      }
      on(e, t, i) {
        if (void 0 === i) {
          if (null == t) return;
          return super.on(e, t);
        }
        Array.isArray(t) || (t = [t]);
        const s = this._createDelegatedListener(e, t, i);
        (this._delegatedListeners = this._delegatedListeners || {}),
          (this._delegatedListeners[e] = this._delegatedListeners[e] || []),
          this._delegatedListeners[e].push(s);
        for (const e in s.delegates) this.on(e, s.delegates[e]);
        return this;
      }
      once(e, t, i) {
        if (void 0 === i) return super.once(e, t);
        Array.isArray(t) || (t = [t]);
        const s = this._createDelegatedListener(e, t, i);
        for (const e in s.delegates) this.once(e, s.delegates[e]);
        return this;
      }
      off(e, t, i) {
        if (void 0 === i) return super.off(e, t);
        t = new Set(Array.isArray(t) ? t : [t]);
        const s = (e, t) => {
            if (e.size !== t.size) return !1;
            for (const i of e) if (!t.has(i)) return !1;
            return !0;
          },
          r = this._delegatedListeners ? this._delegatedListeners[e] : void 0;
        return (
          r &&
            ((e) => {
              for (let r = 0; r < e.length; r++) {
                const n = e[r];
                if (n.listener === i && s(n.layers, t)) {
                  for (const e in n.delegates) this.off(e, n.delegates[e]);
                  return e.splice(r, 1), this;
                }
              }
            })(r),
          this
        );
      }
      queryRenderedFeatures(t, i, s) {
        if (!this.style) return [];
        let r;
        if (
          (void 0 !== i ||
            void 0 === t ||
            t instanceof e.pointGeometry3d ||
            Array.isArray(t) ||
            ((i = t), (t = void 0)),
          (i = i || {}),
          (t = t || [
            [0, 0],
            [this.transform.width, this.transform.height],
          ]) instanceof e.pointGeometry3d || 'number' == typeof t[0])
        ) {
          r = [e.pointGeometry3d.convert(t)];
          const n = this.style.queryRenderedFeatures(r, i, this.transform, s);
          return this.sortFeature(n, this.getPositionByGPUPick(t));
        }
        {
          const n = e.pointGeometry3d.convert(t[0]),
            o = e.pointGeometry3d.convert(t[1]);
          r = [n, new e.pointGeometry3d(o.x, n.y), o, new e.pointGeometry3d(n.x, o.y), n];
          const a = this.style.queryRenderedFeatures(r, i, this.transform, s),
            l = e.pointGeometry3d.convert([(n.x + o.x) / 2, (n.y + o.y) / 2]);
          return this.sortFeature(a, this.getPositionByGPUPick(l));
        }
      }
      sortFeature(e, t) {
        if (null == t) return [];
        const i = xp([t[0], t[1]]);
        e.forEach((e) => {
          null == e.geometry && null != e.feature.geometry && (e = e.feature),
            (e.distanceToClick = 1 / 0);
          const t = e.geometry.type;
          if ('Point' == t) {
            const t = xp(e.geometry.coordinates);
            e.distanceToClick = up(i, t, { units: 'miles' });
          } else if ('MultiLineString' == t)
            e.geometry.coordinates.forEach((t) => {
              const s = vp(t),
                r = pp(i, s, { units: 'miles' });
              r < e.distanceToClick && (e.distanceToClick = r);
            });
          else if ('LineString' == t) {
            const t = vp(e.geometry.coordinates),
              s = pp(i, t, { units: 'miles' });
            s < e.distanceToClick && (e.distanceToClick = s);
          } else if ('Polygon' == t || 'MultiPolygon' == t) {
            let t;
            t =
              1 == e.geometry.coordinates.length
                ? Mm(e.geometry.coordinates)
                : (function (e, t) {
                    if (!e) throw new Error('No coordinates passed');
                    return {
                      type: 'Feature',
                      geometry: { type: 'MultiPolygon', coordinates: e },
                      properties: {},
                    };
                  })(e.geometry.coordinates);
            const s = this.distanceToPolygon(i, t);
            s < e.distanceToClick && (e.distanceToClick = s);
          }
        });
        for (let t = 0; t < e.length - 1; t++)
          for (let i = t + 1; i < e.length; i++)
            if (e[t].distanceToClick > e[i].distanceToClick) {
              const s = e[t];
              (e[t] = e[i]), (e[i] = s);
            }
        return e;
      }
      distanceToPolygon(e, t) {
        let i;
        if (('Feature' === t.type && (t = t.geometry), 'MultiPolygon' === t.type))
          i = t.coordinates
            .map((t) => this.distanceToPolygon(e, Mm(t)))
            .reduce((e, t) => (t < e ? t : e));
        else if (t.coordinates.length > 1) {
          const [s, ...r] = t.coordinates.map((t) => this.distanceToPolygon(e, Mm([t]).geometry));
          if (s < 0) {
            const e = r.reduce((e, t) => (t < e ? t : e));
            i = e < 0 || e < s ? e : s;
          } else i = s;
        } else
          i = pp(
            e,
            (function (e, t) {
              void 0 === t && (t = {});
              var i = _p(e);
              switch (
                (t.properties || 'Feature' !== e.type || (t.properties = e.properties), i.type)
              ) {
                case 'Polygon':
                  return (function (e, t) {
                    return (
                      void 0 === t && (t = {}),
                      yp(
                        _p(e).coordinates,
                        t.properties ? t.properties : 'Feature' === e.type ? e.properties : {},
                      )
                    );
                  })(i, t);
                case 'MultiPolygon':
                  return (function (e, t) {
                    void 0 === t && (t = {});
                    var i = _p(e),
                      s = t.properties ? t.properties : 'Feature' === e.type ? e.properties : {},
                      r = [];
                    return (
                      i.coordinates.forEach(function (e) {
                        r.push(yp(e, s));
                      }),
                      (function (e, t) {
                        void 0 === t && (t = {});
                        var i = { type: 'FeatureCollection' };
                        return (
                          t.id && (i.id = t.id), t.bbox && (i.bbox = t.bbox), (i.features = e), i
                        );
                      })(r)
                    );
                  })(i, t);
                default:
                  throw new Error('invalid poly');
              }
            })(t),
            { units: 'miles' },
          );
        return i;
      }
      queryPixelColor(t, i) {
        if (!this.painter) return [];
        let s;
        if (
          (void 0 !== i ||
            void 0 === t ||
            t instanceof e.pointGeometry3d ||
            Array.isArray(t) ||
            ((i = t), (t = void 0)),
          (i = i || {}),
          (t = t || [
            [0, 0],
            [this.transform.width, this.transform.height],
          ]) instanceof e.pointGeometry3d || 'number' == typeof t[0])
        )
          (t = e.pointGeometry3d.convert(t)), (s = [new e.pointGeometry3d(t.x, t.y, 0)]);
        else {
          const i = e.pointGeometry3d.convert(t[0]),
            r = e.pointGeometry3d.convert(t[1]);
          s = [i, new e.pointGeometry3d(r.x, i.y), r, new e.pointGeometry3d(i.x, r.y), i];
        }
        return this.painter.queryPixelColor(s, i);
      }
      querySpherePosition(e, t) {
        return this.queryDEMSourceHeightByPoint(e, t);
      }
      queryDEMSourceHeightByPoint(e, t) {
        return [];
      }
      querySourceFeatures(e, t) {
        return this.style.querySourceFeatures(e, t);
      }
      getStyle() {
        if (this.style) return this.style.serialize();
      }
      setStyle(t, i) {
        return (
          ((i = e.extend({}, { localIdeographFontFamily: Fp.localIdeographFontFamily }, i)).diff =
            e.defaultValue(i.diff, !1)),
          (i.keepUserInfo = e.defaultValue(i.keepUserInfo, !1)),
          (i.useCustomCamera = e.defaultValue(i.useCustomCamera, !0)),
          this.projection === e.ProjectionType.LATLON && (i.projection = e.ProjectionType.LATLON),
          e.defined(this.style) && (this.style.fristClassificationTypeId = void 0),
          (i.keepUserInfo || i.diff) && e.defined(this.style) && e.defined(t)
            ? (this._diffStyle(t, i), this)
            : (this._clearScene(), this._updateStyle(t, i))
        );
      }
      set minHeightToDemSurface(e) {
        this.transform.minHeightToDemSurface = null != e && null != e ? e : 1;
      }
      get minHeightToDemSurface() {
        return this.transform.minHeightToDemSurface;
      }
      _getUIString(e) {
        const t = this._locale[e];
        if (null == t) throw new Error(`Missing UI string '${e}'`);
        return t;
      }
      _updateStyle(e, t) {
        return (
          this.style && (this.style.setEventedParent(null), this.style._remove()),
          e
            ? ((this.style = new zh(this, t || {})),
              this.style.setEventedParent(this, { style: this.style }),
              'string' == typeof e ? this.style.loadURL(e, t) : this.style.loadJSON(e, t),
              this)
            : (delete this.style, this)
        );
      }
      _clearScene() {
        this.animationManager.removeAll(),
          this.videoManager.removeAll(),
          this.postProcessStages.removeAll(),
          this.analysis.cutFillCollection.removeAll(),
          this.analysis.excavationCollection.removeAll(),
          this.analysis.viewDomeCollection.removeAll(),
          this.analysis.viewshed3DCollection.removeAll(),
          this.analysis.sightlineCollection.removeAll(),
          this.analysis.highlightCollection.removeAll(),
          (this.painter.frameState._sunLight = void 0),
          (this.painter.frameState._enableLight = !1),
          (this.painter.frameState._lights = []),
          this._particleSystemCollection.removeAll();
      }
      _lazyInitEmptyStyle() {
        this.style ||
          ((this.style = new zh(this, {})),
          this.style.setEventedParent(this, { style: this.style }),
          this.style.loadEmpty());
      }
      _diffStyle(t, i) {
        if ('string' == typeof t) {
          const s = Tr(t),
            r = this._transformRequest(s, e.ResourceType.Style);
          e.getJSON(r, (t, s) => {
            t ? this.fire(new e.ErrorEvent(t)) : s && this._updateDiff(s, i);
          });
        } else 'object' == typeof t && this._updateDiff(t, i);
      }
      _updateDiff(t, i) {
        try {
          this.style.setState(t, i.keepUserInfo) &&
            (this._update(!0),
            this.fire(new e.Event('style.load')),
            this.fire(
              new e.Event('processStyleJson', {
                dataType: 'style',
                diff: i.diff,
                keepUserInfo: i.keepUserInfo,
                styleJsonData: t,
              }),
            ));
        } catch (s) {
          e.warnOnce(
            `Unable to perform style diff: ${
              s.message || s.error || s
            }.  Rebuilding the style from scratch.`,
          ),
            this._updateStyle(t, i);
        }
      }
      isStyleLoaded() {
        return this.style ? this.style.loaded() : e.warnOnce('There is no style added to the map.');
      }
      addSceneComponent(e) {
        let t;
        if (Array.isArray(e)) {
          t = [];
          for (let i = 0; i < e.length; i++) t.push(this.style.addSceneComponent(e[i]));
        } else t = this.style.addSceneComponent(e);
        return t;
      }
      getSceneComponent(e) {
        if (this.style) return this.style.getSceneComponent(e);
      }
      removeSceneComponent(e) {
        if (this.style) return this.style.removeSceneComponent(e);
      }
      addPrimitive(e) {
        if (Array.isArray()) for (let t = 0; t < e.length; t++) this.style.addPrimitive(e[t]);
        else this.style.addPrimitive(e);
        return e;
      }
      removePrimitive(e) {
        this.style.removePrimitive(e);
      }
      removePrimitiveById(e) {
        this.style.removePrimitiveById(e);
      }
      getPrimitiveById(e) {
        return this.style.getPrimitiveById(e);
      }
      addParticleSystem(e) {
        this._particleSystemCollection.add(e);
      }
      removeParticleSystemById(e) {
        return this._particleSystemCollection.remove(e, this);
      }
      addSource(e, t) {
        return (
          '3d-tiles' === t.type &&
            console.warn('该添加3d-tiles到source方法已被废弃，请使用addSceneComponent替换！'),
          this._lazyInitEmptyStyle(),
          this.style.addSource(e, t),
          this._update(!0),
          this
        );
      }
      isSourceLoaded(t) {
        const i = this.style && this.style.sourceCaches[t];
        if (void 0 !== i) return i.loaded();
        this.fire(new e.ErrorEvent(new Error(`There is no source with ID '${t}'`)));
      }
      areTilesLoaded() {
        const e = this.style && this.style.sourceCaches;
        for (const t in e) if (!e[t].loaded()) return !1;
        return !!(
          this.style.modelCollection.loaded() &&
          this.style.tilesetCollection.loaded() &&
          this.style.sceneObjectCollection.loaded() &&
          this.style.scenePointPrimitiveCollection.loaded()
        );
      }
      addSourceType(e, t, i) {
        return this._lazyInitEmptyStyle(), this.style.addSourceType(e, t, i);
      }
      removeSource(e) {
        return this.style.removeSource(e), this._update(!0), this;
      }
      getSource(e) {
        if (this.style) return this.style.getSource(e);
      }
      addImage(
        t,
        i,
        { pixelRatio: s = 1, sdf: r = !1, stretchX: n, stretchY: o, content: a } = {},
      ) {
        if ((this._lazyInitEmptyStyle(), i instanceof Gp || (zp && i instanceof zp))) {
          const { width: l, height: h, data: c } = e.exported.getImageData(i);
          this.style.addImage(t, {
            data: new e.RGBAImage({ width: l, height: h }, c),
            pixelRatio: s,
            stretchX: n,
            stretchY: o,
            content: a,
            sdf: r,
            version: 0,
          });
        } else {
          if (void 0 === i.width || void 0 === i.height)
            return this.fire(
              new e.ErrorEvent(
                new Error(
                  'Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`',
                ),
              ),
            );
          {
            const { width: l, height: h, data: c } = i,
              _ = i;
            this.style.addImage(t, {
              data: new e.RGBAImage({ width: l, height: h }, new Uint8Array(c)),
              pixelRatio: s,
              stretchX: n,
              stretchY: o,
              content: a,
              sdf: r,
              version: 0,
              userImage: _,
            }),
              _.onAdd && _.onAdd(this, t);
          }
        }
      }
      updateImage(t, i) {
        const s = this.style.getImage(t);
        if (!s)
          return this.fire(
            new e.ErrorEvent(
              new Error(
                'The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.',
              ),
            ),
          );
        const r = i instanceof Gp || (zp && i instanceof zp) ? e.exported.getImageData(i) : i,
          { width: n, height: o, data: a } = r;
        return void 0 === n || void 0 === o
          ? this.fire(
              new e.ErrorEvent(
                new Error(
                  'Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`',
                ),
              ),
            )
          : n !== s.data.width || o !== s.data.height
          ? this.fire(
              new e.ErrorEvent(
                new Error(
                  'The width and height of the updated image must be that same as the previous version of the image',
                ),
              ),
            )
          : (s.data.replace(a, !(i instanceof Gp || (zp && i instanceof zp))),
            void this.style.updateImage(t, s));
      }
      hasImage(t) {
        return t
          ? !!this.style.getImage(t)
          : (this.fire(new e.ErrorEvent(new Error('Missing required image id'))), !1);
      }
      removeImage(e) {
        this.style.removeImage(e);
      }
      loadImage(t, i) {
        e.getImage(this._transformRequest(t, e.ResourceType.Image), i);
      }
      loadImages(e, t) {
        const i = {};
        e.forEach((s) => {
          this.loadImage(s, (r, n) => {
            r ? t(r) : ((i[s] = n), Object.keys(i).length === e.length && t(null, i));
          });
        });
      }
      listImages() {
        return this.style.listImages();
      }
      addLayer(e, t) {
        return (
          this._lazyInitEmptyStyle(),
          '3d-tiles' === e.type &&
            console.warn('该添加3d-tiles到layer方法已被废弃，请使用addSceneComponent替换！'),
          this.style.addLayer(e, t),
          this._update(!0),
          this.overviewMapInstance && this.updateOverviewMap(e),
          this
        );
      }
      addLight(e) {
        e instanceof Ds
          ? (this.painter.frameState._sunLight = e)
          : this.painter.frameState._lights.push(e);
      }
      removeLight(e) {
        e instanceof Ds
          ? e.id == this.painter.frameState._sunLight.id
            ? (this.painter.frameState._sunLight = void 0)
            : console.warn('不存在此光源')
          : (this.painter.frameState._lights = this.painter.frameState._lights.filter(
              (t) => t.id != e.id,
            ));
      }
      updatePointLightShadow() {
        this.painter.frameState._lights.length > 0 &&
          this.painter.frameState._lights.forEach((e) => {
            e instanceof Au && (e.shadowRepaint = !0);
          });
      }
      getLights() {
        const e = [];
        return (
          this.painter.frameState._lights.length > 0 &&
            this.painter.frameState._lights.forEach((t) => {
              e.push(t);
            }),
          null != this.painter.frameState._sunLight && e.push(this.painter.frameState._sunLight),
          e
        );
      }
      enableLight() {
        this.painter.frameState._enableLight = !0;
      }
      disableLight() {
        this.painter.frameState._enableLight = !1;
      }
      getId(e) {
        return this.style.getId(e);
      }
      moveLayer(e, t) {
        return this.style.moveLayer(e, t), this._update(!0), this;
      }
      upwordMoveLayer(e, t) {
        return this.style.upwordMoveLayer(e, t), this._update(!0), this;
      }
      removeLayer(e) {
        return (
          this.style.removeLayer(e),
          this._update(!0),
          this.overviewMapInstance &&
            void 0 !== this.overviewMapInstance.style.getLayer(e) &&
            (this.overviewMapInstance.style.removeLayer(e), this.overviewMapInstance._update(!0)),
          this
        );
      }
      getLayer(e) {
        return this.style.getLayer(e);
      }
      setFilter(e, t) {
        return this.style.setFilter(e, t), this._update(!0), this;
      }
      setSourceFilter(e, t) {
        return this.style.setSourceFilter(e, t), this._update(!0), this;
      }
      setLayerZoomRange(e, t, i) {
        return this.style.setLayerZoomRange(e, t, i), this._update(!0), this;
      }
      getFilter(e) {
        return this.style.getFilter(e);
      }
      setPaintProperty(e, t, i) {
        return this.style.setPaintProperty(e, t, i), this._update(!0), this;
      }
      getPaintProperty(e, t) {
        return this.style.getPaintProperty(e, t);
      }
      setLayoutProperty(e, t, i) {
        return this.style.setLayoutProperty(e, t, i), this._update(!0);
      }
      getLayoutProperty(e, t) {
        return this.style.getLayoutProperty(e, t);
      }
      setTime() {
        let e;
        void 0 === this._time
          ? ((e = new Date().getTime()),
            this.painter?.frameState?.sunLight && (this.painter.frameState.sunLight.timestamp = e),
            this._update(!0))
          : this.setSunLight(this._time);
      }
      setSunLight(e) {
        const t = new Date(),
          i = new Date(
            e.year || t.getFullYear(),
            e.month - 1,
            e.day,
            e.hour,
            e.minute,
            0,
          ).getTime();
        this.painter?.frameState?.sunLight && (this.painter.frameState.sunLight.timestamp = i),
          this._update(!0);
      }
      getSunDuration(e, t) {
        const i = (function (e, t) {
          const i = Os(t.month),
            s = 23.45 * Math.sin((((360 * (i + t.day - 80)) / 370) * Math.PI) / 180),
            r = Math.PI / 180,
            n = 180 / Math.PI,
            o = Math.tan(e * r) * Math.tan(s * r);
          let a;
          a = o >= 1 ? Math.PI : o < -1 ? 0 : Math.acos(-o);
          const l = (2 / 15) * a * n;
          return [12 - l / 2, 12 + l / 2];
        })(e, t);
        return i;
      }
      setCameraFlyingHeight(e) {
        console.error('调用的setCameraFlyingHeight的方法无效，请参见文档的迁移建议');
      }
      setViewshedVisibleColor() {}
      setViewshedInVisibleColor() {}
      enableShadow(t) {
        t == e.ShadowsType.ShadowMapping || t == e.ShadowsType.PCF
          ? ((this._shadows = !0),
            this.painter.setShadows(this._shadows),
            this.painter.frameState.setShadows(this._shadows),
            (this.painter.frameState._shadowModel = t),
            this._update(!0),
            console.warn('点光源阴影效果当前仅支持最多6个点光源,多余的点光源将不产生阴影!!'))
          : console.warn(`不支持输入阴影类型: ${t}`);
      }
      disableShadow() {
        (this._shadows = !1),
          this.painter.setShadows(this._shadows),
          this.painter.frameState.setShadows(this._shadows),
          (this.painter.frameState._shadowModel = e.ShadowsType.NONE),
          this._update(!0);
      }
      enableNearDetection() {
        (this._nearDetection = !0), this.painter.setNearDetection(this._nearDetection);
      }
      disableNearDetection() {
        (this._nearDetection = !1), this.painter.setNearDetection(this._nearDetection);
      }
      enableNormalPass() {
        (this._enableNormal = !0), this.painter.setNormalPass(this._enableNormal);
      }
      disableNormalPass() {
        (this._enableNormal = !1), this.painter.setNormalPass(this._enableNormal);
      }
      setResolvePass(e) {
        (this._resolvePass = e), this.painter.setResolvePass(e);
      }
      setFeatureState(e, t) {
        return this.style.setFeatureState(e, t), this._update();
      }
      removeFeatureState(e, t) {
        return this.style.removeFeatureState(e, t), this._update();
      }
      getFeatureState(e) {
        return this.style.getFeatureState(e);
      }
      get trackingOptions() {
        return this._trackingOptions;
      }
      set trackingOptions(e) {
        this._trackingOptions = e;
      }
      get roamingOptions() {
        return this._roamingOptions;
      }
      set roamingOptions(e) {
        this._roamingOptions = e;
      }
      getContainer() {
        return this._container;
      }
      getCanvasContainer() {
        return this._canvasContainer;
      }
      getCanvas() {
        return this._canvas;
      }
      _updateContainerDimensions() {
        if (!this._container) return;
        const t = this._container.getBoundingClientRect().width || 400,
          i = this._container.getBoundingClientRect().height || 300;
        let s,
          r = this._container;
        for (; r && !s; ) {
          const t = e.window.getComputedStyle(r).transform;
          t && 'none' !== t && (s = t.match(/matrix.*\((.+)\)/)[1].split(', ')),
            (r = r.parentElement);
        }
        s
          ? ((this._containerWidth = s[0] && '0' !== s[0] ? Math.abs(t / s[0]) : t),
            (this._containerHeight = s[3] && '0' !== s[3] ? Math.abs(i / s[3]) : i))
          : ((this._containerWidth = t), (this._containerHeight = i));
      }
      _detectMissingCSS() {
        'rgb(250, 128, 114)' !==
          e.window.getComputedStyle(this._missingCSSCanary).getPropertyValue('background-color') &&
          e.warnOnce('当前页面没有找到minemap.css声明，可能会产生一些页面布局或者渲染错误。');
      }
      _setupContainer() {
        const e = this._container;
        e.classList.add('minemap-map'),
          ((this._missingCSSCanary = Ur.create('div', 'minemap-canary', e)).style.visibility =
            'hidden'),
          this._detectMissingCSS();
        const t = (this._canvasContainer = Ur.create('div', 'minemap-canvas-container', e));
        this._interactive && t.classList.add('minemap-interactive'),
          (this._canvas = Ur.create('canvas', 'minemap-canvas', t)),
          (this._canvas.style.position = 'absolute'),
          (this._canvas.style.left = '0'),
          this._canvas.addEventListener('webglcontextlost', this._contextLost, !1),
          this._canvas.addEventListener('webglcontextrestored', this._contextRestored, !1),
          this._canvas.setAttribute('tabindex', '0'),
          this._canvas.setAttribute('aria-label', 'Map'),
          this._canvas.setAttribute('role', 'region'),
          this._updateContainerDimensions(),
          this._resizeCanvas(this._containerWidth, this._containerHeight);
        const i = (this._controlContainer = Ur.create('div', 'minemap-control-container', e)),
          s = (this._controlPositions = {});
        ['top-left', 'top-right', 'bottom-left', 'bottom-right'].forEach((e) => {
          s[e] = Ur.create('div', `minemap-ctrl-${e}`, i);
        }),
          this._container.addEventListener('scroll', this._onMapScroll, !1);
      }
      _resizeCanvas(t, i) {
        const s = e.window.devicePixelRatio || 1;
        (this._canvas.width = s * Math.ceil(t)),
          (this._canvas.height = s * Math.ceil(i)),
          (this._canvas.style.width = `${t}px`),
          (this._canvas.style.height = `${i}px`);
      }
      _setupPainter() {
        const t = e.extend(
            {
              failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,
              preserveDrawingBuffer: this._preserveDrawingBuffer,
            },
            sm.webGLContextAttributes,
          ),
          i =
            this._canvas.getContext('webgl', t) || this._canvas.getContext('experimental-webgl', t);
        i
          ? ((this.painter = new Lu(i, this)),
            (this.painter.postProcessStages.fxaa.enabled = this._fxaaRender),
            this.painter.setShadows(this._shadows),
            1 == this._shadows &&
              console.warn('点光源阴影效果当前仅支持最多6个点光源,多余的点光源将不产生阴影!!'),
            this.painter.frameState.setShadows(this._shadows),
            this.painter.setNearDetection(this._nearDetection),
            this.painter.setNormalPass(this._enableNormal),
            this.painter.setResolvePass(this._resolvePass),
            (this.painter.frameState._shadowModel = this._shadowsType),
            (this.painter.mainPass.SSAASamples = this._SSAASamples))
          : this.fire(new e.ErrorEvent(new Error('Failed to initialize WebGL')));
      }
      _contextLost(t) {
        t.preventDefault(),
          this._frame && (this._frame.cancel(), (this._frame = null)),
          this.fire(new e.Event('webglcontextlost', { originalEvent: t }));
      }
      _contextRestored(t) {
        this._setupPainter(),
          this.resize(),
          this._update(),
          this.fire(new e.Event('webglcontextrestored', { originalEvent: t }));
      }
      _onMapScroll(e) {
        if (e.target === this._container)
          return (this._container.scrollTop = 0), (this._container.scrollLeft = 0), !1;
      }
      loaded() {
        return !this._styleDirty && !(!this.style || !this.style.loaded());
      }
      _update(e) {
        this.style &&
          ((this._styleDirty = this._styleDirty || e),
          (this._sourcesDirty = !0),
          this.updatePointLightShadow(),
          this.triggerRepaint());
      }
      _requestRenderFrame(e) {
        return this._update(), this._renderTaskQueue.add(e);
      }
      _cancelRenderFrame(e) {
        this._renderTaskQueue.remove(e);
      }
      _requestDomTask(e) {
        !this.loaded() || (this.loaded() && !this.isMoving())
          ? e()
          : this._domRenderTaskQueue.add(e);
      }
      _render(t) {
        if (
          (this.painter.setBaseState(),
          this._renderTaskQueue.run(t),
          this._domRenderTaskQueue.run(t),
          this._removed)
        )
          return;
        let i = !1;
        if (this.style && this._styleDirty) {
          this._styleDirty = !1;
          const t = this.transform.zoom,
            s = e.exported.now();
          this.style.zoomHistory.update(t, s);
          const r = new e.EvaluationParameters(t, {
              now: s,
              fadeDuration: this._fadeDuration,
              zoomHistory: this.style.zoomHistory,
              transition: this.style.getTransition(),
            }),
            n = r.crossFadingFactor();
          (1 === n && n === this._crossFadingFactor) || ((i = !0), (this._crossFadingFactor = n)),
            this.style.update(r);
        }
        return (
          (this._sourcesDirty = !1),
          this.style._updateSources(),
          (this._placementDirty =
            this.style &&
            this.style._updatePlacement(
              this.painter.transform,
              this.showCollisionBoxes,
              this._fadeDuration,
              this._crossSourceCollisions,
              !1,
              this._symbolNumStrategy,
            )),
          this.painter.render(this.style, {
            showTileBoundaries: this.showTileBoundaries,
            showOverdrawInspector: this._showOverdrawInspector,
            showDebugBoundingBox: this._showDebugBoundingBox,
            rotating: this.isRotating(),
            zooming: this.isZooming(),
            fadeDuration: this._fadeDuration,
          }),
          this.fire(new e.Event('render')),
          this.loaded() && !this._loaded && ((this._loaded = !0), this.fire(new e.Event('load'))),
          this.style && (this.style.hasTransitions() || i) && (this._styleDirty = !0),
          this._sourcesDirty || this._repaint || this._styleDirty || this._placementDirty
            ? this.triggerRepaint()
            : !this.isMoving() && this.loaded() && this.fire(new e.Event('idle')),
          this
        );
      }
      setTerrain(e) {
        for (const t in e) this.style.terrainSourceCache._source[t] = e[t];
        this._terrainFlag = !0;
      }
      remove() {
        this._hash && this._hash.remove();
        for (const e of this._controls) e.onRemove(this);
        (this._controls = []),
          this._frame && (this._frame.cancel(), (this._frame = null)),
          this._renderTaskQueue.clear(),
          this._domRenderTaskQueue.clear(),
          this.style?.sharedTerrainTileCache?.removeAllTerrainTile(),
          this.style?.clearWorkerCaches(),
          this.painter.destroy(),
          this.handlers.destroy(),
          delete this.handlers,
          this.setStyle(null),
          void 0 !== e.window &&
            (e.window.removeEventListener('resize', this._onWindowResize, !1),
            e.window.removeEventListener('orientationchange', this._onWindowResize, !1),
            e.window.removeEventListener('webkitfullscreenchange', this._onWindowResize, !1),
            e.window.removeEventListener('online', this._onWindowOnline, !1));
        const t = this.painter.context.gl.getExtension('WEBGL_lose_context');
        t && t.loseContext(),
          Wp(this._canvasContainer),
          Wp(this._controlContainer),
          Wp(this._missingCSSCanary),
          this._container.classList.remove('minemap-map'),
          (this._removed = !0),
          this.fire(new e.Event('remove')),
          this.removeOverviewMap();
      }
      triggerRepaint() {
        this.style &&
          !this._frame &&
          (this._frame = e.exported.frame((e) => {
            (this._frame = null),
              this.timer.update(e),
              this._updateSyncAnimation(this.timer.getDelta()),
              this._render(e),
              this.roam();
          }));
      }
      getAllLayers() {
        return this.style._layers || {};
      }
      getAllSources() {
        const e = this.style.sourceCaches,
          t = {};
        if (!(Object.keys(e).length > 0)) throw new Error('No data source');
        for (const i in e) e.hasOwnProperty(i) && (t[i] = this.getSource(i));
        return t;
      }
      getAllPopups() {
        return this.__popupList;
      }
      _rerender() {
        this.style &&
          !this._frame &&
          (this._frame = e.exported.frame(() => {
            (this._frame = null), this._render(), this.timer.update();
          }));
      }
      _onWindowOnline() {
        this._update();
      }
      _onWindowResize() {
        this._trackResize && this.resize()._update();
      }
      get showTileBoundaries() {
        return !!this._showTileBoundaries;
      }
      set showTileBoundaries(e) {
        this._showTileBoundaries !== e && ((this._showTileBoundaries = e), this._update());
      }
      get showCollisionBoxes() {
        return !!this._showCollisionBoxes;
      }
      set showCollisionBoxes(e) {
        this._showCollisionBoxes !== e &&
          ((this._showCollisionBoxes = e),
          e ? this.style._generateCollisionBoxes() : this._update());
      }
      get showOverdrawInspector() {
        return !!this._showOverdrawInspector;
      }
      set showOverdrawInspector(e) {
        this._showOverdrawInspector !== e && ((this._showOverdrawInspector = e), this._update());
      }
      get showDebugBoundingBox() {
        return !!this._showDebugBoundingBox;
      }
      set showDebugBoundingBox(e) {
        this._showDebugBoundingBox !== e &&
          ((this._showDebugBoundingBox = e),
          this._showDebugBoundingBox ||
            this.style.debugBoundingBoxPrimitiveCollection.removeAll(!0),
          this._update());
      }
      get repaint() {
        return !!this._repaint;
      }
      set repaint(e) {
        (this._repaint = e), (this.timer.state = !!e), this._update();
      }
      set fxaa(e) {
        (this._fxaaRender = e), (this.painter.postProcessStages.fxaa.enabled = e);
      }
      get fxaa() {
        return this._fxaaRender;
      }
      set SSAASamples(e) {
        const t = Math.floor(
          Math.min(
            this.painter.context.gl.getParameter(this.painter.context.gl.MAX_TEXTURE_SIZE) /
              this.painter.width,
            this.painter.context.gl.getParameter(this.painter.context.gl.MAX_TEXTURE_SIZE) /
              this.painter.height,
          ),
        );
        (this._SSAASamples = Math.max(1, Math.min(e, t))),
          (this.painter.mainPass.SSAASamples = this._SSAASamples);
      }
      get SSAASamples() {
        return this._SSAASamples;
      }
      set hdr(e) {
        this.painter.postProcessStages.useHdr = e;
      }
      get hdr() {
        return this.painter.postProcessStages.useHdr;
      }
      set bloom(e) {
        (this._bloomRender = e), (this.painter.postProcessStages.bloom.enabled = e);
      }
      get bloom() {
        return this._bloomRender;
      }
      get postProcessStages() {
        return this.painter.postProcessStages;
      }
      get projection() {
        return this.mapProjection._projection;
      }
      set projection(t) {
        (t !== e.ProjectionType.MERCATOR && t !== e.ProjectionType.LATLON) ||
          (this.mapProjection._projection = t);
      }
      get vertices() {
        return !!this._vertices;
      }
      set vertices(e) {
        (this._vertices = e), this._update();
      }
      get fPMode() {
        return null;
      }
      set fPMode(e) {}
      setBloomOptions(e) {
        e && (this._bloomOptions = e);
      }
      _onData(t) {
        if ('cesium-tile' === t.dataType) (this._sourcesDirty = !1), this.triggerRepaint();
        else if ('gltf-data-loaded' === t.dataType) this._update(!1, !0);
        else {
          this._update('style' === t.dataType, !1);
          const i = t.styleJsonData;
          e.defined(i) && e.defined(i.cameraPosition) && this.setCameraPosition(i.cameraPosition),
            this.fire(new e.Event(`${t.dataType}data`, t));
        }
      }
      _processStyleJson(t) {
        const i = t.styleJsonData;
        'style' === t.dataType && e.defined(i) && kp.deserialize(this, i, t);
      }
      _onDataLoading(t) {
        this.fire(new e.Event(`${t.dataType}dataloading`, t));
      }
      getTDSpaceCoord(t) {
        if (t.disableLayer) {
          const i = this.unproject(t.point, 0);
          return {
            lngLat: i,
            geographic: i
              ? e.Transforms.cartographicToCartesian3(new e.Vector3([i.lng, i.lat, 0]))
              : null,
            altitude: 0,
          };
        }
        {
          const i = this.queryRenderedFeatures(t.point, {
            disableLayer: !1,
            modelHighlight: t.modelHighlight,
            highlightRange: t.highlightRange || e.CONSTS.HIGHLIGHT_TYPE.PRIMITIVE,
          });
          if (0 === i.length) {
            const i = this.unproject(t.point, 0);
            return {
              lngLat: i,
              geographic: i
                ? e.Transforms.cartographicToCartesian3(new e.Vector3([i.lng, i.lat, 0]))
                : null,
              altitude: 0,
            };
          }
          {
            let s = null;
            for (let e = 0; e < i.length; e++)
              i[e].hasOwnProperty('intersectionPoint') && (s = i[e].intersectionPoint);
            if (s) {
              const t = e.Transforms.cartesian3ToCartographic(new e.Vector3(s));
              return {
                geographic: s,
                lngLat: new e.LngLat(t[0], t[1]),
                altitude: t[2] * e.CONSTS.TRANSFORM.R_ZOOM,
              };
            }
            {
              const i = this.unproject(t.point, 0);
              return {
                lngLat: i,
                geographic: i
                  ? e.Transforms.cartographicToCartesian3(new e.Vector3([i.lng, i.lat, 0]))
                  : null,
                altitude: 0,
              };
            }
          }
        }
      }
      setTimerCount(e) {
        (this.timer.totalTime = e), (this._stopTimerCount = !1), this.timer.resumeTimer();
      }
      pauseTimerCount() {
        this._stopTimerCount || this.timer.pauseTimer();
      }
      resumeTimerCount() {
        this._stopTimerCount || this.timer.resumeTimer();
      }
      stopTimerCount() {
        (this._stopTimerCount = !0), this.timer.pauseTimer();
      }
      getCameraHeight() {
        return +this.transform.position[2].toFixed(2);
      }
      get camera() {
        return this.painter.frameState.camera;
      }
      setMinPitch(e) {
        if ((e = null == e ? 0 : e) < 0)
          throw new Error('minPitch must be greater than or equal to 0');
        if (e >= 0 && e <= this.transform.maxPitch)
          return (
            (this.transform.minPitch = e),
            this._update(),
            this.getPitch() < e && this.setPitch(e),
            this
          );
        throw new Error('minPitch must be between 0 and the current maxPitch, inclusive');
      }
      getMinPitch() {
        return this.transform.minPitch;
      }
      setMaxPitch(e) {
        if ((e = null == e ? 85 : e) > 85)
          throw new Error('maxPitch must be less than or equal to 85');
        if (e >= this.transform.minPitch)
          return (
            (this.transform.maxPitch = e),
            this._update(),
            this.getPitch() > e && this.setPitch(e),
            this
          );
        throw new Error('maxPitch must be greater than the current minPitch');
      }
      getMaxPitch() {
        return this.transform.maxPitch;
      }
      addFPSControl() {
        return (
          this.fpsControl ||
            ((this.fpsControl = new im()), this.addControl(this.fpsControl, 'top-right')),
          this.fpsControl
        );
      }
      removeFPSControl() {
        this.fpsControl && (this.removeControl(this.fpsControl), (this.fpsControl = null));
      }
      getFeatureByGPUPick(e) {
        return this.painter.getFeatureByGPUPick(e);
      }
      getFeatureByPickColor(e) {
        return this.painter.getFeatureByPickColor(e);
      }
      getPositionByGPUPick(e) {
        return this.painter.getPositionByGPUPick(e);
      }
      _updateSyncAnimation(e) {
        this.animationManager.update(e),
          this._particleSystemCollection.collection.length > 0 &&
            this._particleSystemCollection.collection.forEach((t) => {
              t.update(e, this);
            });
      }
    }
    function Wp(e) {
      e.parentNode && e.parentNode.removeChild(e);
    }
    const jp = { showCompass: !0, showZoom: !0, visualizePitch: !1 };
    class qp {
      constructor(t, i, s = !1) {
        (this._clickTolerance = 10),
          (this.element = i),
          (this.mouseRotate = new id({
            clickTolerance: t.dragRotate._mouseRotate._clickTolerance,
          })),
          (this.map = t),
          s &&
            (this.mousePitch = new sd({
              clickTolerance: t.dragRotate._mousePitch._clickTolerance,
            })),
          e.bindAll(
            ['mousedown', 'mousemove', 'mouseup', 'touchstart', 'touchmove', 'touchend', 'reset'],
            this,
          ),
          Ur.addEventListener(i, 'mousedown', this.mousedown),
          Ur.addEventListener(i, 'touchstart', this.touchstart, { passive: !1 }),
          Ur.addEventListener(i, 'touchmove', this.touchmove),
          Ur.addEventListener(i, 'touchend', this.touchend),
          Ur.addEventListener(i, 'touchcancel', this.reset);
      }
      down(e, t) {
        this.mouseRotate.mousedown(e, t),
          this.mousePitch && this.mousePitch.mousedown(e, t),
          Ur.disableDrag();
      }
      move(e, t) {
        const i = this.map,
          s = this.mouseRotate.mousemoveWindow(e, t);
        if (
          (s && s.bearingDelta && i.setBearing(i.getBearing() + s.bearingDelta), this.mousePitch)
        ) {
          const s = this.mousePitch.mousemoveWindow(e, t);
          s && s.pitchDelta && i.setPitch(i.getPitch() + s.pitchDelta);
        }
      }
      off() {
        const e = this.element;
        Ur.removeEventListener(e, 'mousedown', this.mousedown),
          Ur.removeEventListener(e, 'touchstart', this.touchstart, { passive: !1 }),
          Ur.removeEventListener(e, 'touchmove', this.touchmove),
          Ur.removeEventListener(e, 'touchend', this.touchend),
          Ur.removeEventListener(e, 'touchcancel', this.reset),
          this.offTemp();
      }
      offTemp() {
        Ur.enableDrag(),
          Ur.removeEventListener(e.window, 'mousemove', this.mousemove),
          Ur.removeEventListener(e.window, 'mouseup', this.mouseup);
      }
      mousedown(t) {
        this.down(
          e.extend({}, t, { ctrlKey: !0, preventDefault: () => t.preventDefault() }),
          Ur.mousePos(this.element, t),
        ),
          Ur.addEventListener(e.window, 'mousemove', this.mousemove),
          Ur.addEventListener(e.window, 'mouseup', this.mouseup);
      }
      mousemove(e) {
        this.move(e, Ur.mousePos(this.element, e));
      }
      mouseup(e) {
        this.mouseRotate.mouseupWindow(e),
          this.mousePitch && this.mousePitch.mouseupWindow(e),
          this.offTemp();
      }
      touchstart(e) {
        1 !== e.targetTouches.length
          ? this.reset()
          : ((this._startPos = this._lastPos = Ur.touchPos(this.element, e.targetTouches)[0]),
            this.down(
              {
                type: 'mousedown',
                button: 0,
                ctrlKey: !0,
                preventDefault: () => e.preventDefault(),
              },
              this._startPos,
            ));
      }
      touchmove(e) {
        1 !== e.targetTouches.length
          ? this.reset()
          : ((this._lastPos = Ur.touchPos(this.element, e.targetTouches)[0]),
            this.move({ preventDefault: () => e.preventDefault() }, this._lastPos));
      }
      touchend(e) {
        0 === e.targetTouches.length &&
          this._startPos &&
          this._lastPos &&
          this._startPos.dist(this._lastPos) < this._clickTolerance &&
          this.element.click(),
          this.reset();
      }
      reset() {
        this.mouseRotate.reset(),
          this.mousePitch && this.mousePitch.reset(),
          delete this._startPos,
          delete this._lastPos,
          this.offTemp();
      }
    }
    const Xp = {
        positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 },
        fitBoundsOptions: { maxZoom: 15 },
        trackUserLocation: !1,
        showUserLocation: !0,
      },
      Zp = 'minemap-ctrl';
    let $p;
    var Kp = 'object' == typeof global && global && global.Object === Object && global,
      Yp = 'object' == typeof self && self && self.Object === Object && self,
      Qp = Kp || Yp || Function('return this')(),
      Jp = Qp.Symbol,
      ef = Object.prototype,
      tf = ef.hasOwnProperty,
      sf = ef.toString,
      rf = Jp ? Jp.toStringTag : void 0,
      nf = Object.prototype.toString,
      of = Jp ? Jp.toStringTag : void 0,
      af = /\s/,
      lf = /^\s+/;
    function hf(e) {
      var t = typeof e;
      return null != e && ('object' == t || 'function' == t);
    }
    var cf = /^[-+]0x[0-9a-f]+$/i,
      _f = /^0b[01]+$/i,
      uf = /^0o[0-7]+$/i,
      df = parseInt;
    function mf(e) {
      if ('number' == typeof e) return e;
      if (
        (function (e) {
          return (
            'symbol' == typeof e ||
            ((function (e) {
              return null != e && 'object' == typeof e;
            })(e) &&
              '[object Symbol]' ==
                (function (e) {
                  return null == e
                    ? void 0 === e
                      ? '[object Undefined]'
                      : '[object Null]'
                    : of && of in Object(e)
                    ? (function (e) {
                        var t = tf.call(e, rf),
                          i = e[rf];
                        try {
                          e[rf] = void 0;
                          var s = !0;
                        } catch (e) {}
                        var r = sf.call(e);
                        return s && (t ? (e[rf] = i) : delete e[rf]), r;
                      })(e)
                    : (function (e) {
                        return nf.call(e);
                      })(e);
                })(e))
          );
        })(e)
      )
        return NaN;
      if (hf(e)) {
        var t = 'function' == typeof e.valueOf ? e.valueOf() : e;
        e = hf(t) ? t + '' : t;
      }
      if ('string' != typeof e) return 0 === e ? e : +e;
      var i;
      e = (i = e)
        ? i
            .slice(
              0,
              (function (e) {
                for (var t = e.length; t-- && af.test(e.charAt(t)); );
                return t;
              })(i) + 1,
            )
            .replace(lf, '')
        : i;
      var s = _f.test(e);
      return s || uf.test(e) ? df(e.slice(2), s ? 2 : 8) : cf.test(e) ? NaN : +e;
    }
    var pf = function () {
        return Qp.Date.now();
      },
      ff = Math.max,
      gf = Math.min;
    const yf = { maxWidth: 100, unit: 'metric' };
    function Tf(t, i, s, r) {
      const n = (r && r.maxWidth) || 100,
        o = t._container.getBoundingClientRect().height / 2,
        a = t._container.getBoundingClientRect().width / 2,
        l = t.unproject([a, o]),
        h = t.unproject([a + 1, o]);
      if (!l || !h) return;
      const c =
        (function (t, i) {
          const s = e.CONSTS.TRANSFORM.R,
            r = Math.PI / 180,
            n = t.lat * r,
            o = i.lat * r,
            a =
              Math.sin(n) * Math.sin(o) + Math.cos(n) * Math.cos(o) * Math.cos((i.lng - t.lng) * r);
          return s * Math.acos(Math.min(a, 1));
        })(t.unproject([a, o]), t.unproject([a + 1, o])) * n;
      if (r && 'imperial' === r.unit) {
        const e = 3.2808 * c;
        e > 5280
          ? xf(i, s, n, e / 5280, t._getUIString('ScaleControl.Miles'), t)
          : xf(i, s, n, e, t._getUIString('ScaleControl.Feet'), t);
      } else r && 'nautical' === r.unit ? xf(i, s, n, c / 1852, t._getUIString('ScaleControl.NauticalMiles'), t) : c >= 1e3 ? xf(i, s, n, c / 1e3, t._getUIString('ScaleControl.Kilometers'), t) : xf(i, s, n, c, t._getUIString('ScaleControl.Meters'), t);
    }
    function xf(e, t, i, s, r, n) {
      const o = (function (e) {
          const t = Math.pow(10, `${Math.floor(e)}`.length - 1);
          let i = e / t;
          return (i = i >= 10 ? 10 : i >= 5 ? 5 : i >= 3 ? 3 : i >= 2 ? 2 : 1), t * i;
        })(s),
        a = o / s;
      n._requestDomTask(() => {
        (e.style.width = i * a + 'px'), (e.innerHTML = `${o}&nbsp;${r}`);
      }),
        (t.innerHTML = o + r);
    }
    const vf = {
        closeButton: !0,
        closeOnClick: !0,
        focusAfterOpen: !0,
        className: '',
        maxWidth: '240px',
      },
      bf = [
        'a[href]',
        "[tabindex]:not([tabindex='-1'])",
        "[contenteditable]:not([contenteditable='false'])",
        'button:not([disabled])',
        'input:not([disabled])',
        'select:not([disabled])',
        'textarea:not([disabled])',
      ].join(', ');
    var wf = Object.freeze({ DISABLED: 0, ENABLED: 1, CAST_ONLY: 2, RECEIVE_ONLY: 3 }),
      Cf = Object.freeze({
        __proto__: null,
        MathArray: e.MathArray,
        Vector: e.Vector,
        Vector2: e.Vector2,
        Vector3: e.Vector3,
        Vector4: e.Vector4,
        Cartographic: e.Cartographic,
        Matrix: e.Matrix,
        Matrix2: e.Matrix2,
        Matrix3: e.Matrix3,
        Matrix4: e.Matrix4,
        Quaternion: e.Quaternion,
        HeadingPitchRoll: e.HeadingPitchRoll,
        Euler: e.Euler,
        toRadians: e.toRadians,
        toDegrees: e.toDegrees,
      });
    class Sf {
      constructor(t, i) {
        (t = e.defaultValue(t, 0)),
          (this._near = t),
          (i = e.defaultValue(i, Number.MAX_VALUE)),
          (this._far = i);
      }
      get near() {
        return this._near;
      }
      set near(e) {
        this._near = e;
      }
      get far() {
        return this._far;
      }
      set far(e) {
        this._far = e;
      }
      pack(t, i, s) {
        if (!e.defined(t)) throw new Error('value is required');
        if (!e.defined(i)) throw new Error('array is required');
        return (s = e.defaultValue(s, 0)), (i[s++] = t.near), (i[s] = t.far), i;
      }
      unpack(t, i, s) {
        if (!e.defined(t)) throw new Error('array is required');
        return (
          (i = e.defaultValue(i, 0)),
          e.defined(s) || (s = new Sf()),
          (s.near = t[i++]),
          (s.far = t[i]),
          s
        );
      }
      static equals(t, i) {
        return t === i || (e.defined(t) && e.defined(i) && t.near === i.near && t.far === i.far);
      }
      equals(e) {
        return Sf.equals(this, e);
      }
      static clone(t, i) {
        if (e.defined(t))
          return e.defined(i) || (i = new Sf()), (i.near = t.near), (i.far = t.far), i;
      }
      clone(e) {
        return Sf.clone(this, e);
      }
    }
    const Ef = new e.Vector3(0.005, 0.005, 1),
      Pf = new e.Vector3();
    class Mf {
      constructor(t) {
        (t = e.defaultValue(t, e.defaultValue.EMPTY_OBJECT)),
          (this.mass = e.defaultValue(t.mass, 1)),
          (this.position = e.Vector3.clone(e.defaultValue(t.position, e.Vector3.ZERO))),
          (this.positionClone = e.Vector3.clone(e.defaultValue(t.positionClone, e.Vector3.ZERO))),
          (this.velocity = e.Vector3.clone(e.defaultValue(t.velocity, e.Vector3.ZERO))),
          (this.life = e.defaultValue(t.life, Number.MAX_VALUE)),
          (this.image = t.image),
          (this.imageUrl = t.imageUrl),
          (this.startColor = e.Color.clone(
            e.Color.parse(e.defaultValue(t.startColor, e.Color.white)),
          )),
          (this.endColor = e.Color.clone(e.Color.parse(e.defaultValue(t.endColor, e.Color.white)))),
          (this.startScale = e.defaultValue(t.startScale, 1)),
          (this.endScale = e.defaultValue(t.endScale, 1)),
          (this.imageSize = e.Vector3.clone(e.defaultValue(t.imageSize, Ef))),
          (this._age = 0),
          (this._normalizedAge = 0),
          (this._billboard = void 0),
          (this.show = !0);
      }
      get age() {
        return this._age;
      }
      get normalizedAge() {
        return this._normalizedAge;
      }
      update(t, i) {
        return (
          e.Vector3.multiplyByScalar(this.velocity, t, Pf),
          e.Vector3.add(this.position, Pf, this.position),
          e.defined(i) && i(this, t),
          (this._age += t),
          (this._normalizedAge = this.life === Number.MAX_VALUE ? 0 : this._age / this.life),
          this._age <= this.life
        );
      }
    }
    class Af {
      constructor(t) {
        (t = e.defaultValue(t, 1)), (this._radius = e.defaultValue(t, 1));
      }
      emit(t) {
        const i = e.randomBetween(0, e.CONSTS.TRANSFORM.TWO_PI),
          s = e.randomBetween(0, this._radius),
          r = s * Math.cos(i),
          n = s * Math.sin(i);
        (t.position = e.Vector3.fromElements(r, n, 0, t.position)),
          (t.velocity = e.Vector3.clone(e.Vector3.UNIT_Z, t.velocity));
      }
    }
    const Rf = new e.Vector3();
    function If(t) {
      let i = t._particlePool.pop();
      return e.defined(i) || (i = new Mf()), i;
    }
    function Of(e, t) {
      e._particlePool.push(t);
    }
    function Lf(t) {
      e.defined(t) && (t.show = !1);
    }
    function Df(t, i) {
      i.show = !0;
      const s = e.lerp(i.startScale, i.endScale, i.normalizedAge);
      i.scale = s;
      const r = e.lerp(i.startColor.r, i.endColor.r, i.normalizedAge),
        n = e.lerp(i.startColor.g, i.endColor.g, i.normalizedAge),
        o = e.lerp(i.startColor.b, i.endColor.b, i.normalizedAge),
        a = e.lerp(i.startColor.a, i.endColor.a, i.normalizedAge);
      i.color = new e.Color(r, n, o, a);
    }
    function Bf(t, i) {
      (i.startColor = e.Color.clone(t._startColor, i.startColor)),
        (i.endColor = e.Color.clone(t._endColor, i.endColor)),
        (i.startScale = t._startScale),
        (i.endScale = t._endScale),
        (i.image = t.image),
        (i.imageUrl = t.imageUrl),
        (i.texture = t.texture),
        (i.life = t.particleLife),
        (i.mass = e.randomBetween(t._minimumMass, t._maximumMass)),
        (i._normalizedAge = 0),
        (i._age = 0),
        (i.show = !0),
        (i.imageSize = t.imageSize),
        e.Vector3.multiplyByScalar(i.velocity, t._speed, i.velocity),
        t._particles.push(i);
    }
    function Vf(t, i) {
      const s = e.defaultValue(Math.sign, (e) => (0 == (e = +e) || e != e ? e : e > 0 ? 1 : -1)),
        r = e.defaultValue(Math.sign, (e) => (0 == (e = +e) || e != e ? e : e > 0 ? 1 : -1));
      return s === r && Math.abs(t) < Math.abs(i) ? t : ((t % i) + i) % i;
    }
    const Nf = e.CONSTS.CesiumMath.toDegrees(30),
      kf = new e.Vector3(1, 1, 1),
      Ff = new e.Vector3(),
      Gf = new e.Vector3(1, 1, 1),
      Uf = new e.Vector3();
    class zf {
      read(t) {
        if (!t) return null;
        if ('string' == typeof t) {
          const s = ((i = t), new e.window.DOMParser().parseFromString(i, 'application/xml'));
          return this.readFromDocument(s);
        }
        return 'documentElement' in t ? this.readFromDocument(t) : this.readFromNode(t);
        var i;
      }
      readFromDocument(t) {
        for (let i = t.firstChild; i; i = i.nextSibling)
          if (i.nodeType == e.window.Node.ELEMENT_NODE) return this.readFromNode(i);
        return null;
      }
      readFromNode(e) {}
    }
    function Hf(e, t) {
      return Wf(e, t, []).join('');
    }
    function Wf(t, i, s) {
      if (t.nodeType == e.window.Node.CDATA_SECTION_NODE || t.nodeType == e.window.Node.TEXT_NODE)
        s.push(i ? String(t.nodeValue).replace(/(\r\n|\r|\n)/g, '') : t.nodeValue);
      else {
        let e;
        for (e = t.firstChild; e; e = e.nextSibling) Wf(e, i, s);
      }
      return s;
    }
    function jf(e, t) {
      return function (i, s) {
        const r = e.call(void 0 !== t ? t : this, i, s);
        void 0 !== r && s[s.length - 1].push(r);
      };
    }
    function qf(e, t, i) {
      return function (s, r) {
        const n = e.call(void 0 !== i ? i : this, s, r);
        if (void 0 !== n) {
          const e = r[r.length - 1],
            i = void 0 !== t ? t : s.localName;
          let o;
          i in e ? (o = e[i]) : ((o = []), (e[i] = o)), o.push(n);
        }
      };
    }
    function Xf(e, t, i) {
      return function (s, r) {
        const n = e.call(void 0 !== i ? i : this, s, r);
        void 0 !== n && (r[r.length - 1][void 0 !== t ? t : s.localName] = n);
      };
    }
    function Zf(e, t, i) {
      let s, r;
      for (i = void 0 !== i ? i : {}, s = 0, r = e.length; s < r; ++s) i[e[s]] = t;
      return i;
    }
    function $f(e, t, i, s, r) {
      return (
        s.push(e),
        (function (e, t, i, s) {
          let r;
          for (r = t.firstElementChild; r; r = r.nextElementSibling) {
            const t = e[r.namespaceURI];
            if (void 0 !== t) {
              const e = t[r.localName];
              void 0 !== e && e.call(s, r, i);
            }
          }
        })(t, i, s, r),
        s.pop()
      );
    }
    function Kf(e) {
      return e.getAttributeNS('http://www.w3.org/1999/xlink', 'href');
    }
    function Yf(e) {
      return (function (e) {
        const t = /^\s*(\d+)\s*$/.exec(e);
        if (t) return parseInt(t[1], 10);
      })(Hf(e, !1));
    }
    function Qf(e) {
      return Hf(e, !1).trim();
    }
    const Jf = [null, 'http://www.opengis.net/ows/1.1'],
      eg = Zf(Jf, {
        ServiceIdentification: Xf(function (e, t) {
          return $f({}, dg, e, t);
        }),
        ServiceProvider: Xf(function (e, t) {
          return $f({}, mg, e, t);
        }),
        OperationsMetadata: Xf(function (e, t) {
          return $f({}, hg, e, t);
        }),
      });
    class tg extends zf {
      constructor() {
        super();
      }
      readFromNode(e) {
        return $f({}, eg, e, []) || null;
      }
    }
    const ig = Zf(Jf, {
        DeliveryPoint: Xf(Qf),
        City: Xf(Qf),
        AdministrativeArea: Xf(Qf),
        PostalCode: Xf(Qf),
        Country: Xf(Qf),
        ElectronicMailAddress: Xf(Qf),
      }),
      sg = Zf(Jf, {
        Value: qf(function (e) {
          return Qf(e);
        }),
      }),
      rg = Zf(Jf, {
        AllowedValues: Xf(function (e, t) {
          return $f({}, sg, e, t);
        }),
      }),
      ng = Zf(Jf, {
        Phone: Xf(function (e, t) {
          return $f({}, cg, e, t);
        }),
        Address: Xf(function (e, t) {
          return $f({}, ig, e, t);
        }),
      }),
      og = Zf(Jf, {
        HTTP: Xf(function (e, t) {
          return $f({}, ag, e, t);
        }),
      }),
      ag = Zf(Jf, {
        Get: qf(function (e, t) {
          const i = Kf(e);
          if (i) return $f({ href: i }, _g, e, t);
        }),
        Post: void 0,
      }),
      lg = Zf(Jf, {
        DCP: Xf(function (e, t) {
          return $f({}, og, e, t);
        }),
      }),
      hg = Zf(Jf, {
        Operation: function (e, t) {
          const i = e.getAttribute('name'),
            s = $f({}, lg, e, t);
          s && (t[t.length - 1][i] = s);
        },
      }),
      cg = Zf(Jf, { Voice: Xf(Qf), Facsimile: Xf(Qf) }),
      _g = Zf(Jf, {
        Constraint: qf(function (e, t) {
          const i = e.getAttribute('name');
          if (i) return $f({ name: i }, rg, e, t);
        }),
      }),
      ug = Zf(Jf, {
        IndividualName: Xf(Qf),
        PositionName: Xf(Qf),
        ContactInfo: Xf(function (e, t) {
          return $f({}, ng, e, t);
        }),
      }),
      dg = Zf(Jf, {
        Abstract: Xf(Qf),
        AccessConstraints: Xf(Qf),
        Fees: Xf(Qf),
        Title: Xf(Qf),
        ServiceTypeVersion: Xf(Qf),
        ServiceType: Xf(Qf),
      }),
      mg = Zf(Jf, {
        ProviderName: Xf(Qf),
        ProviderSite: Xf(Kf),
        ServiceContact: Xf(function (e, t) {
          return $f({}, ug, e, t);
        }),
      }),
      pg = [null, 'http://www.opengis.net/wmts/1.0'],
      fg = [null, 'http://www.opengis.net/ows/1.1'],
      gg = Zf(pg, {
        Contents: Xf(function (e, t) {
          return $f({}, yg, e, t);
        }),
      }),
      yg = Zf(pg, {
        Layer: qf(function (e, t) {
          return $f({}, Tg, e, t);
        }),
        TileMatrixSet: qf(function (e, t) {
          return $f({}, Eg, e, t);
        }),
      }),
      Tg = Zf(
        pg,
        {
          Style: qf(function (e, t) {
            const i = $f({}, xg, e, t);
            if (!i) return;
            const s = 'true' === e.getAttribute('isDefault');
            return (i.isDefault = s), i;
          }),
          Format: qf(Qf),
          TileMatrixSetLink: qf(function (e, t) {
            return $f({}, vg, e, t);
          }),
          Dimension: qf(function (e, t) {
            return $f({}, Cg, e, t);
          }),
          ResourceURL: qf(function (e) {
            const t = e.getAttribute('format'),
              i = e.getAttribute('template'),
              s = e.getAttribute('resourceType'),
              r = {};
            return t && (r.format = t), i && (r.template = i), s && (r.resourceType = s), r;
          }),
        },
        Zf(fg, { Title: Xf(Qf), Abstract: Xf(Qf), WGS84BoundingBox: Xf(Mg), Identifier: Xf(Qf) }),
      ),
      xg = Zf(
        pg,
        {
          LegendURL: qf(function (e) {
            const t = {};
            return (t.format = e.getAttribute('format')), (t.href = Kf(e)), t;
          }),
        },
        Zf(fg, { Title: Xf(Qf), Identifier: Xf(Qf) }),
      ),
      vg = Zf(pg, {
        TileMatrixSet: Xf(Qf),
        TileMatrixSetLimits: Xf(function (e, t) {
          return $f([], bg, e, t);
        }),
      }),
      bg = Zf(pg, {
        TileMatrixLimits: jf(function (e, t) {
          return $f({}, wg, e, t);
        }),
      }),
      wg = Zf(pg, {
        TileMatrix: Xf(Qf),
        MinTileRow: Xf(Yf),
        MaxTileRow: Xf(Yf),
        MinTileCol: Xf(Yf),
        MaxTileCol: Xf(Yf),
      }),
      Cg = Zf(pg, { Default: Xf(Qf), Value: qf(Qf) }, Zf(fg, { Identifier: Xf(Qf) })),
      Sg = Zf(fg, { LowerCorner: jf(Ag), UpperCorner: jf(Ag) }),
      Eg = Zf(
        pg,
        {
          WellKnownScaleSet: Xf(Qf),
          TileMatrix: qf(function (e, t) {
            return $f({}, Pg, e, t);
          }),
        },
        Zf(fg, { SupportedCRS: Xf(Qf), Identifier: Xf(Qf), BoundingBox: Xf(Mg) }),
      ),
      Pg = Zf(
        pg,
        {
          TopLeftCorner: Xf(Ag),
          ScaleDenominator: Xf(function (e) {
            return (function (e) {
              const t = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(e);
              if (t) return parseFloat(t[1]);
            })(Hf(e, !1));
          }),
          TileWidth: Xf(Yf),
          TileHeight: Xf(Yf),
          MatrixWidth: Xf(Yf),
          MatrixHeight: Xf(Yf),
        },
        Zf(fg, { Identifier: Xf(Qf) }),
      );
    function Mg(e, t) {
      const i = $f([], Sg, e, t);
      if (2 == i.length)
        return (function (e) {
          const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let i = 0, s = e.length; i < s; ++i) Rg(t, e[i]);
          return t;
        })(i);
    }
    function Ag(e) {
      const t = Qf(e).split(/\s+/);
      if (!t || 2 != t.length) return;
      const i = +t[0],
        s = +t[1];
      return isNaN(i) || isNaN(s) ? void 0 : [i, s];
    }
    function Rg(e, t) {
      t[0] < e[0] && (e[0] = t[0]),
        t[0] > e[2] && (e[2] = t[0]),
        t[1] < e[1] && (e[1] = t[1]),
        t[1] > e[3] && (e[3] = t[1]);
    }
    const Ig = [0, 0, 0];
    class Og {
      constructor(e) {
        let t;
        if (
          ((this.minZoom = void 0 !== e.minZoom ? e.minZoom : 0),
          (this.resolutions = e.resolutions),
          !e.origins)
        )
          for (let e = 0, i = this.resolutions.length - 1; e < i; ++e)
            if (t) {
              if (this.resolutions[e] / this.resolutions[e + 1] !== t) {
                t = void 0;
                break;
              }
            } else t = this.resolutions[e] / this.resolutions[e + 1];
        (this.zoomFactor = t),
          (this.maxZoom = this.resolutions.length - 1),
          (this.origin = void 0 !== e.origin ? e.origin : null),
          (this.origins = null),
          void 0 !== e.origins && (this.origins = e.origins);
        const i = e.extent;
        void 0 === i || this.origin || this.origins || (this.origin = [i[0], i[3]]),
          (this.tileSizes = null),
          void 0 !== e.tileSizes && (this.tileSizes = e.tileSizes),
          (this.tileSize = void 0 !== e.tileSize ? e.tileSize : this.tileSizes ? null : 256),
          (this.extent = void 0 !== i ? i : null),
          (this.fullTileRanges = null),
          (this.tmpSize = [0, 0]),
          (this.tmpExtent = [0, 0, 0, 0]),
          void 0 !== e.sizes
            ? (this.fullTileRanges = e.sizes.map(function (e, t) {
                const s = {
                  minX: Math.min(0, e[0]),
                  maxX: Math.max(e[0] - 1, -1),
                  minY: Math.min(0, e[1]),
                  maxY: Math.max(e[1] - 1, -1),
                };
                if (i) {
                  const e = this.getTileRangeForExtentAndZ(i, t);
                  (s.minX = Math.max(e.minX, s.minX)),
                    (s.maxX = Math.min(e.maxX, s.maxX)),
                    (s.minY = Math.max(e.minY, s.minY)),
                    (s.maxY = Math.min(e.maxY, s.maxY));
                }
                return s;
              }, this))
            : i && this.calculateTileRanges(i);
      }
      getMaxZoom() {
        return this.maxZoom;
      }
      getMinZoom() {
        return this.minZoom;
      }
      getOrigin(e) {
        return this.origin ? this.origin : this.origins[e];
      }
      getResolution(e) {
        return this.resolutions[e];
      }
      getTileRangeForExtentAndZ(e, t) {
        this.getTileCoordForXYAndZ(e[0], e[3], t, !1, Ig);
        const i = Ig[1],
          s = Ig[2];
        return (
          this.getTileCoordForXYAndZ(e[2], e[1], t, !0, Ig),
          { minX: i, maxX: Ig[1], minY: s, maxY: Ig[2] }
        );
      }
      getTileCoordForXYAndZ(e, t, i, s, r) {
        const n = this.getOrigin(i),
          o = this.getResolution(i),
          a =
            ((l = this.getTileSize(i)),
            (h = this.tmpSize),
            Array.isArray(l) ? l : (void 0 === h ? (h = [l, l]) : ((h[0] = l), (h[1] = l)), h));
        var l, h;
        let c = (e - n[0]) / o / a[0],
          _ = (n[1] - t) / o / a[1];
        return (
          s
            ? ((c = Math.ceil(Lg(c, 5)) - 1), (_ = Math.ceil(Lg(_, 5)) - 1))
            : ((c = Math.floor(Lg(c, 5))), (_ = Math.floor(Lg(_, 5)))),
          (r[0] = i),
          (r[1] = c),
          (r[2] = _),
          r
        );
      }
      getTileSize(e) {
        return this.tileSize ? this.tileSize : this.tileSizes[e];
      }
      getFullTileRange(e) {
        return this.fullTileRanges
          ? this.fullTileRanges[e]
          : this.extent
          ? this.getTileRangeForExtentAndZ(this.extent, e)
          : null;
      }
      calculateTileRanges(e) {
        const t = this.resolutions.length,
          i = new Array(t);
        for (let s = this.minZoom; s < t; ++s) i[s] = this.getTileRangeForExtentAndZ(e, s);
        this.fullTileRanges = i;
      }
    }
    function Lg(e, t) {
      const i = Math.pow(10, t);
      return Math.round(e * i) / i;
    }
    function Dg(e) {
      if (
        'EPSG:4326' !== (e = e.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, 'EPSG:$3')) &&
        'EPSG:3857' !== e
      )
        throw Error(`WTMS服务中含有不支持的坐标系统${e}`);
      return e;
    }
    class Bg extends Og {
      constructor(e) {
        super({
          extent: e.extent,
          origin: e.origin,
          origins: e.origins,
          resolutions: e.resolutions,
          tileSize: e.tileSize,
          tileSizes: e.tileSizes,
          sizes: e.sizes,
        }),
          (this.matrixIds = e.matrixIds);
      }
      getMatrixId(e) {
        return this.matrixIds[e];
      }
      getMatrixIds() {
        return this.matrixIds;
      }
    }
    const Vg = { getJSON: e.getJSON, getString: e.getString },
      Ng = {
        ArcType: e.ArcType,
        ARCTYPE: e.ARCTYPE,
        AnimationConstants: a,
        AnimationTrackingMode: m,
        AnimationTrackingEffects: l,
        ClassificationType: e.ClassificationType,
        LightingModelType: e.LightingModelType,
        ShadowsModelType: wf,
        ShadowsType: e.ShadowsType,
        ViewDomeType: Nm,
        ProjectionType: e.ProjectionType,
        WebGLConstants: e.WebGLConstants,
        AnimationClip: _,
        AnimationBlender: y,
        MultiTrackingKeyframeTrack: b,
        MultiPositionKeyframeTrack: w,
        TrackingKeyframeTrack: v,
        PositionKeyframeTrack: x,
        Attribution: Yd,
        FPSControl: im,
        Fullscreen: class {
          constructor() {
            (this._fullscreen = !1),
              e.bindAll(['_onClickFullscreen', '_changeIcon'], this),
              'onfullscreenchange' in e.window.document
                ? (this._fullscreenchange = 'fullscreenchange')
                : 'onmozfullscreenchange' in e.window.document
                ? (this._fullscreenchange = 'mozfullscreenchange')
                : 'onwebkitfullscreenchange' in e.window.document
                ? (this._fullscreenchange = 'webkitfullscreenchange')
                : 'onmsfullscreenchange' in e.window.document &&
                  (this._fullscreenchange = 'MSFullscreenChange'),
              (this._className = 'minemap-ctrl');
          }
          onAdd(t) {
            return (
              (this._map = t),
              (this._mapContainer = this._map.getContainer()),
              (this._container = Ur.create('div', `${this._className} minemap-ctrl-group`)),
              this._checkFullscreenSupport()
                ? this._setupUI()
                : ((this._container.style.display = 'none'),
                  e.warnOnce('This device does not support fullscreen mode.')),
              this._container
            );
          }
          onRemove() {
            Ur.remove(this._container),
              (this._map = null),
              e.window.document.removeEventListener(this._fullscreenchange, this._changeIcon);
          }
          _checkFullscreenSupport() {
            return !!(
              e.window.document.fullscreenEnabled ||
              e.window.document.mozFullScreenEnabled ||
              e.window.document.msFullscreenEnabled ||
              e.window.document.webkitFullscreenEnabled
            );
          }
          _setupUI() {
            const t = (this._fullscreenButton = Ur.create(
              'button',
              `${this._className}-icon ${this._className}-fullscreen`,
              this._container,
            ));
            t.setAttribute('aria-label', 'Toggle fullscreen'),
              (t.type = 'button'),
              this._updateTitle(),
              this._fullscreenButton.addEventListener('click', this._onClickFullscreen),
              e.window.document.addEventListener(this._fullscreenchange, this._changeIcon);
          }
          _updateTitle() {
            const e = this._getTitle();
            this._fullscreenButton.setAttribute('aria-label', e),
              (this._fullscreenButton.title = e);
          }
          _getTitle() {
            return this._map._getUIString(
              this._isFullscreen() ? 'FullscreenControl.Exit' : 'FullscreenControl.Enter',
            );
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _changeIcon() {
            ((e.window.document.fullscreenElement ||
              e.window.document.mozFullScreenElement ||
              e.window.document.webkitFullscreenElement ||
              e.window.document.msFullscreenElement) ===
              this._mapContainer) !==
              this._fullscreen &&
              ((this._fullscreen = !this._fullscreen),
              this._fullscreenButton.classList.toggle(`${this._className}-shrink`),
              this._fullscreenButton.classList.toggle(`${this._className}-fullscreen`));
          }
          _onClickFullscreen() {
            this._isFullscreen()
              ? e.window.document.exitFullscreen
                ? e.window.document.exitFullscreen()
                : e.window.document.mozCancelFullScreen
                ? e.window.document.mozCancelFullScreen()
                : e.window.document.msExitFullscreen
                ? e.window.document.msExitFullscreen()
                : e.window.document.webkitCancelFullScreen &&
                  e.window.document.webkitCancelFullScreen()
              : this._mapContainer.requestFullscreen
              ? this._mapContainer.requestFullscreen()
              : this._mapContainer.mozRequestFullScreen
              ? this._mapContainer.mozRequestFullScreen()
              : this._mapContainer.msRequestFullscreen
              ? this._mapContainer.msRequestFullscreen()
              : this._mapContainer.webkitRequestFullscreen &&
                this._mapContainer.webkitRequestFullscreen();
          }
        },
        Geolocate: class extends e.Evented {
          constructor(t) {
            super(),
              (this.options = e.extend({}, Xp, t)),
              e.bindAll(
                ['_onSuccess', '_onError', '_finish', '_setupUI', '_updateCamera', '_updateMarker'],
                this,
              );
          }
          onAdd(t) {
            var i;
            return (
              (this._map = t),
              (this._container = Ur.create('div', `${Zp} ${Zp}-group`)),
              (i = this._setupUI),
              void 0 !== $p
                ? i($p)
                : void 0 !== e.window.navigator.permissions
                ? e.window.navigator.permissions.query({ name: 'geolocation' }).then((e) => {
                    ($p = 'denied' !== e.state), i($p);
                  })
                : (($p = !!e.window.navigator.geolocation), i($p)),
              this._container
            );
          }
          onRemove() {
            void 0 !== this._geolocationWatchID &&
              (e.window.navigator.geolocation.clearWatch(this._geolocationWatchID),
              (this._geolocationWatchID = void 0)),
              this.options.showUserLocation && this._userLocationDotMarker.remove(),
              Ur.remove(this._container),
              (this._map = void 0);
          }
          _onSuccess(t) {
            if (this.options.trackUserLocation)
              switch (((this._lastKnownPosition = t), this._watchState)) {
                case 'WAITING_ACTIVE':
                case 'ACTIVE_LOCK':
                case 'ACTIVE_ERROR':
                  (this._watchState = 'ACTIVE_LOCK'),
                    this._geolocateButton.classList.remove('minemap-ctrl-geolocate-waiting'),
                    this._geolocateButton.classList.remove('minemap-ctrl-geolocate-active-error'),
                    this._geolocateButton.classList.add('minemap-ctrl-geolocate-active');
                  break;
                case 'BACKGROUND':
                case 'BACKGROUND_ERROR':
                  (this._watchState = 'BACKGROUND'),
                    this._geolocateButton.classList.remove('minemap-ctrl-geolocate-waiting'),
                    this._geolocateButton.classList.remove(
                      'minemap-ctrl-geolocate-background-error',
                    ),
                    this._geolocateButton.classList.add('minemap-ctrl-geolocate-background');
              }
            this.options.showUserLocation && 'OFF' !== this._watchState && this._updateMarker(t),
              (this.options.trackUserLocation && 'ACTIVE_LOCK' !== this._watchState) ||
                this._updateCamera(t),
              this.options.showUserLocation &&
                this._dotElement.classList.remove('minemap-user-location-dot-stale'),
              this.fire(new e.Event('geolocate', t)),
              this._finish();
          }
          _updateCamera(t) {
            const i = new e.LngLat(t.coords.longitude, t.coords.latitude);
            this._map.fitBounds(i.toBounds(t.coords.accuracy), this.options.fitBoundsOptions, {
              geolocateSource: !0,
            });
          }
          _updateMarker(e) {
            e
              ? this._userLocationDotMarker
                  .setLngLat([e.coords.longitude, e.coords.latitude])
                  .addTo(this._map)
              : this._userLocationDotMarker.remove();
          }
          _onError(t) {
            if (this.options.trackUserLocation)
              if (1 === t.code)
                (this._watchState = 'OFF'),
                  this._geolocateButton.classList.remove('minemap-ctrl-geolocate-waiting'),
                  this._geolocateButton.classList.remove('minemap-ctrl-geolocate-active'),
                  this._geolocateButton.classList.remove('minemap-ctrl-geolocate-active-error'),
                  this._geolocateButton.classList.remove('minemap-ctrl-geolocate-background'),
                  this._geolocateButton.classList.remove('minemap-ctrl-geolocate-background-error'),
                  void 0 !== this._geolocationWatchID && this._clearWatch();
              else
                switch (this._watchState) {
                  case 'WAITING_ACTIVE':
                    (this._watchState = 'ACTIVE_ERROR'),
                      this._geolocateButton.classList.remove('minemap-ctrl-geolocate-active'),
                      this._geolocateButton.classList.add('minemap-ctrl-geolocate-active-error');
                    break;
                  case 'ACTIVE_LOCK':
                    (this._watchState = 'ACTIVE_ERROR'),
                      this._geolocateButton.classList.remove('minemap-ctrl-geolocate-active'),
                      this._geolocateButton.classList.add('minemap-ctrl-geolocate-active-error'),
                      this._geolocateButton.classList.add('minemap-ctrl-geolocate-waiting');
                    break;
                  case 'BACKGROUND':
                    (this._watchState = 'BACKGROUND_ERROR'),
                      this._geolocateButton.classList.remove('minemap-ctrl-geolocate-background'),
                      this._geolocateButton.classList.add(
                        'minemap-ctrl-geolocate-background-error',
                      ),
                      this._geolocateButton.classList.add('minemap-ctrl-geolocate-waiting');
                }
            'OFF' !== this._watchState &&
              this.options.showUserLocation &&
              this._dotElement.classList.add('minemap-user-location-dot-stale'),
              this.fire(new e.Event('error', t)),
              this._finish();
          }
          _finish() {
            this._timeoutId && clearTimeout(this._timeoutId), (this._timeoutId = void 0);
          }
          _setupUI(t) {
            !1 !== t
              ? (this._container.addEventListener('contextmenu', (e) => e.preventDefault()),
                (this._geolocateButton = Ur.create(
                  'button',
                  `${Zp}-icon ${Zp}-geolocate`,
                  this._container,
                )),
                (this._geolocateButton.type = 'button'),
                this._geolocateButton.setAttribute(
                  'aria-label',
                  this._map._getUIString('GeolocateControl.Geolocate'),
                ),
                this.options.trackUserLocation &&
                  (this._geolocateButton.setAttribute('aria-pressed', 'false'),
                  (this._watchState = 'OFF')),
                this.options.showUserLocation &&
                  ((this._dotElement = Ur.create('div', 'minemap-user-location-dot')),
                  (this._userLocationDotMarker = new um(this._dotElement)),
                  this.options.trackUserLocation && (this._watchState = 'OFF')),
                this._geolocateButton.addEventListener('click', this.trigger.bind(this)),
                (this._setup = !0),
                this.options.trackUserLocation &&
                  this._map.on('movestart', (t) => {
                    t.geolocateSource ||
                      'ACTIVE_LOCK' !== this._watchState ||
                      ((this._watchState = 'BACKGROUND'),
                      this._geolocateButton.classList.add('minemap-ctrl-geolocate-background'),
                      this._geolocateButton.classList.remove('minemap-ctrl-geolocate-active'),
                      this.fire(new e.Event('trackuserlocationend')));
                  }))
              : e.warnOnce(
                  'Geolocation support is not available, the GeolocateControl will not be visible.',
                );
          }
          trigger() {
            if (!this._setup)
              return e.warnOnce('Geolocate control triggered before added to a map'), !1;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case 'OFF':
                  (this._watchState = 'WAITING_ACTIVE'),
                    this.fire(new e.Event('trackuserlocationstart'));
                  break;
                case 'WAITING_ACTIVE':
                case 'ACTIVE_LOCK':
                case 'ACTIVE_ERROR':
                case 'BACKGROUND_ERROR':
                  (this._watchState = 'OFF'),
                    this._geolocateButton.classList.remove('minemap-ctrl-geolocate-waiting'),
                    this._geolocateButton.classList.remove('minemap-ctrl-geolocate-active'),
                    this._geolocateButton.classList.remove('minemap-ctrl-geolocate-active-error'),
                    this._geolocateButton.classList.remove('minemap-ctrl-geolocate-background'),
                    this._geolocateButton.classList.remove(
                      'minemap-ctrl-geolocate-background-error',
                    ),
                    this.fire(new e.Event('trackuserlocationend'));
                  break;
                case 'BACKGROUND':
                  (this._watchState = 'ACTIVE_LOCK'),
                    this._geolocateButton.classList.remove('minemap-ctrl-geolocate-background'),
                    this._lastKnownPosition && this._updateCamera(this._lastKnownPosition),
                    this.fire(new e.Event('trackuserlocationstart'));
              }
              switch (this._watchState) {
                case 'WAITING_ACTIVE':
                  this._geolocateButton.classList.add('minemap-ctrl-geolocate-waiting'),
                    this._geolocateButton.classList.add('minemap-ctrl-geolocate-active');
                  break;
                case 'ACTIVE_LOCK':
                  this._geolocateButton.classList.add('minemap-ctrl-geolocate-active');
                  break;
                case 'ACTIVE_ERROR':
                  this._geolocateButton.classList.add('minemap-ctrl-geolocate-waiting'),
                    this._geolocateButton.classList.add('minemap-ctrl-geolocate-active-error');
                  break;
                case 'BACKGROUND':
                  this._geolocateButton.classList.add('minemap-ctrl-geolocate-background');
                  break;
                case 'BACKGROUND_ERROR':
                  this._geolocateButton.classList.add('minemap-ctrl-geolocate-waiting'),
                    this._geolocateButton.classList.add('minemap-ctrl-geolocate-background-error');
              }
              'OFF' === this._watchState && void 0 !== this._geolocationWatchID
                ? this._clearWatch()
                : void 0 === this._geolocationWatchID &&
                  (this._geolocateButton.classList.add('minemap-ctrl-geolocate-waiting'),
                  this._geolocateButton.setAttribute('aria-pressed', 'true'),
                  (this._geolocationWatchID = e.window.navigator.geolocation.watchPosition(
                    this._onSuccess,
                    this._onError,
                    this.options.positionOptions,
                  )));
            } else
              e.window.navigator.geolocation.getCurrentPosition(
                this._onSuccess,
                this._onError,
                this.options.positionOptions,
              ),
                (this._timeoutId = setTimeout(this._finish, 1e4));
            return !0;
          }
          _clearWatch() {
            e.window.navigator.geolocation.clearWatch(this._geolocationWatchID),
              (this._geolocationWatchID = void 0),
              this._geolocateButton.classList.remove('minemap-ctrl-geolocate-waiting'),
              this._geolocateButton.setAttribute('aria-pressed', 'false'),
              this.options.showUserLocation && this._updateMarker(null);
          }
        },
        Navigation: class {
          constructor(t) {
            (this.options = e.extend({}, jp, t)),
              (this._container = Ur.create('div', 'minemap-ctrl minemap-ctrl-group')),
              this._container.addEventListener('contextmenu', (e) => e.preventDefault()),
              this.options.showZoom &&
                (e.bindAll(['_setButtonTitle', '_updateZoomButtons'], this),
                (this._zoomInButton = this._createButton(
                  'minemap-ctrl-icon minemap-ctrl-zoom-in',
                  (e) => this._map.zoomIn({}, { originalEvent: e }),
                )),
                Ur.create('span', 'minemap-ctrl-icon', this._zoomInButton).setAttribute(
                  'aria-hidden',
                  !0,
                ),
                (this._zoomOutButton = this._createButton(
                  'minemap-ctrl-icon minemap-ctrl-zoom-out',
                  (e) => this._map.zoomOut({}, { originalEvent: e }),
                )),
                Ur.create('span', 'minemap-ctrl-icon', this._zoomOutButton).setAttribute(
                  'aria-hidden',
                  !0,
                )),
              this.options.showCompass &&
                (e.bindAll(['_rotateCompassArrow'], this),
                (this._compass = this._createButton(
                  'minemap-ctrl-icon minemap-ctrl-compass',
                  (e) => {
                    this.options.visualizePitch
                      ? this._map.resetNorthPitch({}, { originalEvent: e })
                      : this._map.resetNorth({}, { originalEvent: e });
                  },
                )),
                (this._compassIcon = Ur.create(
                  'span',
                  'minemap-ctrl-compass-arrow',
                  this._compass,
                )),
                this._compassIcon.setAttribute('aria-hidden', !0));
          }
          _updateZoomButtons() {
            const e = this._map.getZoom(),
              t = e >= this._map.getMaxZoom(),
              i = e <= this._map.getMinZoom();
            (this._zoomInButton.disabled = t),
              (this._zoomOutButton.disabled = i),
              this._zoomInButton.setAttribute('aria-disabled', t.toString()),
              this._zoomOutButton.setAttribute('aria-disabled', i.toString());
          }
          _rotateCompassArrow() {
            const e = `rotate(${-this._map.transform.hpr.heading * (180 / Math.PI)}deg)`;
            this._map._requestDomTask(() => {
              this._compassIcon && (this._compassIcon.style.transform = e);
            });
          }
          onAdd(e) {
            return (
              (this._map = e),
              this.options.showZoom &&
                (this._setButtonTitle(this._zoomInButton, 'ZoomIn'),
                this._setButtonTitle(this._zoomOutButton, 'ZoomOut'),
                this._map.on('zoom', this._updateZoomButtons),
                this._updateZoomButtons()),
              this.options.showCompass &&
                (this._setButtonTitle(this._compass, 'ResetBearing'),
                this.options.visualizePitch && this._map.on('pitch', this._rotateCompassArrow),
                this._map.on('rotate', this._rotateCompassArrow),
                this._rotateCompassArrow(),
                (this._handler = new qp(this._map, this._compass, this.options.visualizePitch))),
              this._container
            );
          }
          onRemove() {
            this._container.remove(),
              this.options.showZoom && this._map.off('zoom', this._updateZoomButtons),
              this.options.showCompass &&
                (this.options.visualizePitch && this._map.off('pitch', this._rotateCompassArrow),
                this._map.off('rotate', this._rotateCompassArrow),
                this._map.off('panorama-change-bearing', this._rotateCompassArrow),
                this._handler.off(),
                delete this._handler),
              delete this._map;
          }
          _createButton(e, t) {
            const i = Ur.create('button', e, this._container);
            return (i.type = 'button'), i.addEventListener('click', t), i;
          }
          _setButtonTitle(e, t) {
            const i = this._map._getUIString(`NavigationControl.${t}`);
            e.setAttribute('aria-label', i),
              e.firstElementChild && e.firstElementChild.setAttribute('title', i);
          }
        },
        Scale: class {
          constructor(t) {
            (this.options = e.extend({}, yf, t)), e.bindAll(['_onMove', 'setUnit'], this);
          }
          getDefaultPosition() {
            return 'bottom-left';
          }
          onAdd(e) {
            (this._map = e),
              (this._container = Ur.create(
                'div',
                'minemap-ctrl minemap-ctrl-scale',
                e.getContainer(),
              )),
              (this._content = Ur.create('div', 'minemap-ctrl-scale-text', this._container)),
              this._container.appendChild(this._content);
            const t = Ur.create('div', 'minemap-ctrl-scale-left-bar', this._container),
              i = Ur.create('div', 'minemap-ctrl-scale-right-bar', this._container),
              s = Ur.create('div', 'minemap-ctrl-scale-bottom-bar', this._container);
            return (
              this._container.appendChild(t),
              this._container.appendChild(i),
              this._container.appendChild(s),
              (this._onMove =
                ((r = () => {
                  Tf(this._map, this._container, this._content, this.options);
                }),
                (o = !0),
                (a = !0),
                hf(n) &&
                  ((o = 'leading' in n ? !!n.leading : o),
                  (a = 'trailing' in n ? !!n.trailing : a)),
                (function (e, t, i) {
                  var s,
                    r,
                    n,
                    o,
                    a,
                    l,
                    h = 0,
                    c = !1,
                    _ = !1,
                    u = !0;
                  if ('function' != typeof e) throw new TypeError('Expected a function');
                  function d(t) {
                    var i = s,
                      n = r;
                    return (s = r = void 0), (h = t), (o = e.apply(n, i));
                  }
                  function m(e) {
                    var i = e - l;
                    return void 0 === l || i >= t || i < 0 || (_ && e - h >= n);
                  }
                  function p() {
                    var e = pf();
                    if (m(e)) return f(e);
                    a = setTimeout(
                      p,
                      (function (e) {
                        var i = t - (e - l);
                        return _ ? gf(i, n - (e - h)) : i;
                      })(e),
                    );
                  }
                  function f(e) {
                    return (a = void 0), u && s ? d(e) : ((s = r = void 0), o);
                  }
                  function g() {
                    var e = pf(),
                      i = m(e);
                    if (((s = arguments), (r = this), (l = e), i)) {
                      if (void 0 === a)
                        return (function (e) {
                          return (h = e), (a = setTimeout(p, t)), c ? d(e) : o;
                        })(l);
                      if (_) return clearTimeout(a), (a = setTimeout(p, t)), d(l);
                    }
                    return void 0 === a && (a = setTimeout(p, t)), o;
                  }
                  return (
                    (t = mf(t) || 0),
                    hf(i) &&
                      ((c = !!i.leading),
                      (n = (_ = 'maxWait' in i) ? ff(mf(i.maxWait) || 0, t) : n),
                      (u = 'trailing' in i ? !!i.trailing : u)),
                    (g.cancel = function () {
                      void 0 !== a && clearTimeout(a), (h = 0), (s = l = r = a = void 0);
                    }),
                    (g.flush = function () {
                      return void 0 === a ? o : f(pf());
                    }),
                    g
                  );
                })(r, 200, { leading: o, maxWait: 200, trailing: a }))),
              this._map.on('move', this._onMove),
              this._onMove(),
              this._container
            );
            var r, n, o, a;
          }
          onRemove() {
            Ur.remove(this._container), this._map.off('move', this._onMove), (this._map = void 0);
          }
          setUnit(e) {
            (this.options.unit = e), Tf(this._map, this._container, this._content, this.options);
          }
        },
        Marker: um,
        Popup: class extends e.Evented {
          constructor(t) {
            super(),
              (this.options = e.extend(Object.create(vf), t)),
              (this.heightToSurface = 0),
              e.bindAll(
                ['_update', '_onClose', 'remove', '_onMouseMove', '_onMouseUp', '_onDrag'],
                this,
              ),
              (this._classList = new Set(t && t.className ? t.className.trim().split(/\s+/) : []));
          }
          addTo(t) {
            return (
              this._map && this.remove(),
              (this._map = t),
              this.options.closeOnClick && this._map.on('preclick', this._onClose),
              this.options.closeOnMove && this._map.on('move', this._onClose),
              this._map.on('remove', this.remove),
              this._update(),
              this._focusFirstElement(),
              this._trackPointer
                ? (this._map.on('mousemove', this._onMouseMove),
                  this._map.on('mouseup', this._onMouseUp),
                  this._map._canvasContainer.classList.add('minemap-track-pointer'))
                : this._map.on('move', this._update),
              t.__popupList.push(this),
              this.fire(new e.Event('open')),
              this
            );
          }
          isOpen() {
            return !!this._map;
          }
          remove() {
            if (
              (this._content && this._content.remove(),
              this._container && (this._container.remove(), delete this._container),
              this._map)
            ) {
              for (let e = 0; e < this._map.__popupList.length; e++)
                this._map.__popupList[e] === this && this._map.__popupList.splice(e, 1);
              this._map.off('move', this._update),
                this._map.off('move', this._onClose),
                this._map.off('click', this._onClose),
                this._map.off('remove', this.remove),
                this._map.off('mousemove', this._onMouseMove),
                this._map.off('mouseup', this._onMouseUp),
                this._map.off('drag', this._onDrag),
                delete this._map;
            }
            return this.fire(new e.Event('close')), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(t) {
            return (
              (t = e.LngLat.convert(t)),
              (e.LngLat.equals(t, this._lngLat || new e.LngLat(0, 0)) && this.boundingVolume) ||
                (this.boundingVolume = new e.BoundingSphere(
                  e.Vector3.fromDegrees(t.lng, t.lat, this.heightToSurface),
                  100,
                )),
              (this._lngLat = e.LngLat.convert(t)),
              (this._pos = null),
              (this._trackPointer = !1),
              this._update(),
              this._map &&
                (this._map.on('move', this._update),
                this._map.off('mousemove', this._onMouseMove),
                this._map._canvasContainer.classList.remove('minemap-track-pointer')),
              this
            );
          }
          trackPointer() {
            return (
              (this._trackPointer = !0),
              (this._pos = null),
              this._update(),
              this._map &&
                (this._map.off('move', this._update),
                this._map.on('mousemove', this._onMouseMove),
                this._map.on('drag', this._onDrag),
                this._map._canvasContainer.classList.add('minemap-track-pointer')),
              this
            );
          }
          getAltitude() {
            return this.heightToSurface;
          }
          setAltitude(t) {
            return (
              (this.heightToSurface = t),
              (this.boundingVolume = new e.BoundingSphere(
                e.Vector3.fromDegrees(this._lngLat.lng, this._lngLat.lat, this.heightToSurface),
                100,
              )),
              (this._pos = null),
              this._update(),
              (this._trackPointer = !1),
              this._map &&
                (this._map.on('move', this._update),
                this._map.off('mousemove', this._onMouseMove),
                this._container && this._container.classList.remove('minemap-popup-track-pointer'),
                this._map._canvasContainer.classList.remove('minemap-track-pointer')),
              this
            );
          }
          setText(t) {
            return this.setDOMContent(e.window.document.createTextNode(t));
          }
          setHTML(t) {
            const i = e.window.document.createDocumentFragment(),
              s = e.window.document.createElement('body');
            let r;
            for (s.innerHTML = t; (r = s.firstChild), r; ) i.appendChild(r);
            return this.setDOMContent(i);
          }
          getMaxWidth() {
            return this._container && this._container.style.maxWidth;
          }
          setMaxWidth(e) {
            return (this.options.maxWidth = e), this._update(), this;
          }
          setDOMContent(e) {
            if (this._content)
              for (; this._content.hasChildNodes(); )
                this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else this._content = Ur.create('div', 'minemap-popup-content', this._container);
            return (
              this._content.appendChild(e),
              this._createCloseButton(),
              this._update(),
              this._focusFirstElement(),
              this
            );
          }
          addClassName(e) {
            return this._classList.add(e), this._container && this._updateClassList(), this;
          }
          removeClassName(e) {
            return this._classList.delete(e), this._container && this._updateClassList(), this;
          }
          setOffset(e) {
            return (this.options.offset = e), this._update(), this;
          }
          toggleClassName(e) {
            let t;
            return (
              this._classList.delete(e) ? (t = !1) : (this._classList.add(e), (t = !0)),
              this._container && this._updateClassList(),
              t
            );
          }
          _createCloseButton() {
            this.options.closeButton &&
              ((this._closeButton = Ur.create(
                'button',
                'minemap-popup-close-button',
                this._content,
              )),
              (this._closeButton.type = 'button'),
              this._closeButton.setAttribute('aria-label', 'Close popup'),
              this._closeButton.setAttribute('aria-hidden', 'true'),
              (this._closeButton.innerHTML = '&#215;'),
              this._closeButton.addEventListener('click', this._onClose));
          }
          _createContent() {
            this._content && Ur.remove(this._content),
              (this._content = Ur.create('div', 'minemap-popup-content', this._container)),
              this.options.closeButton &&
                ((this._closeButton = Ur.create(
                  'button',
                  'minemap-popup-close-button',
                  this._content,
                )),
                (this._closeButton.type = 'button'),
                this._closeButton.setAttribute('aria-label', 'Close popup'),
                (this._closeButton.innerHTML = '&#215;'),
                this._closeButton.addEventListener('click', this._onClickClose));
          }
          _updateClassList() {
            const e = [...this._classList];
            e.push('minemap-popup'),
              this._anchor && e.push(`minemap-popup-anchor-${this._anchor}`),
              this._trackPointer && e.push('minemap-popup-track-pointer'),
              (this._container.className = e.join(' '));
          }
          _update(t) {
            if (this._map && (this._lngLat || this._trackPointer) && this._content) {
              if (
                (this._container ||
                  ((this._container = Ur.create('div', 'minemap-popup', this._map.getContainer())),
                  (this._tip = Ur.create('div', 'minemap-popup-tip', this._container)),
                  this._container.appendChild(this._content)),
                this.options.maxWidth &&
                  this._container.style.maxWidth !== this.options.maxWidth &&
                  (this._container.style.maxWidth = this.options.maxWidth),
                !this._trackPointer || t)
              ) {
                const i = (this._pos =
                    this._trackPointer && t
                      ? t
                      : this._map.project(this._lngLat, this.heightToSurface)),
                  s = (function (t) {
                    if ((t || (t = new e.pointGeometry3d(0, 0)), 'number' == typeof t)) {
                      const i = Math.round(Math.sqrt(0.5 * Math.pow(t, 2)));
                      return {
                        center: new e.pointGeometry3d(0, 0),
                        top: new e.pointGeometry3d(0, t),
                        'top-left': new e.pointGeometry3d(i, i),
                        'top-right': new e.pointGeometry3d(-i, i),
                        bottom: new e.pointGeometry3d(0, -t),
                        'bottom-left': new e.pointGeometry3d(i, -i),
                        'bottom-right': new e.pointGeometry3d(-i, -i),
                        left: new e.pointGeometry3d(t, 0),
                        right: new e.pointGeometry3d(-t, 0),
                      };
                    }
                    if (t instanceof e.pointGeometry3d || Array.isArray(t)) {
                      const i = e.pointGeometry3d.convert(t);
                      return {
                        center: i,
                        top: i,
                        'top-left': i,
                        'top-right': i,
                        bottom: i,
                        'bottom-left': i,
                        'bottom-right': i,
                        left: i,
                        right: i,
                      };
                    }
                    return {
                      center: e.pointGeometry3d.convert(t.center || [0, 0]),
                      top: e.pointGeometry3d.convert(t.top || [0, 0]),
                      'top-left': e.pointGeometry3d.convert(t['top-left'] || [0, 0]),
                      'top-right': e.pointGeometry3d.convert(t['top-right'] || [0, 0]),
                      bottom: e.pointGeometry3d.convert(t.bottom || [0, 0]),
                      'bottom-left': e.pointGeometry3d.convert(t['bottom-left'] || [0, 0]),
                      'bottom-right': e.pointGeometry3d.convert(t['bottom-right'] || [0, 0]),
                      left: e.pointGeometry3d.convert(t.left || [0, 0]),
                      right: e.pointGeometry3d.convert(t.right || [0, 0]),
                    };
                  })(this.options.offset),
                  r = (this._anchor = this._getAnchor(s)),
                  n = i.add(s[r]).round();
                this._map._requestDomTask(() => {
                  this._container &&
                    r &&
                    (this._container.style.transform = `${_m[r]} translate(${n.x}px,${n.y}px)`);
                }),
                  this._updatePanoramaMode();
              }
              this._updateClassList();
            }
          }
          _updatePanoramaMode() {
            if (!this._trackPointer) {
              const t =
                this._map.transform.activeCamera.frustumCrate.cullingVolume.computeVisibility(
                  this.boundingVolume,
                );
              this._container.style.visibility =
                t === e.INTERSECTION.OUTSIDE ? 'hidden' : 'visible';
            }
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const e = this._container.querySelector(bf);
            e && e.focus();
          }
          _onClose() {
            this.remove();
          }
          _setOpacity(e) {
            this._content && (this._content.style.opacity = e),
              this._tip && (this._tip.style.opacity = e);
          }
          getElement() {
            return this._container;
          }
          getMap() {
            return this._map;
          }
          _onMouseUp(e) {
            this._update(e.point);
          }
          _onMouseMove(e) {
            this._update(e.point);
          }
          _onDrag(e) {
            this._update(e.point);
          }
          _getAnchor(e) {
            if (this.options.anchor) return this.options.anchor;
            const t = this._pos,
              i = this._container.offsetWidth,
              s = this._container.offsetHeight;
            let r;
            return (
              (r =
                t.y + e.bottom.y < s
                  ? ['top']
                  : t.y > this._map.transform.height - s
                  ? ['bottom']
                  : []),
              t.x < i / 2
                ? r.push('left')
                : t.x > this._map.transform.width - i / 2 && r.push('right'),
              0 === r.length ? 'bottom' : r.join('-')
            );
          }
        },
        OrthographicCamera: o,
        PerspectiveCamera: n,
        BillboardMaterial: Rr,
        GradientColorBoxMaterial: Ip,
        PhysicalMaterial: Fs,
        StandardMaterial: e.StandardMaterial,
        WaterMaterial: Lp,
        MirrorMaterial: Ru,
        PhongMaterial: Op,
        LambertMaterial: class extends e.Material {
          constructor(t) {
            (t.type = 'LambertMaterial'),
              super(t),
              (this.color = new e.Color(1, 1, 1).toVector3()),
              (this.map = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.emissive = new e.Color(0, 0, 0).toVector3()),
              (this.emissiveIntensity = 1),
              (this.emissiveMap = null),
              (this.bumpMap = null),
              (this.bumpScale = 1),
              (this.normalMap = null),
              (this.normalScale = new e.Vector2(1, 1)),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.specularMap = null),
              (this.alphaMap = null),
              (this.envMap = null),
              (this.reflectivity = 1),
              (this.refractionRatio = 0.98),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = 'round'),
              (this.wireframeLinejoin = 'round'),
              (this.flatShading = !1),
              (this.fog = !0),
              (this.opacity = 1),
              this.setValues(t);
          }
          setValues(e) {
            super.setValues(e);
          }
          update(e, t, i = {}) {
            super.update(e, t, i),
              this._uniforms.set('u_Color', () => this.color),
              this._uniforms.set('u_Reflectivity', () => this.reflectivity),
              this._uniforms.set('u_Opacity', () => this.opacity);
          }
          serialize() {
            return {
              type: this.type,
              color: e.Vector3.pack(this.color, new Array(3)),
              reflectivity: this.reflectivity,
              opacity: this.opacity,
            };
          }
          destroy() {}
        },
        PolylineMaterial: e.PolylineMaterial,
        BoxGeometry: wp,
        BoxOutlineGeometry: $_,
        ConeGeometry: Cp,
        CylinderGeometry: Sp,
        FrustumGeometry: ym,
        FrustumOutlineGeometry: Tm,
        PlaneGeometry: Mp,
        PlaneOutlineGeometry: Ap,
        PolygonGeometry: e.PolygonGeometry,
        PolygonOutlineGeometry: Pm,
        SimplePolylineGeometry: Km,
        SphereGeometry: Vn,
        GradientColorBoxGeometry: Pp,
        WallGeometry: Lm,
        WallOutlineGeometry: Rp,
        PolylineGeometry: e.PolylineGeometry,
        BillboardGeometry: Or,
        FenceGeometry: Ep,
        Geometries: {
          BoxGeometry: wp,
          BoxOutlineGeometry: $_,
          ConeGeometry: Cp,
          CylinderGeometry: Sp,
          FrustumGeometry: ym,
          FrustumOutlineGeometry: Tm,
          PlaneGeometry: Mp,
          PlaneOutlineGeometry: Ap,
          PolygonGeometry: e.PolygonGeometry,
          PolygonOutlineGeometry: Pm,
          SimplePolylineGeometry: Km,
          SphereGeometry: Vn,
          GradientColorBoxGeometry: Pp,
          WallGeometry: Lm,
          WallOutlineGeometry: Rp,
          PolylineGeometry: e.PolylineGeometry,
          BillboardGeometry: Or,
          FenceGeometry: Ep,
        },
        PointPrimitive: va,
        PointPrimitiveCollection: Sa,
        Primitive: e.Primitive,
        AmbientLight: Np,
        SunLight: Ds,
        DirectionalLight: Cs,
        PointLight: Au,
        AxisAlignedBoundingBox: e.AxisAlignedBoundingBox,
        BoundingRectangle: e.BoundingRectangle,
        BoundingSphere: e.BoundingSphere,
        OrientedBoundingBox: e.OrientedBoundingBox,
        Bounds: {
          AxisAlignedBoundingBox: e.AxisAlignedBoundingBox,
          BoundingRectangle: e.BoundingRectangle,
          BoundingSphere: e.BoundingSphere,
          OrientedBoundingBox: e.OrientedBoundingBox,
        },
        SphereEmitter: class {
          constructor(t) {
            (t = e.defaultValue(t, 1)), (this._radius = e.defaultValue(t, 1));
          }
          emit(t) {
            const i = e.randomBetween(0, e.CONSTS.TRANSFORM.TWO_PI),
              s = e.randomBetween(0, e.CONSTS.TRANSFORM.PI),
              r = e.randomBetween(0, this._radius),
              n = r * Math.cos(i) * Math.sin(s),
              o = r * Math.sin(i) * Math.sin(s),
              a = r * Math.cos(s);
            (t.position = e.Vector3.fromElements(n, o, a, t.position)),
              (t.velocity = e.Vector3.normalize(t.position, t.velocity));
          }
        },
        CircleEmitter: Af,
        ConeEmitter: class {
          constructor(t) {
            this._angle = e.defaultValue(t, Nf);
          }
          emit(t) {
            const i = Math.tan(this._angle),
              s = e.randomBetween(0, e.CONSTS.TRANSFORM.TWO_PI),
              r = e.randomBetween(0, i),
              n = r * Math.cos(s),
              o = r * Math.sin(s);
            (t.velocity = e.Vector3.fromElements(n, o, 1, t.velocity)),
              e.Vector3.normalize(t.velocity, t.velocity),
              (t.position = e.Vector3.clone(e.Vector3.ZERO, t.position));
          }
        },
        BoxEmitter: class {
          constructor(t) {
            (t = e.defaultValue(t, kf)), (this._dimensions = e.Vector3.clone(t));
          }
          emit(t) {
            const i = e.Vector3.multiplyByScalar(this._dimensions, 0.5, Ff),
              s = e.randomBetween(-i.x, i.x),
              r = e.randomBetween(-i.y, i.y),
              n = e.randomBetween(-i.z, i.z);
            (t.position = e.Vector3.fromElements(s, r, n, t.position)),
              (t.velocity = e.Vector3.normalize(t.position, t.velocity));
          }
        },
        RandomBoxEmitter: class {
          constructor(t) {
            (t = e.defaultValue(t, Gf)),
              (this._dimensions = e.Vector3.clone(t)),
              (this._isComplete = !1),
              (this.isRandomBoxEmitter = !0);
          }
          emit(t) {
            const i = e.Vector3.multiplyByScalar(this._dimensions, 0.5, Uf),
              s = e.randomBetween(-i.x, i.x),
              r = e.randomBetween(-i.y, i.y),
              n = e.randomBetween(-i.z, i.z);
            t.position = e.Vector3.fromElements(s, r, n, t.position);
          }
        },
        ParticleBurst: class {
          constructor(t) {
            (t = e.defaultValue(t, e.defaultValue.EMPTY_OBJECT)),
              (this.time = e.defaultValue(t.time, 0)),
              (this.minimum = e.defaultValue(t.minimum, 0)),
              (this.maximum = e.defaultValue(t.maximum, 50)),
              (this._complete = !1);
          }
          get complete() {
            return this._complete;
          }
        },
        ParticleSystem: class {
          constructor(t) {
            (t = e.defaultValue(t, e.defaultValue.EMPTY_OBJECT)),
              (this.show = e.defaultValue(t.show, !0)),
              (this.updateCallback = t.updateCallback),
              (this.loop = e.defaultValue(t.loop, !0)),
              (this.image = e.defaultValue(t.image, void 0));
            let i = t.emitter;
            e.defined(i) || (i = new Af(0.5)),
              (this._emitter = i),
              (this._bursts = t.bursts),
              (this._modelMatrix = e.Matrix4.clone(
                e.defaultValue(t.modelMatrix, e.Matrix4.IDENTITY),
                new e.Matrix4(),
              )),
              (this._emitterModelMatrix = e.Matrix4.clone(
                e.defaultValue(t.emitterModelMatrix, e.Matrix4.IDENTITY),
                new e.Matrix4(),
              )),
              (this._matrixDirty = !0),
              (this._combinedMatrix = new e.Matrix4()),
              (this._startColor = e.Color.clone(
                e.defaultValue(t.color, e.Color.parse(e.defaultValue(t.startColor, e.Color.white))),
              )),
              (this._endColor = e.Color.clone(
                e.defaultValue(t.color, e.Color.parse(e.defaultValue(t.endColor, e.Color.white))),
              )),
              (this._particleNumber = e.defaultValue(t.particleNumber, 1e4)),
              (this._startScale = e.defaultValue(t.scale, e.defaultValue(t.startScale, 1))),
              (this._endScale = e.defaultValue(t.scale, e.defaultValue(t.endScale, 1))),
              (this._emissionRate = e.defaultValue(t.emissionRate, 5)),
              (this.sizeattenuation = e.defaultValue(t.sizeattenuation, !0)),
              (this._speed = e.defaultValue(t.speed, 1)),
              (this._particleLife = e.defaultValue(t.particleLife, 5)),
              (this._minimumMass = e.defaultValue(t.mass, e.defaultValue(t.minimumMass, 1))),
              (this._maximumMass = e.defaultValue(t.mass, e.defaultValue(t.maximumMass, 1))),
              (this._lifetime = e.defaultValue(t.lifetime, Number.MAX_VALUE)),
              (this._plummeting = e.defaultValue(t.plummeting, !1)),
              (this._billboardCollection = void 0),
              (this._particles = []),
              (this._particlePool = []),
              (this._previousTime = void 0),
              (this._currentTime = 0),
              (this._carryOver = 0),
              (this._isComplete = !1),
              (this._updateParticlePool = !0),
              (this._particleEstimate = 0),
              (this._primitive = null),
              (this.imageSize = t.imageSize),
              (this.imageUrl = t.imageUrl),
              (this.texture = t.texture),
              (this.id = e.defaultValue(t.id, e.uuid()));
          }
          get emitter() {
            return this._emitter;
          }
          set emitter(e) {
            this._emitter = e;
          }
          get bursts() {
            return this._bursts;
          }
          set bursts(e) {
            (this._bursts = e), (this._updateParticlePool = !0);
          }
          get modelMatrix() {
            return this._modelMatrix;
          }
          set modelMatrix(t) {
            e.defined(t) &&
              ((this._matrixDirty = this._matrixDirty || !e.Matrix4.equals(this._modelMatrix, t)),
              e.Matrix4.clone(t, this._modelMatrix));
          }
          get emitterModelMatrix() {
            return this._emitterModelMatrix;
          }
          set emitterModelMatrix(t) {
            (this._matrixDirty =
              this._matrixDirty || !e.Matrix4.equals(this._emitterModelMatrix, t)),
              e.Matrix4.clone(t, this._emitterModelMatrix);
          }
          get startColor() {
            return this._startColor;
          }
          set startColor(t) {
            e.Color.clone(t, this._startColor);
          }
          get endColor() {
            return this._endColor;
          }
          set endColor(t) {
            e.Color.clone(t, this._endColor);
          }
          get startScale() {
            return this._startScale;
          }
          set startScale(t) {
            e.Color.clone(t, this._startScale);
          }
          get endScale() {
            return this._endScale;
          }
          set endScale(t) {
            e.Color.clone(t, this._endScale);
          }
          get emissionRate() {
            return this._emissionRate;
          }
          set emissionRate(e) {
            (this._emissionRate = e), (this._updateParticlePool = !0);
          }
          get speed() {
            return this._speed;
          }
          set speed(e) {
            this._speed = e;
          }
          get particleLife() {
            return this._particleLife;
          }
          set particleLife(e) {
            this._particleLife = e;
          }
          get lifetime() {
            return this._lifetime;
          }
          set lifetime(e) {
            this._lifetime = e;
          }
          get isComplete() {
            return this._isComplete;
          }
          get particleNumber() {
            return this._particleNumber;
          }
          set particleNumber(e) {
            (this._particleNumber = e), (this._emitter.isComplete = !1), (this._particles = []);
          }
          update(t, i) {
            if (!this.show) return;
            e.defined(this._billboardCollection) || (this._billboardCollection = []),
              this._updateParticlePool &&
                ((function (t, i) {
                  const s = t._emissionRate,
                    r = t._maximumParticleLife;
                  let n = 0;
                  const o = t._bursts;
                  if (e.defined(o)) {
                    const e = o.length;
                    for (let t = 0; t < e; ++t) n += o[t].maximum;
                  }
                  const a = t.image,
                    l = t.imageUrl,
                    h = t.texture,
                    c = Math.ceil(s * r + n),
                    _ = t._particlePool;
                  let u;
                  u = t._emitter.isRandomBoxEmitter
                    ? t._particleNumber
                    : Math.max(c - t._particles.length - _.length, 0);
                  for (let e = 0; e < u; ++e) {
                    const e = new Mf({ imageSize: t.imageSize });
                    (e.image = a), _.push(e);
                  }
                  if (((t._particleEstimate = c), !t._primitive)) {
                    const s = new Or();
                    let r;
                    a
                      ? (r = new Rr({
                          image: a,
                          sizeattenuation: t.sizeattenuation,
                          scale: t.imageSize,
                        }))
                      : l
                      ? (r = new Rr({
                          imageUrl: l,
                          sizeattenuation: t.sizeattenuation,
                          scale: t.imageSize,
                        }))
                      : h
                      ? (r = new Rr({
                          texture: h,
                          sizeattenuation: t.sizeattenuation,
                          scale: t.imageSize,
                        }))
                      : console.error('请传入纹理texture或图片路径imageUrl或是canvas图片image');
                    const n = new e.Primitive({
                      id: t.id,
                      geometry: s,
                      material: r,
                      particleSystem: !0,
                    });
                    i.addPrimitive(n), (t._primitive = n);
                  }
                })(this, i),
                (this._updateParticlePool = !1));
            let s = 0;
            (s += t), s < 0 && (s = 0);
            const r = this._particles,
              n = this._emitter,
              o = this.updateCallback;
            let a, l;
            if (this._emitter.isRandomBoxEmitter) {
              if (this._emitter.isComplete) {
                this._matrixDirty &&
                  ((this._combinedMatrix = e.Matrix4.multiply(
                    this._combinedMatrix,
                    this.modelMatrix,
                    this.emitterModelMatrix,
                  )),
                  (this._matrixDirty = !1));
                const t = this._combinedMatrix,
                  i = -this._emitter._dimensions.z / 2,
                  r = -this._emitter._dimensions.y / 2,
                  n = -this._emitter._dimensions.x / 2;
                for (a = 0; a < this._particles.length; a++) {
                  if (this._plummeting) {
                    const e = 10 * Math.cos(0.15 * s * this._particles[a].velocity.z);
                    this._particles[a].positionClone.z -= e * this._speed;
                  } else {
                    const e = 1e3 * Math.sin(0.5 * s * this._particles[a].velocity.x),
                      t = 10 * Math.cos(0.15 * s * this._particles[a].velocity.z);
                    (this._particles[a].positionClone.x += e),
                      (this._particles[a].positionClone.y += 5 * this._particles[a].velocity.y),
                      (this._particles[a].positionClone.z -= t * this._speed);
                  }
                  i > this._particles[a].positionClone.z &&
                    (this._particles[a].positionClone.z += this._emitter._dimensions.z),
                    r > this._particles[a].positionClone.y &&
                      (this._particles[a].positionClone.y += this._emitter._dimensions.y),
                    -r < this._particles[a].positionClone.y &&
                      (this._particles[a].positionClone.y += -this._emitter._dimensions.y),
                    n > this._particles[a].positionClone.x &&
                      (this._particles[a].positionClone.x += this._emitter._dimensions.x),
                    -n < this._particles[a].positionClone.x &&
                      (this._particles[a].positionClone.x += -this._emitter._dimensions.x),
                    e.Matrix4.multiplyByPoint(
                      t,
                      this._particles[a].positionClone,
                      this._particles[a].position,
                    ),
                    Df(0, this._particles[a]);
                }
              }
              if (!this._emitter.isComplete) {
                this._matrixDirty &&
                  ((this._combinedMatrix = e.Matrix4.multiply(
                    this._combinedMatrix,
                    this.modelMatrix,
                    this.emitterModelMatrix,
                  )),
                  (this._matrixDirty = !1));
                const t = this._combinedMatrix;
                for (a = 0; a < this._particleNumber; a++) {
                  (l = If(this)), this._emitter.emit(l);
                  const i = 0.1 * Math.floor(6 * Math.random() - 3),
                    s = -0.05 * Math.floor(10 * Math.random() + 3),
                    r = 0.1 * Math.floor(6 * Math.random() - 3);
                  (l.velocity = new e.Vector3(i, s, r)),
                    e.Vector3.add(l.position, l.velocity, Rf),
                    e.Matrix4.multiplyByPoint(t, Rf, Rf),
                    (l.positionClone = e.Vector3.clone(e.defaultValue(l.position, Rf))),
                    e.Matrix4.multiplyByPoint(t, l.position, l.position),
                    Bf(this, l),
                    Df(0, l);
                }
                this._emitter.isComplete = !0;
              }
            } else {
              let t = r.length;
              for (a = 0; a < t; ++a)
                (l = r[a]),
                  l.update(s, o) ? Df(0, l) : (Lf(l), Of(this, l), (r[a] = r[t - 1]), --a, --t);
              r.length = t;
              const i = (function (t, i) {
                if (t._isComplete) return 0;
                const s = (i = Vf(i, t._lifetime)) * t._emissionRate;
                let r = Math.floor(s);
                if (
                  ((t._carryOver += s - r),
                  t._carryOver > 1 && (r++, (t._carryOver -= 1)),
                  e.defined(t.bursts))
                ) {
                  const i = t.bursts.length;
                  for (let s = 0; s < i; s++) {
                    const i = t.bursts[s],
                      n = t._currentTime;
                    e.defined(i) &&
                      !i._complete &&
                      n > i.time &&
                      ((r += e.randomBetween(i.minimum, i.maximum)), (i._complete = !0));
                  }
                }
                return r;
              })(this, s);
              if (i > 0 && e.defined(n)) {
                this._matrixDirty &&
                  ((this._combinedMatrix = e.Matrix4.multiply(
                    this._combinedMatrix,
                    this.modelMatrix,
                    this.emitterModelMatrix,
                  )),
                  (this._matrixDirty = !1));
                const t = this._combinedMatrix;
                for (a = 0; a < i; a++)
                  (l = If(this)),
                    this._emitter.emit(l),
                    e.Vector3.add(l.position, l.velocity, Rf),
                    e.Matrix4.multiplyByPoint(t, Rf, Rf),
                    e.Matrix4.multiplyByPoint(t, l.position, l.position),
                    e.Vector3.subtract(Rf, l.position, l.velocity),
                    e.Vector3.normalize(l.velocity, l.velocity),
                    Bf(this, l),
                    Df(0, l);
              }
            }
            const h = [],
              c = [],
              _ = [];
            for (let e = 0; e < this._particles.length; e++) {
              const t = this._particles[e];
              t.show &&
                (h.push(t.position),
                c.push(t.color.r, t.color.g, t.color.b, t.color.a),
                _.push(t.scale));
            }
            if (
              (this._primitive.particleSystemInstanceCollection.updateData({
                positions: h,
                colorArr: c,
                scaleArr: _,
                frameState: i.painter.frameState,
              }),
              (this._currentTime += s),
              this._lifetime !== Number.MAX_VALUE && this._currentTime > this._lifetime)
            )
              if (this.loop) {
                if (((this._currentTime = Vf(this._currentTime, this._lifetime)), this.bursts)) {
                  const e = this.bursts.length;
                  for (a = 0; a < e; a++) this.bursts[a]._complete = !1;
                }
              } else this._isComplete = !0;
          }
          destroy(e) {
            (this._billboardCollection = []),
              (this._particlePool = []),
              this._primitive.particleSystemInstanceCollection.destroy(),
              this.texture && e.painter.textureResourceManager.removeTexture(this.texture.texUrl),
              (this.texture = null),
              (this.image = null),
              (this.imageUrl = null),
              (this.modelMatrix = null),
              (this.startColor = null),
              (this.endColor = null),
              (this._emitter = null),
              (this._bursts = null),
              (this._combinedMatrix = null),
              (this.speed = null),
              (this._emissionRate = null),
              (this._lifetime = null),
              (this._endScale = null),
              (this._isComplete = null),
              (this._particleNumber = null),
              (this._particles = []),
              (this._startColor = null),
              e.removePrimitive(this._primitive);
          }
        },
        Highlight: Sm,
        LimitHeight: Jm,
        Sightline: Ym,
        ViewDome: Fm,
        Viewshed3D: zm,
        Measurement3D: Dh,
        Excavation: Bm,
        Earth: Zm,
        AirLine: Bh,
        Skybox: Lh,
        SceneModel: Ar,
        SceneTileset: mh,
        ModelInstance: e.ModelInstance,
        ModelInstanceCollection: e.ModelInstanceCollection,
        ClippingPlane: e.ClippingPlane,
        ClippingPlaneCollection: e.ClippingPlaneCollection,
        PostProcessStageLibrary: Fc,
        PostProcessStage: bc,
        PostProcessStageComposite: Mc,
        Math: Cf,
        Transforms: e.Transforms,
        Event: e.Event,
        Evented: e.Evented,
        Map: Hp,
        Color: e.Color,
        Ellipsoid: e.Ellipsoid,
        DistanceDisplayCondition: Sf,
        LngLat: e.LngLat,
        LngLatBounds: e.LngLatBounds,
        NearFarScalar: xa,
        TextureLoader: ks,
        Texture: e.Texture,
        VideoProjection: vm,
        CutFill: Am,
        WMTSCapabilities: class extends zf {
          constructor() {
            super(), (this.owsParser_ = new tg());
          }
          readFromNode(e) {
            let t = e.getAttribute('version');
            t && (t = t.trim());
            let i = this.owsParser_.readFromNode(e);
            return i ? ((i.version = t), (i = $f(i, gg, e, [])), i || null) : null;
          }
        },
        util: Vg,
      },
      kg = {
        optionsFromCapabilities: function (e, t) {
          const i = e.Contents.Layer.find((e) => e.Identifier === t.layer);
          if (!i) throw Error(`WTMS服务中未找到${t.layer}图层`);
          const s = e.Contents.TileMatrixSet;
          let r;
          (r =
            i.TileMatrixSetLink.length > 1
              ? i.TileMatrixSetLink.findIndex(
                  'projection' in t
                    ? (e) => {
                        const i = s.find((t) => t.Identifier === e.TileMatrixSet).SupportedCRS,
                          r = Dg(i),
                          n = Dg(t.projection);
                        return r && n ? r === n : i === t.projection;
                      }
                    : (e) => e.TileMatrixSet === t.matrixSet,
                )
              : 0),
            r < 0 && (r = 0);
          const n = i.TileMatrixSetLink[r].TileMatrixSet,
            o = i.TileMatrixSetLink[r].TileMatrixSetLimits;
          let a = i.Format[0];
          'format' in t && (a = t.format),
            (r = i.Style.findIndex((e) => ('style' in t ? e.Title === t.style : e.isDefault))),
            r < 0 && (r = 0);
          const l = i.Style[r].Identifier,
            h = new Map();
          'Dimension' in i &&
            i.Dimension.forEach((e) => {
              let t = e.Default;
              void 0 === t && (t = e.Value[0]), h.set(e.Identifier, t);
            });
          const c = e.Contents.TileMatrixSet.find((e) => e.Identifier === n);
          let _;
          const u = c.SupportedCRS;
          if ((u && (_ = Dg(u)), 'projection' in t)) {
            const e = Dg(t.projection);
            e && ((_ && e !== _) || (_ = e));
          }
          let d, m;
          if ('EPSG:4326' === _) (d = (6378137 * Math.PI) / 180), (m = !0);
          else {
            if ('EPSG:3857' !== _) throw Error(`WTMS服务中含有不支持的坐标系统${_}`);
            (d = 1), (m = !1);
          }
          let p = c.TileMatrix[0],
            f = {
              MinTileCol: 0,
              MinTileRow: 0,
              MaxTileCol: p.MatrixWidth - 1,
              MaxTileRow: p.MatrixHeight - 1,
            };
          if (o) {
            f = o[o.length - 1];
            const e = c.TileMatrix.find(
              (e) =>
                e.Identifier === f.TileMatrix || `${c.Identifier}:${e.Identifier}` === f.TileMatrix,
            );
            e && (p = e);
          }
          const g = (28e-5 * p.ScaleDenominator) / d,
            y = m ? [p.TopLeftCorner[1], p.TopLeftCorner[0]] : p.TopLeftCorner,
            T = p.TileWidth * g,
            x = p.TileHeight * g;
          let v = c.BoundingBox;
          v && m && (v = [v[1], v[0], v[3], v[2]]);
          let b = [
            y[0] + T * f.MinTileCol,
            y[1] - x * (1 + f.MaxTileRow),
            y[0] + T * (1 + f.MaxTileCol),
            y[1] - x * f.MinTileRow,
          ];
          var w, C;
          void 0 === v ||
            ((w = v)[0] <= (C = b)[0] && C[2] <= w[2] && w[1] <= C[1] && C[3] <= w[3]) ||
            (b = v);
          const S = (function (e, t, i) {
              const s = [],
                r = [],
                n = [],
                o = [],
                a = [];
              i = void 0 !== i ? i : [];
              const l = 'TileMatrix',
                h = 'Identifier',
                c = 'ScaleDenominator',
                _ = 'TopLeftCorner',
                u = Dg(e.SupportedCRS);
              let d, m;
              if ('EPSG:4326' === u) (d = (6378137 * Math.PI) / 180), (m = !0);
              else {
                if ('EPSG:3857' !== u) throw Error(`WTMS服务中含有不支持的坐标系统${u}`);
                (d = 1), (m = !1);
              }
              return (
                e[l].sort((e, t) => t[c] - e[c]),
                e[l].forEach((t) => {
                  let u;
                  if (
                    ((u =
                      !(i.length > 0) ||
                      i.find(
                        (i) => t[h] === i[l] || (!t[h].includes(':') && `${e[h]}:${t[h]}` === i[l]),
                      )),
                    u)
                  ) {
                    r.push(t[h]);
                    const e = (28e-5 * t[c]) / d,
                      i = t.TileWidth,
                      l = t.TileHeight;
                    n.push(m ? [t[_][1], t[_][0]] : t[_]),
                      s.push(e),
                      o.push(i === l ? i : [i, l]),
                      a.push([t.MatrixWidth, t.MatrixHeight]);
                  }
                }),
                new Bg({
                  extent: t,
                  origins: n,
                  resolutions: s,
                  matrixIds: r,
                  tileSizes: o,
                  sizes: a,
                })
              );
            })(c, b, o),
            E = [];
          let P = t.requestEncoding;
          if (
            ((P = void 0 !== P ? P : ''),
            'OperationsMetadata' in e && 'GetTile' in e.OperationsMetadata)
          ) {
            const t = e.OperationsMetadata.GetTile.DCP.HTTP.Get;
            for (let e = 0, i = t.length; e < i; ++e)
              if (t[e].Constraint) {
                const i = t[e].Constraint.find((e) => 'GetEncoding' === e.name).AllowedValues.Value;
                if (('' === P && (P = i[0]), 'KVP' !== P)) break;
                i.includes('KVP') && E.push(t[e].href);
              } else t[e].href && ((P = 'KVP'), E.push(t[e].href));
          }
          if (
            0 === E.length &&
            ((P = 'REST'),
            i.ResourceURL.forEach((e) => {
              'tile' === e.resourceType && a && e.format === a && E.push(e.template);
            }),
            0 === E.length)
          )
            throw Error('未找到对应图层的url, 请检查参数是否正确');
          return {
            urls: E,
            layer: t.layer,
            matrixSet: n,
            format: a,
            projection: _,
            requestEncoding: P,
            tileGrid: S,
            style: l,
            dimensions: h,
            wrapX: !1,
            crossOrigin: t.crossOrigin,
          };
        },
        setRTLTextPlugin: e.setRTLTextPlugin,
        getRTLTextPluginStatus: e.getRTLTextPluginStatus,
      },
      Fg = {
        get accessToken() {
          return pr.ACCESS_TOKEN;
        },
        set accessToken(e) {
          pr.ACCESS_TOKEN = e;
        },
        get appKey() {
          return pr.APP_KEY;
        },
        set appKey(e) {
          pr.APP_KEY = e;
        },
        get key() {
          return pr.KEY;
        },
        set key(e) {
          pr.KEY = e;
        },
        get solution() {
          return pr.SOLU;
        },
        set solution(e) {
          pr.SOLU = e;
        },
        get dataVersion() {
          return pr.DATA_VERSION;
        },
        set dataVersion(e) {
          pr.DATA_VERSION = e;
        },
        get spriteUrl() {
          return pr.spriteUrl;
        },
        set spriteUrl(e) {
          pr.spriteUrl = e;
        },
        get fontsUrl() {
          return pr.fontsUrl;
        },
        set fontsUrl(e) {
          pr.fontsUrl = e;
        },
        get serviceUrl() {
          return pr.SERVICE_URL;
        },
        set serviceUrl(e) {
          pr.SERVICE_URL = e;
        },
        get domainUrl() {
          return pr.DOMAIN;
        },
        set domainUrl(e) {
          (pr.DOMAIN = e),
            (pr.SRC_URL = pr.DOMAIN + pr.SRC_BASE),
            (pr.SERVICE_URL = pr.DOMAIN + pr.SERVICE_BASE);
        },
        get dataDomainUrl() {
          return pr.DATA_DOMAIN;
        },
        set dataDomainUrl(e) {
          (pr.DATA_DOMAIN = e),
            Array.isArray(e)
              ? ((pr.API_URL = pr.DATA_DOMAIN.map((e) => e + pr.API_BASE)),
                (pr.DYN_URL = pr.DATA_DOMAIN.map((e) => e + pr.DYN_BASE)),
                (pr.MERGE_URL = pr.DATA_DOMAIN.map((e) => e + pr.MERGE_BASE)),
                (pr.OTHER_URL = pr.DATA_DOMAIN.map((e) => e + pr.OTHER_BASE)))
              : ((pr.API_URL = pr.DATA_DOMAIN + pr.API_BASE),
                (pr.DYN_URL = pr.DATA_DOMAIN + pr.DYN_BASE),
                (pr.MERGE_URL = pr.DATA_DOMAIN + pr.MERGE_BASE),
                (pr.OTHER_URL = pr.DATA_DOMAIN + pr.OTHER_BASE));
        },
        get serverDomainUrl() {
          return pr.SERVER_DOMAIN;
        },
        set serverDomainUrl(e) {
          (pr.SERVER_DOMAIN = e),
            (pr.SERVER_URL = Array.isArray(e)
              ? pr.SERVER_DOMAIN.map((e) => `${e}/service/`)
              : `${pr.SERVER_DOMAIN}/service/`);
        },
        workerUrl: '',
      };
    return e.extend(Fg, Ng, kg, { version: C }), Fg;
  });

  //

  var minemap$1 = minemap;

  return minemap$1;
});
